webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports) {

eval("/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvdXRpbC5qcz9lZWM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbiAgICAvLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbiAgICB2YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICAgICAgICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAgICAgICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgICAgICAgLy8gRm9yIG5vZGUtY2FudmFzXG4gICAgICAgICdbb2JqZWN0IEltYWdlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc10nOiAxXG4gICAgfTtcblxuICAgIHZhciBUWVBFRF9BUlJBWSA9IHtcbiAgICAgICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBJbnQzMkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogMVxuICAgIH07XG5cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG4gICAgdmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG4gICAgdmFyIG5hdGl2ZUZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xuICAgIHZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG4gICAgdmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xuICAgIHZhciBuYXRpdmVSZWR1Y2UgPSBhcnJheVByb3RvLnJlZHVjZTtcblxuICAgIC8qKlxuICAgICAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAgICAgKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAgICAgKiBUaG9zZSBkYXRhIHR5cGVzIHdpbGwgYmUgYXNzZ2luZWQgdXNpbmcgdGhlIG9yZ2luYWwgZGF0YTpcbiAgICAgKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAgICAgKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHByb3RvdHlwZS5cbiAgICAgKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICAgICAqXG4gICAgICogQ2F1dGlvbjogZG8gbm90IHN1cHBvcnQgY2xvbmUgRGF0ZSwgZm9yIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb24uXG4gICAgICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gICAgICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHJldHVybiB7Kn0gbmV3XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgdmFyIHR5cGVTdHIgPSBvYmpUb1N0cmluZy5jYWxsKHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKHR5cGVTdHIgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZS5jb25zdHJ1Y3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUJVSUxUSU5fT0JKRUNUW3R5cGVTdHJdICYmICFpc1ByaW1pdGl2ZShzb3VyY2UpICYmICFpc0RvbShzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBlc2NhcHNlIHRoYXQgc291cmNlIGlzIHN0cmluZ1xuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cbiAgICAgICAgaWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVByb3AgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiBpc09iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNEb20oc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRBbmRTb3VyY2VzIFRoZSBmaXJzdCBpdGVtIGlzIHRhcmdldCwgYW5kIHRoZSByZXN0cyBhcmUgc291cmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZUFsbCh0YXJnZXRBbmRTb3VyY2VzLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldEFuZFNvdXJjZXNbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXJnZShyZXN1bHQsIHRhcmdldEFuZFNvdXJjZXNbaV0sIG92ZXJ3cml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVufSBbb3ZlcmxheT1mYWxzZV1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAgICAgJiYgKG92ZXJsYXkgPyBzb3VyY2Vba2V5XSAhPSBudWxsIDogdGFyZ2V0W2tleV0gPT0gbnVsbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG4gICAgLy8gRklYTUVcbiAgICB2YXIgX2N0eDtcbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgICBpZiAoIV9jdHgpIHtcbiAgICAgICAgICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBjcmVhdGVDYW52YXMgbWF5IGJlIG92ZXJ3cml0dGVuIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudFxuICAgICAgICAgICAgX2N0eCA9IHV0aWwuY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2N0eDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaehOmAoOexu+e7p+aJv+WFs+ezu1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gICAgICAgIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgICAgICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgICAgICAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcmxheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gICAgICAgIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gICAgICAgIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG5cbiAgICAgICAgZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnNpZGVyIHR5cGVkIGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgICAgICAgaWYgKCEgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFjaChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE5pig5bCEXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5tYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbWVtb11cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShvYmosIGNiLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVkdWNlKGNiLCBtZW1vLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gY2IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOi/h+a7pFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5maWx0ZXIoY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmpbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4Tpobnmn6Xmib5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gICAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgKCEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRG9tKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAmJiB0eXBlb2YgdmFsdWUub3duZXJEb2N1bWVudCA9PT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpcyBleGFjdGx5IE5hTi4gTm90aWNlIGlzTmFOKCdhJykgcmV0dXJucyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxTmFOKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdmFsdWUxIGlzIG5vdCBudWxsLCB0aGVuIHJldHVybiB2YWx1ZTEsIG90aGVyd2lzZSBqdWRnZXQgcmVzdCBvZiB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmUodmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZSgpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJpbWl0aXZlS2V5ID0gJ19fZWNfcHJpbWl0aXZlX18nO1xuICAgIC8qKlxuICAgICAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbcHJpbWl0aXZlS2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9ubHkgYXBwbHkgYG93blByb3BlcnR5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICAgICAgICBvYmogJiYgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHByZWZpeCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG4gICAgdmFyIEhBU0hfTUFQX1BSRUZJWCA9ICdfZWNfJztcbiAgICB2YXIgSEFTSF9NQVBfUFJFRklYX0xFTkdUSCA9IDQ7XG5cbiAgICBIYXNoTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IEhhc2hNYXAsXG4gICAgICAgIC8vIERvIG5vdCBwcm92aWRlIGBoYXNgIG1ldGhvZCB0byBhdm9pZCBkZWZpbmluZyB3aGF0IGlzIGBoYXNgLlxuICAgICAgICAvLyAoV2UgdXN1YWxseSB0cmVhdCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFzIHRoZSBzYW1lLCBkaWZmZXJlbnRcbiAgICAgICAgLy8gZnJvbSBFUzYgTWFwKS5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIENvbXBhcmluZyB3aXRoIGludm9jYXRpb24gY2hhaW5pbmcsIGByZXR1cm4gdmFsdWVgIGlzIG1vcmUgY29tbW9ubHlcbiAgICAgICAgICAgIC8vIHVzZWQgaW4gdGhpcyBjYXNlOiBgdmFyIHNvbWVWYWwgPSBtYXAuc2V0KCdhJywgZ2VuVmFsKCkpO2BcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWx0aG91Z2ggdXRpbC5lYWNoIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhpcyBoYXNoTWFwIGRpcmVjdGx5LCB1c2VyXG4gICAgICAgIC8vIHNob3VsZCBub3QgdXNlIHRoZSBleHBvc2VkIGtleXMsIHdobyBhcmUgcHJlZml4ZWQuXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCAhPT0gdm9pZCAwICYmIChjYiA9IGJpbmQoY2IsIGNvbnRleHQpKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByZWZpeGVkS2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc093blByb3BlcnR5KHByZWZpeGVkS2V5KVxuICAgICAgICAgICAgICAgICAgICAmJiBjYih0aGlzW3ByZWZpeGVkS2V5XSwgcHJlZml4ZWRLZXkuc2xpY2UoSEFTSF9NQVBfUFJFRklYX0xFTkdUSCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBEbyBub3QgdXNlIHRoaXMgbWV0aG9kIGlmIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgICAgICAgcmVtb3ZlS2V5OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xuICAgIH1cblxuICAgIHZhciB1dGlsID0ge1xuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgICAgIG1peGluOiBtaXhpbixcbiAgICAgICAgY2xvbmU6IGNsb25lLFxuICAgICAgICBtZXJnZTogbWVyZ2UsXG4gICAgICAgIG1lcmdlQWxsOiBtZXJnZUFsbCxcbiAgICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgZ2V0Q29udGV4dDogZ2V0Q29udGV4dCxcbiAgICAgICAgY3JlYXRlQ2FudmFzOiBjcmVhdGVDYW52YXMsXG4gICAgICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgICAgIHNsaWNlOiBzbGljZSxcbiAgICAgICAgZmluZDogZmluZCxcbiAgICAgICAgaXNBcnJheUxpa2U6IGlzQXJyYXlMaWtlLFxuICAgICAgICBlYWNoOiBlYWNoLFxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBiaW5kOiBiaW5kLFxuICAgICAgICBjdXJyeTogY3VycnksXG4gICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICAgICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgICAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgICAgICBpc0J1aWx0SW5PYmplY3Q6IGlzQnVpbHRJbk9iamVjdCxcbiAgICAgICAgaXNEb206IGlzRG9tLFxuICAgICAgICBlcU5hTjogZXFOYU4sXG4gICAgICAgIHJldHJpZXZlOiByZXRyaWV2ZSxcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIHNldEFzUHJpbWl0aXZlOiBzZXRBc1ByaW1pdGl2ZSxcbiAgICAgICAgY3JlYXRlSGFzaE1hcDogY3JlYXRlSGFzaE1hcCxcbiAgICAgICAgbm9vcDogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gdXRpbDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = __webpack_require__(6);\n\n    var GlobalModel = __webpack_require__(167);\n    var ExtensionAPI = __webpack_require__(104);\n    var CoordinateSystemManager = __webpack_require__(31);\n    var OptionManager = __webpack_require__(168);\n\n    var ComponentModel = __webpack_require__(13);\n    var SeriesModel = __webpack_require__(35);\n\n    var ComponentView = __webpack_require__(67);\n    var ChartView = __webpack_require__(66);\n    var graphic = __webpack_require__(2);\n    var modelUtil = __webpack_require__(4);\n    var throttle = __webpack_require__(65);\n\n    var zrender = __webpack_require__(220);\n    var zrUtil = __webpack_require__(0);\n    var colorTool = __webpack_require__(22);\n    var Eventful = __webpack_require__(21);\n    var timsort = __webpack_require__(39);\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer？\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.6.2',\n        dependencies: {\n            zrender: '3.5.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(181));\n    echarts.registerPreprocessor(__webpack_require__(175));\n    echarts.registerLoading('default', __webpack_require__(166));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = __webpack_require__(61);\n    echarts.Model = __webpack_require__(9);\n\n    echarts.Axis = __webpack_require__(57);\n\n    echarts.graphic = __webpack_require__(2);\n    echarts.number = __webpack_require__(5);\n    echarts.format = __webpack_require__(10);\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = __webpack_require__(20);\n    echarts.vector = __webpack_require__(7);\n    echarts.color = __webpack_require__(22);\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = __webpack_require__(163);\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2VjaGFydHMuanM/MjU5ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQjtBQUNoQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qiw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qiw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsMEJBQTBCOztBQUVuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwyREFBMkQ7QUFDMUUsZUFBZSx3REFBd0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSwyREFBMkQ7QUFDMUUsZUFBZSx3REFBd0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBNkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEUsaURBQWlELE1BQU07QUFDdkQ7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEVuYWJsZSBERVYgbW9kZSB3aGVuIHVzaW5nIHNvdXJjZSBjb2RlIHdpdGhvdXQgYnVpbGQuIHdoaWNoIGhhcyBubyBfX0RFVl9fIHZhcmlhYmxlXG4vLyBJbiBidWlsZCBwcm9jZXNzICd0eXBlb2YgX19ERVZfXycgd2lsbCBiZSByZXBsYWNlIHdpdGggJ2Jvb2xlYW4nXG4vLyBTbyB0aGlzIGNvZGUgd2lsbCBiZSByZW1vdmVkIG9yIGRpc2FibGVkIGFueXdheSBhZnRlciBidWlsdC5cbmlmICh0eXBlb2YgX19ERVZfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBJbiBicm93c2VyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5fX0RFVl9fID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSW4gbm9kZVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsb2JhbC5fX0RFVl9fID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8qIVxuICogRUNoYXJ0cywgYSBqYXZhc2NyaXB0IGludGVyYWN0aXZlIGNoYXJ0IGxpYnJhcnkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBCYWlkdSBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvZWNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzXG4gKi9cblxuXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG5cbiAgICB2YXIgR2xvYmFsTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL0dsb2JhbCcpO1xuICAgIHZhciBFeHRlbnNpb25BUEkgPSByZXF1aXJlKCcuL0V4dGVuc2lvbkFQSScpO1xuICAgIHZhciBDb29yZGluYXRlU3lzdGVtTWFuYWdlciA9IHJlcXVpcmUoJy4vQ29vcmRpbmF0ZVN5c3RlbScpO1xuICAgIHZhciBPcHRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9tb2RlbC9PcHRpb25NYW5hZ2VyJyk7XG5cbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL0NvbXBvbmVudCcpO1xuICAgIHZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvU2VyaWVzJyk7XG5cbiAgICB2YXIgQ29tcG9uZW50VmlldyA9IHJlcXVpcmUoJy4vdmlldy9Db21wb25lbnQnKTtcbiAgICB2YXIgQ2hhcnRWaWV3ID0gcmVxdWlyZSgnLi92aWV3L0NoYXJ0Jyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgdGhyb3R0bGUgPSByZXF1aXJlKCcuL3V0aWwvdGhyb3R0bGUnKTtcblxuICAgIHZhciB6cmVuZGVyID0gcmVxdWlyZSgnenJlbmRlcicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQnKTtcblxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gQ29tcG9uZW50TW9kZWwucGFyc2VDbGFzc1R5cGU7XG5cbiAgICB2YXIgUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUiA9IDEwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1BST0NFU1NPUl9TVEFUSVNUSUMgPSA1MDAwO1xuXG5cbiAgICB2YXIgUFJJT1JJVFlfVklTVUFMX0xBWU9VVCA9IDEwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9HTE9CQUwgPSAyMDAwO1xuICAgIHZhciBQUklPUklUWV9WSVNVQUxfQ0hBUlQgPSAzMDAwO1xuICAgIHZhciBQUklPUklUWV9WSVNVQUxfQ09NUE9ORU5UID0gNDAwMDtcbiAgICAvLyBGSVhNRVxuICAgIC8vIG5lY2Vzc2FyeT9cbiAgICB2YXIgUFJJT1JJVFlfVklTVUFMX0JSVVNIID0gNTAwMDtcblxuICAgIC8vIE1haW4gcHJvY2VzcyBoYXZlIHRocmVlIGVudHJpZXM6IGBzZXRPcHRpb25gLCBgZGlzcGF0Y2hBY3Rpb25gIGFuZCBgcmVzaXplYCxcbiAgICAvLyB3aGVyZSB0aGV5IG11c3Qgbm90IGJlIGludm9rZWQgbmVzdGVkbHksIGV4Y2VwdCB0aGUgb25seSBjYXNlOiBpbnZva2VcbiAgICAvLyBkaXNwYXRjaEFjdGlvbiB3aXRoIHVwZGF0ZU1ldGhvZCBcIm5vbmVcIiBpbiBtYWluIHByb2Nlc3MuXG4gICAgLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gY2Fycnkgb3V0IHRoaXMgcnVsZS5cbiAgICAvLyBBbGwgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkIG91dCBzaWRlIG1haW4gcHJvY2VzcyAoaS5lLiB3aGVuICF0aGlzW0lOX01BSU5fUFJPQ0VTU10pLlxuICAgIHZhciBJTl9NQUlOX1BST0NFU1MgPSAnX19mbGFnSW5NYWluUHJvY2Vzcyc7XG4gICAgdmFyIEhBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHID0gJ19faGFzR3JhZGllbnRPclBhdHRlcm5CZyc7XG4gICAgdmFyIE9QVElPTl9VUERBVEVEID0gJ19fb3B0aW9uVXBkYXRlZCc7XG4gICAgdmFyIEFDVElPTl9SRUcgPSAvXlthLXpBLVowLTlfXSskLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZShtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IG5hbWUgaXMgYWxsIGxvd2VyY2FzZVxuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lICYmIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgRXZlbnRmdWwucHJvdG90eXBlW21ldGhvZF0uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgZWNoYXJ0c35NZXNzYWdlQ2VudGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZUNlbnRlcigpIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub24gPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uJyk7XG4gICAgTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub2ZmID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvZmYnKTtcbiAgICBNZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vbmUgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uZScpO1xuICAgIHpyVXRpbC5taXhpbihNZXNzYWdlQ2VudGVyLCBFdmVudGZ1bCk7XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIGVjaGFydHN+RUNoYXJ0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVDaGFydHMoZG9tLCB0aGVtZSwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAvLyBHZXQgdGhlbWUgYnkgbmFtZVxuICAgICAgICBpZiAodHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhlbWUgPSB0aGVtZVN0b3JhZ2VbdGhlbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkO1xuICAgICAgICAvKipcbiAgICAgICAgICogR3JvdXAgaWRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb20gPSBkb207XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xuICAgICAgICAgICAgcmVuZGVyZXI6IG9wdHMucmVuZGVyZXIgfHwgJ2NhbnZhcycsXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBvcHRzLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICB3aWR0aDogb3B0cy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogb3B0cy5oZWlnaHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGVjdCA2MCBwZnMuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFpyRmx1c2ggPSB0aHJvdHRsZS50aHJvdHRsZSh6clV0aWwuYmluZCh6ci5mbHVzaCwgenIpLCAxNyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aGVtZSA9IHpyVXRpbC5jbG9uZSh0aGVtZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGFydHNWaWV3cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2hhcnRzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1ZpZXdzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvQ29vcmRpbmF0ZVN5c3RlbX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nvb3JkU3lzTWdyID0gbmV3IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hcGkgPSBjcmVhdGVFeHRlbnNpb25BUEkodGhpcyk7XG5cbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzfk1lc3NhZ2VDZW50ZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZXNzYWdlQ2VudGVyID0gbmV3IE1lc3NhZ2VDZW50ZXIoKTtcblxuICAgICAgICAvLyBJbml0IG1vdXNlIGV2ZW50c1xuICAgICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAgICAgLy8gSW4gY2FzZSBzb21lIHBlb3BsZSB3cml0ZSBgd2luZG93Lm9ucmVzaXplID0gY2hhcnQucmVzaXplYFxuICAgICAgICB0aGlzLnJlc2l6ZSA9IHpyVXRpbC5iaW5kKHRoaXMucmVzaXplLCB0aGlzKTtcblxuICAgICAgICAvLyBDYW4ndCBkaXNwYXRjaCBhY3Rpb24gZHVyaW5nIHJlbmRlcmluZyBwcm9jZWR1cmVcbiAgICAgICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMgPSBbXTtcbiAgICAgICAgLy8gU29ydCBvbiBkZW1hbmRcbiAgICAgICAgZnVuY3Rpb24gcHJpb3JpdHlTb3J0RnVuYyhhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvIC0gYi5wcmlvO1xuICAgICAgICB9XG4gICAgICAgIHRpbXNvcnQodmlzdWFsRnVuY3MsIHByaW9yaXR5U29ydEZ1bmMpO1xuICAgICAgICB0aW1zb3J0KGRhdGFQcm9jZXNzb3JGdW5jcywgcHJpb3JpdHlTb3J0RnVuYyk7XG5cbiAgICAgICAgenIuYW5pbWF0aW9uLm9uKCdmcmFtZScsIHRoaXMuX29uZnJhbWUsIHRoaXMpO1xuXG4gICAgICAgIC8vIEVDaGFydHMgaW5zdGFuY2UgY2FuIGJlIHVzZWQgYXMgdmFsdWUuXG4gICAgICAgIHpyVXRpbC5zZXRBc1ByaW1pdGl2ZSh0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgZWNoYXJ0c1Byb3RvID0gRUNoYXJ0cy5wcm90b3R5cGU7XG5cbiAgICBlY2hhcnRzUHJvdG8uX29uZnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIExhenkgdXBkYXRlXG4gICAgICAgIGlmICh0aGlzW09QVElPTl9VUERBVEVEXSkge1xuICAgICAgICAgICAgdmFyIHNpbGVudCA9IHRoaXNbT1BUSU9OX1VQREFURURdLnNpbGVudDtcblxuICAgICAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcblxuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcblxuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0hUTUxEb21FbGVtZW50fVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXREb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb207XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyflpSZW5kZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFpyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fenI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzYWdlOlxuICAgICAqIGNoYXJ0LnNldE9wdGlvbihvcHRpb24sIG5vdE1lcmdlLCBsYXp5VXBkYXRlKTtcbiAgICAgKiBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCB7XG4gICAgICogICAgIG5vdE1lcmdlOiAuLi4sXG4gICAgICogICAgIGxhenlVcGRhdGU6IC4uLixcbiAgICAgKiAgICAgc2lsZW50OiAuLi5cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbb3B0c10gb3B0cyBvciBub3RNZXJnZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLm5vdE1lcmdlPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMubGF6eVVwZGF0ZT1mYWxzZV0gVXNlZnVsIHdoZW4gc2V0T3B0aW9uIGZyZXF1ZW50bHkuXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIG5vdE1lcmdlLCBsYXp5VXBkYXRlKSB7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KCF0aGlzW0lOX01BSU5fUFJPQ0VTU10sICdgc2V0T3B0aW9uYCBzaG91bGQgbm90IGJlIGNhbGxlZCBkdXJpbmcgbWFpbiBwcm9jZXNzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbGVudDtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChub3RNZXJnZSkpIHtcbiAgICAgICAgICAgIGxhenlVcGRhdGUgPSBub3RNZXJnZS5sYXp5VXBkYXRlO1xuICAgICAgICAgICAgc2lsZW50ID0gbm90TWVyZ2Uuc2lsZW50O1xuICAgICAgICAgICAgbm90TWVyZ2UgPSBub3RNZXJnZS5ub3RNZXJnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlbCB8fCBub3RNZXJnZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbk1hbmFnZXIgPSBuZXcgT3B0aW9uTWFuYWdlcih0aGlzLl9hcGkpO1xuICAgICAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5fdGhlbWU7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsID0gbmV3IEdsb2JhbE1vZGVsKG51bGwsIG51bGwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKTtcbiAgICAgICAgICAgIGVjTW9kZWwuaW5pdChudWxsLCBudWxsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb2RlbC5zZXRPcHRpb24ob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyk7XG5cbiAgICAgICAgaWYgKGxhenlVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0ge3NpbGVudDogc2lsZW50fTtcbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgenIgcmVmcmVzaCBzeWNocm9ub3VzbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmVcbiAgICAgICAgICAgIC8vIGZldGNoZWQgYWZ0ZXIgYHNldE9wdGlvbmAuXG4gICAgICAgICAgICB0aGlzLl96ci5mbHVzaCgpO1xuXG4gICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQERFUFJFQ0FURURcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uc2V0VGhlbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFQ2hhcnRzI3NldFRoZW1lKCkgaXMgREVQUkVDQVRFRCBpbiBFQ2hhcnRzIDMuMCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0T3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwuZ2V0T3B0aW9uKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRXaWR0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldERldmljZVBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ci5wYWludGVyLmRwciB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFJlbmRlcmVkQ2FudmFzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMucGl4ZWxSYXRpbyA9IG9wdHMucGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBvcHRzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICB8fCB0aGlzLl9tb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgdmFyIGxpc3QgPSB6ci5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgIC8vIFN0b3AgYW5pbWF0aW9uc1xuICAgICAgICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4genIucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyhvcHRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5waXhlbFJhdGlvPTFdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZXhjbHVkZUNvbXBvbmVudHNdXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldERhdGFVUkwgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdmFyIGV4Y2x1ZGVDb21wb25lbnRzID0gb3B0cy5leGNsdWRlQ29tcG9uZW50cztcbiAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICAgICAgdmFyIGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MgPSBbXTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGVhY2goZXhjbHVkZUNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiBjb21wb25lbnRUeXBlXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBzZWxmLl9jb21wb25lbnRzTWFwW2NvbXBvbmVudC5fX3ZpZXdJZF07XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3Lmdyb3VwLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlc0NvbXBvbmVudFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZ3JvdXAuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0UmVuZGVyZWRDYW52YXMob3B0cykudG9EYXRhVVJMKFxuICAgICAgICAgICAgJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpXG4gICAgICAgICk7XG5cbiAgICAgICAgZWFjaChleGNsdWRlc0NvbXBvbmVudFZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgdmlldy5ncm91cC5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnR5cGU9J3BuZyddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnBpeGVsUmF0aW89MV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRDb25uZWN0ZWREYXRhVVJMID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwSWQgPSB0aGlzLmdyb3VwO1xuICAgICAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgICAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgICAgICB2YXIgTUFYX05VTUJFUiA9IEluZmluaXR5O1xuICAgICAgICBpZiAoY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IE1BWF9OVU1CRVI7XG4gICAgICAgICAgICB2YXIgdG9wID0gTUFYX05VTUJFUjtcbiAgICAgICAgICAgIHZhciByaWdodCA9IC1NQVhfTlVNQkVSO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IC1NQVhfTlVNQkVSO1xuICAgICAgICAgICAgdmFyIGNhbnZhc0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBkcHIgPSAob3B0cyAmJiBvcHRzLnBpeGVsUmF0aW8pIHx8IDE7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24gKGNoYXJ0LCBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFydC5ncm91cCA9PT0gZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gY2hhcnQuZ2V0UmVuZGVyZWRDYW52YXMoXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuY2xvbmUob3B0cylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IGNoYXJ0LmdldERvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbWF0aE1pbihib3VuZGluZ1JlY3QubGVmdCwgbGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LnRvcCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5yaWdodCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb206IGNhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0ICo9IGRwcjtcbiAgICAgICAgICAgIHRvcCAqPSBkcHI7XG4gICAgICAgICAgICByaWdodCAqPSBkcHI7XG4gICAgICAgICAgICBib3R0b20gKj0gZHByO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRDYW52YXMgPSB6clV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB2YXIgenIgPSB6cmVuZGVyLmluaXQodGFyZ2V0Q2FudmFzKTtcblxuICAgICAgICAgICAgZWFjaChjYW52YXNMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLmxlZnQgKiBkcHIgLSBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS50b3AgKiBkcHIgLSB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaXRlbS5kb21cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHpyLmFkZChpbWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB6ci5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGFVUkwob3B0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBmcm9tIGxvZ2ljYWwgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gcGl4ZWwgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogU2VlIENvb3JkaW5hdGVTeXN0ZW0jY29udmVydFRvUGl4ZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAgICAgKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAgICAgKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gICAgICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkLCBnZW9OYW1lLFxuICAgICAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gICAgICogICAgICAgICAgICB4QXhpc0luZGV4IC8geEF4aXNJZCAvIHhBeGlzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gICAgICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAgICAgKiAgICAgICAgfVxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fG51bWJlcn0gcmVzdWx0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNvbnZlcnRUb1BpeGVsID0genJVdGlsLmN1cnJ5KGRvQ29udmVydFBpeGVsLCAnY29udmVydFRvUGl4ZWwnKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZnJvbSBwaXhlbCBjb29yZGluYXRlIHN5c3RlbSB0byBsb2dpY2FsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIFNlZSBDb29yZGluYXRlU3lzdGVtI2NvbnZlcnRGcm9tUGl4ZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAgICAgKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAgICAgKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gICAgICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkIC8gZ2VvTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGJtYXBJbmRleCAvIGJtYXBJZCAvIGJtYXBOYW1lLFxuICAgICAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZVxuICAgICAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gICAgICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAgICAgKiAgICAgICAgfVxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fG51bWJlcn0gcmVzdWx0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSB6clV0aWwuY3VycnkoZG9Db252ZXJ0UGl4ZWwsICdjb252ZXJ0RnJvbVBpeGVsJyk7XG5cbiAgICBmdW5jdGlvbiBkb0NvbnZlcnRQaXhlbChtZXRob2ROYW1lLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciBjb29yZFN5c0xpc3QgPSB0aGlzLl9jb29yZFN5c01nci5nZXRDb29yZGluYXRlU3lzdGVtcygpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRTeXNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBjb29yZFN5c0xpc3RbaV07XG4gICAgICAgICAgICBpZiAoY29vcmRTeXNbbWV0aG9kTmFtZV1cbiAgICAgICAgICAgICAgICAmJiAocmVzdWx0ID0gY29vcmRTeXNbbWV0aG9kTmFtZV0oZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkpICE9IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdObyBjb29yZGluYXRlIHN5c3RlbSB0aGF0IHN1cHBvcnRzICcgKyBtZXRob2ROYW1lICsgJyBmb3VuZCBieSB0aGUgZ2l2ZW4gZmluZGVyLidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUgc3lzdGVtcyBvciBjb21wb25lbnRzIGNvbnRhaW4gdGhlIGdpdmVuIHBpeGVsIHBvaW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gICAgICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gICAgICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCAvIGdlb05hbWUsXG4gICAgICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgeUF4aXNJbmRleCAvIHlBeGlzSWQgLyB5QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICBncmlkSW5kZXggLyBncmlkSWQgLyBncmlkTmFtZSxcbiAgICAgKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICAgICAqICAgICAgICB9XG4gICAgICogQHBhcmFtIHtBcnJheXxudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gcmVzdWx0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNvbnRhaW5QaXhlbCA9IGZ1bmN0aW9uIChmaW5kZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgZmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG5cbiAgICAgICAgenJVdGlsLmVhY2goZmluZGVyLCBmdW5jdGlvbiAobW9kZWxzLCBrZXkpIHtcbiAgICAgICAgICAgIGtleS5pbmRleE9mKCdNb2RlbHMnKSA+PSAwICYmIHpyVXRpbC5lYWNoKG1vZGVscywgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gbW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuY29udGFpblBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAhIWNvb3JkU3lzLmNvbnRhaW5Qb2ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3Nlcmllc01vZGVscycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jaGFydHNNYXBbbW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldyAmJiB2aWV3LmNvbnRhaW5Qb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IHZpZXcuY29udGFpblBvaW50KHZhbHVlLCBtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihrZXkgKyAnOiAnICsgKHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnVGhlIGZvdW5kIGNvbXBvbmVudCBkbyBub3Qgc3VwcG9ydCBjb250YWluUG9pbnQuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdObyB2aWV3IG1hcHBpbmcgdG8gdGhlIGZvdW5kIGNvbXBvbmVudC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgJzogY29udGFpblBvaW50IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aXN1YWwgZnJvbSBzZXJpZXMgb3IgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICAgICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdzZXJpZXMnLCBtZWFucyB7c2VyaWVzSW5kZXg6IDB9LlxuICAgICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGRhdGFJbmRleCAvIGRhdGFJbmRleEluc2lkZVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgICAgIElmIGRhdGFJbmRleCBpcyBub3Qgc3BlY2lmaWVkLCBzZXJpZXMgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCxcbiAgICAgKiAgICAgICAgYnV0IG5vdCBkYXRhIGl0ZW0gdmlzdWFsLlxuICAgICAqICAgICAgICBJZiBhbGwgb2Ygc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lIGFyZSBub3Qgc3BlY2lmaWVkLFxuICAgICAqICAgICAgICB2aXN1YWwgd2lsbCBiZSBmZXRjaGVkIGZyb20gZmlyc3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aXN1YWxUeXBlICdjb2xvcicsICdzeW1ib2wnLCAnc3ltYm9sU2l6ZSdcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGZpbmRlciwgdmlzdWFsVHlwZSkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIsIHtkZWZhdWx0TWFpblR5cGU6ICdzZXJpZXMnfSk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIXNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGVyZSBpcyBubyBzcGVjaWZpZWQgc2VpcmVzIG1vZGVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICB2YXIgZGF0YUluZGV4SW5zaWRlID0gZmluZGVyLmhhc093blByb3BlcnR5KCdkYXRhSW5kZXhJbnNpZGUnKVxuICAgICAgICAgICAgPyBmaW5kZXIuZGF0YUluZGV4SW5zaWRlXG4gICAgICAgICAgICA6IGZpbmRlci5oYXNPd25Qcm9wZXJ0eSgnZGF0YUluZGV4JylcbiAgICAgICAgICAgID8gZGF0YS5pbmRleE9mUmF3SW5kZXgoZmluZGVyLmRhdGFJbmRleClcbiAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICByZXR1cm4gZGF0YUluZGV4SW5zaWRlICE9IG51bGxcbiAgICAgICAgICAgID8gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleEluc2lkZSwgdmlzdWFsVHlwZSlcbiAgICAgICAgICAgIDogZGF0YS5nZXRWaXN1YWwodmlzdWFsVHlwZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50IG1vZGVsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb21wb25lbnRNb2RlbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbCA9IGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcFtjb21wb25lbnRNb2RlbC5fX3ZpZXdJZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgc2VyaWVzIG1vZGVsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFZpZXdPZlNlcmllc01vZGVsID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgIH07XG5cblxuICAgIHZhciB1cGRhdGVNZXRob2RzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5wcm9maWxlICYmIGNvbnNvbGUucHJvZmlsZSgndXBkYXRlJyk7XG5cbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzTWdyID0gdGhpcy5fY29vcmRTeXNNZ3I7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpeG1lIEZpcnN0IHRpbWUgdXBkYXRlID9cbiAgICAgICAgICAgIGVjTW9kZWwucmVzdG9yZURhdGEoKTtcblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gU2F2ZSB0b3RhbCBlY01vZGVsIGhlcmUgZm9yIHVuZG8vcmVkbyAoYWZ0ZXIgcmVzdG9yaW5nIGRhdGEgYW5kIGJlZm9yZSBwcm9jZXNzaW5nIGRhdGEpLlxuICAgICAgICAgICAgLy8gVW5kbyAocmVzdG9yYXRpb24gb2YgdG90YWwgZWNNb2RlbCkgY2FuIGJlIGNhcnJpZWQgb3V0IGluICdhY3Rpb24nIG9yIG91dHNpZGUgQVBJIGNhbGwuXG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgY29vcmRpbmF0ZSBzeXN0ZW0gZWFjaCB1cGRhdGVcbiAgICAgICAgICAgIC8vIEluIExpbmVWaWV3IG1heSBzYXZlIHRoZSBvbGQgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIHVzZSBpdCB0byBnZXQgdGhlIG9yaWduYWwgcG9pbnRcbiAgICAgICAgICAgIGNvb3JkU3lzTWdyLmNyZWF0ZSh0aGlzLl9tb2RlbCwgdGhpcy5fYXBpKTtcblxuICAgICAgICAgICAgcHJvY2Vzc0RhdGEuY2FsbCh0aGlzLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgICAgICAgICBzdGFja1Nlcmllc0RhdGEuY2FsbCh0aGlzLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgY29vcmRTeXNNZ3IudXBkYXRlKGVjTW9kZWwsIGFwaSk7XG5cbiAgICAgICAgICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgZG9SZW5kZXIuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgLy8gU2V0IGJhY2tncm91bmRcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlY01vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJ3RyYW5zcGFyZW50JztcblxuICAgICAgICAgICAgdmFyIHBhaW50ZXIgPSB6ci5wYWludGVyO1xuICAgICAgICAgICAgLy8gVE9ETyBhbGwgdXNlIGNsZWFyQ29sb3IgP1xuICAgICAgICAgICAgaWYgKHBhaW50ZXIuaXNTaW5nbGVDYW52YXMgJiYgcGFpbnRlci5pc1NpbmdsZUNhbnZhcygpKSB7XG4gICAgICAgICAgICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIElFOFxuICAgICAgICAgICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gY29sb3JUb29sLnN0cmluZ2lmeShjb2xvckFyciwgJ3JnYicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JBcnJbM10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvci5jb2xvclN0b3BzIHx8IGJhY2tncm91bmRDb2xvci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHcmFkaWVudCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEZpeGVkIGxheWVy77yfXG4gICAgICAgICAgICAgICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3I6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlYWNoKHBvc3RVcGRhdGVGdW5jcywgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBmdW5jKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5wcm9maWxlICYmIGNvbnNvbGUucHJvZmlsZUVuZCgndXBkYXRlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVWaWV3OiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldERhdGEoKS5jbGVhckFsbFZpc3VhbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaW52b2tlVXBkYXRlTWV0aG9kLmNhbGwodGhpcywgJ3VwZGF0ZVZpZXcnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVZpc3VhbDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY2xlYXJBbGxWaXN1YWwoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVWaXN1YWwnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvTGF5b3V0LmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVMYXlvdXQnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVBbmRVcGRhdGU6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICBwcmVwYXJlVmlldy5jYWxsKHRoaXMsICdjb21wb25lbnQnLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgcHJlcGFyZVZpZXcuY2FsbCh0aGlzLCAnY2hhcnQnLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZURpcmVjdGx5KGVjSW5zLCBtZXRob2QsIHBheWxvYWQsIG1haW5UeXBlLCBzdWJUeXBlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gZWNJbnMuX21vZGVsO1xuXG4gICAgICAgIC8vIGJyb2FkY2FzdFxuICAgICAgICBpZiAoIW1haW5UeXBlKSB7XG4gICAgICAgICAgICBlYWNoKGVjSW5zLl9jb21wb25lbnRzVmlld3MuY29uY2F0KGVjSW5zLl9jaGFydHNWaWV3cyksIGNhbGxWaWV3KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBxdWVyeSA9IHt9O1xuICAgICAgICBxdWVyeVttYWluVHlwZSArICdJZCddID0gcGF5bG9hZFttYWluVHlwZSArICdJZCddO1xuICAgICAgICBxdWVyeVttYWluVHlwZSArICdJbmRleCddID0gcGF5bG9hZFttYWluVHlwZSArICdJbmRleCddO1xuICAgICAgICBxdWVyeVttYWluVHlwZSArICdOYW1lJ10gPSBwYXlsb2FkW21haW5UeXBlICsgJ05hbWUnXTtcblxuICAgICAgICB2YXIgY29uZGl0aW9uID0ge21haW5UeXBlOiBtYWluVHlwZSwgcXVlcnk6IHF1ZXJ5fTtcbiAgICAgICAgc3ViVHlwZSAmJiAoY29uZGl0aW9uLnN1YlR5cGUgPSBzdWJUeXBlKTsgLy8gc3ViVHlwZSBtYXkgYmUgJycgYnkgcGFyc2VDbGFzc1R5cGU7XG5cbiAgICAgICAgLy8gSWYgZGlzcGF0Y2hBY3Rpb24gYmVmb3JlIHNldE9wdGlvbiwgZG8gbm90aGluZy5cbiAgICAgICAgZWNNb2RlbCAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoY29uZGl0aW9uLCBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAgICBjYWxsVmlldyhlY0luc1tcbiAgICAgICAgICAgICAgICBtYWluVHlwZSA9PT0gJ3NlcmllcycgPyAnX2NoYXJ0c01hcCcgOiAnX2NvbXBvbmVudHNNYXAnXG4gICAgICAgICAgICBdW21vZGVsLl9fdmlld0lkXSk7XG4gICAgICAgIH0sIGVjSW5zKTtcblxuICAgICAgICBmdW5jdGlvbiBjYWxsVmlldyh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3ICYmIHZpZXcuX19hbGl2ZSAmJiB2aWV3W21ldGhvZF0gJiYgdmlld1ttZXRob2RdKFxuICAgICAgICAgICAgICAgIHZpZXcuX19tb2RlbCwgZWNNb2RlbCwgZWNJbnMuX2FwaSwgcGF5bG9hZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0aGUgY2hhcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KCF0aGlzW0lOX01BSU5fUFJPQ0VTU10sICdgcmVzaXplYCBzaG91bGQgbm90IGJlIGNhbGxlZCBkdXJpbmcgbWFpbiBwcm9jZXNzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl96ci5yZXNpemUob3B0cyk7XG5cbiAgICAgICAgdmFyIG9wdGlvbkNoYW5nZWQgPSB0aGlzLl9tb2RlbCAmJiB0aGlzLl9tb2RlbC5yZXNldE9wdGlvbignbWVkaWEnKTtcbiAgICAgICAgdmFyIHVwZGF0ZU1ldGhvZCA9IG9wdGlvbkNoYW5nZWQgPyAncHJlcGFyZUFuZFVwZGF0ZScgOiAndXBkYXRlJztcblxuICAgICAgICB1cGRhdGVNZXRob2RzW3VwZGF0ZU1ldGhvZF0uY2FsbCh0aGlzKTtcblxuICAgICAgICAvLyBSZXNpemUgbG9hZGluZyBlZmZlY3RcbiAgICAgICAgdGhpcy5fbG9hZGluZ0ZYICYmIHRoaXMuX2xvYWRpbmdGWC5yZXNpemUoKTtcblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcblxuICAgICAgICB2YXIgc2lsZW50ID0gb3B0cyAmJiBvcHRzLnNpbGVudDtcblxuICAgICAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcblxuICAgICAgICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgc2lsZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvdyBsb2FkaW5nIGVmZmVjdFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gW25hbWU9J2RlZmF1bHQnXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2NmZ11cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uc2hvd0xvYWRpbmcgPSBmdW5jdGlvbiAobmFtZSwgY2ZnKSB7XG4gICAgICAgIGlmICh6clV0aWwuaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNmZyA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgaWYgKCFsb2FkaW5nRWZmZWN0c1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0xvYWRpbmcgZWZmZWN0cyAnICsgbmFtZSArICcgbm90IGV4aXN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSBsb2FkaW5nRWZmZWN0c1tuYW1lXSh0aGlzLl9hcGksIGNmZyk7XG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyO1xuICAgICAgICB0aGlzLl9sb2FkaW5nRlggPSBlbDtcblxuICAgICAgICB6ci5hZGQoZWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGxvYWRpbmcgZWZmZWN0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmhpZGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2FkaW5nRlggJiYgdGhpcy5fenIucmVtb3ZlKHRoaXMuX2xvYWRpbmdGWCk7XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE9ialxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8ubWFrZUFjdGlvbkZyb21FdmVudCA9IGZ1bmN0aW9uIChldmVudE9iaikge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHpyVXRpbC5leHRlbmQoe30sIGV2ZW50T2JqKTtcbiAgICAgICAgcGF5bG9hZC50eXBlID0gZXZlbnRBY3Rpb25NYXBbZXZlbnRPYmoudHlwZV07XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHViaWxjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BheWxvYWQudHlwZV0gQWN0aW9uIHR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbb3B0XSBJZiBwYXNzIGJvb2xlYW4sIG1lYW5zIG9wdC5zaWxlbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuc2lsZW50PWZhbHNlXSBXaGV0aGVyIHRyaWdnZXIgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5mbHVzaD11bmRlZmluZWRdXG4gICAgICogICAgICAgICAgICAgICAgICB0cnVlOiBGbHVzaCBpbW1lZGlhdGVseSwgYW5kIHRoZW4gcGl4ZWwgaW4gY2FudmFzIGNhbiBiZSBmZXRjaGVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlbHkuIENhdXRpb246IGl0IG1pZ2h0IGFmZmVjdCBwZXJmb3JtYW5jZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgIGZhbHNlOiBOb3Qgbm90IGZsdXNoLlxuICAgICAqICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkOiBBdXRvIGRlY2lkZSB3aGV0aGVyIHBlcmZvcm0gZmx1c2guXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQsIG9wdCkge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgICBvcHQgPSB7c2lsZW50OiAhIW9wdH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFjdGlvbnNbcGF5bG9hZC50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF5IGRpc3BhdGNoQWN0aW9uIGluIHJlbmRlcmluZyBwcm9jZWR1cmVcbiAgICAgICAgaWYgKHRoaXNbSU5fTUFJTl9QUk9DRVNTXSkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvRGlzcGF0Y2hBY3Rpb24uY2FsbCh0aGlzLCBwYXlsb2FkLCBvcHQuc2lsZW50KTtcblxuICAgICAgICBpZiAob3B0LmZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLl96ci5mbHVzaCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHQuZmx1c2ggIT09IGZhbHNlICYmIGVudi5icm93c2VyLndlQ2hhdCkge1xuICAgICAgICAgICAgLy8gSW4gV2VDaGF0IGVtYmVkZWQgYnJvd3NlciwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYW5kIGBzZXRJbnRlcnZhbGBcbiAgICAgICAgICAgIC8vIGhhbmcgd2hlbiBzbGlkaW5nIHBhZ2UgKG9uIHRvdWNoIGV2ZW50KSwgd2hpY2ggY2F1c2UgdGhhdCB6ciBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gcmVmcmVzaCB1dGlsIHVzZXIgaW50ZXJhY3Rpb24gZmluaXNoZWQsIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAgICAgICAgIC8vIEJ1dCBgZGlzcGF0Y2hBY3Rpb25gIG1heSBiZSBjYWxsZWQgdG9vIGZyZXF1ZW50bHkgd2hlbiBwYW4gb24gdG91Y2hcbiAgICAgICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggaW1wYWN0cyBwZXJmb3JtYW5jZSBpZiBkbyBub3QgdGhyb3R0bGUgdGhlbS5cbiAgICAgICAgICAgIHRoaXMuX3Rocm90dGxlZFpyRmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBvcHQuc2lsZW50KTtcblxuICAgICAgICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgb3B0LnNpbGVudCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRvRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgc2lsZW50KSB7XG4gICAgICAgIHZhciBwYXlsb2FkVHlwZSA9IHBheWxvYWQudHlwZTtcbiAgICAgICAgdmFyIGVzY2FwZUNvbm5lY3QgPSBwYXlsb2FkLmVzY2FwZUNvbm5lY3Q7XG4gICAgICAgIHZhciBhY3Rpb25XcmFwID0gYWN0aW9uc1twYXlsb2FkVHlwZV07XG4gICAgICAgIHZhciBhY3Rpb25JbmZvID0gYWN0aW9uV3JhcC5hY3Rpb25JbmZvO1xuXG4gICAgICAgIHZhciBjcHRUeXBlID0gKGFjdGlvbkluZm8udXBkYXRlIHx8ICd1cGRhdGUnKS5zcGxpdCgnOicpO1xuICAgICAgICB2YXIgdXBkYXRlTWV0aG9kID0gY3B0VHlwZS5wb3AoKTtcbiAgICAgICAgY3B0VHlwZSA9IGNwdFR5cGVbMF0gIT0gbnVsbCAmJiBwYXJzZUNsYXNzVHlwZShjcHRUeXBlWzBdKTtcblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gICAgICAgIHZhciBwYXlsb2FkcyA9IFtwYXlsb2FkXTtcbiAgICAgICAgdmFyIGJhdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQmF0Y2ggYWN0aW9uXG4gICAgICAgIGlmIChwYXlsb2FkLmJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBheWxvYWRzID0genJVdGlsLm1hcChwYXlsb2FkLmJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmV4dGVuZCh7fSwgaXRlbSksIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGl0ZW0uYmF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRPYmpCYXRjaCA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRPYmo7XG4gICAgICAgIHZhciBpc0hpZ2hEb3duID0gcGF5bG9hZFR5cGUgPT09ICdoaWdobGlnaHQnIHx8IHBheWxvYWRUeXBlID09PSAnZG93bnBsYXknO1xuXG4gICAgICAgIGVhY2gocGF5bG9hZHMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICAgICAgICAgIC8vIEFjdGlvbiBjYW4gc3BlY2lmeSB0aGUgZXZlbnQgYnkgcmV0dXJuIGl0LlxuICAgICAgICAgICAgZXZlbnRPYmogPSBhY3Rpb25XcmFwLmFjdGlvbihiYXRjaEl0ZW0sIHRoaXMuX21vZGVsLCB0aGlzLl9hcGkpO1xuICAgICAgICAgICAgLy8gRW1pdCBldmVudCBvdXRzaWRlXG4gICAgICAgICAgICBldmVudE9iaiA9IGV2ZW50T2JqIHx8IHpyVXRpbC5leHRlbmQoe30sIGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHR5cGUgdG8gZXZlbnRUeXBlXG4gICAgICAgICAgICBldmVudE9iai50eXBlID0gYWN0aW9uSW5mby5ldmVudCB8fCBldmVudE9iai50eXBlO1xuICAgICAgICAgICAgZXZlbnRPYmpCYXRjaC5wdXNoKGV2ZW50T2JqKTtcblxuICAgICAgICAgICAgLy8gbGlnaHQgdXBkYXRlIGRvZXMgbm90IHBlcmZvcm0gZGF0YSBwcm9jZXNzLCBsYXlvdXQgYW5kIHZpc3VhbC5cbiAgICAgICAgICAgIGlmIChpc0hpZ2hEb3duKSB7XG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kLCBwYXlsb2FkLCBtYWluVHlwZSwgc3ViVHlwZVxuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGx5KHRoaXMsIHVwZGF0ZU1ldGhvZCwgYmF0Y2hJdGVtLCAnc2VyaWVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRGlyZWN0bHkodGhpcywgdXBkYXRlTWV0aG9kLCBiYXRjaEl0ZW0sIGNwdFR5cGUubWFpbiwgY3B0VHlwZS5zdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAodXBkYXRlTWV0aG9kICE9PSAnbm9uZScgJiYgIWlzSGlnaERvd24gJiYgIWNwdFR5cGUpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIGRpcnR5XG4gICAgICAgICAgICBpZiAodGhpc1tPUFRJT05fVVBEQVRFRF0pIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBQYXNzIHBheWxvYWQgP1xuICAgICAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVNZXRob2RzW3VwZGF0ZU1ldGhvZF0uY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvbGxvdyB0aGUgcnVsZSBvZiBhY3Rpb24gYmF0Y2hcbiAgICAgICAgaWYgKGJhdGNoZWQpIHtcbiAgICAgICAgICAgIGV2ZW50T2JqID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGFjdGlvbkluZm8uZXZlbnQgfHwgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgZXNjYXBlQ29ubmVjdDogZXNjYXBlQ29ubmVjdCxcbiAgICAgICAgICAgICAgICBiYXRjaDogZXZlbnRPYmpCYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50T2JqID0gZXZlbnRPYmpCYXRjaFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgICFzaWxlbnQgJiYgdGhpcy5fbWVzc2FnZUNlbnRlci50cmlnZ2VyKGV2ZW50T2JqLnR5cGUsIGV2ZW50T2JqKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdBY3Rpb25zKHNpbGVudCkge1xuICAgICAgICB2YXIgcGVuZGluZ0FjdGlvbnMgPSB0aGlzLl9wZW5kaW5nQWN0aW9ucztcbiAgICAgICAgd2hpbGUgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBwZW5kaW5nQWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgZG9EaXNwYXRjaEFjdGlvbi5jYWxsKHRoaXMsIHBheWxvYWQsIHNpbGVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyVXBkYXRlZEV2ZW50KHNpbGVudCkge1xuICAgICAgICAhc2lsZW50ICYmIHRoaXMudHJpZ2dlcigndXBkYXRlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGV2ZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb24nKTtcbiAgICBlY2hhcnRzUHJvdG8ub2ZmID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvZmYnKTtcbiAgICBlY2hhcnRzUHJvdG8ub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2VVcGRhdGVNZXRob2QobWV0aG9kTmFtZSwgZWNNb2RlbCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgY29tcG9uZW50c1xuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gY29tcG9uZW50Ll9fbW9kZWw7XG4gICAgICAgICAgICBjb21wb25lbnRbbWV0aG9kTmFtZV0oY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFVwYXRlIGFsbCBjaGFydHNcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgY2hhcnQgPSB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgICAgY2hhcnRbbWV0aG9kTmFtZV0oc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooc2VyaWVzTW9kZWwsIGNoYXJ0KTtcblxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3NpdmVBbmRCbGVuZChzZXJpZXNNb2RlbCwgY2hhcnQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBJZiB1c2UgaG92ZXIgbGF5ZXJcbiAgICAgICAgdXBkYXRlSG92ZXJMYXllclN0YXR1cyh0aGlzLl96ciwgZWNNb2RlbCk7XG5cbiAgICAgICAgLy8gUG9zdCByZW5kZXJcbiAgICAgICAgZWFjaChwb3N0VXBkYXRlRnVuY3MsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICBmdW5jKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdmlldyBpbnN0YW5jZXMgb2YgY2hhcnRzIGFuZCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlVmlldyh0eXBlLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBpc0NvbXBvbmVudCA9IHR5cGUgPT09ICdjb21wb25lbnQnO1xuICAgICAgICB2YXIgdmlld0xpc3QgPSBpc0NvbXBvbmVudCA/IHRoaXMuX2NvbXBvbmVudHNWaWV3cyA6IHRoaXMuX2NoYXJ0c1ZpZXdzO1xuICAgICAgICB2YXIgdmlld01hcCA9IGlzQ29tcG9uZW50ID8gdGhpcy5fY29tcG9uZW50c01hcCA6IHRoaXMuX2NoYXJ0c01hcDtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlld0xpc3RbaV0uX19hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWNNb2RlbFtpc0NvbXBvbmVudCA/ICdlYWNoQ29tcG9uZW50JyA6ICdlYWNoU2VyaWVzJ10oZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZSA9PT0gJ3NlcmllcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVsID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29uc2lkZXI6IGlkIHNhbWUgYW5kIHR5cGUgY2hhbmdlZC5cbiAgICAgICAgICAgIHZhciB2aWV3SWQgPSAnX2VjXycgKyBtb2RlbC5pZCArICdfJyArIG1vZGVsLnR5cGU7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdNYXBbdmlld0lkXTtcbiAgICAgICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShtb2RlbC50eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgQ2xhenogPSBpc0NvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICA/IENvbXBvbmVudFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIpXG4gICAgICAgICAgICAgICAgICAgIDogQ2hhcnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5zdWIpO1xuICAgICAgICAgICAgICAgIGlmIChDbGF6eikge1xuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gbmV3IENsYXp6KCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaW5pdChlY01vZGVsLCB0aGlzLl9hcGkpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3TWFwW3ZpZXdJZF0gPSB2aWV3O1xuICAgICAgICAgICAgICAgICAgICB2aWV3TGlzdC5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB6ci5hZGQodmlldy5ncm91cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFcnJvclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb2RlbC5fX3ZpZXdJZCA9IHZpZXcuX19pZCA9IHZpZXdJZDtcbiAgICAgICAgICAgIHZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB2aWV3Ll9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgICAgIHZpZXcuZ3JvdXAuX19lY0NvbXBvbmVudEluZm8gPSB7XG4gICAgICAgICAgICAgICAgbWFpblR5cGU6IG1vZGVsLm1haW5UeXBlLFxuICAgICAgICAgICAgICAgIGluZGV4OiBtb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3TGlzdC5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKCF2aWV3Ll9fYWxpdmUpIHtcbiAgICAgICAgICAgICAgICB6ci5yZW1vdmUodmlldy5ncm91cCk7XG4gICAgICAgICAgICAgICAgdmlldy5kaXNwb3NlKGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgICAgICAgICAgICAgdmlld0xpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2aWV3TWFwW3ZpZXcuX19pZF07XG4gICAgICAgICAgICAgICAgdmlldy5fX2lkID0gdmlldy5ncm91cC5fX2VjQ29tcG9uZW50SW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzb3IgZGF0YSBpbiBlYWNoIHNlcmllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICBlYWNoKGRhdGFQcm9jZXNzb3JGdW5jcywgZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZnVuYyhlY01vZGVsLCBhcGkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2VyaWVzRGF0YShlY01vZGVsKSB7XG4gICAgICAgIHZhciBzdGFja2VkRGF0YU1hcCA9IHt9O1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gc2VyaWVzLmdldCgnc3RhY2snKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzLmdldERhdGEoKTtcbiAgICAgICAgICAgIGlmIChzdGFjayAmJiBkYXRhLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1N0YWNrID0gc3RhY2tlZERhdGFNYXBbc3RhY2tdO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIGlmIChzdGFja2VkRGF0YU1hcC5oYXNPd25Qcm9wZXJ0eShzdGFjaykgJiYgcHJldmlvdXNTdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YWNrZWRPbiA9IHByZXZpb3VzU3RhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrZWREYXRhTWFwW3N0YWNrXSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExheW91dCBiZWZvcmUgZWFjaCBjaGFydCByZW5kZXIgdGhlcmUgc2VyaWVzLCBzcGVjaWFsIHZpc3VhbCBlbmNvZGluZyBzdGFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvTGF5b3V0KGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgZWFjaCh2aXN1YWxGdW5jcywgZnVuY3Rpb24gKHZpc3VhbCkge1xuICAgICAgICAgICAgaWYgKHZpc3VhbC5pc0xheW91dCkge1xuICAgICAgICAgICAgICAgIHZpc3VhbC5mdW5jKGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZSB2aXN1YWwgaW5mb21hdGlvbiBmcm9tIGRhdGEgYWZ0ZXIgZGF0YSBwcm9jZXNzaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlc0xheW91dF1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvVmlzdWFsRW5jb2RpbmcoZWNNb2RlbCwgcGF5bG9hZCwgZXhjbHVkZXNMYXlvdXQpIHtcbiAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgZWNNb2RlbC5jbGVhckNvbG9yUGFsZXR0ZSgpO1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5jbGVhckNvbG9yUGFsZXR0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCh2aXN1YWxGdW5jcywgZnVuY3Rpb24gKHZpc3VhbCkge1xuICAgICAgICAgICAgKCFleGNsdWRlc0xheW91dCB8fCAhdmlzdWFsLmlzTGF5b3V0KVxuICAgICAgICAgICAgICAgICYmIHZpc3VhbC5mdW5jKGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBlYWNoIGNoYXJ0IGFuZCBjb21wb25lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvUmVuZGVyKGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgLy8gUmVuZGVyIGFsbCBjb21wb25lbnRzXG4gICAgICAgIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50Vmlldykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gY29tcG9uZW50Vmlldy5fX21vZGVsO1xuICAgICAgICAgICAgY29tcG9uZW50Vmlldy5yZW5kZXIoY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudFZpZXcpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBlYWNoKHRoaXMuX2NoYXJ0c1ZpZXdzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgICAgIGNoYXJ0Ll9fYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gUmVuZGVyIGFsbCBjaGFydHNcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgY2hhcnRWaWV3ID0gdGhpcy5fY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXTtcbiAgICAgICAgICAgIGNoYXJ0Vmlldy5fX2FsaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNoYXJ0Vmlldy5yZW5kZXIoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGNoYXJ0Vmlldy5ncm91cC5zaWxlbnQgPSAhIXNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldyk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVByb2dyZXNzaXZlQW5kQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldyk7XG5cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gSWYgdXNlIGhvdmVyIGxheWVyXG4gICAgICAgIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXModGhpcy5fenIsIGVjTW9kZWwpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBncm91cHMgb2YgdW5yZW5kZXJlZCBjaGFydHNcbiAgICAgICAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICBpZiAoIWNoYXJ0Ll9fYWxpdmUpIHtcbiAgICAgICAgICAgICAgICBjaGFydC5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gW1xuICAgICAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsXG4gICAgICAgICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdnbG9iYWxvdXQnLCAnY29udGV4dG1lbnUnXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3pyLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmdldE1vZGVsKCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcztcblxuICAgICAgICAgICAgICAgIC8vIG5vIGUudGFyZ2V0IHdoZW4gJ2dsb2JhbG91dCcuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZU5hbWUgPT09ICdnbG9iYWxvdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChlbC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGRhdGFNb2RlbCAmJiBkYXRhTW9kZWwuZ2V0RGF0YVBhcmFtcyhlbC5kYXRhSW5kZXgsIGVsLmRhdGFUeXBlKSB8fCB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBoYXMgY3VzdG9tIGV2ZW50RGF0YSBvZiBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwgJiYgZWwuZXZlbnREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHpyVXRpbC5leHRlbmQoe30sIGVsLmV2ZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVOYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGVhY2goZXZlbnRBY3Rpb25NYXAsIGZ1bmN0aW9uIChhY3Rpb25UeXBlLCBldmVudFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VDZW50ZXIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnRUeXBlLCBldmVudCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmlzRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKHsgc2VyaWVzOiBbXSB9LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbnN0YW5jZSAnICsgdGhpcy5pZCArICcgaGFzIGJlZW4gZGlzcG9zZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgY2hhcnQuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEaXNwb3NlIGFmdGVyIGFsbCB2aWV3cyBkaXNwb3NlZFxuICAgICAgICB0aGlzLl96ci5kaXNwb3NlKCk7XG5cbiAgICAgICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICB9O1xuXG4gICAgenJVdGlsLm1peGluKEVDaGFydHMsIEV2ZW50ZnVsKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXMoenIsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB6ci5zdG9yYWdlO1xuICAgICAgICB2YXIgZWxDb3VudCA9IDA7XG4gICAgICAgIHN0b3JhZ2UudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxDb3VudCA+IGVjTW9kZWwuZ2V0KCdob3ZlckxheWVyVGhyZXNob2xkJykgJiYgIWVudi5ub2RlKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC51c2VIb3ZlckxheWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGFydCBwcm9ncmVzc2l2ZSBhbmQgYmxlbmQuXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN8bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBtb2RlbFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnR8bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydH0gdmlld1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzaXZlQW5kQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldykge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBjb25maWd1cmF0aW9uXG4gICAgICAgIHZhciBlbENvdW50ID0gMDtcbiAgICAgICAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgIT09ICdncm91cCcgJiYgIWVsLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGVsQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmcmFtZURyYXdOdW0gPSArc2VyaWVzTW9kZWwuZ2V0KCdwcm9ncmVzc2l2ZScpO1xuICAgICAgICB2YXIgbmVlZFByb2dyZXNzaXZlID0gZWxDb3VudCA+IHNlcmllc01vZGVsLmdldCgncHJvZ3Jlc3NpdmVUaHJlc2hvbGQnKSAmJiBmcmFtZURyYXdOdW0gJiYgIWVudi5ub2RlO1xuICAgICAgICBpZiAobmVlZFByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgbWFya2VyIGFuZCBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnByb2dyZXNzaXZlID0gbmVlZFByb2dyZXNzaXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZWxDb3VudCsrIC8gZnJhbWVEcmF3TnVtKSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCbGVuZCBjb25maWdyYXRpb25cbiAgICAgICAgdmFyIGJsZW5kTW9kZSA9IHNlcmllc01vZGVsLmdldCgnYmxlbmRNb2RlJykgfHwgbnVsbDtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCAmJiBibGVuZE1vZGUgJiYgYmxlbmRNb2RlICE9PSAnc291cmNlLW92ZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdPbmx5IGNhbnZhcyBzdXBwb3J0IGJsZW5kTW9kZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0U3R5bGUoJ2JsZW5kJywgYmxlbmRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN8bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBtb2RlbFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnR8bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydH0gdmlld1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVoobW9kZWwsIHZpZXcpIHtcbiAgICAgICAgdmFyIHogPSBtb2RlbC5nZXQoJ3onKTtcbiAgICAgICAgdmFyIHpsZXZlbCA9IG1vZGVsLmdldCgnemxldmVsJyk7XG4gICAgICAgIC8vIFNldCB6IGFuZCB6bGV2ZWxcbiAgICAgICAgdmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgeiAhPSBudWxsICYmIChlbC56ID0geik7XG4gICAgICAgICAgICAgICAgemxldmVsICE9IG51bGwgJiYgKGVsLnpsZXZlbCA9IHpsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkFQSShlY0luc3RhbmNlKSB7XG4gICAgICAgIHZhciBjb29yZFN5c01nciA9IGVjSW5zdGFuY2UuX2Nvb3JkU3lzTWdyO1xuICAgICAgICByZXR1cm4genJVdGlsLmV4dGVuZChuZXcgRXh0ZW5zaW9uQVBJKGVjSW5zdGFuY2UpLCB7XG4gICAgICAgICAgICAvLyBJbmplY3QgbWV0aG9kc1xuICAgICAgICAgICAgZ2V0Q29vcmRpbmF0ZVN5c3RlbXM6IHpyVXRpbC5iaW5kKFxuICAgICAgICAgICAgICAgIGNvb3JkU3lzTWdyLmdldENvb3JkaW5hdGVTeXN0ZW1zLCBjb29yZFN5c01nclxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGdldENvbXBvbmVudEJ5RWxlbWVudDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbEluZm8gPSBlbC5fX2VjQ29tcG9uZW50SW5mbztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWNJbnN0YW5jZS5fbW9kZWwuZ2V0Q29tcG9uZW50KG1vZGVsSW5mby5tYWluVHlwZSwgbW9kZWxJbmZvLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R9IGtleTogYWN0aW9uVHlwZS5cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgYWN0aW9ucyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogTWFwIGV2ZW50VHlwZSB0byBhY3Rpb25UeXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgZXZlbnRBY3Rpb25NYXAgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERhdGEgcHJvY2Vzc29yIGZ1bmN0aW9ucyBvZiBlYWNoIHN0YWdlXG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3QuPHN0cmluZywgRnVuY3Rpb24+Pn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgZGF0YVByb2Nlc3NvckZ1bmNzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBwb3N0VXBkYXRlRnVuY3MgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFZpc3VhbCBlbmNvZGluZyBmdW5jdGlvbnMgb2YgZWFjaCBzdGFnZVxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIHZpc3VhbEZ1bmNzID0gW107XG4gICAgLyoqXG4gICAgICogVGhlbWUgc3RvcmFnZVxuICAgICAqIEB0eXBlIHtPYmplY3QuPGtleSwgT2JqZWN0Pn1cbiAgICAgKi9cbiAgICB2YXIgdGhlbWVTdG9yYWdlID0ge307XG4gICAgLyoqXG4gICAgICogTG9hZGluZyBlZmZlY3RzXG4gICAgICovXG4gICAgdmFyIGxvYWRpbmdFZmZlY3RzID0ge307XG5cblxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTtcbiAgICB2YXIgY29ubmVjdGVkR3JvdXBzID0ge307XG5cbiAgICB2YXIgaWRCYXNlID0gbmV3IERhdGUoKSAtIDA7XG4gICAgdmFyIGdyb3VwSWRCYXNlID0gbmV3IERhdGUoKSAtIDA7XG4gICAgdmFyIERPTV9BVFRSSUJVVEVfS0VZID0gJ19lY2hhcnRzX2luc3RhbmNlXyc7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHNcbiAgICAgKi9cbiAgICB2YXIgZWNoYXJ0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2ZXJzaW9uOiAnMy42LjInLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgICAgIHpyZW5kZXI6ICczLjUuMidcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbmFibGVDb25uZWN0KGNoYXJ0KSB7XG4gICAgICAgIHZhciBTVEFUVVNfUEVORElORyA9IDA7XG4gICAgICAgIHZhciBTVEFUVVNfVVBEQVRJTkcgPSAxO1xuICAgICAgICB2YXIgU1RBVFVTX1VQREFURUQgPSAyO1xuICAgICAgICB2YXIgU1RBVFVTX0tFWSA9ICdfX2Nvbm5lY3RVcGRhdGVTdGF0dXMnO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhjaGFydHMsIHN0YXR1cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDaGFydCA9IGNoYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBvdGhlckNoYXJ0W1NUQVRVU19LRVldID0gc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgenJVdGlsLmVhY2goZXZlbnRBY3Rpb25NYXAsIGZ1bmN0aW9uIChhY3Rpb25UeXBlLCBldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNoYXJ0Ll9tZXNzYWdlQ2VudGVyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RlZEdyb3Vwc1tjaGFydC5ncm91cF0gJiYgY2hhcnRbU1RBVFVTX0tFWV0gIT09IFNUQVRVU19QRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBldmVudC5lc2NhcGVDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gY2hhcnQubWFrZUFjdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckNoYXJ0cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24gKG90aGVyQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckNoYXJ0ICE9PSBjaGFydCAmJiBvdGhlckNoYXJ0Lmdyb3VwID09PSBjaGFydC5ncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQ2hhcnRzLnB1c2gob3RoZXJDaGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhvdGhlckNoYXJ0cywgU1RBVFVTX1BFTkRJTkcpO1xuICAgICAgICAgICAgICAgICAgICBlYWNoKG90aGVyQ2hhcnRzLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ2hhcnRbU1RBVFVTX0tFWV0gIT09IFNUQVRVU19VUERBVElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQ2hhcnQuZGlzcGF0Y2hBY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhvdGhlckNoYXJ0cywgU1RBVFVTX1VQREFURUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxEb21FbGVtZW50fSBkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3RoZW1lXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dIFVzZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyXSBDdXJyZW50bHkgb25seSAnY2FudmFzJyBpcyBzdXBwb3J0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBVc2UgY2xpZW50V2lkdGggb2YgdGhlIGlucHV0IGBkb21gIGJ5IGRlZmF1bHQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBVc2UgY2xpZW50SGVpZ2h0IG9mIHRoZSBpbnB1dCBgZG9tYCBieSBkZWZhdWx0LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqL1xuICAgIGVjaGFydHMuaW5pdCA9IGZ1bmN0aW9uIChkb20sIHRoZW1lLCBvcHRzKSB7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoKHpyZW5kZXIudmVyc2lvbi5yZXBsYWNlKCcuJywgJycpIC0gMCkgPCAoZWNoYXJ0cy5kZXBlbmRlbmNpZXMuenJlbmRlci5yZXBsYWNlKCcuJywgJycpIC0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdaUmVuZGVyICcgKyB6cmVuZGVyLnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgKyAnIGlzIHRvbyBvbGQgZm9yIEVDaGFydHMgJyArIGVjaGFydHMudmVyc2lvblxuICAgICAgICAgICAgICAgICAgICArICcuIEN1cnJlbnQgdmVyc2lvbiBuZWVkIFpSZW5kZXIgJ1xuICAgICAgICAgICAgICAgICAgICArIGVjaGFydHMuZGVwZW5kZW5jaWVzLnpyZW5kZXIgKyAnKydcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRvbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4aXN0SW5zdGFuY2UgPSBlY2hhcnRzLmdldEluc3RhbmNlQnlEb20oZG9tKTtcbiAgICAgICAgaWYgKGV4aXN0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGVyZSBpcyBhIGNoYXJ0IGluc3RhbmNlIGFscmVhZHkgaW5pdGlhbGl6ZWQgb24gdGhlIGRvbS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleGlzdEluc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmICh6clV0aWwuaXNEb20oZG9tKVxuICAgICAgICAgICAgICAgICYmIGRvbS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQ0FOVkFTJ1xuICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgKCFkb20uY2xpZW50V2lkdGggJiYgKCFvcHRzIHx8IG9wdHMud2lkdGggPT0gbnVsbCkpXG4gICAgICAgICAgICAgICAgICAgIHx8ICghZG9tLmNsaWVudEhlaWdodCAmJiAoIW9wdHMgfHwgb3B0cy5oZWlnaHQgPT0gbnVsbCkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYW5cXCd0IGdldCBkb20gd2lkdGggb3IgaGVpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhcnQgPSBuZXcgRUNoYXJ0cyhkb20sIHRoZW1lLCBvcHRzKTtcbiAgICAgICAgY2hhcnQuaWQgPSAnZWNfJyArIGlkQmFzZSsrO1xuICAgICAgICBpbnN0YW5jZXNbY2hhcnQuaWRdID0gY2hhcnQ7XG5cbiAgICAgICAgaWYgKGRvbS5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGNoYXJ0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbVtET01fQVRUUklCVVRFX0tFWV0gPSBjaGFydC5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuYWJsZUNvbm5lY3QoY2hhcnQpO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfEFycmF5Ljxtb2R1bGU6ZWNoYXJ0c35FQ2hhcnRzPn0gZ3JvdXBJZFxuICAgICAqL1xuICAgIGVjaGFydHMuY29ubmVjdCA9IGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgIC8vIElzIGFycmF5IG9mIGNoYXJ0c1xuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkoZ3JvdXBJZCkpIHtcbiAgICAgICAgICAgIHZhciBjaGFydHMgPSBncm91cElkO1xuICAgICAgICAgICAgZ3JvdXBJZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJZiBhbnkgY2hhcnQgaGFzIGdyb3VwXG4gICAgICAgICAgICB6clV0aWwuZWFjaChjaGFydHMsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFydC5ncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQgPSBjaGFydC5ncm91cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3VwSWQgPSBncm91cElkIHx8ICgnZ18nICsgZ3JvdXBJZEJhc2UrKyk7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChjaGFydHMsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgICAgIGNoYXJ0Lmdyb3VwID0gZ3JvdXBJZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBncm91cElkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAREVQUkVDQVRFRFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gZ3JvdXBJZFxuICAgICAqL1xuICAgIGVjaGFydHMuZGlzQ29ubmVjdCA9IGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgIGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGdyb3VwSWRcbiAgICAgKi9cbiAgICBlY2hhcnRzLmRpc2Nvbm5lY3QgPSBlY2hhcnRzLmRpc0Nvbm5lY3Q7XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIGEgY2hhcnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0c35FQ2hhcnRzfEhUTUxEb21FbGVtZW50fHN0cmluZ30gY2hhcnRcbiAgICAgKi9cbiAgICBlY2hhcnRzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJ0ID0gaW5zdGFuY2VzW2NoYXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGNoYXJ0IGluc3RhbmNlb2YgRUNoYXJ0cykpe1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHRyZWF0IGFzIGRvbVxuICAgICAgICAgICAgY2hhcnQgPSBlY2hhcnRzLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY2hhcnQgaW5zdGFuY2VvZiBFQ2hhcnRzKSAmJiAhY2hhcnQuaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICBjaGFydC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7SFRNTERvbUVsZW1lbnR9IGRvbVxuICAgICAqIEByZXR1cm4ge2VjaGFydHN+RUNoYXJ0c31cbiAgICAgKi9cbiAgICBlY2hhcnRzLmdldEluc3RhbmNlQnlEb20gPSBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGlmIChkb20uZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBrZXkgPSBkb20uZ2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IGRvbVtET01fQVRUUklCVVRFX0tFWV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1trZXldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7ZWNoYXJ0c35FQ2hhcnRzfVxuICAgICAqL1xuICAgIGVjaGFydHMuZ2V0SW5zdGFuY2VCeUlkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHRoZW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclRoZW1lID0gZnVuY3Rpb24gKG5hbWUsIHRoZW1lKSB7XG4gICAgICAgIHRoZW1lU3RvcmFnZVtuYW1lXSA9IHRoZW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBvcHRpb24gcHJlcHJvY2Vzc29yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlcHJvY2Vzc29yRnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IgPSBmdW5jdGlvbiAocHJlcHJvY2Vzc29yRnVuYykge1xuICAgICAgICBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcy5wdXNoKHByZXByb2Nlc3NvckZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvY2Vzc29yRnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbiAocHJpb3JpdHksIHByb2Nlc3NvckZ1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvY2Vzc29yRnVuYyA9IHByaW9yaXR5O1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gcHJvY2Vzc29yIHByaW9yaXR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVByb2Nlc3NvckZ1bmNzLnB1c2goe1xuICAgICAgICAgICAgcHJpbzogcHJpb3JpdHksXG4gICAgICAgICAgICBmdW5jOiBwcm9jZXNzb3JGdW5jXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBwb3N0VXBkYXRlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBvc3RVcGRhdGVGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclBvc3RVcGRhdGUgPSBmdW5jdGlvbiAocG9zdFVwZGF0ZUZ1bmMpIHtcbiAgICAgICAgcG9zdFVwZGF0ZUZ1bmNzLnB1c2gocG9zdFVwZGF0ZUZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2FnZTpcbiAgICAgKiByZWdpc3RlckFjdGlvbignc29tZUFjdGlvbicsICdzb21lRXZlbnQnLCBmdW5jdGlvbiAoKSB7IC4uLiB9KTtcbiAgICAgKiByZWdpc3RlckFjdGlvbignc29tZUFjdGlvbicsIGZ1bmN0aW9uICgpIHsgLi4uIH0pO1xuICAgICAqIHJlZ2lzdGVyQWN0aW9uKFxuICAgICAqICAgICB7dHlwZTogJ3NvbWVBY3Rpb24nLCBldmVudDogJ3NvbWVFdmVudCcsIHVwZGF0ZTogJ3VwZGF0ZVZpZXcnfSxcbiAgICAgKiAgICAgZnVuY3Rpb24gKCkgeyAuLi4gfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8T2JqZWN0KX0gYWN0aW9uSW5mb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25JbmZvLnR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbkluZm8uZXZlbnRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthY3Rpb25JbmZvLnVwZGF0ZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2V2ZW50TmFtZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25cbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbkluZm8sIGV2ZW50TmFtZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBldmVudE5hbWU7XG4gICAgICAgICAgICBldmVudE5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aW9uVHlwZSA9IHpyVXRpbC5pc09iamVjdChhY3Rpb25JbmZvKVxuICAgICAgICAgICAgPyBhY3Rpb25JbmZvLnR5cGVcbiAgICAgICAgICAgIDogKFthY3Rpb25JbmZvLCBhY3Rpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWVcbiAgICAgICAgICAgIH1dWzBdKTtcblxuICAgICAgICAvLyBFdmVudCBuYW1lIGlzIGFsbCBsb3dlcmNhc2VcbiAgICAgICAgYWN0aW9uSW5mby5ldmVudCA9IChhY3Rpb25JbmZvLmV2ZW50IHx8IGFjdGlvblR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGV2ZW50TmFtZSA9IGFjdGlvbkluZm8uZXZlbnQ7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgYWN0aW9uIHR5cGUgYW5kIGV2ZW50IG5hbWUuXG4gICAgICAgIHpyVXRpbC5hc3NlcnQoQUNUSU9OX1JFRy50ZXN0KGFjdGlvblR5cGUpICYmIEFDVElPTl9SRUcudGVzdChldmVudE5hbWUpKTtcblxuICAgICAgICBpZiAoIWFjdGlvbnNbYWN0aW9uVHlwZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbnNbYWN0aW9uVHlwZV0gPSB7YWN0aW9uOiBhY3Rpb24sIGFjdGlvbkluZm86IGFjdGlvbkluZm99O1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50QWN0aW9uTWFwW2V2ZW50TmFtZV0gPSBhY3Rpb25UeXBlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gQ29vcmRpbmF0ZVN5c3RlbVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtID0gZnVuY3Rpb24gKHR5cGUsIENvb3JkaW5hdGVTeXN0ZW0pIHtcbiAgICAgICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIodHlwZSwgQ29vcmRpbmF0ZVN5c3RlbSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBkaW1lbnNpb25zIG9mIHNwZWNpZmllZCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBlY2hhcnRzLmdldENvb3JkaW5hdGVTeXN0ZW1EaW1lbnNpb25zID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGNvb3JkU3lzQ3JlYXRvciA9IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGNvb3JkU3lzQ3JlYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkU3lzQ3JlYXRvci5nZXREaW1lbnNpb25zSW5mb1xuICAgICAgICAgICAgICAgICAgICA/IGNvb3JkU3lzQ3JlYXRvci5nZXREaW1lbnNpb25zSW5mbygpXG4gICAgICAgICAgICAgICAgICAgIDogY29vcmRTeXNDcmVhdG9yLmRpbWVuc2lvbnMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMYXlvdXQgaXMgYSBzcGVjaWFsIHN0YWdlIG9mIHZpc3VhbCBlbmNvZGluZ1xuICAgICAqIE1vc3QgdmlzdWFsIGVuY29kaW5nIGxpa2UgY29sb3IgYXJlIGNvbW1vbiBmb3IgZGlmZmVyZW50IGNoYXJ0XG4gICAgICogQnV0IGVhY2ggY2hhcnQgaGFzIGl0J3Mgb3duIGxheW91dCBhbGdvcml0aG1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsYXlvdXRGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCA9IGZ1bmN0aW9uIChwcmlvcml0eSwgbGF5b3V0RnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsYXlvdXRGdW5jID0gcHJpb3JpdHk7XG4gICAgICAgICAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1ZJU1VBTF9MQVlPVVQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmIChpc05hTihwcmlvcml0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua293biBsYXlvdXQgcHJpb3JpdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXN1YWxGdW5jcy5wdXNoKHtcbiAgICAgICAgICAgIHByaW86IHByaW9yaXR5LFxuICAgICAgICAgICAgZnVuYzogbGF5b3V0RnVuYyxcbiAgICAgICAgICAgIGlzTGF5b3V0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTMwMDBdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdmlzdWFsRnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJWaXN1YWwgPSBmdW5jdGlvbiAocHJpb3JpdHksIHZpc3VhbEZ1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmlzdWFsRnVuYyA9IHByaW9yaXR5O1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBQUklPUklUWV9WSVNVQUxfQ0hBUlQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmIChpc05hTihwcmlvcml0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua293biB2aXN1YWwgcHJpb3JpdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXN1YWxGdW5jcy5wdXNoKHtcbiAgICAgICAgICAgIHByaW86IHByaW9yaXR5LFxuICAgICAgICAgICAgZnVuYzogdmlzdWFsRnVuY1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyTG9hZGluZyA9IGZ1bmN0aW9uIChuYW1lLCBsb2FkaW5nRngpIHtcbiAgICAgICAgbG9hZGluZ0VmZmVjdHNbbmFtZV0gPSBsb2FkaW5nRng7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICAgICAqL1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwgPSBmdW5jdGlvbiAob3B0cy8qLCBzdXBlckNsYXNzKi8pIHtcbiAgICAgICAgLy8gdmFyIENsYXp6ID0gQ29tcG9uZW50TW9kZWw7XG4gICAgICAgIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgIC8vICAgICBDbGF6eiA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcgPSBmdW5jdGlvbiAob3B0cy8qLCBzdXBlckNsYXNzKi8pIHtcbiAgICAgICAgLy8gdmFyIENsYXp6ID0gQ29tcG9uZW50VmlldztcbiAgICAgICAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgICAgICAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFZpZXcuZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZFNlcmllc01vZGVsID0gZnVuY3Rpb24gKG9wdHMvKiwgc3VwZXJDbGFzcyovKSB7XG4gICAgICAgIC8vIHZhciBDbGF6eiA9IFNlcmllc01vZGVsO1xuICAgICAgICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgICAvLyAgICAgc3VwZXJDbGFzcyA9ICdzZXJpZXMuJyArIHN1cGVyQ2xhc3MucmVwbGFjZSgnc2VyaWVzLicsICcnKTtcbiAgICAgICAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgICAgICAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBTZXJpZXNNb2RlbC5leHRlbmQob3B0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICAgICAqL1xuICAgIGVjaGFydHMuZXh0ZW5kQ2hhcnRWaWV3ID0gZnVuY3Rpb24gKG9wdHMvKiwgc3VwZXJDbGFzcyovKSB7XG4gICAgICAgIC8vIHZhciBDbGF6eiA9IENoYXJ0VmlldztcbiAgICAgICAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgLy8gICAgIHN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzLnJlcGxhY2UoJ3Nlcmllcy4nLCAnJyk7XG4gICAgICAgIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgIC8vICAgICBDbGF6eiA9IENoYXJ0Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgdHJ1ZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIENoYXJ0Vmlldy5leHRlbmQob3B0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFpSZW5kZXIgbmVlZCBhIGNhbnZhcyBjb250ZXh0IHRvIGRvIG1lYXN1cmVUZXh0LlxuICAgICAqIEJ1dCBpbiBub2RlIGVudmlyb25tZW50IGNhbnZhcyBtYXkgYmUgY3JlYXRlZCBieSBub2RlLWNhbnZhcy5cbiAgICAgKiBTbyB3ZSBuZWVkIHRvIHNwZWNpZnkgaG93IHRvIGNyZWF0ZSBhIGNhbnZhcyBpbnN0ZWFkIG9mIHVzaW5nIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICpcbiAgICAgKiBCZSBjYXJlZnVsIG9mIHVzaW5nIGl0IGluIHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3JlYXRvclxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIHZhciBDYW52YXMgPSByZXF1aXJlKCdjYW52YXMnKTtcbiAgICAgKiAgICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCdlY2hhcnRzJyk7XG4gICAgICogICAgIGVjaGFydHMuc2V0Q2FudmFzQ3JlYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICAgICAvLyBTbWFsbCBzaXplIGlzIGVub3VnaC5cbiAgICAgKiAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzKDMyLCAzMik7XG4gICAgICogICAgIH0pO1xuICAgICAqL1xuICAgIGVjaGFydHMuc2V0Q2FudmFzQ3JlYXRvciA9IGZ1bmN0aW9uIChjcmVhdG9yKSB7XG4gICAgICAgIHpyVXRpbC5jcmVhdGVDYW52YXMgPSBjcmVhdG9yO1xuICAgIH07XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKFBSSU9SSVRZX1ZJU1VBTF9HTE9CQUwsIHJlcXVpcmUoJy4vdmlzdWFsL3Nlcmllc0NvbG9yJykpO1xuICAgIGVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IocmVxdWlyZSgnLi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQnKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxvYWRpbmcoJ2RlZmF1bHQnLCByZXF1aXJlKCcuL2xvYWRpbmcvZGVmYXVsdCcpKTtcblxuICAgIC8vIERlZmF1bHQgYWN0aW9uXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdoaWdobGlnaHQnLFxuICAgICAgICBldmVudDogJ2hpZ2hsaWdodCcsXG4gICAgICAgIHVwZGF0ZTogJ2hpZ2hsaWdodCdcbiAgICB9LCB6clV0aWwubm9vcCk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgICAgIGV2ZW50OiAnZG93bnBsYXknLFxuICAgICAgICB1cGRhdGU6ICdkb3ducGxheSdcbiAgICB9LCB6clV0aWwubm9vcCk7XG5cblxuICAgIC8vIC0tLS0tLS0tXG4gICAgLy8gRXhwb3J0c1xuICAgIC8vIC0tLS0tLS0tXG4gICAgZWNoYXJ0cy56cmVuZGVyID0genJlbmRlcjtcblxuICAgIGVjaGFydHMuTGlzdCA9IHJlcXVpcmUoJy4vZGF0YS9MaXN0Jyk7XG4gICAgZWNoYXJ0cy5Nb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvTW9kZWwnKTtcblxuICAgIGVjaGFydHMuQXhpcyA9IHJlcXVpcmUoJy4vY29vcmQvQXhpcycpO1xuXG4gICAgZWNoYXJ0cy5ncmFwaGljID0gcmVxdWlyZSgnLi91dGlsL2dyYXBoaWMnKTtcbiAgICBlY2hhcnRzLm51bWJlciA9IHJlcXVpcmUoJy4vdXRpbC9udW1iZXInKTtcbiAgICBlY2hhcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vdXRpbC9mb3JtYXQnKTtcbiAgICBlY2hhcnRzLnRocm90dGxlID0gdGhyb3R0bGUudGhyb3R0bGU7XG4gICAgZWNoYXJ0cy5tYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xuICAgIGVjaGFydHMudmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcbiAgICBlY2hhcnRzLmNvbG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xuXG4gICAgZWNoYXJ0cy51dGlsID0ge307XG4gICAgZWFjaChbXG4gICAgICAgICAgICAnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLCAncmVkdWNlJywgJ2ZpbHRlcicsXG4gICAgICAgICAgICAnYmluZCcsICdjdXJyeScsICdpc0FycmF5JywgJ2lzU3RyaW5nJywgJ2lzT2JqZWN0JywgJ2lzRnVuY3Rpb24nLFxuICAgICAgICAgICAgJ2V4dGVuZCcsICdkZWZhdWx0cycsICdjbG9uZScsICdtZXJnZSdcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGVjaGFydHMudXRpbFtuYW1lXSA9IHpyVXRpbFtuYW1lXTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBlY2hhcnRzLmhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XG5cblxuICAgIC8vIFBSSU9SSVRZXG4gICAgZWNoYXJ0cy5QUklPUklUWSA9IHtcbiAgICAgICAgUFJPQ0VTU09SOiB7XG4gICAgICAgICAgICBGSUxURVI6IFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVIsXG4gICAgICAgICAgICBTVEFUSVNUSUM6IFBSSU9SSVRZX1BST0NFU1NPUl9TVEFUSVNUSUNcbiAgICAgICAgfSxcbiAgICAgICAgVklTVUFMOiB7XG4gICAgICAgICAgICBMQVlPVVQ6IFBSSU9SSVRZX1ZJU1VBTF9MQVlPVVQsXG4gICAgICAgICAgICBHTE9CQUw6IFBSSU9SSVRZX1ZJU1VBTF9HTE9CQUwsXG4gICAgICAgICAgICBDSEFSVDogUFJJT1JJVFlfVklTVUFMX0NIQVJULFxuICAgICAgICAgICAgQ09NUE9ORU5UOiBQUklPUklUWV9WSVNVQUxfQ09NUE9ORU5ULFxuICAgICAgICAgICAgQlJVU0g6IFBSSU9SSVRZX1ZJU1VBTF9CUlVTSFxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZWNoYXJ0cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9lY2hhcnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var pathTool = __webpack_require__(218);\n    var Path = __webpack_require__(8);\n    var colorTool = __webpack_require__(22);\n    var matrix = __webpack_require__(20);\n    var vector = __webpack_require__(7);\n    var Transformable = __webpack_require__(79);\n    var BoundingRect = __webpack_require__(11);\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var graphic = {};\n\n    graphic.Group = __webpack_require__(27);\n\n    graphic.Image = __webpack_require__(75);\n\n    graphic.Text = __webpack_require__(202);\n\n    graphic.Circle = __webpack_require__(209);\n\n    graphic.Sector = __webpack_require__(215);\n\n    graphic.Ring = __webpack_require__(214);\n\n    graphic.Polygon = __webpack_require__(211);\n\n    graphic.Polyline = __webpack_require__(212);\n\n    graphic.Rect = __webpack_require__(213);\n\n    graphic.Line = __webpack_require__(210);\n\n    graphic.BezierCurve = __webpack_require__(208);\n\n    graphic.Arc = __webpack_require__(207);\n\n    graphic.CompoundPath = __webpack_require__(199);\n\n    graphic.LinearGradient = __webpack_require__(200);\n\n    graphic.RadialGradient = __webpack_require__(201);\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    graphic.getFont = function (opt, ecModel) {\n        var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    module.exports = graphic;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvZ3JhcGhpYy5qcz9lYTAwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGlDQUFpQztBQUNoRCxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEIsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QyxnQ0FBZ0MsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QixnQ0FBZ0MsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsMENBQTBDO0FBQ3pEO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU8sT0FBTztBQUM3QixnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxPQUFPLGFBQWE7QUFDbkMsZUFBZSxPQUFPLE9BQU87QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgcGF0aFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL3BhdGgnKTtcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpO1xuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL2NvbG9yJyk7XG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcblxuICAgIHZhciBncmFwaGljID0ge307XG5cbiAgICBncmFwaGljLkdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwJyk7XG5cbiAgICBncmFwaGljLkltYWdlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZScpO1xuXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XG5cbiAgICBncmFwaGljLkNpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XG5cbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XG5cbiAgICBncmFwaGljLlJpbmcgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcnKTtcblxuICAgIGdyYXBoaWMuUG9seWdvbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbicpO1xuXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcblxuICAgIGdyYXBoaWMuUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdCcpO1xuXG4gICAgZ3JhcGhpYy5MaW5lID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lJyk7XG5cbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xuXG4gICAgZ3JhcGhpYy5BcmMgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYycpO1xuXG4gICAgZ3JhcGhpYy5Db21wb3VuZFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aCcpO1xuXG4gICAgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQnKTtcblxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XG5cbiAgICBncmFwaGljLkJvdW5kaW5nUmVjdCA9IEJvdW5kaW5nUmVjdDtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBzaGFwZSB3aXRoIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBncmFwaGljLmV4dGVuZFNoYXBlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgcGF0aFxuICAgICAqL1xuICAgIGdyYXBoaWMuZXh0ZW5kUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cykge1xuICAgICAgICByZXR1cm4gcGF0aFRvb2wuZXh0ZW5kRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHBhdGggZWxlbWVudCBmcm9tIHBhdGggZGF0YSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aERhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xuICAgICAqL1xuICAgIGdyYXBoaWMubWFrZVBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMsIHJlY3QsIGxheW91dCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICAgICAgcmVjdC54ID0gY3ggLSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgcmVjdC55ID0gY3kgLSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JhcGhpYy5yZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBncmFwaGljLm1lcmdlUGF0aCA9IHBhdGhUb29sLm1lcmdlUGF0aCxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBhIHBhdGggdG8gZml0IHRoZSByZWN0XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxuICAgICAqL1xuICAgIGdyYXBoaWMucmVzaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByZWN0KSB7XG4gICAgICAgIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGhSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcblxuICAgICAgICB2YXIgbSA9IHBhdGhSZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShyZWN0KTtcblxuICAgICAgICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55MV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXG4gICAgICovXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XG5cbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLngxICogMikgPT09IHJvdW5kKHNoYXBlLngyICogMikpIHtcbiAgICAgICAgICAgIHNoYXBlLngxID0gc2hhcGUueDIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngxLCBsaW5lV2lkdGgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3VuZChzaGFwZS55MSAqIDIpID09PSByb3VuZChzaGFwZS55MiAqIDIpKSB7XG4gICAgICAgICAgICBzaGFwZS55MSA9IHNoYXBlLnkyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55MSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSByZWN0IGZvciBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLndpZHRoXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxuICAgICAqL1xuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xuICAgICAgICB2YXIgb3JpZ2luWCA9IHNoYXBlLng7XG4gICAgICAgIHZhciBvcmlnaW5ZID0gc2hhcGUueTtcbiAgICAgICAgdmFyIG9yaWdpbldpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgIHZhciBvcmlnaW5IZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgIHNoYXBlLnggPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gICAgICAgIHNoYXBlLnkgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnksIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gICAgICAgIHNoYXBlLndpZHRoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LFxuICAgICAgICAgICAgb3JpZ2luV2lkdGggPT09IDAgPyAwIDogMVxuICAgICAgICApO1xuICAgICAgICBzaGFwZS5oZWlnaHQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWSArIG9yaWdpbkhlaWdodCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS55LFxuICAgICAgICAgICAgb3JpZ2luSGVpZ2h0ID09PSAwID8gMCA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIENvb3JkaW5hdGUsIHN1Y2ggYXMgeCwgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggU2hvdWxkIGJlIG5vbm5lZ2F0aXZlIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcG9zaXRpdmVPck5lZ2F0aXZlIERlZmF1bHQgZmFsc2UgKG5lZ2F0aXZlKS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wdGltaXplZCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGxpbmVXaWR0aCwgcG9zaXRpdmVPck5lZ2F0aXZlKSB7XG4gICAgICAgIC8vIEFzc3VyZSB0aGF0IChwb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpIGlzIG5lYXIgaW50ZWdlciBlZGdlLFxuICAgICAgICAvLyBvdGhlcndpc2UgbGluZSB3aWxsIGJlIGZ1enp5IGluIGNhbnZhcy5cbiAgICAgICAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XG4gICAgICAgIHJldHVybiAoZG91YmxlZFBvc2l0aW9uICsgcm91bmQobGluZVdpZHRoKSkgJSAyID09PSAwXG4gICAgICAgICAgICA/IGRvdWJsZWRQb3NpdGlvbiAvIDJcbiAgICAgICAgICAgIDogKGRvdWJsZWRQb3NpdGlvbiArIChwb3NpdGl2ZU9yTmVnYXRpdmUgPyAxIDogLTEpKSAvIDI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhc0ZpbGxPclN0cm9rZShmaWxsT3JTdHJva2UpIHtcbiAgICAgICAgcmV0dXJuIGZpbGxPclN0cm9rZSAhPSBudWxsICYmIGZpbGxPclN0cm9rZSAhPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlmdENvbG9yKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnID8gY29sb3JUb29sLmxpZnQoY29sb3IsIC0wLjEpIDogY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZUVsZW1lbnRTdGwoZWwpIHtcbiAgICAgICAgaWYgKGVsLl9faG92ZXJTdGxEaXJ0eSkge1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IGVsLnN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIHZhciBmaWxsID0gZWwuc3R5bGUuZmlsbDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGhvdmVyU3R5bGUgb24gbW91c2VvdmVyXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGVsLl9faG92ZXJTdGw7XG4gICAgICAgICAgICBob3ZlclN0eWxlLmZpbGwgPSBob3ZlclN0eWxlLmZpbGxcbiAgICAgICAgICAgICAgICB8fCAoaGFzRmlsbE9yU3Ryb2tlKGZpbGwpID8gbGlmdENvbG9yKGZpbGwpIDogbnVsbCk7XG4gICAgICAgICAgICBob3ZlclN0eWxlLnN0cm9rZSA9IGhvdmVyU3R5bGUuc3Ryb2tlXG4gICAgICAgICAgICAgICAgfHwgKGhhc0ZpbGxPclN0cm9rZShzdHJva2UpID8gbGlmdENvbG9yKHN0cm9rZSkgOiBudWxsKTtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbFN0eWxlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhvdmVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxTdHlsZVtuYW1lXSA9IGVsLnN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcblxuICAgICAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvU2luZ2xlRW50ZXJIb3ZlcihlbCkge1xuICAgICAgICBpZiAoZWwuX19pc0hvdmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuXG4gICAgICAgIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgICAgICAgICBlbC5fX3pyICYmIGVsLl9fenIuYWRkSG92ZXIoZWwsIGVsLl9faG92ZXJTdGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0U3R5bGUoZWwuX19ob3ZlclN0bCk7XG4gICAgICAgICAgICBlbC56MiArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuX19pc0hvdmVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpIHtcbiAgICAgICAgaWYgKCFlbC5fX2lzSG92ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3JtYWxTdGwgPSBlbC5fX25vcm1hbFN0bDtcbiAgICAgICAgaWYgKGVsLnVzZUhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgIGVsLl9fenIgJiYgZWwuX196ci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcbiAgICAgICAgICAgIGVsLnoyIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUVudGVySG92ZXIoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGRvU2luZ2xlRW50ZXJIb3ZlcihlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9MZWF2ZUhvdmVyKGVsKSB7XG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVMZWF2ZUhvdmVyKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdGwpIHtcbiAgICAgICAgLy8gSWYgZWxlbWVudCBoYXMgc2VwY2lmaWVkIGhvdmVyU3R5bGUsIHRoZW4gdXNlIGl0IGluc3RlYWQgb2YgZ2l2ZW4gaG92ZXJTdHlsZVxuICAgICAgICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XG4gICAgICAgIGVsLl9faG92ZXJTdGwgPSBlbC5ob3ZlclN0eWxlIHx8IGhvdmVyU3RsIHx8IHt9O1xuICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSB0cnVlO1xuXG4gICAgICAgIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICAgICAgICAgIGNhY2hlRWxlbWVudFN0bChlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU92ZXIoZSkge1xuICAgICAgICBpZiAodGhpcy5fX2hvdmVyU2lsZW50T25Ub3VjaCAmJiBlLnpyQnlUb3VjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9faG92ZXJTaWxlbnRPblRvdWNoICYmIGUuenJCeVRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xuICAgICAgICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9MZWF2ZUhvdmVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVudGVyRW1waGFzaXMoKSB7XG4gICAgICAgIHRoaXMuX19pc0VtcGhhc2lzID0gdHJ1ZTtcbiAgICAgICAgZG9FbnRlckhvdmVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoKSB7XG4gICAgICAgIHRoaXMuX19pc0VtcGhhc2lzID0gZmFsc2U7XG4gICAgICAgIGRvTGVhdmVIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudC5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHJlcGVhdGx5IHdpdGhvdXQgc2lkZS1lZmZlY3RzLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2hvdmVyU3R5bGVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmhvdmVyU2lsZW50T25Ub3VjaD1mYWxzZV1cbiAgICAgKiAgICAgICAgSW4gdG91Y2ggZGV2aWNlLCBtb3VzZW92ZXIgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyIG9uIHRvdWNoc3RhcnQgZXZlbnRcbiAgICAgKiAgICAgICAgKHNlZSBtb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5KS4gQnkgdGhpcyBtZWNoYW5pc20sIHdlIGNhblxuICAgICAqICAgICAgICBjb252aW5pZW50bHkgdXNlIGhvdmVyU3R5bGUgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuIHdpdGhvdXQgYWRkaXRpb25hbFxuICAgICAqICAgICAgICBjb2RlIGZvciBjb21wYXRpYmlsaXR5LlxuICAgICAqICAgICAgICBCdXQgaWYgdGhlIGNoYXJ0L2NvbXBvbmVudCBoYXMgc2VsZWN0IGZlYXR1cmUsIHdoaWNoIHVzdWFsbHkgYWxzbyB1c2VcbiAgICAgKiAgICAgICAgaG92ZXJTdHlsZSwgdGhlcmUgbWlnaHQgYmUgY29uZmxpY3QgYmV0d2VlbiAnc2VsZWN0LWhpZ2hsaWdodCcgYW5kXG4gICAgICogICAgICAgICdob3Zlci1oaWdobGlnaHQnIGVzcGVjaWFsbHkgd2hlbiByb2FtIGlzIGVuYWJsZWQgKHNlZSBnZW8gZm9yIGV4YW1wbGUpLlxuICAgICAqICAgICAgICBJbiB0aGlzIGNhc2UsIGhvdmVyU2lsZW50T25Ub3VjaCBzaG91bGQgYmUgdXNlZCB0byBkaXNhYmxlIGhvdmVyLWhpZ2hsaWdodFxuICAgICAqICAgICAgICBvbiB0b3VjaCBkZXZpY2UuXG4gICAgICovXG4gICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlID0gZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlLCBvcHQpIHtcbiAgICAgICAgZWwuX19ob3ZlclNpbGVudE9uVG91Y2ggPSBvcHQgJiYgb3B0LmhvdmVyU2lsZW50T25Ub3VjaDtcblxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcblxuICAgICAgICAvLyBEdXBsaWNhdGVkIGZ1bmN0aW9uIHdpbGwgYmUgYXV0by1pZ25vcmVkLCBzZWUgRXZlbnRmdWwuanMuXG4gICAgICAgIGVsLm9uKCdtb3VzZW92ZXInLCBvbkVsZW1lbnRNb3VzZU92ZXIpXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcblxuICAgICAgICAvLyBFbXBoYXNpcywgbm9ybWFsIGNhbiBiZSB0cmlnZ2VyZWQgbWFudWFsbHlcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcbiAgICAgICAgICAub24oJ25vcm1hbCcsIGxlYXZlRW1waGFzaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGxhYmVsTW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKi9cbiAgICBncmFwaGljLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcikge1xuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcbiAgICAgICAgdmFyIGxhYmVsT2Zmc2V0ID0gbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdvZmZzZXQnKTtcbiAgICAgICAgdmFyIGxhYmVsQ29sb3IgPSBsYWJlbFBvc2l0aW9uLmluZGV4T2YoJ2luc2lkZScpID49IDAgPyAnd2hpdGUnIDogY29sb3I7XG4gICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xuICAgICAgICAgICAgdGV4dERpc3RhbmNlOiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJykgfHwgNSxcbiAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0T2Zmc2V0OiBsYWJlbE9mZnNldCxcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBncmFwaGljLmdldEZvbnQgPSBmdW5jdGlvbiAob3B0LCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBnVGV4dFN0eWxlTW9kZWwgPSBlY01vZGVsICYmIGVjTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gRklYTUUgaW4gbm9kZS1jYW52YXMgZm9udFdlaWdodCBpcyBiZWZvcmUgZm9udFN0eWxlXG4gICAgICAgICAgICBvcHQuZm9udFN0eWxlIHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFN0eWxlJykgfHwgJycsXG4gICAgICAgICAgICBvcHQuZm9udFdlaWdodCB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSB8fCAnJyxcbiAgICAgICAgICAgIChvcHQuZm9udFNpemUgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250U2l6ZScpIHx8IDEyKSArICdweCcsXG4gICAgICAgICAgICBvcHQuZm9udEZhbWlseSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKSB8fCAnc2Fucy1zZXJpZidcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBkYXRhSW5kZXg7XG4gICAgICAgICAgICBkYXRhSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBjaGVjayAnYW5pbWF0aW9uJyBwcm9wZXJ0eSBkaXJlY3RseSBoZXJlLiBDb25zaWRlciB0aGlzIGNhc2U6XG4gICAgICAgIC8vIGFuaW1hdGlvbiBtb2RlbCBpcyBhbiBgaXRlbU1vZGVsYCwgd2hvc2UgZG9lcyBub3QgaGF2ZSBgaXNBbmltYXRpb25FbmFibGVkYFxuICAgICAgICAvLyBidXQgaXRzIHBhcmVudCBtb2RlbCAoYHNlcmllc01vZGVsYCkgZG9lcy5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSBhbmltYXRhYmxlTW9kZWwgJiYgYW5pbWF0YWJsZU1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuXG4gICAgICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRWFzaW5nJyArIHBvc3RmaXgpO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkRlbGF5JyArIHBvc3RmaXgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmltYXRpb25EZWxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0aW9uRGVsYXkoXG4gICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFuaW1hdGFibGVNb2RlbC5nZXRBbmltYXRpb25EZWxheVBhcmFtcyhlbCwgZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID4gMFxuICAgICAgICAgICAgICAgID8gZWwuYW5pbWF0ZVRvKHByb3BzLCBkdXJhdGlvbiwgYW5pbWF0aW9uRGVsYXkgfHwgMCwgYW5pbWF0aW9uRWFzaW5nLCBjYilcbiAgICAgICAgICAgICAgICA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIGVsLmF0dHIocHJvcHMpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAgICAgKiAgICAgfSwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICAgICAqICAgICAvLyBPclxuICAgICAqICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICogICAgICAgICBwb3NpdGlvbjogWzEwMCwgMTAwXVxuICAgICAqICAgICB9LCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICAgICAqL1xuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMgPSBmdW5jdGlvbiAoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgICAgICAgYW5pbWF0ZU9yU2V0UHJvcHModHJ1ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICovXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSBmdW5jdGlvbiAoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgICAgICAgYW5pbWF0ZU9yU2V0UHJvcHMoZmFsc2UsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zZm9ybSBtYXRyaXggb2YgdGFyZ2V0IChwYXJhbSB0YXJnZXQpLFxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBbYW5jZXN0b3JdXG4gICAgICovXG4gICAgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBhbmNlc3Rvcikge1xuICAgICAgICB2YXIgbWF0ID0gbWF0cml4LmlkZW50aXR5KFtdKTtcblxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIG1hdHJpeC5tdWwobWF0LCB0YXJnZXQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSwgbWF0KTtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldCBbeCwgeV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fFR5cGVkQXJyYXkuPG51bWJlcj58T2JqZWN0fSB0cmFuc2Zvcm0gQ2FuIGJlOlxuICAgICAqICAgICAgKyBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICAgICAqICAgICAgKyB7cG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZX0sIHRoZSBzYW1lIGFzIGB6cmVuZGVyL1RyYW5zZm9ybWFibGVgLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cbiAgICAgKi9cbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSAmJiAhenJVdGlsLmlzQXJyYXlMaWtlKHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVRyYW5zZm9ybShbXSwgdGFyZ2V0LCB0cmFuc2Zvcm0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXG4gICAgICovXG4gICAgZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCB0cmFuc2Zvcm0sIGludmVydCkge1xuXG4gICAgICAgIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cbiAgICAgICAgdmFyIGhCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzBdID09PSAwKVxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XG4gICAgICAgIHZhciB2QmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVsyXSA9PT0gMClcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMl0pO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBbXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IC1oQmFzZSA6IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IGhCYXNlIDogMCxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXG4gICAgICAgIF07XG5cbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnModmVydGV4WzBdKSA+IE1hdGguYWJzKHZlcnRleFsxXSlcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgICAgICAgICAgOiAodmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBncm91cCB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmcm9tIGcxIHRvIGcyLlxuICAgICAqIElmIG5vIGFuaW1hdGFibGVNb2RlbCwgbm8gYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGdyYXBoaWMuZ3JvdXBUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGcxLCBnMiwgYW5pbWF0YWJsZU1vZGVsLCBjYikge1xuICAgICAgICBpZiAoIWcxIHx8ICFnMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RWxNYXAoZykge1xuICAgICAgICAgICAgdmFyIGVsTWFwID0ge307XG4gICAgICAgICAgICBnLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCAmJiBlbC5hbmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsTWFwW2VsLmFuaWRdID0gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZWxNYXA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWN0b3IuY2xvbmUoZWwucG9zaXRpb24pLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBlbC5yb3RhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlbC5zaGFwZSkge1xuICAgICAgICAgICAgICAgIG9iai5zaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGVsLnNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsTWFwMSA9IGdldEVsTWFwKGcxKTtcblxuICAgICAgICBnMi50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCAmJiBlbC5hbmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEVsID0gZWxNYXAxW2VsLmFuaWRdO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UHJvcCA9IGdldEFuaW1hdGFibGVQcm9wcyhlbCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmF0dHIoZ2V0QW5pbWF0YWJsZVByb3BzKG9sZEVsKSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIG5ld1Byb3AsIGFuaW1hdGFibGVNb2RlbCwgZWwuZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChlbC5wcmV2aW91c1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBvaW50cyBMaWtlOiBbWzIzLCA0NF0sIFs1MywgNjZdLCAuLi5dXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gICAgICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gQSBuZXcgY2xpcHBlZCBwb2ludHMuXG4gICAgICovXG4gICAgZ3JhcGhpYy5jbGlwUG9pbnRzQnlSZWN0ID0gZnVuY3Rpb24gKHBvaW50cywgcmVjdCkge1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgdmFyIHggPSBwb2ludFswXTtcbiAgICAgICAgICAgIHggPSBtYXRoTWF4KHgsIHJlY3QueCk7XG4gICAgICAgICAgICB4ID0gbWF0aE1pbih4LCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgICAgICAgICAgIHZhciB5ID0gcG9pbnRbMV07XG4gICAgICAgICAgICB5ID0gbWF0aE1heCh5LCByZWN0LnkpO1xuICAgICAgICAgICAgeSA9IG1hdGhNaW4oeSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRSZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgY2xpcHBlZCByZWN0LiBJZiByZWN0IHNpemUgYXJlIG5lZ2F0aXZlLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGdyYXBoaWMuY2xpcFJlY3RCeVJlY3QgPSBmdW5jdGlvbiAodGFyZ2V0UmVjdCwgcmVjdCkge1xuICAgICAgICB2YXIgeCA9IG1hdGhNYXgodGFyZ2V0UmVjdC54LCByZWN0LngpO1xuICAgICAgICB2YXIgeDIgPSBtYXRoTWluKHRhcmdldFJlY3QueCArIHRhcmdldFJlY3Qud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpO1xuICAgICAgICB2YXIgeSA9IG1hdGhNYXgodGFyZ2V0UmVjdC55LCByZWN0LnkpO1xuICAgICAgICB2YXIgeTIgPSBtYXRoTWluKHRhcmdldFJlY3QueSArIHRhcmdldFJlY3QuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cbiAgICAgICAgaWYgKHgyID49IHggJiYgeTIgPj0geSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHgyIC0geCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHkyIC0geVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoaWM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi91dGlsL2dyYXBoaWMuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIgLyogc2VydmVyIG9ubHkgKi9cbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIHZhciBmdW5jdGlvbmFsID0gb3B0aW9ucy5mdW5jdGlvbmFsXG4gICAgdmFyIGV4aXN0aW5nID0gZnVuY3Rpb25hbFxuICAgICAgPyBvcHRpb25zLnJlbmRlclxuICAgICAgOiBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgIGlmICghZnVuY3Rpb25hbCkge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var formatUtil = __webpack_require__(10);\n    var nubmerUtil = __webpack_require__(5);\n    var Model = __webpack_require__(9);\n    var zrUtil = __webpack_require__(0);\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvbW9kZWwuanM/MzYwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyxXQUFXLGVBQWUsZUFBZTtBQUMxRTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFdBQVcsZUFBZSxlQUFlO0FBQzFFO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQXNEO0FBQ3JFLGVBQWUsc0JBQXNCO0FBQ3JDLGdCQUFnQixlQUFlLGdCQUFnQix3QkFBd0IsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxnQkFBZ0Isd0JBQXdCLElBQUk7QUFDMUU7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVLEdBQUcsVUFBVSxHQUFHLEdBQUc7QUFDNUQsOEJBQThCLEdBQUcsR0FBRyxVQUFVLEdBQUcsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxnQkFBZ0IsbUNBQW1DO0FBQ2pGLGVBQWUsZUFBZSxnQkFBZ0IsbUNBQW1DO0FBQ2pGLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsVUFBVTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0NBQW9DO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsY0FBYztBQUM3Qiw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuICAgIHZhciBudWJtZXJVdGlsID0gcmVxdWlyZSgnLi9udW1iZXInKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcblxuICAgIHZhciBtb2RlbFV0aWwgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIElmIHZhbHVlIGlzIG5vdCBhcnJheSwgdGhlbiB0cmFuc2xhdGUgaXQgdG8gYXJyYXkuXG4gICAgICogQHBhcmFtICB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gW3ZhbHVlXSBvciB2YWx1ZVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgIDogW3ZhbHVlXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3luYyBkZWZhdWx0IG9wdGlvbiBiZXR3ZWVuIG5vcm1hbCBhbmQgZW1waGFzaXMgbGlrZSBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgKiBJbiBjYXNlIHNvbWUgb25lIHdpbGwgd3JpdGUgY29kZSBsaWtlXG4gICAgICogICAgIGxhYmVsOiB7XG4gICAgICogICAgICAgICBub3JtYWw6IHtcbiAgICAgKiAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgKiAgICAgICAgICAgICBwb3NpdGlvbjogJ291dHNpZGUnLFxuICAgICAqICAgICAgICAgICAgIHRleHRTdHlsZToge1xuICAgICAqICAgICAgICAgICAgICAgICBmb250U2l6ZTogMThcbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgKiAgICAgICAgICAgICBzaG93OiB0cnVlXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc3ViT3B0c1xuICAgICAqL1xuICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzID0gZnVuY3Rpb24gKG9wdCwgc3ViT3B0cykge1xuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICB2YXIgZW1waGFzaXNPcHQgPSBvcHQuZW1waGFzaXMgPSBvcHQuZW1waGFzaXMgfHwge307XG4gICAgICAgICAgICB2YXIgbm9ybWFsT3B0ID0gb3B0Lm5vcm1hbCA9IG9wdC5ub3JtYWwgfHwge307XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgZW1waGFzaXMgb3B0aW9uIGZyb20gbm9ybWFsXG4gICAgICAgICAgICBlYWNoKHN1Yk9wdHMsIGZ1bmN0aW9uIChzdWJPcHROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHpyVXRpbC5yZXRyaWV2ZShlbXBoYXNpc09wdFtzdWJPcHROYW1lXSwgbm9ybWFsT3B0W3N1Yk9wdE5hbWVdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1waGFzaXNPcHRbc3ViT3B0TmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kZWxVdGlsLkxBQkVMX09QVElPTlMgPSBbJ3Bvc2l0aW9uJywgJ29mZnNldCcsICdzaG93JywgJ3RleHRTdHlsZScsICdkaXN0YW5jZScsICdmb3JtYXR0ZXInXTtcblxuICAgIC8qKlxuICAgICAqIGRhdGEgY291bGQgYmUgWzEyLCAyMzIzLCB7dmFsdWU6IDIyM30sIFsxMjIxLCAyM10sIHt2YWx1ZTogWzIsIDIzXX1dXG4gICAgICogVGhpcyBoZWxwZXIgbWV0aG9kIHJldGlldmVzIHZhbHVlIGZyb20gZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8RGF0ZXxBcnJheXxPYmplY3R9IGRhdGFJdGVtXG4gICAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ3xEYXRlfEFycmF5LjxudW1iZXJ8c3RyaW5nfERhdGU+fVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5nZXREYXRhSXRlbVZhbHVlID0gZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgICAgICAgcmV0dXJuIGRhdGFJdGVtICYmIChkYXRhSXRlbS52YWx1ZSA9PSBudWxsID8gZGF0YUl0ZW0gOiBkYXRhSXRlbS52YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRhdGEgY291bGQgYmUgWzEyLCAyMzIzLCB7dmFsdWU6IDIyM30sIFsxMjIxLCAyM10sIHt2YWx1ZTogWzIsIDIzXX1dXG4gICAgICogVGhpcyBoZWxwZXIgbWV0aG9kIGRldGVybWluZSBpZiBkYXRhSXRlbSBoYXMgZXh0cmEgb3B0aW9uIGJlc2lkZXMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8RGF0ZXxBcnJheXxPYmplY3R9IGRhdGFJdGVtXG4gICAgICovXG4gICAgbW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24gPSBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGRhdGFJdGVtKVxuICAgICAgICAgICAgJiYgIShkYXRhSXRlbSBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgICAgICAgIC8vIC8vIG1hcmtMaW5lIGRhdGEgY2FuIGJlIGFycmF5XG4gICAgICAgICAgICAvLyAmJiAhKGRhdGFJdGVtWzBdICYmIGlzT2JqZWN0KGRhdGFJdGVtWzBdKSAmJiAhKGRhdGFJdGVtWzBdIGluc3RhbmNlb2YgQXJyYXkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBoZWxwZXIgbWV0aG9kIGNvbnZlcnQgdmFsdWUgaW4gZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8RGF0ZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtkaW1JbmZvXSBJZiBzdHJpbmcgKGxpa2UgJ3gnKSwgZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuY29udmVyRGF0YVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkaW1JbmZvKSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgICAgICAgdmFyIGRpbVR5cGUgPSBkaW1JbmZvICYmIGRpbUluZm8udHlwZTtcbiAgICAgICAgaWYgKGRpbVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbVR5cGUgPT09ICd0aW1lJ1xuICAgICAgICAgICAgLy8gc3BlYWQgdXAgd2hlbiB1c2luZyB0aW1lc3RhbXBcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIHZhbHVlICE9IG51bGxcbiAgICAgICAgICAgICYmIHZhbHVlICE9PSAnLSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICtudWJtZXJVdGlsLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkaW1UeXBlIGRlZmF1bHRzICdudW1iZXInLlxuICAgICAgICAvLyBJZiBkaW1UeXBlIGlzIG5vdCBvcmRpbmFsIGFuZCB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBOYU4gb3IgJy0nLFxuICAgICAgICAvLyBwYXJzZSB0byBOYU4uXG4gICAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpXG4gICAgICAgICAgICA/IE5hTiA6ICt2YWx1ZTsgLy8gSWYgc3RyaW5nIChsaWtlICctJyksIHVzaW5nICcrJyBwYXJzZSB0byBOYU5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbW9kZWwgcHJveHkgdG8gYmUgdXNlZCBpbiB0b29sdGlwIGZvciBlZGdlIGRhdGEsIG1hcmtMaW5lIGRhdGEsIG1hcmtQb2ludCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LnNlcmllc0luZGV4XVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lm5hbWVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQubWFpblR5cGVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQuc3ViVHlwZV1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuY3JlYXRlRGF0YUZvcm1hdE1vZGVsID0gZnVuY3Rpb24gKGRhdGEsIG9wdCkge1xuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoKTtcbiAgICAgICAgenJVdGlsLm1peGluKG1vZGVsLCBtb2RlbFV0aWwuZGF0YUZvcm1hdE1peGluKTtcbiAgICAgICAgbW9kZWwuc2VyaWVzSW5kZXggPSBvcHQuc2VyaWVzSW5kZXg7XG4gICAgICAgIG1vZGVsLm5hbWUgPSBvcHQubmFtZSB8fCAnJztcbiAgICAgICAgbW9kZWwubWFpblR5cGUgPSBvcHQubWFpblR5cGU7XG4gICAgICAgIG1vZGVsLnN1YlR5cGUgPSBvcHQuc3ViVHlwZTtcblxuICAgICAgICBtb2RlbC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9O1xuXG4gICAgLy8gUEVORElORyBBIGxpdHRsZSB1Z2x5XG4gICAgbW9kZWxVdGlsLmRhdGFGb3JtYXRNaXhpbiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwYXJhbXMgZm9yIGZvcm1hdHRlclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldERhdGFQYXJhbXM6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGFUeXBlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIHJhd0RhdGFJbmRleCA9IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgaXRlbU9wdCA9IGRhdGEuZ2V0UmF3RGF0YUl0ZW0oZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IHRoaXMubWFpblR5cGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3ViVHlwZTogdGhpcy5zdWJUeXBlLFxuICAgICAgICAgICAgICAgIHNlcmllc1R5cGU6IHRoaXMubWFpblR5cGUgPT09ICdzZXJpZXMnID8gdGhpcy5zdWJUeXBlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogdGhpcy5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBzZXJpZXNOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IHJhd0RhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtT3B0LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIG1hcmtlcjogZm9ybWF0VXRpbC5nZXRUb29sdGlwTWFya2VyKGNvbG9yKSxcblxuICAgICAgICAgICAgICAgIC8vIFBhcmFtIG5hbWUgbGlzdCBmb3IgbWFwcGluZyBgYWAsIGBiYCwgYGNgLCBgZGAsIGBlYFxuICAgICAgICAgICAgICAgICR2YXJzOiBbJ3Nlcmllc05hbWUnLCAnbmFtZScsICd2YWx1ZSddXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXQgbGFiZWxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXR1cz0nbm9ybWFsJ10gJ25vcm1hbCcgb3IgJ2VtcGhhc2lzJ1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbUluZGV4XVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsUHJvcD0nbGFiZWwnXVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGRhdGFJbmRleCwgc3RhdHVzLCBkYXRhVHlwZSwgZGltSW5kZXgsIGxhYmVsUHJvcCkge1xuICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzIHx8ICdub3JtYWwnO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICBpZiAoZGltSW5kZXggIT0gbnVsbCAmJiAocGFyYW1zLnZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnZhbHVlID0gcGFyYW1zLnZhbHVlW2RpbUluZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGl0ZW1Nb2RlbC5nZXQoW2xhYmVsUHJvcCB8fCAnbGFiZWwnLCBzdGF0dXMsICdmb3JtYXR0ZXInXSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRVdGlsLmZvcm1hdFRwbChmb3JtYXR0ZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCByYXcgdmFsdWUgaW4gb3B0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmF3VmFsdWU6IGZ1bmN0aW9uIChpZHgsIGRhdGFUeXBlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhLmdldFJhd0RhdGFJdGVtKGlkeCk7XG4gICAgICAgICAgICBpZiAoZGF0YUl0ZW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QoZGF0YUl0ZW0pICYmICEoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICAgICAgICAgICAgICAgID8gZGF0YUl0ZW0udmFsdWUgOiBkYXRhSXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpcGxlU2VyaWVzPWZhbHNlXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRvb2x0aXAgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXRUb29sdGlwOiB6clV0aWwubm9vcFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYXBwaW5nIHRvIGV4aXN0cyBmb3IgbWVyZ2UuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50Pn0gZXhpc3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPE9iamVjdD59IG5ld0NwdE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gUmVzdWx0LCBsaWtlIFt7ZXhpc3Q6IC4uLiwgb3B0aW9uOiAuLi59LCB7fV0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IG9mIHdoaWNoIGlzIHRoZSBzYW1lIGFzIGV4aXN0cy5cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzID0gZnVuY3Rpb24gKGV4aXN0cywgbmV3Q3B0T3B0aW9ucykge1xuICAgICAgICAvLyBNYXBwaW5nIGJ5IHRoZSBvcmRlciBieSBvcmlnaW5hbCBvcHRpb24gKGJ1dCBub3Qgb3JkZXIgb2ZcbiAgICAgICAgLy8gbmV3IG9wdGlvbikgaW4gbWVyZ2UgbW9kZS4gQmVjYXVzZSB3ZSBzaG91bGQgZW5zdXJlXG4gICAgICAgIC8vIHNvbWUgc3BlY2lmaWVkIGluZGV4IChsaWtlIHhBeGlzSW5kZXgpIGlzIGNvbnNpc3RlbnQgd2l0aFxuICAgICAgICAvLyBvcmlnaW5hbCBvcHRpb24sIHdoaWNoIGlzIGVhc3kgdG8gdW5kZXJzdGFuZCwgZXNwYXRpYWxseSBpblxuICAgICAgICAvLyBtZWRpYSBxdWVyeS4gQW5kIGluIG1vc3QgY2FzZSwgbWVyZ2Ugb3B0aW9uIGlzIHVzZWQgdG9cbiAgICAgICAgLy8gdXBkYXRlIHBhcnRpYWwgb3B0aW9uIGJ1dCBub3QgYmUgZXhwZWN0ZWQgdG8gY2hhbmdlIG9yZGVyLlxuICAgICAgICBuZXdDcHRPcHRpb25zID0gKG5ld0NwdE9wdGlvbnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHpyVXRpbC5tYXAoZXhpc3RzIHx8IFtdLCBmdW5jdGlvbiAob2JqLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtleGlzdDogb2JqfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFwcGluZyBieSBpZCBvciBuYW1lIGlmIHNwZWNpZmllZC5cbiAgICAgICAgZWFjaChuZXdDcHRPcHRpb25zLCBmdW5jdGlvbiAoY3B0T3B0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChjcHRPcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZCBoYXMgaGlnaGVzdCBwcmlvcml0eS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uIC8vIENvbnNpZGVyIG5hbWU6IHR3byBtYXAgdG8gb25lLlxuICAgICAgICAgICAgICAgICAgICAmJiBjcHRPcHRpb24uaWQgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAmJiByZXN1bHRbaV0uZXhpc3QuaWQgPT09IGNwdE9wdGlvbi5pZCArICcnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgICAgICAgICAgICAgIG5ld0NwdE9wdGlvbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3QgPSByZXN1bHRbaV0uZXhpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uIC8vIENvbnNpZGVyIG5hbWU6IHR3byBtYXAgdG8gb25lLlxuICAgICAgICAgICAgICAgICAgICAvLyBDYW4gbm90IG1hdGNoIHdoZW4gYm90aCBpZHMgZXhpc3QgYnV0IGRpZmZlcmVudC5cbiAgICAgICAgICAgICAgICAgICAgJiYgKGV4aXN0LmlkID09IG51bGwgfHwgY3B0T3B0aW9uLmlkID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICYmIGNwdE9wdGlvbi5uYW1lICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgJiYgIW1vZGVsVXRpbC5pc0lkSW5uZXIoY3B0T3B0aW9uKVxuICAgICAgICAgICAgICAgICAgICAmJiAhbW9kZWxVdGlsLmlzSWRJbm5lcihleGlzdClcbiAgICAgICAgICAgICAgICAgICAgJiYgZXhpc3QubmFtZSA9PT0gY3B0T3B0aW9uLm5hbWUgKyAnJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBuZXdDcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBtYXBwaW5nIGJ5IGluZGV4LlxuICAgICAgICBlYWNoKG5ld0NwdE9wdGlvbnMsIGZ1bmN0aW9uIChjcHRPcHRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGlzdGluZyBtb2RlbCB0aGF0IGFscmVhZHkgaGFzIGlkIHNob3VsZCBiZSBhYmxlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcHBlZCB0byAoYmVjYXVzZSBhZnRlciBtYXBwaW5nIHBlcmZvcm1lZCBtb2RlbCBtYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgYXNzaWduZWQgd2l0aCBhIGlkLCB3aGlzaCBzaG91bGQgbm90IGFmZmVjdCBuZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcHBpbmcpLCBleGNlcHQgdGhvc2UgaGFzIGlubmVyIGlkLlxuICAgICAgICAgICAgICAgICAgICAmJiAhbW9kZWxVdGlsLmlzSWRJbm5lcihleGlzdClcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2F1dGlvbjpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSBpZC4gQnV0IG5hbWUgY2FuIGJlIG92ZXJ3cml0dGVuLFxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGF4aXMgdXNlIG5hbWUgYXMgJ3Nob3cgbGFiZWwgdGV4dCcuXG4gICAgICAgICAgICAgICAgICAgIC8vICdleGlzdCcgYWx3YXlzIGhhcyBpZCBhbmQgbmFtZSBhbmQgd2UgZG9udFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIGl0LlxuICAgICAgICAgICAgICAgICAgICAmJiBjcHRPcHRpb24uaWQgPT0gbnVsbFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID49IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7b3B0aW9uOiBjcHRPcHRpb259KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBpZCBhbmQgbmFtZSBmb3IgbWFwcGluZyByZXN1bHQgKHJlc3VsdCBvZiBtYXBwaW5nVG9FeGlzdHMpXG4gICAgICogaW50byBga2V5SW5mb2AgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gUmVzdWx0LCBsaWtlIFt7ZXhpc3Q6IC4uLiwgb3B0aW9uOiAuLi59LCB7fV0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIG9yZGVyIGlzIHRoZSBzYW1lIGFzIGV4aXN0cy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gVGhlIGlucHV0LlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5tYWtlSWRBbmROYW1lID0gZnVuY3Rpb24gKG1hcFJlc3VsdCkge1xuICAgICAgICAvLyBXZSB1c2UgdGhpcyBpZCB0byBoYXNoIGNvbXBvbmVudCBtb2RlbHMgYW5kIHZpZXcgaW5zdGFuY2VzXG4gICAgICAgIC8vIGluIGVjaGFydHMuIGlkIGNhbiBiZSBzcGVjaWZpZWQgYnkgdXNlciwgb3IgYXV0byBnZW5lcmF0ZWQuXG5cbiAgICAgICAgLy8gVGhlIGlkIGdlbmVyYXRpb24gcnVsZSBlbnN1cmVzIG5ldyB2aWV3IGluc3RhbmNlIGFyZSBhYmxlXG4gICAgICAgIC8vIHRvIG1hcHBlZCB0byBvbGQgaW5zdGFuY2Ugd2hlbiBzZXRPcHRpb24gYXJlIGNhbGxlZCBpblxuICAgICAgICAvLyBuby1tZXJnZSBtb2RlLiBTbyB3ZSBnZW5lcmF0ZSBtb2RlbCBpZCBieSBuYW1lIGFuZCBwbHVzXG4gICAgICAgIC8vIHR5cGUgaW4gdmlldyBpZC5cblxuICAgICAgICAvLyBuYW1lIGNhbiBiZSBkdXBsaWNhdGVkIGFtb25nIGNvbXBvbmVudHMsIHdoaWNoIGlzIGNvbnZlbmllbnRcbiAgICAgICAgLy8gdG8gc3BlY2lmeSBtdWx0aSBjb21wb25lbnRzIChsaWtlIHNlcmllcykgYnkgb25lIG5hbWUuXG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgZWFjaCBpZCBpcyBkaXN0aW5jdC5cbiAgICAgICAgdmFyIGlkTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcblxuICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RDcHQgPSBpdGVtLmV4aXN0O1xuICAgICAgICAgICAgZXhpc3RDcHQgJiYgaWRNYXAuc2V0KGV4aXN0Q3B0LmlkLCBpdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuXG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICFvcHQgfHwgb3B0LmlkID09IG51bGwgfHwgIWlkTWFwLmdldChvcHQuaWQpIHx8IGlkTWFwLmdldChvcHQuaWQpID09PSBpdGVtLFxuICAgICAgICAgICAgICAgICdpZCBkdXBsaWNhdGVzOiAnICsgKG9wdCAmJiBvcHQuaWQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvcHQgJiYgb3B0LmlkICE9IG51bGwgJiYgaWRNYXAuc2V0KG9wdC5pZCwgaXRlbSk7XG4gICAgICAgICAgICAhaXRlbS5rZXlJbmZvICYmIChpdGVtLmtleUluZm8gPSB7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1ha2UgbmFtZSBhbmQgaWQuXG4gICAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBleGlzdENwdCA9IGl0ZW0uZXhpc3Q7XG4gICAgICAgICAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG4gICAgICAgICAgICB2YXIga2V5SW5mbyA9IGl0ZW0ua2V5SW5mbztcblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBuYW1lIGNhbiBiZSBvdmVyd2l0dGVuLiBDb25zaWRlciBjYXNlOiBheGlzLm5hbWUgPSAnMjBrbScuXG4gICAgICAgICAgICAvLyBCdXQgaWQgZ2VuZXJhdGVkIGJ5IG5hbWUgd2lsbCBub3QgYmUgY2hhbmdlZCwgd2hpY2ggYWZmZWN0XG4gICAgICAgICAgICAvLyBvbmx5IGluIHRoYXQgY2FzZTogc2V0T3B0aW9uIHdpdGggJ25vdCBtZXJnZSBtb2RlJyBhbmQgdmlld1xuICAgICAgICAgICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSByZWNyZWF0ZWQsIHdoaWNoIGNhbiBiZSBhY2NlcHRlZC5cbiAgICAgICAgICAgIGtleUluZm8ubmFtZSA9IG9wdC5uYW1lICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IG9wdC5uYW1lICsgJydcbiAgICAgICAgICAgICAgICA6IGV4aXN0Q3B0XG4gICAgICAgICAgICAgICAgPyBleGlzdENwdC5uYW1lXG4gICAgICAgICAgICAgICAgOiAnXFwwLSc7IC8vIG5hbWUgbWF5IGJlIGRpc3BsYXllZCBvbiBzY3JlZW4sIHNvIHVzZSAnLScuXG5cbiAgICAgICAgICAgIGlmIChleGlzdENwdCkge1xuICAgICAgICAgICAgICAgIGtleUluZm8uaWQgPSBleGlzdENwdC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdC5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAga2V5SW5mby5pZCA9IG9wdC5pZCArICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBzaXR1YXRvaW46XG4gICAgICAgICAgICAgICAgLy8gIG9wdGlvbkE6IFt7bmFtZTogJ2EnfSwge25hbWU6ICdhJ30sIHsuLn1dXG4gICAgICAgICAgICAgICAgLy8gIG9wdGlvbkIgW3suLn0sIHtuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfV1cbiAgICAgICAgICAgICAgICAvLyBTZXJpZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGJldHdlZW4gb3B0aW9uQSBhbmQgb3B0aW9uQlxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBtYXBwZWQuXG4gICAgICAgICAgICAgICAgdmFyIGlkTnVtID0gMDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGtleUluZm8uaWQgPSAnXFwwJyArIGtleUluZm8ubmFtZSArICdcXDAnICsgaWROdW0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlkTWFwLmdldChrZXlJbmZvLmlkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlkTWFwLnNldChrZXlJbmZvLmlkLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3B0T3B0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuaXNJZElubmVyID0gZnVuY3Rpb24gKGNwdE9wdGlvbikge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoY3B0T3B0aW9uKVxuICAgICAgICAgICAgJiYgY3B0T3B0aW9uLmlkXG4gICAgICAgICAgICAmJiAoY3B0T3B0aW9uLmlkICsgJycpLmluZGV4T2YoJ1xcMF9lY19cXDAnKSA9PT0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZm9yIHJlbW92aW5nIGR1cGxpY2F0ZSBpdGVtcyBiZXR3ZWVuIGJhdGNoQSBhbmQgYmF0Y2hCLFxuICAgICAqIGFuZCBpbiB0aGVtc2VsdmVzLCBhbmQgY2F0ZWdvcml6ZSBieSBzZXJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBiYXRjaEEgTGlrZTogW3tzZXJpZXNJZDogMiwgZGF0YUluZGV4OiBbMzIsIDQsIDVdfSwgLi4uXVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGJhdGNoQiBMaWtlOiBbe3Nlcmllc0lkOiAyLCBkYXRhSW5kZXg6IFszMiwgNCwgNV19LCAuLi5dXG4gICAgICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxPYmplY3Q+LCBBcnJheS48T2JqZWN0Pj59IHJlc3VsdDogW3Jlc3VsdEJhdGNoQSwgcmVzdWx0QmF0Y2hCXVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5jb21wcmVzc0JhdGNoZXMgPSBmdW5jdGlvbiAoYmF0Y2hBLCBiYXRjaEIpIHtcbiAgICAgICAgdmFyIG1hcEEgPSB7fTtcbiAgICAgICAgdmFyIG1hcEIgPSB7fTtcblxuICAgICAgICBtYWtlTWFwKGJhdGNoQSB8fCBbXSwgbWFwQSk7XG4gICAgICAgIG1ha2VNYXAoYmF0Y2hCIHx8IFtdLCBtYXBCLCBtYXBBKTtcblxuICAgICAgICByZXR1cm4gW21hcFRvQXJyYXkobWFwQSksIG1hcFRvQXJyYXkobWFwQildO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VNYXAoc291cmNlQmF0Y2gsIG1hcCwgb3RoZXJNYXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VCYXRjaC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJZCA9IHNvdXJjZUJhdGNoW2ldLnNlcmllc0lkO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KHNvdXJjZUJhdGNoW2ldLmRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyRGF0YUluZGljZXMgPSBvdGhlck1hcCAmJiBvdGhlck1hcFtzZXJpZXNJZF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGRhdGFJbmRpY2VzLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gZGF0YUluZGljZXNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRGF0YUluZGljZXMgJiYgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlckRhdGFJbmRpY2VzW2RhdGFJbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKG1hcFtzZXJpZXNJZF0gfHwgKG1hcFtzZXJpZXNJZF0gPSB7fSkpW2RhdGFJbmRleF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXAsIGlzRGF0YSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGkpICYmIG1hcFtpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCtpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyA9IG1hcFRvQXJyYXkobWFwW2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbmRpY2VzLmxlbmd0aCAmJiByZXN1bHQucHVzaCh7c2VyaWVzSWQ6IGksIGRhdGFJbmRleDogZGF0YUluZGljZXN9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBDb250YWlucyBkYXRhSW5kZXggKG1lYW5zIHJhd0luZGV4KSAvIGRhdGFJbmRleEluc2lkZSAvIG5hbWVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIG9mIHdoaWNoIGNhbiBiZSBBcnJheSBvciBwcmltYXJ5IHR5cGUuXG4gICAgICogQHJldHVybiB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBkYXRhSW5kZXggSWYgbm90IGZvdW5kLCByZXR1cm4gdW5kZWZpbmVkL251bGwuXG4gICAgICovXG4gICAgbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4ID0gZnVuY3Rpb24gKGRhdGEsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQuZGF0YUluZGV4SW5zaWRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLmRhdGFJbmRleEluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXlsb2FkLmRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmlzQXJyYXkocGF5bG9hZC5kYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgPyB6clV0aWwubWFwKHBheWxvYWQuZGF0YUluZGV4LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaW5kZXhPZlJhd0luZGV4KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogZGF0YS5pbmRleE9mUmF3SW5kZXgocGF5bG9hZC5kYXRhSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBheWxvYWQubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmlzQXJyYXkocGF5bG9hZC5uYW1lKVxuICAgICAgICAgICAgICAgID8genJVdGlsLm1hcChwYXlsb2FkLm5hbWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5pbmRleE9mTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IGRhdGEuaW5kZXhPZk5hbWUocGF5bG9hZC5uYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgcHJvcGVydHkgc3RvcmFnZSB0byBhbnkgaG9zdCBvYmplY3QuXG4gICAgICogTm90aWNlOiBTZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZTpcbiAgICAgKiB2YXIgZ2V0ID0gbW9kZWxVaXRsLm1ha2VHZXR0ZXIoKTtcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNvbWUoaG9zdE9iaikge1xuICAgICAqICAgICAgZ2V0KGhvc3RPYmopLl9zb21lUHJvcGVydHkgPSAxMjEyO1xuICAgICAqICAgICAgLi4uXG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgbW9kZWxVdGlsLm1ha2VHZXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleSA9ICdcXDBfX2VjX3Byb3BfZ2V0dGVyXycgKyBpbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChob3N0T2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RPYmpba2V5XSB8fCAoaG9zdE9ialtrZXldID0ge30pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICAgICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICAgICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleCwgc2VyaWVzSWQsIHNlcmllc05hbWUsXG4gICAgICogICAgICAgICAgICBnZW9JbmRleCwgZ2VvSWQsIGdlb05hbWUsXG4gICAgICogICAgICAgICAgICBibWFwSW5kZXgsIGJtYXBJZCwgYm1hcE5hbWUsXG4gICAgICogICAgICAgICAgICB4QXhpc0luZGV4LCB4QXhpc0lkLCB4QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICB5QXhpc0luZGV4LCB5QXhpc0lkLCB5QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICBncmlkSW5kZXgsIGdyaWRJZCwgZ3JpZE5hbWUsXG4gICAgICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICAgICBFYWNoIHByb3BlcnRpZXMgY2FuIGJlIG51bWJlcnxzdHJpbmd8QXJyYXkuPG51bWJlcj58QXJyYXkuPHN0cmluZz5cbiAgICAgKiAgICAgICAgRm9yIGV4YW1wbGUsIGEgZmluZGVyIGNvdWxkIGJlXG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4OiAzLFxuICAgICAqICAgICAgICAgICAgZ2VvSWQ6IFsnYWEnLCAnY2MnXSxcbiAgICAgKiAgICAgICAgICAgIGdyaWROYW1lOiBbJ3h4JywgJ3JyJ11cbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICAgICB4eHhJbmRleCBjYW4gYmUgc2V0IGFzICdhbGwnIChtZWFucyBhbGwgeHh4KSBvciAnbm9uZScgKG1lYW5zIG5vdCBzcGVjaWZ5KVxuICAgICAqICAgICAgICBJZiBub3RoaW5nIG9yIG51bGwvdW5kZWZpbmVkIHNwZWNpZmllZCwgcmV0dXJuIG5vdGhpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuZGVmYXVsdE1haW5UeXBlXVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtvcHQuaW5jbHVkZU1haW5UeXBlc11cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCBsaWtlOlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNNb2RlbHM6IFtzZXJpZXNNb2RlbDEsIHNlcmllc01vZGVsMl0sXG4gICAgICogICAgICAgICAgICBzZXJpZXNNb2RlbDogc2VyaWVzTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAgICAgKiAgICAgICAgICAgIGdlb01vZGVsczogW2dlb01vZGVsMSwgZ2VvTW9kZWwyXSxcbiAgICAgKiAgICAgICAgICAgIGdlb01vZGVsOiBnZW9Nb2RlbDEsIC8vIFRoZSBmaXJzdCBtb2RlbFxuICAgICAqICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgIH1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwucGFyc2VGaW5kZXIgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCBvcHQpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc1N0cmluZyhmaW5kZXIpKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICBvYmpbZmluZGVyICsgJ0luZGV4J10gPSAwO1xuICAgICAgICAgICAgZmluZGVyID0gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRNYWluVHlwZSA9IG9wdCAmJiBvcHQuZGVmYXVsdE1haW5UeXBlO1xuICAgICAgICBpZiAoZGVmYXVsdE1haW5UeXBlXG4gICAgICAgICAgICAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ0luZGV4JylcbiAgICAgICAgICAgICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnSWQnKVxuICAgICAgICAgICAgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdOYW1lJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmaW5kZXJbZGVmYXVsdE1haW5UeXBlICsgJ0luZGV4J10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGVhY2goZmluZGVyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZmluZGVyW2tleV07XG5cbiAgICAgICAgICAgIC8vIEV4Y2x1ZGUgJ2RhdGFJbmRleCcgYW5kIG90aGVyIGlsbGdhbCBrZXlzLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2RhdGFJbmRleCcgfHwga2V5ID09PSAnZGF0YUluZGV4SW5zaWRlJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyc2VkS2V5ID0ga2V5Lm1hdGNoKC9eKFxcdyspKEluZGV4fElkfE5hbWUpJC8pIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG1haW5UeXBlID0gcGFyc2VkS2V5WzFdO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5VHlwZSA9IChwYXJzZWRLZXlbMl0gfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmICghbWFpblR5cGVcbiAgICAgICAgICAgICAgICB8fCAhcXVlcnlUeXBlXG4gICAgICAgICAgICAgICAgfHwgdmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgICAgIHx8IChxdWVyeVR5cGUgPT09ICdpbmRleCcgJiYgdmFsdWUgPT09ICdub25lJylcbiAgICAgICAgICAgICAgICB8fCAob3B0ICYmIG9wdC5pbmNsdWRlTWFpblR5cGVzICYmIHpyVXRpbC5pbmRleE9mKG9wdC5pbmNsdWRlTWFpblR5cGVzLCBtYWluVHlwZSkgPCAwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcXVlcnlQYXJhbSA9IHttYWluVHlwZTogbWFpblR5cGV9O1xuICAgICAgICAgICAgaWYgKHF1ZXJ5VHlwZSAhPT0gJ2luZGV4JyB8fCB2YWx1ZSAhPT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtW3F1ZXJ5VHlwZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vZGVscyA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHF1ZXJ5UGFyYW0pO1xuICAgICAgICAgICAgcmVzdWx0W21haW5UeXBlICsgJ01vZGVscyddID0gbW9kZWxzO1xuICAgICAgICAgICAgcmVzdWx0W21haW5UeXBlICsgJ01vZGVsJ10gPSBtb2RlbHNbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc31cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGF0YURpbVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuZGF0YURpbVRvQ29vcmREaW0gPSBmdW5jdGlvbiAoZGF0YSwgZGF0YURpbSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGRhdGEuZGltZW5zaW9ucztcbiAgICAgICAgZGF0YURpbSA9IGRhdGEuZ2V0RGltZW5zaW9uKGRhdGFEaW0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbWVuc2lvbnNbaV0pO1xuICAgICAgICAgICAgaWYgKGRpbUl0ZW0ubmFtZSA9PT0gZGF0YURpbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaW1JdGVtLmNvb3JkRGltO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc31cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZERpbVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBkYXRhIGRpbWVuc2lvbnMgb24gdGhlIGNvb3JkRGltLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5jb29yZERpbVRvRGF0YURpbSA9IGZ1bmN0aW9uIChkYXRhLCBjb29yZERpbSkge1xuICAgICAgICB2YXIgZGF0YURpbSA9IFtdO1xuICAgICAgICBlYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpO1xuICAgICAgICAgICAgaWYgKGRpbUl0ZW0uY29vcmREaW0gPT09IGNvb3JkRGltKSB7XG4gICAgICAgICAgICAgICAgZGF0YURpbVtkaW1JdGVtLmNvb3JkRGltSW5kZXhdID0gZGltSXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGFEaW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc31cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvdGhlckRpbSBDYW4gYmUgYG90aGVyRGltc2BcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGxpa2UgJ2xhYmVsJyBvciAndG9vbHRpcCcuXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRhdGEgZGltZW5zaW9ucyBvbiB0aGUgb3RoZXJEaW0uXG4gICAgICovXG4gICAgbW9kZWxVdGlsLm90aGVyRGltVG9EYXRhRGltID0gZnVuY3Rpb24gKGRhdGEsIG90aGVyRGltKSB7XG4gICAgICAgIHZhciBkYXRhRGltID0gW107XG4gICAgICAgIGVhY2goZGF0YS5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltTmFtZSkge1xuICAgICAgICAgICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltTmFtZSk7XG4gICAgICAgICAgICB2YXIgb3RoZXJEaW1zID0gZGltSXRlbS5vdGhlckRpbXM7XG4gICAgICAgICAgICB2YXIgZGltSW5kZXggPSBvdGhlckRpbXNbb3RoZXJEaW1dO1xuICAgICAgICAgICAgaWYgKGRpbUluZGV4ICE9IG51bGwgJiYgZGltSW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGF0YURpbVtkaW1JbmRleF0gPSBkaW1JdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YURpbTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFzKG9iaiwgcHJvcCkge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1vZGVsVXRpbDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvbW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 数值处理模块\n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * @return {number} in minutes\n     */\n    number.getTimezoneOffset = function () {\n        return (new Date()).getTimezoneOffset();\n    };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            var timezoneOffset = number.getTimezoneOffset();\n            var timeOffset = !match[8]\n                ? 0\n                : match[8].toUpperCase() === 'Z'\n                ? timezoneOffset\n                : +match[8].slice(0, 3) * 60 + timezoneOffset;\n\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0) - timeOffset,\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a “nice” number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the “nicest”\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvbnVtYmVyLmpzPzhlOWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QyxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixFQUFFLGFBQWEsSUFBSSxhQUFhLElBQUksWUFBWSxJQUFJLHVFQUF1RTs7QUFFdko7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLCtCQUErQixRQUFRO0FBQ3ZDLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQyxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksMENBQTBDO0FBQ3RELFlBQVksb0NBQW9DO0FBQ2hELFlBQVksbUNBQW1DO0FBQy9DLFlBQVksbUNBQW1DO0FBQy9DLFlBQVksb0NBQW9DO0FBQ2hELFlBQVk7QUFDWjtBQUNBLFlBQVksMENBQTBDO0FBQ3RELFlBQVksb0NBQW9DO0FBQ2hELFlBQVksbUNBQW1DO0FBQy9DLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksbUNBQW1DO0FBQy9DLFlBQVk7QUFDWjtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5pWw5YC85aSE55CG5qih5Z2XXG4gKiBAbW9kdWxlIGVjaGFydHMvdXRpbC9udW1iZXJcbiAqL1xuXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBudW1iZXIgPSB7fTtcblxuICAgIHZhciBSQURJQU5fRVBTSUxPTiA9IDFlLTQ7XG5cbiAgICBmdW5jdGlvbiBfdHJpbShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5lYXIgbWFwcGluZyBhIHZhbHVlIGZyb20gZG9tYWluIHRvIHJhbmdlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gICAgICogQHBhcmFtICB7KG51bWJlcnxBcnJheS48bnVtYmVyPil9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBkb21haW4gRG9tYWluIGV4dGVudCBkb21haW5bMF0gY2FuIGJlIGJpZ2dlciB0aGFuIGRvbWFpblsxXVxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByYW5nZSAgUmFuZ2UgZXh0ZW50IHJhbmdlWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiByYW5nZVsxXVxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAgICogQHJldHVybiB7KG51bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBudW1iZXIubGluZWFyTWFwID0gZnVuY3Rpb24gKHZhbCwgZG9tYWluLCByYW5nZSwgY2xhbXApIHtcbiAgICAgICAgdmFyIHN1YkRvbWFpbiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcbiAgICAgICAgdmFyIHN1YlJhbmdlID0gcmFuZ2VbMV0gLSByYW5nZVswXTtcblxuICAgICAgICBpZiAoc3ViRG9tYWluID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViUmFuZ2UgPT09IDBcbiAgICAgICAgICAgICAgICA/IHJhbmdlWzBdXG4gICAgICAgICAgICAgICAgOiAocmFuZ2VbMF0gKyByYW5nZVsxXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgYWNjdXJhY3kgcHJvYmxlbSBpbiBlZGdlLCBzdWNoIGFzXG4gICAgICAgIC8vIDE0Ni4zOSAtIDYyLjgzID09PSA4My41NTk5OTk5OTk5OTk5OS5cbiAgICAgICAgLy8gU2VlIGVjaGFydHMvdGVzdC91dC9zcGVjL3V0aWwvbnVtYmVyLmpzI2xpbmVhck1hcCNhY2N1cmFjeUVycm9yXG4gICAgICAgIC8vIEl0IGlzIGEgbGl0dGxlIHZlcmJvc2UgZm9yIGVmZmljaWVuY3kgY29uc2lkZXJpbmcgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gaXMgYSBob3RzcG90LlxuICAgICAgICBpZiAoY2xhbXApIHtcbiAgICAgICAgICAgIGlmIChzdWJEb21haW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8PSBkb21haW5bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgPj0gZG9tYWluWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsID49IGRvbWFpblswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8PSBkb21haW5bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IGRvbWFpblswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgPT09IGRvbWFpblsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodmFsIC0gZG9tYWluWzBdKSAvIHN1YkRvbWFpbiAqIHN1YlJhbmdlICsgcmFuZ2VbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBwZXJjZW50IHN0cmluZyB0byBhYnNvbHV0ZSBudW1iZXIuXG4gICAgICogUmV0dXJucyBOYU4gaWYgcGVyY2VudCBpcyBub3QgYSB2YWxpZCBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFsbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucGFyc2VQZXJjZW50ID0gZnVuY3Rpb24ocGVyY2VudCwgYWxsKSB7XG4gICAgICAgIHN3aXRjaCAocGVyY2VudCkge1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnMCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVyY2VudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChfdHJpbShwZXJjZW50KS5tYXRjaCgvJSQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpIC8gMTAwICogYWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwZXJjZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwZXJjZW50ID09IG51bGwgPyBOYU4gOiArcGVyY2VudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogKDEpIEZpeCByb3VuZGluZyBlcnJvciBvZiBmbG9hdCBudW1iZXJzLlxuICAgICAqICgyKSBTdXBwb3J0IHJldHVybiBzdHJpbmcgdG8gYXZvaWQgc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlICczLjVlLTcnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbl1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5TdHJdXG4gICAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cbiAgICAgKi9cbiAgICBudW1iZXIucm91bmQgPSBmdW5jdGlvbiAoeCwgcHJlY2lzaW9uLCByZXR1cm5TdHIpIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCByYW5nZSBlcnJvclxuICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBwcmVjaXNpb24pLCAyMCk7XG4gICAgICAgIHggPSAoK3gpLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblN0ciA/IHggOiAreDtcbiAgICB9O1xuXG4gICAgbnVtYmVyLmFzYyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBwcmVjaXNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gICAgICovXG4gICAgbnVtYmVyLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcbiAgICAgICAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIG11Y2ggZmFzdGVyIHRoYW4gbWV0aG9kcyBjb252ZXJ0aW5nIG51bWJlciB0byBzdHJpbmcgYXMgZm9sbG93c1xuICAgICAgICAvLyAgICAgIHZhciB0bXAgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gICAgICByZXR1cm4gdG1wLmxlbmd0aCAtIDEgLSB0bXAuaW5kZXhPZignLicpO1xuICAgICAgICAvLyBlc3BlY2lhbGx5IHdoZW4gcHJlY2lzaW9uIGlzIGxvd1xuICAgICAgICB2YXIgZSA9IDE7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHdoaWxlIChNYXRoLnJvdW5kKHZhbCAqIGUpIC8gZSAhPT0gdmFsKSB7XG4gICAgICAgICAgICBlICo9IDEwO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5nZXRQcmVjaXNpb25TYWZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgc3RyID0gdmFsLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgLy8gQ29uc2lkZXIgc2NpZW50aWZpYyBub3RhdGlvbjogJzMuNGUtMTInICczLjRlKzEyJ1xuICAgICAgICB2YXIgZUluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcbiAgICAgICAgaWYgKGVJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSArc3RyLnNsaWNlKGVJbmRleCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHByZWNpc2lvbiA8IDAgPyAtcHJlY2lzaW9uIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkb3RJbmRleCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgICByZXR1cm4gZG90SW5kZXggPCAwID8gMCA6IHN0ci5sZW5ndGggLSAxIC0gZG90SW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWluaW1hbCBkaWNlcm5pYmxlIGRhdGEgcHJlY2lzaW9pbiBhY2NvcmRpbmcgdG8gYSBzaW5nbGUgcGl4ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhRXh0ZW50XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGl4ZWxFeHRlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHByZWNpc2lvblxuICAgICAqL1xuICAgIG51bWJlci5nZXRQaXhlbFByZWNpc2lvbiA9IGZ1bmN0aW9uIChkYXRhRXh0ZW50LCBwaXhlbEV4dGVudCkge1xuICAgICAgICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gICAgICAgIHZhciBMTjEwID0gTWF0aC5MTjEwO1xuICAgICAgICB2YXIgZGF0YVF1YW50aXR5ID0gTWF0aC5mbG9vcihsb2coZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gTE4xMCk7XG4gICAgICAgIHZhciBzaXplUXVhbnRpdHkgPSBNYXRoLnJvdW5kKGxvZyhNYXRoLmFicyhwaXhlbEV4dGVudFsxXSAtIHBpeGVsRXh0ZW50WzBdKSkgLyBMTjEwKTtcbiAgICAgICAgLy8gdG9GaXhlZCgpIGRpZ2l0cyBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjAuXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgtZGF0YVF1YW50aXR5ICsgc2l6ZVF1YW50aXR5LCAwKSwgMjApO1xuICAgICAgICByZXR1cm4gIWlzRmluaXRlKHByZWNpc2lvbikgPyAyMCA6IHByZWNpc2lvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgZGF0YSBvZiBnaXZlbiBwcmVjaXNpb24sIGFzc3VyaW5nIHRoZSBzdW0gb2YgcGVyY2VudGFnZXNcbiAgICAgKiBpbiB2YWx1ZUxpc3QgaXMgMS5cbiAgICAgKiBUaGUgbGFyZ2VzdCByZW1haW5lciBtZXRob2QgaXMgdXNlZC5cbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXJnZXN0X3JlbWFpbmRlcl9tZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlTGlzdCBhIGxpc3Qgb2YgYWxsIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IGluZGV4IG9mIHRoZSBkYXRhIHRvIGJlIHByb2Nlc3NlZCBpbiB2YWx1ZUxpc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJlY2lzaW9uIGludGVnZXIgbnVtYmVyIHNob3dpbmcgZGlnaXRzIG9mIHByZWNpc2lvblxuICAgICAqIEByZXR1cm4ge251bWJlcn0gcGVyY2VudCByYW5naW5nIGZyb20gMCB0byAxMDBcbiAgICAgKi9cbiAgICBudW1iZXIuZ2V0UGVyY2VudFdpdGhQcmVjaXNpb24gPSBmdW5jdGlvbiAodmFsdWVMaXN0LCBpZHgsIHByZWNpc2lvbikge1xuICAgICAgICBpZiAoIXZhbHVlTGlzdFtpZHhdKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdW0gPSB6clV0aWwucmVkdWNlKHZhbHVlTGlzdCwgZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgKGlzTmFOKHZhbCkgPyAwIDogdmFsKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmIChzdW0gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZ2l0cyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICB2YXIgdm90ZXNQZXJRdW90YSA9IHpyVXRpbC5tYXAodmFsdWVMaXN0LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzTmFOKHZhbCkgPyAwIDogdmFsKSAvIHN1bSAqIGRpZ2l0cyAqIDEwMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0YXJnZXRTZWF0cyA9IGRpZ2l0cyAqIDEwMDtcblxuICAgICAgICB2YXIgc2VhdHMgPSB6clV0aWwubWFwKHZvdGVzUGVyUXVvdGEsIGZ1bmN0aW9uICh2b3Rlcykge1xuICAgICAgICAgICAgLy8gQXNzaWduIGF1dG9tYXRpYyBzZWF0cy5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZvdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdXJyZW50U3VtID0genJVdGlsLnJlZHVjZShzZWF0cywgZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgdmFsO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICB2YXIgcmVtYWluZGVyID0genJVdGlsLm1hcCh2b3Rlc1BlclF1b3RhLCBmdW5jdGlvbiAodm90ZXMsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvdGVzIC0gc2VhdHNbaWR4XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSGFzIHJlbWFpbmRpbmcgdm90ZXMuXG4gICAgICAgIHdoaWxlIChjdXJyZW50U3VtIDwgdGFyZ2V0U2VhdHMpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgbmV4dCBsYXJnZXN0IHJlbWFpbmRlci5cbiAgICAgICAgICAgIHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB2YXIgbWF4SWQgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlbWFpbmRlci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5kZXJbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gcmVtYWluZGVyW2ldO1xuICAgICAgICAgICAgICAgICAgICBtYXhJZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgYSB2b3RlIHRvIG1heCByZW1haW5kZXIuXG4gICAgICAgICAgICArK3NlYXRzW21heElkXTtcbiAgICAgICAgICAgIHJlbWFpbmRlclttYXhJZF0gPSAwO1xuICAgICAgICAgICAgKytjdXJyZW50U3VtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlYXRzW2lkeF0gLyBkaWdpdHM7XG4gICAgfTtcblxuICAgIC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBpZSBkbyBub3Qgc3VwcG9ydC5cbiAgICBudW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgICAvKipcbiAgICAgKiBUbyAwIC0gMiAqIFBJLCBjb25zaWRlcmluZyBuZWdhdGl2ZSByYWRpYW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhblxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucmVtUmFkaWFuID0gZnVuY3Rpb24gKHJhZGlhbikge1xuICAgICAgICB2YXIgcGkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIHJldHVybiAocmFkaWFuICUgcGkyICsgcGkyKSAlIHBpMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt0eXBlfSByYWRpYW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIG51bWJlci5pc1JhZGlhbkFyb3VuZFplcm8gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiAtUkFESUFOX0VQU0lMT04gJiYgdmFsIDwgUkFESUFOX0VQU0lMT047XG4gICAgfTtcblxuICAgIHZhciBUSU1FX1JFRyA9IC9eKD86KFxcZHs0fSkoPzpbLVxcL10oXFxkezEsMn0pKD86Wy1cXC9dKFxcZHsxLDJ9KSg/OltUIF0oXFxkezEsMn0pKD86OihcXGRcXGQpKD86OihcXGRcXGQpKD86Wy4sXShcXGQrKSk/KT8pPyhafFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQpPyk/KT8pPyk/JC87IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBpbiBtaW51dGVzXG4gICAgICovXG4gICAgbnVtYmVyLmdldFRpbWV6b25lT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfERhdGV8bnVtYmVyfSB2YWx1ZSBUaGVzZSB2YWx1ZXMgY2FuIGJlIGFjY2VwdGVkOlxuICAgICAqICAgKyBBbiBpbnN0YW5jZSBvZiBEYXRlLCByZXByZXNlbnQgYSB0aW1lIGluIGl0cyBvd24gdGltZSB6b25lLlxuICAgICAqICAgKyBPciBzdHJpbmcgaW4gYSBzdWJzZXQgb2YgSVNPIDg2MDEsIG9ubHkgaW5jbHVkaW5nOlxuICAgICAqICAgICArIG9ubHkgeWVhciwgbW9udGgsIGRhdGU6ICcyMDEyLTAzJywgJzIwMTItMDMtMDEnLCAnMjAxMi0wMy0wMSAwNScsICcyMDEyLTAzLTAxIDA1OjA2JyxcbiAgICAgKiAgICAgKyBzZXBhcmF0ZWQgd2l0aCBUIG9yIHNwYWNlOiAnMjAxMi0wMy0wMVQxMjoyMjozMy4xMjMnLCAnMjAxMi0wMy0wMSAxMjoyMjozMy4xMjMnLFxuICAgICAqICAgICArIHRpbWUgem9uZTogJzIwMTItMDMtMDFUMTI6MjI6MzNaJywgJzIwMTItMDMtMDFUMTI6MjI6MzMrODAwMCcsICcyMDEyLTAzLTAxVDEyOjIyOjMzLTA1OjAwJyxcbiAgICAgKiAgICAgYWxsIG9mIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBsb2NhbCB0aW1lIGlmIHRpbWUgem9uZSBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogICAgIChzZWUgPGh0dHBzOi8vbW9tZW50anMuY29tLz4pLlxuICAgICAqICAgKyBPciBvdGhlciBzdHJpbmcgZm9ybWF0LCBpbmNsdWRpbmcgKGFsbCBvZiB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgbG9hY2FsIHRpbWUpOlxuICAgICAqICAgICAnMjAxMicsICcyMDEyLTMtMScsICcyMDEyLzMvMScsICcyMDEyLzAzLzAxJyxcbiAgICAgKiAgICAgJzIwMDkvNi8xMiAyOjAwJywgJzIwMDkvNi8xMiAyOjA1OjA4JywgJzIwMDkvNi8xMiAyOjA1OjA4LjEyMydcbiAgICAgKiAgICsgYSB0aW1lc3RhbXAsIHdoaWNoIHJlcHJlc2VudCBhIHRpbWUgaW4gVVRDLlxuICAgICAqIEByZXR1cm4ge0RhdGV9IGRhdGVcbiAgICAgKi9cbiAgICBudW1iZXIucGFyc2VEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBEaWZmZXJlbnQgYnJvd3NlcnMgcGFyc2UgZGF0ZSBpbiBkaWZmZXJlbnQgd2F5LCBzbyB3ZSBwYXJzZSBpdCBtYW51YWxseS5cbiAgICAgICAgICAgIC8vIFNvbWUgb3RoZXIgaXNzdWVzOlxuICAgICAgICAgICAgLy8gbmV3IERhdGUoJzE5NzAtMDEtMDEnKSBpcyBVVEMsXG4gICAgICAgICAgICAvLyBuZXcgRGF0ZSgnMTk3MC8wMS8wMScpIGFuZCBuZXcgRGF0ZSgnMTk3MC0xLTAxJykgaXMgbG9jYWwuXG4gICAgICAgICAgICAvLyBTZWUgaXNzdWUgIzM2MjNcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IFRJTUVfUkVHLmV4ZWModmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIEludmFsaWQgRGF0ZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gbnVtYmVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgdGltZU9mZnNldCA9ICFtYXRjaFs4XVxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogbWF0Y2hbOF0udG9VcHBlckNhc2UoKSA9PT0gJ1onXG4gICAgICAgICAgICAgICAgPyB0aW1lem9uZU9mZnNldFxuICAgICAgICAgICAgICAgIDogK21hdGNoWzhdLnNsaWNlKDAsIDMpICogNjAgKyB0aW1lem9uZU9mZnNldDtcblxuICAgICAgICAgICAgLy8gbWF0Y2hbbl0gY2FuIG9ubHkgYmUgc3RyaW5nIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vIEJ1dCB0YWtlIGNhcmUgb2YgJzEyJyArIDEgPT4gJzEyMScuXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgK21hdGNoWzFdLFxuICAgICAgICAgICAgICAgICsobWF0Y2hbMl0gfHwgMSkgLSAxLFxuICAgICAgICAgICAgICAgICttYXRjaFszXSB8fCAxLFxuICAgICAgICAgICAgICAgICttYXRjaFs0XSB8fCAwLFxuICAgICAgICAgICAgICAgICsobWF0Y2hbNV0gfHwgMCkgLSB0aW1lT2Zmc2V0LFxuICAgICAgICAgICAgICAgICttYXRjaFs2XSB8fCAwLFxuICAgICAgICAgICAgICAgICttYXRjaFs3XSB8fCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE1hdGgucm91bmQodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUXVhbnRpdHkgb2YgYSBudW1iZXIuIGUuZy4gMC4xLCAxLCAxMCwgMTAwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucXVhbnRpdHkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgcXVhbnRpdHlFeHBvbmVudCh2YWwpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcXVhbnRpdHlFeHBvbmVudCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4xMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZCBhIOKAnG5pY2XigJ0gbnVtYmVyIGFwcHJveGltYXRlbHkgZXF1YWwgdG8geC4gUm91bmQgdGhlIG51bWJlciBpZiByb3VuZCA9IHRydWUsXG4gICAgICogdGFrZSBjZWlsaW5nIGlmIHJvdW5kID0gZmFsc2UuIFRoZSBwcmltYXJ5IG9ic2VydmF0aW9uIGlzIHRoYXQgdGhlIOKAnG5pY2VzdOKAnVxuICAgICAqIG51bWJlcnMgaW4gZGVjaW1hbCBhcmUgMSwgMiwgYW5kIDUsIGFuZCBhbGwgcG93ZXItb2YtdGVuIG11bHRpcGxlcyBvZiB0aGVzZSBudW1iZXJzLlxuICAgICAqXG4gICAgICogU2VlIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbCBOb24tbmVnYXRpdmUgdmFsdWUuXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gcm91bmRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyLm5pY2UgPSBmdW5jdGlvbiAodmFsLCByb3VuZCkge1xuICAgICAgICB2YXIgZXhwb25lbnQgPSBxdWFudGl0eUV4cG9uZW50KHZhbCk7XG4gICAgICAgIHZhciBleHAxMCA9IE1hdGgucG93KDEwLCBleHBvbmVudCk7XG4gICAgICAgIHZhciBmID0gdmFsIC8gZXhwMTA7IC8vIDEgPD0gZiA8IDEwXG4gICAgICAgIHZhciBuZjtcbiAgICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgICAgICBpZiAoZiA8IDEuNSkgeyBuZiA9IDE7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCAyLjUpIHsgbmYgPSAyOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgNCkgeyBuZiA9IDM7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCA3KSB7IG5mID0gNTsgfVxuICAgICAgICAgICAgZWxzZSB7IG5mID0gMTA7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmIDwgMSkgeyBuZiA9IDE7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCAyKSB7IG5mID0gMjsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDMpIHsgbmYgPSAzOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgNSkgeyBuZiA9IDU7IH1cbiAgICAgICAgICAgIGVsc2UgeyBuZiA9IDEwOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gbmYgKiBleHAxMDtcblxuICAgICAgICAvLyBGaXggMyAqIDAuMSA9PT0gMC4zMDAwMDAwMDAwMDAwMDAwNCBpc3N1ZSAoc2VlIElFRUUgNzU0KS5cbiAgICAgICAgLy8gMjAgaXMgdGhlIHVwcHBlciBib3VuZCBvZiB0b0ZpeGVkLlxuICAgICAgICByZXR1cm4gZXhwb25lbnQgPj0gLTIwID8gK3ZhbC50b0ZpeGVkKGV4cG9uZW50IDwgMCA/IC1leHBvbmVudCA6IDApIDogdmFsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcmRlciBpbnRlcnZhbHMgYXNjLCBhbmQgc3BsaXQgdGhlbSB3aGVuIG92ZXJsYXAuXG4gICAgICogZXhwZWN0KG51bWJlclV0aWwucmVmb3JtSW50ZXJ2YWxzKFtcbiAgICAgKiAgICAge2ludGVydmFsOiBbMTgsIDYyXSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWy1JbmZpbml0eSwgLTcwXSwgY2xvc2U6IFswLCAwXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWy03MCwgLTI2XSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWy0yNiwgMThdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbNjIsIDE1MF0sIGNsb3NlOiBbMSwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxMDYsIDE1MF0sIGNsb3NlOiBbMSwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxNTAsIEluZmluaXR5XSwgY2xvc2U6IFswLCAwXX1cbiAgICAgKiBdKSkudG9FcXVhbChbXG4gICAgICogICAgIHtpbnRlcnZhbDogWy1JbmZpbml0eSwgLTcwXSwgY2xvc2U6IFswLCAwXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWy03MCwgLTI2XSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWy0yNiwgMThdLCBjbG9zZTogWzAsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbMTgsIDYyXSwgY2xvc2U6IFswLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzYyLCAxNTBdLCBjbG9zZTogWzAsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbMTUwLCBJbmZpbml0eV0sIGNsb3NlOiBbMCwgMF19XG4gICAgICogXSk7XG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gbGlzdCwgd2hlcmUgYGNsb3NlYCBtZWFuIG9wZW4gb3IgY2xvc2VcbiAgICAgKiAgICAgICAgb2YgdGhlIGludGVydmFsLCBhbmQgSW5maW5pdHkgY2FuIGJlIHVzZWQuXG4gICAgICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFRoZSBvcmlnaW4gbGlzdCwgd2hpY2ggaGFzIGJlZW4gcmVmb3JtZWQuXG4gICAgICovXG4gICAgbnVtYmVyLnJlZm9ybUludGVydmFscyA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGxpdHRsZVRoYW4oYSwgYiwgMCkgPyAtMSA6IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjdXJyID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgY3VyckNsb3NlID0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGxpc3RbaV0uaW50ZXJ2YWw7XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBsaXN0W2ldLmNsb3NlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBsZyA9IDA7IGxnIDwgMjsgbGcrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbFtsZ10gPD0gY3Vycikge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbFtsZ10gPSBjdXJyO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZVtsZ10gPSAhbGcgPyAxIC0gY3VyckNsb3NlIDogMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyciA9IGludGVydmFsW2xnXTtcbiAgICAgICAgICAgICAgICBjdXJyQ2xvc2UgPSBjbG9zZVtsZ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnRlcnZhbFswXSA9PT0gaW50ZXJ2YWxbMV0gJiYgY2xvc2VbMF0gKiBjbG9zZVsxXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG5cbiAgICAgICAgZnVuY3Rpb24gbGl0dGxlVGhhbihhLCBiLCBsZykge1xuICAgICAgICAgICAgcmV0dXJuIGEuaW50ZXJ2YWxbbGddIDwgYi5pbnRlcnZhbFtsZ11cbiAgICAgICAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAgICAgICAgIGEuaW50ZXJ2YWxbbGddID09PSBiLmludGVydmFsW2xnXVxuICAgICAgICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoYS5jbG9zZVtsZ10gLSBiLmNsb3NlW2xnXSA9PT0gKCFsZyA/IDEgOiAtMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoIWxnICYmIGxpdHRsZVRoYW4oYSwgYiwgMSkpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcbiAgICAgKiAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG4gICAgICogc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIG51bWJlci5pc051bWVyaWMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiAtIHBhcnNlRmxvYXQodikgPj0gMDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBudW1iZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvdXRpbC9udW1iZXIuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvZW52LmpzPzkzNmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BELDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZWNoYXJ0c+iuvuWkh+eOr+Wig+ivhuWIq1xuICpcbiAqIEBkZXNjIGVjaGFydHPln7rkuo5DYW52YXPvvIznuq9KYXZhc2NyaXB05Zu+6KGo5bqT77yM5o+Q5L6b55u06KeC77yM55Sf5Yqo77yM5Y+v5Lqk5LqS77yM5Y+v5Liq5oCn5YyW5a6a5Yi255qE5pWw5o2u57uf6K6h5Zu+6KGo44CCXG4gKiBAYXV0aG9yIGZpcmVkZVtmaXJlZGVAZmlyZWRlLnVzXVxuICogQGRlc2MgdGhhbmtzIHplcHRvLlxuICovXG5cbiAgICB2YXIgZW52ID0ge307XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEluIG5vZGVcbiAgICAgICAgZW52ID0ge1xuICAgICAgICAgICAgYnJvd3Nlcjoge30sXG4gICAgICAgICAgICBvczoge30sXG4gICAgICAgICAgICBub2RlOiB0cnVlLFxuICAgICAgICAgICAgLy8gQXNzdW1lIGNhbnZhcyBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW52ID0gZGV0ZWN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZW52O1xuXG4gICAgLy8gWmVwdG8uanNcbiAgICAvLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuICAgIC8vIFplcHRvLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4gICAgZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gICAgICAgIHZhciBvcyA9IHt9O1xuICAgICAgICB2YXIgYnJvd3NlciA9IHt9O1xuICAgICAgICAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgICAgICAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAgICAgICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgICAgICAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgICAgICAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgICAgICAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgICAgICAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgdmFyIGZpcmVmb3ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9Nb2JpbGVcXC8vKSAmJiAhY2hyb21lO1xuICAgICAgICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcbiAgICAgICAgdmFyIGllID0gdWEubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKVxuICAgICAgICAgICAgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgICAgICAgICAgIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgICAgICAgdmFyIGVkZ2UgPSB1YS5tYXRjaCgvRWRnZVxcLyhbXFxkLl0rKS8pOyAvLyBJRSAxMiBhbmQgMTIrXG5cbiAgICAgICAgdmFyIHdlQ2hhdCA9ICgvbWljcm9tZXNzZW5nZXIvaSkudGVzdCh1YSk7XG5cbiAgICAgICAgLy8gVG9kbzogY2xlYW4gdGhpcyB1cCB3aXRoIGEgYmV0dGVyIE9TL2Jyb3dzZXIgc2VwZXJhdGlvbjpcbiAgICAgICAgLy8gLSBkaXNjZXJuIChtb3JlKSBiZXR3ZWVuIG11bHRpcGxlIGJyb3dzZXJzIG9uIGFuZHJvaWRcbiAgICAgICAgLy8gLSBkZWNpZGUgaWYga2luZGxlIGZpcmUgaW4gc2lsayBtb2RlIGlzIGFuZHJvaWQgb3Igbm90XG4gICAgICAgIC8vIC0gRmlyZWZveCBvbiBBbmRyb2lkIGRvZXNuJ3Qgc3BlY2lmeSB0aGUgQW5kcm9pZCB2ZXJzaW9uXG4gICAgICAgIC8vIC0gcG9zc2libHkgZGV2aWRlIGluIG9zLCBkZXZpY2UgYW5kIGJyb3dzZXIgaGFzaGVzXG5cbiAgICAgICAgLy8gaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXTtcblxuICAgICAgICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAgICAgICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICAgIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gICAgICAgIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gICAgICAgIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAgICAgICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAgICAgICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAgICAgICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAgICAgICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgICAgICAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuICAgICAgICBpZiAoZmlyZWZveCkge1xuICAgICAgICAgICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IGZpcmVmb3hbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHNhZmFyaSAmJiAodWEubWF0Y2goL1NhZmFyaS8pIHx8ICEhb3MuaW9zKSkgYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgICAgICAvLyBpZiAod2VidmlldykgYnJvd3Nlci53ZWJ2aWV3ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgYnJvd3Nlci5lZGdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IGVkZ2VbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdCBpcyBkaWZmaWN1bHQgdG8gZGV0ZWN0IFdlQ2hhdCBpbiBXaW4gUGhvbmUgcHJlY2lzZWx5LCBiZWNhdXNlIHVhIGNhblxuICAgICAgICAvLyBub3QgYmUgc2V0IG9uIHdpbiBwaG9uZS4gU28gd2UgZG8gbm90IGNvbnNpZGVyIFdpbiBQaG9uZS5cbiAgICAgICAgaWYgKHdlQ2hhdCkge1xuICAgICAgICAgICAgYnJvd3Nlci53ZUNoYXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gICAgICAgIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gICAgICAgIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gICAgICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICAgICAgICAgIG9zOiBvcyxcbiAgICAgICAgICAgIG5vZGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgICAgICAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAvLyBAc2VlIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MTcwMjkvd2hhdHMtdGhlLWJlc3Qtd2F5LXRvLWRldGVjdC1hLXRvdWNoLXNjcmVlbi1kZXZpY2UtdXNpbmctamF2YXNjcmlwdD5cbiAgICAgICAgICAgIC8vIHdvcmtzIG9uIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgICAgICAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgICAgICAgICAgdG91Y2hFdmVudHNTdXBwb3J0ZWQ6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhYnJvd3Nlci5pZSAmJiAhYnJvd3Nlci5lZGdlLFxuICAgICAgICAgICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCwgb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBjdXJyZW50bHkuIFNvIHdlIGRvbnQgdXNlIHRoYXQgb24gb3RoZXIgYnJvd3NlcnMgdW5sZXNzIHRlc3RlZCBzdWZmaWNpZW50bHkuXG4gICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggSUUgMTAgc3VwcG9ydHMgcG9pbnRlciBldmVudCwgaXQgdXNlIG9sZCBzdHlsZSBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQuIFNvIHdlIGV4Y2x1ZGUgdGhhdC4gKElFIDEwIGlzIGhhcmRseSB1c2VkIG9uIHRvdWNoIGRldmljZSlcbiAgICAgICAgICAgICAgICAmJiAoYnJvd3Nlci5lZGdlIHx8IChicm93c2VyLmllICYmIGJyb3dzZXIudmVyc2lvbiA+PSAxMSkpXG4gICAgICAgIH07XG4gICAgfVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

eval("\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzPzlkODQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICB2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBBcnJheVxuICAgICAgICA6IEZsb2F0MzJBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IFZlY3RvcjJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiDkuoznu7TlkJHph4/nsbtcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvdmVjdG9yXG4gICAgICovXG4gICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dFswXSA9IHg7XG4gICAgICAgICAgICBvdXRbMV0gPSB5O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYvpmobkuIDkuKrlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn0g57uT5p6cXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGE7XG4gICAgICAgICAgICBvdXRbMV0gPSBiO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP55u45YqgXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVBbmRBZGQ6IGZ1bmN0aW9uIChvdXQsIHYxLCB2MiwgYSkge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB2MlswXSAqIGE7XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+ebuOWHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAtIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gLSB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mVv+W6plxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlblNxdWFyZSh2KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mVv+W6puW5s+aWuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuU3F1YXJlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+S5mOazlVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG11bDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAqIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mZpOazlVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIGRpdjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAvIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gLyB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+eCueS5mFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZG90OiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+e8qeaUvlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAob3V0LCB2LCBzKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdICogcztcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV0gKiBzO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP5b2S5LiA5YyWXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgbm9ybWFsaXplOiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHZlY3Rvci5sZW4odik7XG4gICAgICAgICAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dFswXSA9IHZbMF0gLyBkO1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IHZbMV0gLyBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6h566X5ZCR6YeP6Ze06Led56a7XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6Led56a75bmz5pa5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkaXN0YW5jZVNxdWFyZTogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICAgICAgICAgICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLotJ/lkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGU6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IC12WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gLXZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmj5LlgLzkuKTkuKrngrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gICAgICAgICAqL1xuICAgICAgICBsZXJwOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIsIHQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdCAqICh2MlswXSAtIHYxWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteW3puS5mOWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBtXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKG91dCwgdiwgbSkge1xuICAgICAgICAgICAgdmFyIHggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHkgPSB2WzFdO1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgICAgICAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGgubWluKHYxWzFdLCB2MlsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLm1heCh2MVsxXSwgdjJbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2ZWN0b3IubGVuZ3RoID0gdmVjdG9yLmxlbjtcbiAgICB2ZWN0b3IubGVuZ3RoU3F1YXJlID0gdmVjdG9yLmxlblNxdWFyZTtcbiAgICB2ZWN0b3IuZGlzdCA9IHZlY3Rvci5kaXN0YW5jZTtcbiAgICB2ZWN0b3IuZGlzdFNxdWFyZSA9IHZlY3Rvci5kaXN0YW5jZVNxdWFyZTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gdmVjdG9yO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29yZS92ZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = __webpack_require__(40);\n    var zrUtil = __webpack_require__(0);\n    var PathProxy = __webpack_require__(28);\n    var pathContain = __webpack_require__(193);\n\n    var Pattern = __webpack_require__(76);\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcz9jYjc2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBhdGggZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgcGF0aENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3BhdGgnKTtcblxuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9QYXR0ZXJuJyk7XG4gICAgdmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xuXG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gICAgdmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGhcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXRoKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgfVxuXG4gICAgUGF0aC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGgsXG5cbiAgICAgICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgICAgIF9fZGlydHlQYXRoOiB0cnVlLFxuXG4gICAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKTtcbiAgICAgICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbEdyYWRpZW50ID0gaGFzRmlsbCAmJiAhIShmaWxsLmNvbG9yU3RvcHMpO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZUdyYWRpZW50ID0gaGFzU3Ryb2tlICYmICEhKHN0cm9rZS5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISEoZmlsbC5pbWFnZSk7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlUGF0dGVybiA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuaW1hZ2UpO1xuXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdDtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ3JhZGllbnQgYmVjYXVzZSBib3VuZGluZyByZWN0IG1heSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIHRoZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBJZiBtYXkgaGF2ZSBhZmZlY3QgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGxHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZpbGxQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1N0cm9rZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gc3R5bGUubGluZURhc2g7XG4gICAgICAgICAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcblxuICAgICAgICAgICAgdmFyIGN0eExpbmVEYXNoID0gISFjdHguc2V0TGluZURhc2g7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwYXRoIHN4LCBzeVxuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuXG4gICAgICAgICAgICAvLyBQcm94eSBjb250ZXh0XG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAgICAgICAgIC8vIDEuIFBhdGggaXMgZGlydHlcbiAgICAgICAgICAgIC8vIDIuIFBhdGggbmVlZHMgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lRGFzaCBzdHJva2luZy5cbiAgICAgICAgICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aFxuICAgICAgICAgICAgICAgIHx8IChsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgbGluZSBkYXNoIGJlZm9yZSBidWlsZCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcGF0aCBkaXJ0eSBmbGFnXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHBhdGggYnVpbGRpbmdcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc0ZpbGwgJiYgcGF0aC5maWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc1N0cm9rZSAmJiBwYXRoLnN0cm9rZShjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxpbmVEYXNoXG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdoZW4gYnVuZGxpbmcgcGF0aCwgc29tZSBzaGFwZSBtYXkgZGVjaWRlIGlmIHVzZSBtb3ZlVG8gdG8gYmVnaW4gYSBuZXcgc3VicGF0aCBvciBjbG9zZVBhdGhcbiAgICAgICAgLy8gTGlrZSBpbiBjaXJjbGVcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZUNmZywgaW5CdW5kbGUpIHt9LFxuXG4gICAgICAgIGNyZWF0ZVBhdGhQcm94eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBuZWVkc1VwZGF0ZVJlY3QgPSAhcmVjdDtcbiAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZVJlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBhdGggb24gZGVtYW5kLlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWRzIHVwZGF0ZSByZWN0IHdpdGggc3Ryb2tlIGxpbmVXaWR0aCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gMS4gRWxlbWVudCBjaGFuZ2VzIHNjYWxlIG9yIGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFdpdGhTdHJva2UgPSB0aGlzLl9yZWN0V2l0aFN0cm9rZSB8fCAodGhpcy5fcmVjdFdpdGhTdHJva2UgPSByZWN0LmNsb25lKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KHcsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBsaW5lIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS53aWR0aCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UuaGVpZ2h0ICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueSAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiByZWN0IHdpdGggc3Ryb2tlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RXaXRoU3Ryb2tlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgICAgICAgICAgeSA9IGxvY2FsUG9zWzFdO1xuXG4gICAgICAgICAgICBpZiAocmVjdC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5wYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBNYXRoLm1heChsaW5lV2lkdGgsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aENvbnRhaW4uY29udGFpbihwYXRoRGF0YSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBkaXJ0eVBhdGhcbiAgICAgICAgICovXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoZGlydHlQYXRoKSB7XG4gICAgICAgICAgICBpZiAoZGlydHlQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBtYXJrIGRpcnR5LCBub3QgbWFyayBjbGVhblxuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBkaXJ0eVBhdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICAvLyBVc2VkIGFzIGEgY2xpcHBpbmcgcGF0aFxuICAgICAgICAgICAgaWYgKHRoaXMuX19jbGlwVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NsaXBUYXJnZXQuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3NoYXBlJylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlU2hhcGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBhdHRyS1ZcbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERpc3BsYXlhYmxlLnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcbiAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMaW5lU2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAgICAgICAvLyBmb3Igd2lkdGguXG4gICAgICAgICAgICByZXR1cm4gbSAmJiBhYnMobVswXSAtIDEpID4gMWUtMTAgJiYgYWJzKG1bM10gLSAxKSA+IDFlLTEwXG4gICAgICAgICAgICAgICAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKVxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDmianlsZXkuIDkuKogUGF0aCBlbGVtZW50LCDmr5TlpoLmmJ/lvaLvvIzlnIbnrYnjgIJcbiAgICAgKiBFeHRlbmQgYSBwYXRoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSBQYXRoIHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5pbml0IEluaXRpYWxpemVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnN0eWxlXSBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc2hhcGVdIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXG4gICAgICovXG4gICAgUGF0aC5leHRlbmQgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5leHRlbmRGcm9tKGRlZmF1bHRzLnN0eWxlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHNoYXBlXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFNoYXBlID0gZGVmYXVsdHMuc2hhcGU7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNTaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgISB0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRlZmF1bHRTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7XG5cbiAgICAgICAgLy8gRklYTUUg5LiN6IO9IGV4dGVuZCBwb3NpdGlvbiwgcm90YXRpb24g562J5byV55So5a+56LGhXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIC8vIEV4dGVuZGluZyBwcm90b3R5cGUgdmFsdWVzIGFuZCBtZXRob2RzXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgU3ViLnByb3RvdHlwZVtuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN1YjtcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var clazzUtil = __webpack_require__(12);\n    var env = __webpack_require__(6);\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model 的初始化函数\n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         * 从新的 Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, __webpack_require__(173));\n    mixin(Model, __webpack_require__(170));\n    mixin(Model, __webpack_require__(174));\n    mixin(Model, __webpack_require__(172));\n\n    module.exports = Model;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL01vZGVsLmpzP2YyMDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQiwyQkFBMkI7QUFDOUMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLHlCQUF5QixzQkFBc0I7QUFDL0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9tb2RlbC9Nb2RlbFxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtwYXJlbnRNb2RlbF1cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gW2VjTW9kZWxdXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW9kZWwob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcblxuICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgICAgIC8vIGlmICh0aGlzLmluaXQpIHtcbiAgICAgICAgLy8gICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IE1vZGVsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbCDnmoTliJ3lp4vljJblh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LuO5paw55qEIE9wdGlvbiBtZXJnZVxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlUGFyZW50PWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZG9HZXQoXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb24sXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVBhdGgocGF0aCksXG4gICAgICAgICAgICAgICAgIWlnbm9yZVBhcmVudCAmJiBnZXRQYXJlbnQodGhpcywgcGF0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlUGFyZW50PWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2hhbGxvdzogZnVuY3Rpb24gKGtleSwgaWdub3JlUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG5cbiAgICAgICAgICAgIHZhciB2YWwgPSBvcHRpb24gPT0gbnVsbCA/IG9wdGlvbiA6IG9wdGlvbltrZXldO1xuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gIWlnbm9yZVBhcmVudCAmJiBnZXRQYXJlbnQodGhpcywga2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHBhcmVudE1vZGVsLmdldFNoYWxsb3coa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbcGF0aF1cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3BhcmVudE1vZGVsXVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1vZGVsOiBmdW5jdGlvbiAocGF0aCwgcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBwYXRoID09IG51bGxcbiAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9uXG4gICAgICAgICAgICAgICAgOiBkb0dldCh0aGlzLm9wdGlvbiwgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpKTtcblxuICAgICAgICAgICAgdmFyIHRoaXNQYXJlbnRNb2RlbDtcbiAgICAgICAgICAgIHBhcmVudE1vZGVsID0gcGFyZW50TW9kZWwgfHwgKFxuICAgICAgICAgICAgICAgICh0aGlzUGFyZW50TW9kZWwgPSBnZXRQYXJlbnQodGhpcywgcGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXNQYXJlbnRNb2RlbC5nZXRNb2RlbChwYXRoKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlbChvYmosIHBhcmVudE1vZGVsLCB0aGlzLmVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBtb2RlbCBoYXMgb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLy8gUGVuZGluZ1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFJlYWRPbmx5OiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgY2xhenpVdGlsLnNldFJlYWRPbmx5KHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIElmIHBhdGggaXMgbnVsbC91bmRlZmluZWQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgICAgICAgcGFyc2VQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRQYXJlbnRNZXRob2RcbiAgICAgICAgICogICAgICAgIHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IHBhdGhcbiAgICAgICAgICogICAgICAgIHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICBjdXN0b21pemVHZXRQYXJlbnQ6IGZ1bmN0aW9uIChnZXRQYXJlbnRNZXRob2QpIHtcbiAgICAgICAgICAgIGNsYXp6VXRpbC5zZXQodGhpcywgJ2dldFBhcmVudCcsIGdldFBhcmVudE1ldGhvZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBbmltYXRpb25FbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uLmFuaW1hdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMub3B0aW9uLmFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9HZXQob2JqLCBwYXRoQXJyLCBwYXJlbnRNb2RlbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbXB0eVxuICAgICAgICAgICAgaWYgKCFwYXRoQXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcbiAgICAgICAgICAgIG9iaiA9IChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpID8gb2JqW3BhdGhBcnJbaV1dIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGhBcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLy8gYHBhdGhgIGNhbiBiZSBudWxsL3VuZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGdldFBhcmVudChtb2RlbCwgcGF0aCkge1xuICAgICAgICB2YXIgZ2V0UGFyZW50TWV0aG9kID0gY2xhenpVdGlsLmdldChtb2RlbCwgJ2dldFBhcmVudCcpO1xuICAgICAgICByZXR1cm4gZ2V0UGFyZW50TWV0aG9kID8gZ2V0UGFyZW50TWV0aG9kLmNhbGwobW9kZWwsIHBhdGgpIDogbW9kZWwucGFyZW50TW9kZWw7XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIE1vZGVsLmV4dGVuZC5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoTW9kZWwpO1xuXG4gICAgdmFyIG1peGluID0genJVdGlsLm1peGluO1xuICAgIG1peGluKE1vZGVsLCByZXF1aXJlKCcuL21peGluL2xpbmVTdHlsZScpKTtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9hcmVhU3R5bGUnKSk7XG4gICAgbWl4aW4oTW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vdGV4dFN0eWxlJykpO1xuICAgIG1peGluKE1vZGVsLCByZXF1aXJlKCcuL21peGluL2l0ZW1TdHlsZScpKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvbW9kZWwvTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var numberUtil = __webpack_require__(5);\n    var textContain = __webpack_require__(16);\n\n    var formatUtil = {};\n\n    /**\n     * 每三位默认加,格式化\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvZm9ybWF0LmpzPzM0OTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUksVUFBVSxFQUFFO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQzs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQix1REFBdUQ7QUFDeEU7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3RELDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFLHNDQUFzQyxVQUFVLFdBQVc7QUFDM0QsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XG5cbiAgICB2YXIgZm9ybWF0VXRpbCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICog5q+P5LiJ5L2N6buY6K6k5YqgLOagvOW8j+WMllxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0geFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtYXRVdGlsLmFkZENvbW1hcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICAgICAgcmV0dXJuICctJztcbiAgICAgICAgfVxuICAgICAgICB4ID0gKHggKyAnJykuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHhbMF0ucmVwbGFjZSgvKFxcZHsxLDN9KSg/PSg/OlxcZHszfSkrKD8hXFxkKSkvZywnJDEsJylcbiAgICAgICAgICAgICAgICsgKHgubGVuZ3RoID4gMSA/ICgnLicgKyB4WzFdKSA6ICcnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwcGVyQ2FzZUZpcnN0PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAgICovXG4gICAgZm9ybWF0VXRpbC50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIsIHVwcGVyQ2FzZUZpcnN0KSB7XG4gICAgICAgIHN0ciA9IChzdHIgfHwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihtYXRjaCwgZ3JvdXAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1cHBlckNhc2VGaXJzdCAmJiBzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICAgICAqIGUuZy5cbiAgICAgKiAgMyA9PiBbMywgMywgMywgM11cbiAgICAgKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICAgICAqICBbNCwgMywgMl0gPT4gWzQsIDMsIDIsIDNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mICh2YWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICAgICAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMl0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZUhUTUwgPSBmb3JtYXRVdGlsLmVuY29kZUhUTUwgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc291cmNlKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xuICAgIH07XG5cbiAgICB2YXIgVFBMX1ZBUl9BTElBUyA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZyddO1xuXG4gICAgdmFyIHdyYXBWYXIgPSBmdW5jdGlvbiAodmFyTmFtZSwgc2VyaWVzSWR4KSB7XG4gICAgICAgIHJldHVybiAneycgKyB2YXJOYW1lICsgKHNlcmllc0lkeCA9PSBudWxsID8gJycgOiBzZXJpZXNJZHgpICsgJ30nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBmb3JtYXR0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmNvZGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuZm9ybWF0VHBsID0gZnVuY3Rpb24gKHRwbCwgcGFyYW1zTGlzdCwgZW5jb2RlKSB7XG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkocGFyYW1zTGlzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtc0xpc3QgPSBbcGFyYW1zTGlzdF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcmllc0xlbiA9IHBhcmFtc0xpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoIXNlcmllc0xlbikge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICR2YXJzID0gcGFyYW1zTGlzdFswXS4kdmFycyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFsaWFzID0gVFBMX1ZBUl9BTElBU1tpXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSB3cmFwVmFyKGFsaWFzLCAwKTtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoYWxpYXMpLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgJHZhcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gcGFyYW1zTGlzdFtzZXJpZXNJZHhdWyR2YXJzW2tdXTtcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgd3JhcFZhcihUUExfVkFSX0FMSUFTW2tdLCBzZXJpZXNJZHgpLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRwbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2ltcGxlIFRlbXBsYXRlIGZvcm1hdHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5mb3JtYXRUcGxTaW1wbGUgPSBmdW5jdGlvbiAodHBsLCBwYXJhbSwgZW5jb2RlKSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKHBhcmFtLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgJ3snICsga2V5ICsgJ30nLFxuICAgICAgICAgICAgICAgIGVuY29kZSA/IGVuY29kZUhUTUwodmFsdWUpIDogdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHBsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4dHJhQ3NzVGV4dF1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5nZXRUb29sdGlwTWFya2VyID0gZnVuY3Rpb24gKGNvbG9yLCBleHRyYUNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yXG4gICAgICAgICAgICA/ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1yaWdodDo1cHg7J1xuICAgICAgICAgICAgICAgICsgJ2JvcmRlci1yYWRpdXM6MTBweDt3aWR0aDo5cHg7aGVpZ2h0OjlweDtiYWNrZ3JvdW5kLWNvbG9yOidcbiAgICAgICAgICAgICAgICArIGZvcm1hdFV0aWwuZW5jb2RlSFRNTChjb2xvcikgKyAnOycgKyAoZXh0cmFDc3NUZXh0IHx8ICcnKSArICdcIj48L3NwYW4+J1xuICAgICAgICAgICAgOiAnJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgczJkID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyIDwgMTAgPyAoJzAnICsgc3RyKSA6IHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSVNPIERhdGUgZm9ybWF0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzVVRDPWZhbHNlXSBEZWZhdWx0IGluIGxvY2FsIHRpbWUuXG4gICAgICogICAgICAgICAgIHNlZSBgbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZWBcbiAgICAgKiAgICAgICAgICAgYW5kIGBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlciNwYXJzZURhdGVgLlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuZm9ybWF0VGltZSA9IGZ1bmN0aW9uICh0cGwsIHZhbHVlLCBpc1VUQykge1xuICAgICAgICBpZiAodHBsID09PSAnd2VlaydcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ21vbnRoJ1xuICAgICAgICAgICAgfHwgdHBsID09PSAncXVhcnRlcidcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ2hhbGYteWVhcidcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ3llYXInXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHBsID0gJ01NLWRkXFxueXl5eSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0ZSA9IG51bWJlclV0aWwucGFyc2VEYXRlKHZhbHVlKTtcbiAgICAgICAgdmFyIHV0YyA9IGlzVVRDID8gJ1VUQycgOiAnJztcbiAgICAgICAgdmFyIHkgPSBkYXRlWydnZXQnICsgdXRjICsgJ0Z1bGxZZWFyJ10oKTtcbiAgICAgICAgdmFyIE0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01vbnRoJ10oKSArIDE7XG4gICAgICAgIHZhciBkID0gZGF0ZVsnZ2V0JyArIHV0YyArICdEYXRlJ10oKTtcbiAgICAgICAgdmFyIGggPSBkYXRlWydnZXQnICsgdXRjICsgJ0hvdXJzJ10oKTtcbiAgICAgICAgdmFyIG0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01pbnV0ZXMnXSgpO1xuICAgICAgICB2YXIgcyA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnU2Vjb25kcyddKCk7XG5cbiAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UoJ01NJywgczJkKE0pKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKCd5eXl5JywgeSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCd5eScsIHkgJSAxMDApXG4gICAgICAgICAgICAucmVwbGFjZSgnZGQnLCBzMmQoZCkpXG4gICAgICAgICAgICAucmVwbGFjZSgnZCcsIGQpXG4gICAgICAgICAgICAucmVwbGFjZSgnaGgnLCBzMmQoaCkpXG4gICAgICAgICAgICAucmVwbGFjZSgnaCcsIGgpXG4gICAgICAgICAgICAucmVwbGFjZSgnbW0nLCBzMmQobSkpXG4gICAgICAgICAgICAucmVwbGFjZSgnbScsIG0pXG4gICAgICAgICAgICAucmVwbGFjZSgnc3MnLCBzMmQocykpXG4gICAgICAgICAgICAucmVwbGFjZSgncycsIHMpO1xuXG4gICAgICAgIHJldHVybiB0cGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhcGl0YWwgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuY2FwaXRhbEZpcnN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyID8gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKSA6IHN0cjtcbiAgICB9O1xuXG4gICAgZm9ybWF0VXRpbC50cnVuY2F0ZVRleHQgPSB0ZXh0Q29udGFpbi50cnVuY2F0ZVRleHQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZvcm1hdFV0aWw7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi91dGlsL2Zvcm1hdC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = __webpack_require__(7);\n    var matrix = __webpack_require__(20);\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzP2M5OWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx3Q0FBd0M7QUFDdkQsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIEJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgICAgICAgICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci54ICsgb3RoZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICApIC0geDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueSArIG90aGVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApIC0geTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqIEBtZXRob2RzXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJiID0gW107XG4gICAgICAgICAgICB2YXIgbGIgPSBbXTtcbiAgICAgICAgICAgIHZhciBydCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgICAgICAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXgwID0gYS54O1xuICAgICAgICAgICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgYXkwID0gYS55O1xuICAgICAgICAgICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgYngwID0gYi54O1xuICAgICAgICAgICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgICAgICAgICB2YXIgYnkwID0gYi55O1xuICAgICAgICAgICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gISAoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHggPj0gcmVjdC54XG4gICAgICAgICAgICAgICAgJiYgeCA8PSAocmVjdC54ICsgcmVjdC53aWR0aClcbiAgICAgICAgICAgICAgICAmJiB5ID49IHJlY3QueVxuICAgICAgICAgICAgICAgICYmIHkgPD0gKHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLnggPSBvdGhlci54O1xuICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBCb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb3VuZGluZ1JlY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvY2xhenouanM/NWQ1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGNsYXp6ID0ge307XG5cbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19FQ19fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xuICAgIHZhciBNRU1CRVJfUFJJRklYID0gJ1xcMGVjX1xcMCc7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHByaXZhdGUgY2xhc3MgbWVtYmVyLlxuICAgICAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBob3N0W25hbWVdID0gdmFsdWU7YCAoY2FuIGJlIHJpZ2h0LXZhbHVlKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5zZXQgPSBmdW5jdGlvbiAoaG9zdCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXSA9IHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZSBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdFtuYW1lXTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6LmdldCA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9yIGhpZGRlbiBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6Lmhhc093biA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0Lmhhc093blByb3BlcnR5KE1FTUJFUl9QUklGSVggKyBuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWNlLCBwYXJzZUNsYXNzVHlwZSgnJykgc2hvdWxkIHJldHVybnMge21haW46ICcnLCBzdWI6ICcnfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBjbGF6ei5wYXJzZUNsYXNzVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIHZhciByZXQgPSB7bWFpbjogJycsIHN1YjogJyd9O1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGUuc3BsaXQoVFlQRV9ERUxJTUlURVIpO1xuICAgICAgICAgICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xuICAgICAgICAgICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgIC9eW2EtekEtWjAtOV9dKyhbLl1bYS16QS1aMC05X10rKT8kLy50ZXN0KGNvbXBvbmVudFR5cGUpLFxuICAgICAgICAgICAgJ2NvbXBvbmVudFR5cGUgXCInICsgY29tcG9uZW50VHlwZSArICdcIiBpbGxlZ2FsJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5lbmFibGVDbGFzc0V4dGVuZCA9IGZ1bmN0aW9uIChSb290Q2xhc3MsIG1hbmRhdG9yeU1ldGhvZHMpIHtcblxuICAgICAgICBSb290Q2xhc3MuJGNvbnN0cnVjdG9yID0gUm9vdENsYXNzO1xuICAgICAgICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG5cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gobWFuZGF0b3J5TWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3RvW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTWV0aG9kIGAnICsgbWV0aG9kICsgJ2Agc2hvdWxkIGJlIGltcGxlbWVudGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgKHByb3RvLnR5cGUgPyAnIGluICcgKyBwcm90by50eXBlIDogJycpICsgJy4nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdXBlckNsYXNzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvdG8uJGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLiRjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHpyVXRpbC5leHRlbmQoRXh0ZW5kZWRDbGFzcy5wcm90b3R5cGUsIHByb3RvKTtcblxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDYWxsID0gc3VwZXJDYWxsO1xuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcbiAgICAgICAgICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG5cbiAgICAgICAgICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBzdXBlckNhbGwgc2hvdWxkIGhhdmUgY2xhc3MgaW5mbywgd2hpY2ggY2FuIG5vdCBiZSBmZXRjaCBmcm9tICd0aGlzJy5cbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XG4gICAgLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXG4gICAgLy8gY2xhc3MgQiBpbmhlcml0cyBjbGFzcyBBLCBvdmVycmlkZXMgbWV0aG9kIGYsIGYgY2FsbCBzdXBlckFwcGx5KCdmJyksXG4gICAgLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxuICAgIC8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxuICAgIGZ1bmN0aW9uIHN1cGVyQ2FsbChjb250ZXh0LCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZF1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhenouZW5hYmxlQ2xhc3NNYW5hZ2VtZW50ID0gZnVuY3Rpb24gKGVudGl0eSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlLFxuICAgICAgICAgKiB2YWx1ZTpcbiAgICAgICAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcbiAgICAgICAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB7fTtcblxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjaGVja0NsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbXBvbmVudFR5cGUubWFpbiArICcgZXhpc3RzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJbY29tcG9uZW50VHlwZS5zdWJdID0gQ2xheno7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENsYXp6O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRNYWluVHlwZSwgc3ViVHlwZSwgdGhyb3dXaGVuTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50TWFpblR5cGVdO1xuXG4gICAgICAgICAgICBpZiAoQ2xhenogJiYgQ2xhenpbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgICAgICAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgIXN1YlR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAndHlwZSBzaG91bGQgYmUgc3BlY2lmaWVkLidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ0NvbXBvbmVudCAnICsgY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAoc3ViVHlwZSB8fCAnJykgKyAnIG5vdCBleGlzdHMuIExvYWQgaXQgZmlyc3QuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcbiAgICAgICAgfTtcblxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuXG4gICAgICAgICAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlICE9PSBJU19DT05UQUlORVIgJiYgcmVzdWx0LnB1c2gobyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cbiAgICAgICAgICovXG4gICAgICAgIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IFtdO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RvcmFnZSwgZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG1haW5UeXBlXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBlbnRpdHkuaGFzU3ViVHlwZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl07XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5LnBhcnNlQ2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XG4gICAgICAgICAgICAgICAgY29udGFpbmVyW0lTX0NPTlRBSU5FUl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW5kID0gZW50aXR5LmV4dGVuZDtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBvcmlnaW5hbEV4dGVuZC5jYWxsKHRoaXMsIHByb3RvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsYXp6LnNldFJlYWRPbmx5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcGVydGllcykge1xuICAgICAgICAvLyBGSVhNRSBJdCBzZWVtcyBicm9rZW4gaW4gSUU4IHNpbXVsYXRpb24gb2YgSUUxMVxuICAgICAgICAvLyBpZiAoIXpyVXRpbC5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICAgIC8vICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyAhPSBudWxsID8gW3Byb3BlcnRpZXNdIDogW107XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8genJVdGlsLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgLy8gICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcblxuICAgICAgICAvLyAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAgIC8vICAgICAgICAgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICAvLyAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICAvLyAgICAgICAgIH0pO1xuICAgICAgICAvLyAgICAgenJVdGlsLmlzQXJyYXkob2JqW3Byb3BdKVxuICAgICAgICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemVcbiAgICAgICAgLy8gICAgICAgICAmJiBPYmplY3QuZnJlZXplKG9ialtwcm9wXSk7XG4gICAgICAgIC8vIH0pO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNsYXp6O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvY2xhenouanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = __webpack_require__(9);\n    var zrUtil = __webpack_require__(0);\n    var arrayPush = Array.prototype.push;\n    var componentUtil = __webpack_require__(37);\n    var clazzUtil = __webpack_require__(12);\n    var layout = __webpack_require__(15);\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, __webpack_require__(171));\n\n    module.exports = ComponentModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL0NvbXBvbmVudC5qcz9mMWI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21wb25lbnQgbW9kZWxcbiAqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gKi9cblxuXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXJyYXlQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG4gICAgdmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvbmVudCcpO1xuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHBhcmVudE1vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gZWNNb2RlbFxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG1haW5UeXBlOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJUeXBlOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnRJbmRleDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wdGlvbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBlY01vZGVsOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGVcbiAgICAgICAgICogdmFsdWU6ICBDb21wb25lbnQgbW9kZWwgbGlzdCwgY2FuIG5vdCBiZSBudWxsLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD4+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGRlcGVuZGVudE1vZGVsczogW10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdWlkOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAgICAgICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXRNb2RlOiBudWxsLFxuXG4gICAgICAgICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgICAgICAgICBNb2RlbC5jYWxsKHRoaXMsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcblxuICAgICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgICAgICAgICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZVxuICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgIHZhciB0aGVtZU1vZGVsID0gZWNNb2RlbC5nZXRUaGVtZSgpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQodGhpcy5tYWluVHlwZSkpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuXG4gICAgICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIGV4dHJhT3B0KSB7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgb3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBIb29rZXIgYWZ0ZXIgaW5pdCBvciBtZXJnZU9wdGlvblxuICAgICAgICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAobmV3Q3B0T3B0aW9uLCBpc0luaXQpIHt9LFxuXG4gICAgICAgIGdldERlZmF1bHRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghY2xhenpVdGlsLmhhc093bih0aGlzLCAnX19kZWZhdWx0T3B0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBDbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgd2hpbGUgKENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgb3B0ICYmIG9wdExpc3QucHVzaChvcHQpO1xuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb24sIG9wdExpc3RbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGF6elV0aWwuc2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nLCBkZWZhdWx0T3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGF6elV0aWwuZ2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSZWZlcnJpbmdDb21wb25lbnRzOiBmdW5jdGlvbiAobWFpblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0luZGV4JywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0lkJywgdHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIFJlc2V0IENvbXBvbmVudE1vZGVsLmV4dGVuZCwgYWRkIHByZUNvbnN0cnVjdC5cbiAgICAvLyBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoXG4gICAgLy8gICAgIENvbXBvbmVudE1vZGVsLFxuICAgIC8vICAgICBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICAvLyAgICAgICAgIC8vIFNldCBkZXBlbmRlbnRNb2RlbHMsIGNvbXBvbmVudEluZGV4LCBuYW1lLCBpZCwgbWFpblR5cGUsIHN1YlR5cGUuXG4gICAgLy8gICAgICAgICB6clV0aWwuZXh0ZW5kKHRoaXMsIGV4dHJhT3B0KTtcblxuICAgIC8vICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcblxuICAgIC8vICAgICAgICAgLy8gdGhpcy5zZXRSZWFkT25seShbXG4gICAgLy8gICAgICAgICAvLyAgICAgJ3R5cGUnLCAnaWQnLCAndWlkJywgJ25hbWUnLCAnbWFpblR5cGUnLCAnc3ViVHlwZScsXG4gICAgLy8gICAgICAgICAvLyAgICAgJ2RlcGVuZGVudE1vZGVscycsICdjb21wb25lbnRJbmRleCdcbiAgICAvLyAgICAgICAgIC8vIF0pO1xuICAgIC8vICAgICB9XG4gICAgLy8gKTtcblxuICAgIC8vIEFkZCBjYXBhYmlsaXR5IG9mIHJlZ2lzdGVyQ2xhc3MsIGdldENsYXNzLCBoYXNDbGFzcywgcmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyIGFuZCBzbyBvbi5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KFxuICAgICAgICBDb21wb25lbnRNb2RlbCwge3JlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZX1cbiAgICApO1xuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlcihDb21wb25lbnRNb2RlbCk7XG5cbiAgICAvLyBBZGQgY2FwYWJpbGl0eSBvZiBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbC5cbiAgICBjb21wb25lbnRVdGlsLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKENvbXBvbmVudE1vZGVsLCBnZXREZXBlbmRlbmNpZXMpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgdmFyIGRlcHMgPSBbXTtcbiAgICAgICAgenJVdGlsLmVhY2goQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUoY29tcG9uZW50VHlwZSksIGZ1bmN0aW9uIChDbGF6eikge1xuICAgICAgICAgICAgYXJyYXlQdXNoLmFwcGx5KGRlcHMsIENsYXp6LnByb3RvdHlwZS5kZXBlbmRlbmNpZXMgfHwgW10pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRW5zdXJlIG1haW4gdHlwZVxuICAgICAgICByZXR1cm4genJVdGlsLm1hcChkZXBzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXp6VXRpbC5wYXJzZUNsYXNzVHlwZSh0eXBlKS5tYWluO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB6clV0aWwubWl4aW4oQ29tcG9uZW50TW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vYm94TGF5b3V0JykpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9tb2RlbC9Db21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var features = {};\n\n    module.exports = {\n        register: function (name, ctor) {\n            features[name] = ctor;\n        },\n\n        get: function (name) {\n            return features[name];\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmVNYW5hZ2VyLmpzP2QwMjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBmZWF0dXJlcyA9IHt9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAobmFtZSwgY3Rvcikge1xuICAgICAgICAgICAgZmVhdHVyZXNbbmFtZV0gPSBjdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Layout helpers for each component positioning\n\n\n    var zrUtil = __webpack_require__(0);\n    var BoundingRect = __webpack_require__(11);\n    var numberUtil = __webpack_require__(5);\n    var formatUtil = __webpack_require__(10);\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvbGF5b3V0LmpzPzk0N2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLE9BQU8sRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxHQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU8scUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0IsY0FBYztBQUNsRTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHVCQUF1QjtBQUN4RCxpQ0FBaUMsV0FBVyxpQkFBaUIsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIExheW91dCBoZWxwZXJzIGZvciBlYWNoIGNvbXBvbmVudCBwb3NpdGlvbmluZ1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuL251bWJlcicpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIHZhciBsYXlvdXQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB2YXIgTE9DQVRJT05fUEFSQU1TID0gbGF5b3V0LkxPQ0FUSU9OX1BBUkFNUyA9IFtcbiAgICAgICAgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB2YXIgSFZfTkFNRVMgPSBsYXlvdXQuSFZfTkFNRVMgPSBbXG4gICAgICAgIFsnd2lkdGgnLCAnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBbJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJ11cbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gYm94TGF5b3V0KG9yaWVudCwgZ3JvdXAsIGdhcCwgbWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgaWYgKG1heFdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heFdpZHRoID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudExpbmVNYXhTaXplID0gMDtcbiAgICAgICAgZ3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBjaGlsZC5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gZ3JvdXAuY2hpbGRBdChpZHggKyAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRSZWN0ID0gbmV4dENoaWxkICYmIG5leHRDaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBuZXh0WDtcbiAgICAgICAgICAgIHZhciBuZXh0WTtcbiAgICAgICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/ICgtbmV4dENoaWxkUmVjdC54ICsgcmVjdC54KSA6IDApO1xuICAgICAgICAgICAgICAgIG5leHRYID0geCArIG1vdmVYO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heFdpZHRoIG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcbiAgICAgICAgICAgICAgICBpZiAobmV4dFggPiBtYXhXaWR0aCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZXh0WCA9IG1vdmVYO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gKC1uZXh0Q2hpbGRSZWN0LnkgKyByZWN0LnkpIDogMCk7XG4gICAgICAgICAgICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCB3aGVuIHdpZHRoIGV4Y2VlZHMgbWF4SGVpZ2h0IG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcbiAgICAgICAgICAgICAgICBpZiAobmV4dFkgPiBtYXhIZWlnaHQgfHwgY2hpbGQubmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5leHRZID0gbW92ZVk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uWzBdID0geDtcbiAgICAgICAgICAgIHBvc2l0aW9uWzFdID0geTtcblxuICAgICAgICAgICAgb3JpZW50ID09PSAnaG9yaXpvbnRhbCdcbiAgICAgICAgICAgICAgICA/ICh4ID0gbmV4dFggKyBnYXApXG4gICAgICAgICAgICAgICAgOiAoeSA9IG5leHRZICsgZ2FwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVkJveCBvciBIQm94IGxheW91dGluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQuYm94ID0gYm94TGF5b3V0O1xuXG4gICAgLyoqXG4gICAgICogVkJveCBsYXlvdXRpbmdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQudmJveCA9IHpyVXRpbC5jdXJyeShib3hMYXlvdXQsICd2ZXJ0aWNhbCcpO1xuXG4gICAgLyoqXG4gICAgICogSEJveCBsYXlvdXRpbmdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQuaGJveCA9IHpyVXRpbC5jdXJyeShib3hMYXlvdXQsICdob3Jpem9udGFsJyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB4IG9yIHgyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ2NlbnRlcicgJ2xlZnQnICdyaWdodCcsXG4gICAgICogdGhlIHdpZHRoIHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gICAgICogSWYgeSBvciB5MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdtaWRkbGUnICd0b3AnICdib3R0b20nLFxuICAgICAqIHRoZSBoZWlnaHQgd291bGQgYmUgYXMgbG9uZyBhcyBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueV1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueDJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnkyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHt3aWR0aCwgaGVpZ2h0fVxuICAgICAqL1xuICAgIGxheW91dC5nZXRBdmFpbGFibGVTaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luKSB7XG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lclJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcblxuICAgICAgICB2YXIgeCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgeSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueSwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdmFyIHgyID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54MiwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgeTIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnkyLCBjb250YWluZXJIZWlnaHQpO1xuXG4gICAgICAgIChpc05hTih4KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby54KSkpICYmICh4ID0gMCk7XG4gICAgICAgIChpc05hTih4MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueDIpKSkgJiYgKHgyID0gY29udGFpbmVyV2lkdGgpO1xuICAgICAgICAoaXNOYU4oeSkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueSkpKSAmJiAoeSA9IDApO1xuICAgICAgICAoaXNOYU4oeTIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkyKSkpICYmICh5MiA9IGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgbWFyZ2luID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShtYXJnaW4gfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCh4MiAtIHggLSBtYXJnaW5bMV0gLSBtYXJnaW5bM10sIDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCh5MiAtIHkgLSBtYXJnaW5bMF0gLSBtYXJnaW5bMl0sIDApXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHBvc2l0aW9uIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmxlZnRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmJvdHRvbV1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYXNwZWN0XSBBc3BlY3QgaXMgd2lkdGggLyBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW21hcmdpbl1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAqL1xuICAgIGxheW91dC5nZXRMYXlvdXRSZWN0ID0gZnVuY3Rpb24gKFxuICAgICAgICBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpblxuICAgICkge1xuICAgICAgICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcblxuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmxlZnQsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdmFyIHRvcCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8udG9wLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnJpZ2h0LCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHZhciBib3R0b20gPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmJvdHRvbSwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby53aWR0aCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5oZWlnaHQsIGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbWFyZ2luWzJdICsgbWFyZ2luWzBdO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IG1hcmdpblsxXSArIG1hcmdpblszXTtcbiAgICAgICAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7XG5cbiAgICAgICAgLy8gSWYgd2lkdGggaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIHdpZHRoIGZyb20gbGVmdCBhbmQgcmlnaHRcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAtIGJvdHRvbSAtIHZlcnRpY2FsTWFyZ2luIC0gdG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2lkdGggYW5kIGhlaWdodCBhcmUgbm90IGdpdmVuXG4gICAgICAgIC8vIDEuIEdyYXBoIHNob3VsZCBub3QgZXhjZWVkcyB0aGUgY29udGFpbmVyXG4gICAgICAgIC8vIDIuIEFzcGVjdCBtdXN0IGJlIGtlZXBlZFxuICAgICAgICAvLyAzLiBHcmFwaCBzaG91bGQgdGFrZSB0aGUgc3BhY2UgYXMgbW9yZSBhcyBwb3NzaWJsZVxuICAgICAgICBpZiAoaXNOYU4od2lkdGgpICYmIGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggKiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgKiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvciBoZWlnaHQgd2l0aCBnaXZlbiBhc3BlY3RcbiAgICAgICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGFzcGVjdCAqIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsZWZ0IGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBsZWZ0IGZyb20gcmlnaHQgYW5kIHdpZHRoXG4gICAgICAgIGlmIChpc05hTihsZWZ0KSkge1xuICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSB3aWR0aCAtIGhvcml6b250YWxNYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKHRvcCkpIHtcbiAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGJvdHRvbSAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxpZ24gbGVmdCBhbmQgdG9wXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAvIDIgLSB3aWR0aCAvIDIgLSBtYXJnaW5bM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLnRvcCB8fCBwb3NpdGlvbkluZm8uYm90dG9tKSB7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMiAtIG1hcmdpblswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC0gaGVpZ2h0IC0gdmVydGljYWxNYXJnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHdyb25nIGFuZCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgYXJlIGNhbGN1bGF0ZWQgYXMgTmFOXG4gICAgICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IHRvcCB8fCAwO1xuICAgICAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBXaWR0aCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCB3aWR0aFxuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIGxlZnQgLSAocmlnaHQgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAtIHRvcCAtIChib3R0b20gfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobGVmdCArIG1hcmdpblszXSwgdG9wICsgbWFyZ2luWzBdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIGEgenIgZWxlbWVudCBpbiB2aWV3cG9ydFxuICAgICAqICBHcm91cCBwb3NpdGlvbiBpcyBzcGVjaWZpZWQgYnkgZWl0aGVyXG4gICAgICogIHtsZWZ0LCB0b3B9LCB7cmlnaHQsIGJvdHRvbX1cbiAgICAgKiAgSWYgYWxsIHByb3BlcnRpZXMgZXhpc3RzLCByaWdodCBhbmQgYm90dG9tIHdpbGwgYmUgaWdvbnJlZC5cbiAgICAgKlxuICAgICAqIExvZ2ljOlxuICAgICAqICAgICAxLiBTY2FsZSAoYWdhaW5zdCBvcmlnaW4gcG9pbnQgaW4gcGFyZW50IGNvb3JkKVxuICAgICAqICAgICAyLiBSb3RhdGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAgICAgKiAgICAgMy4gVHJhc2xhdGUgKHdpdGggZWwucG9zaXRpb24gYnkgdGhpcyBtZXRob2QpXG4gICAgICogU28gdGhpcyBtZXRob2Qgb25seSBmaXhlcyB0aGUgbGFzdCBzdGVwICdUcmFzbGF0ZScsIHdoaWNoIGRvZXMgbm90IGFmZmVjdFxuICAgICAqIHNjYWxpbmcgYW5kIHJvdGF0aW5nLlxuICAgICAqXG4gICAgICogSWYgYmUgY2FsbGVkIHJlcGVhdGx5IHdpdGggdGhlIHNhbWUgaW5wdXQgZWwsIHRoZSBzYW1lIHJlc3VsdCB3aWxsIGJlIGdvdHRlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgU2hvdWxkIGhhdmUgYGdldEJvdW5kaW5nUmVjdGAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ubGVmdF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8udG9wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5yaWdodF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYm90dG9tXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3B0Lmh2PVsxLDFdXSBPbmx5IGhvcml6b250YWwgb3Igb25seSB2ZXJ0aWNhbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3B0LmJvdW5kaW5nTW9kZT0nYWxsJ11cbiAgICAgKiAgICAgICAgU3BlY2lmeSBob3cgdG8gY2FsY3VsYXRlIGJvdW5kaW5nUmVjdCB3aGVuIGxvY2F0aW5nLlxuICAgICAqICAgICAgICAnYWxsJzogUG9zaXRpb24gdGhlIGJvdW5kaW5nUmVjdCB0aGF0IGlzIHRyYW5zZm9ybWVkIGFuZCB1aW9uZWRcbiAgICAgKiAgICAgICAgICAgICAgIGJvdGggaXRzZWxmIGFuZCBpdHMgZGVzY2VuZGFudHMuXG4gICAgICogICAgICAgICAgICAgICBUaGlzIG1vZGUgc2ltcGxpZXMgY29uZmluZSB0aGUgZWxlbWVudHMgaW4gdGhlIGJvdW5kaW5nXG4gICAgICogICAgICAgICAgICAgICBvZiB0aGVpciBjb250YWluZXIgKGUuZy4sIHVzaW5nICdyaWdodDogMCcpLlxuICAgICAqICAgICAgICAncmF3JzogUG9zaXRpb24gdGhlIGJvdW5kaW5nUmVjdCB0aGF0IGlzIG5vdCB0cmFuc2Zvcm1lZCBhbmQgb25seSBpdHNlbGYuXG4gICAgICogICAgICAgICAgICAgICBUaGlzIG1vZGUgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgYSBlbGVtZW50IGNhbiBvdmVyZmxvdyBpdHNcbiAgICAgKiAgICAgICAgICAgICAgIGNvbnRhaW5lci4gKENvbnNpZGVyIGEgcm90YXRlZCBjaXJjbGUgbmVlZHMgdG8gYmUgbG9jYXRlZCBpbiBhIGNvcm5lci4pXG4gICAgICogICAgICAgICAgICAgICBJbiB0aGlzIG1vZGUgcG9zaXRpb25JbmZvLndpZHRoL2hlaWdodCBjYW4gb25seSBiZSBudW1iZXIuXG4gICAgICovXG4gICAgbGF5b3V0LnBvc2l0aW9uRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgcG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4sIG9wdCkge1xuICAgICAgICB2YXIgaCA9ICFvcHQgfHwgIW9wdC5odiB8fCBvcHQuaHZbMF07XG4gICAgICAgIHZhciB2ID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlsxXTtcbiAgICAgICAgdmFyIGJvdW5kaW5nTW9kZSA9IG9wdCAmJiBvcHQuYm91bmRpbmdNb2RlIHx8ICdhbGwnO1xuXG4gICAgICAgIGlmICghaCAmJiAhdikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3Q7XG4gICAgICAgIGlmIChib3VuZGluZ01vZGUgPT09ICdyYXcnKSB7XG4gICAgICAgICAgICByZWN0ID0gZWwudHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgICAgID8gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCArcG9zaXRpb25JbmZvLndpZHRoIHx8IDAsICtwb3NpdGlvbkluZm8uaGVpZ2h0IHx8IDApXG4gICAgICAgICAgICAgICAgOiBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIGlmIChlbC5uZWVkTG9jYWxUcmFuc2Zvcm0oKSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIC8vIE5vdGljZTogcmF3IHJlY3QgbWF5IGJlIGlubmVyIG9iamVjdCBvZiBlbCxcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb25JbmZvID0gbGF5b3V0LmdldExheW91dFJlY3QoXG4gICAgICAgICAgICB6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAge3dpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0fSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkluZm9cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjb250YWluZXJSZWN0LFxuICAgICAgICAgICAgbWFyZ2luXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQmVjYXVzZSAndHJhbmxhdGUnIGlzIHRoZSBsYXN0IHN0ZXAgaW4gdHJhbnNmb3JtXG4gICAgICAgIC8vIChzZWUgenJlbmRlci9jb3JlL1RyYW5zZm9ybWFibGUjZ2V0TG9jYWxUcmFuc2Zyb20pLFxuICAgICAgICAvLyB3ZSBjYW4ganVzdCBvbmx5IG1vZGlmeSBlbC5wb3NpdGlvbiB0byBnZXQgZmluYWwgcmVzdWx0LlxuICAgICAgICB2YXIgZWxQb3MgPSBlbC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGR4ID0gaCA/IHBvc2l0aW9uSW5mby54IC0gcmVjdC54IDogMDtcbiAgICAgICAgdmFyIGR5ID0gdiA/IHBvc2l0aW9uSW5mby55IC0gcmVjdC55IDogMDtcblxuICAgICAgICBlbC5hdHRyKCdwb3NpdGlvbicsIGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycgPyBbZHgsIGR5XSA6IFtlbFBvc1swXSArIGR4LCBlbFBvc1sxXSArIGR5XSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gQ29udGFpbnMgc29tZSBvZiB0aGUgcHJvcGVydGllcyBpbiBIVl9OQU1FUy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaHZJZHggMDogaG9yaXpvbnRhbDsgMTogdmVydGljYWwuXG4gICAgICovXG4gICAgbGF5b3V0LnNpemVDYWxjdWxhYmxlID0gZnVuY3Rpb24gKG9wdGlvbiwgaHZJZHgpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbltIVl9OQU1FU1todklkeF1bMF1dICE9IG51bGxcbiAgICAgICAgICAgIHx8IChvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzFdXSAhPSBudWxsICYmIG9wdGlvbltIVl9OQU1FU1todklkeF1bMl1dICE9IG51bGwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25zaWRlciBDYXNlOlxuICAgICAqIFdoZW4gZGVmdWxhdCBvcHRpb24gaGFzIHtsZWZ0OiAwLCB3aWR0aDogMTAwfSwgYW5kIHdlIHNldCB7cmlnaHQ6IDB9XG4gICAgICogdGhyb3VnaCBzZXRPcHRpb24gb3IgbWVkaWEgcXVlcnksIHVzaW5nIG5vcm1hbCB6clV0aWwubWVyZ2Ugd2lsbCBjYXVzZVxuICAgICAqIHtyaWdodDogMH0gZG9lcyBub3QgdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gICAgICogICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG4gICAgICogICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGlucHV0UG9zaXRpb25QYXJhbXMpO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgICAqICAgICAgICAgbmV3T3B0aW9uICYmIHpyVXRpbC5tZXJnZSh0aGlzT3B0aW9uLCBuZXdPcHRpb24sIHRydWUpO1xuICAgICAqICAgICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0odGhpc09wdGlvbiwgbmV3T3B0aW9uKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldE9wdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRdXG4gICAgICogQHBhcmFtIHtib29sZWFufEFycmF5Ljxib29sZWFuPn0gW29wdC5pZ25vcmVTaXplPWZhbHNlXSBTb21lIGNvbXBvbmVudCBtdXN0IGhhcyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtID0gZnVuY3Rpb24gKHRhcmdldE9wdGlvbiwgbmV3T3B0aW9uLCBvcHQpIHtcbiAgICAgICAgIXpyVXRpbC5pc09iamVjdChvcHQpICYmIChvcHQgPSB7fSk7XG5cbiAgICAgICAgdmFyIGlnbm9yZVNpemUgPSBvcHQuaWdub3JlU2l6ZTtcbiAgICAgICAgIXpyVXRpbC5pc0FycmF5KGlnbm9yZVNpemUpICYmIChpZ25vcmVTaXplID0gW2lnbm9yZVNpemUsIGlnbm9yZVNpemVdKTtcblxuICAgICAgICB2YXIgaFJlc3VsdCA9IG1lcmdlKEhWX05BTUVTWzBdLCAwKTtcbiAgICAgICAgdmFyIHZSZXN1bHQgPSBtZXJnZShIVl9OQU1FU1sxXSwgMSk7XG5cbiAgICAgICAgY29weShIVl9OQU1FU1swXSwgdGFyZ2V0T3B0aW9uLCBoUmVzdWx0KTtcbiAgICAgICAgY29weShIVl9OQU1FU1sxXSwgdGFyZ2V0T3B0aW9uLCB2UmVzdWx0KTtcblxuICAgICAgICBmdW5jdGlvbiBtZXJnZShuYW1lcywgaHZJZHgpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtZXJnZWRWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBlbm91Z2hQYXJhbU51bWJlciA9IDI7XG5cbiAgICAgICAgICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGNhc2U6IG5ld09wdGlvbi53aWR0aCBpcyBudWxsLCB3aGljaCBpc1xuICAgICAgICAgICAgICAgIC8vIHNldCBieSB1c2VyIGZvciByZW1vdmluZyB3aWR0aCBzZXR0aW5nLlxuICAgICAgICAgICAgICAgIGhhc1Byb3AobmV3T3B0aW9uLCBuYW1lKSAmJiAobmV3UGFyYW1zW25hbWVdID0gbWVyZ2VkW25hbWVdID0gbmV3T3B0aW9uW25hbWVdKTtcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShuZXdQYXJhbXMsIG5hbWUpICYmIG5ld1ZhbHVlQ291bnQrKztcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShtZXJnZWQsIG5hbWUpICYmIG1lcmdlZFZhbHVlQ291bnQrKztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaWdub3JlU2l6ZVtodklkeF0pIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IG9uZSBvZiBsZWZ0L3JpZ2h0IGlzIHByZW1pdHRlZCB0byBleGlzdC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzVmFsdWUobmV3T3B0aW9uLCBuYW1lc1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW25hbWVzWzJdXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFtuYW1lc1sxXV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYXNlOiBuZXdPcHRpb246IHt3aWR0aDogLi4uLCByaWdodDogLi4ufSxcbiAgICAgICAgICAgIC8vIG9yIHRhcmdldE9wdGlvbjoge3JpZ2h0OiAuLi59IGFuZCBuZXdPcHRpb246IHt3aWR0aDogLi4ufSxcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgICAgICAgICAgLy8gbGl0dGxlIHRoYW4gZW5vdWdoUGFyYW1OdW1iZXIuXG4gICAgICAgICAgICBpZiAobWVyZ2VkVmFsdWVDb3VudCA9PT0gZW5vdWdoUGFyYW1OdW1iZXIgfHwgIW5ld1ZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgICAgICAgICAvLyBUaGFuIHdlIGNhbiBtYWtlIHN1cmUgdXNlciBvbmx5IHdhbnQgdGhvc2UgdHdvLCBhbmQgaWdub3JlXG4gICAgICAgICAgICAvLyBhbGwgb3JpZ2luIHBhcmFtcyBpbiB0YXJnZXRPcHRpb24uXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZUNvdW50ID49IGVub3VnaFBhcmFtTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENob3NlIGFub3RoZXIgcGFyYW0gZnJvbSB0YXJnZXRPcHRpb24gYnkgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AobmV3UGFyYW1zLCBuYW1lKSAmJiBoYXNQcm9wKHRhcmdldE9wdGlvbiwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtc1tuYW1lXSA9IHRhcmdldE9wdGlvbltuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhc1ZhbHVlKG9iaiwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtuYW1lXSAhPSBudWxsICYmIG9ialtuYW1lXSAhPT0gJ2F1dG8nO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29weShuYW1lcywgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnIGZyb20gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJlc3VsdCBjb250YWlucyB0aG9zZSBwcm9wcy5cbiAgICAgKi9cbiAgICBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbGF5b3V0LmNvcHlMYXlvdXRQYXJhbXMoe30sIHNvdXJjZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXN1bHQgY29udGFpbnMgdGhvc2UgcHJvcHMuXG4gICAgICovXG4gICAgbGF5b3V0LmNvcHlMYXlvdXRQYXJhbXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgc291cmNlICYmIHRhcmdldCAmJiBlYWNoKExPQ0FUSU9OX1BBUkFNUywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAodGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbGF5b3V0O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvdXRpbC9sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = __webpack_require__(0);\n    var BoundingRect = __webpack_require__(11);\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var lineHeight = textRect.lineHeight;\n        var halfHeight = height / 2 - textHeight / 2 + lineHeight;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight - lineHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance + lineHeight;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance + lineHeight;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance + lineHeight;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'alphabetic'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcz82MDhiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgIHZhciB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgIHZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciByZXRyaWV2ZSA9IHV0aWwucmV0cmlldmU7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0V2lkdGgodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRleHQgKyAnOicgKyB0ZXh0Rm9udDtcbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1lYXN1cmVUZXh0IOWPr+S7peiiq+imhuebluS7peWFvOWuueS4jeaUr+aMgSBDYW52YXMg55qE546v5aKDXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgdGV4dEZvbnQpLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHRSZWN0KHRleHQsIHRleHRGb250LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgICAgICB2YXIgdGV4dExpbmVMZW4gPSAoKHRleHQgfHwgJycpICsgJycpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUg6auY5bqm6K6h566X5q+U6L6D57KX5pq0XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0TGluZUxlbiAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBUZXh0IGhhcyBhIHNwZWNpYWwgbGluZSBoZWlnaHQgcHJvcGVydHlcbiAgICAgICAgcmVjdC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAvLyBjYXNlICdsZWZ0JzpcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0ZXh0UmVjdC5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgLSB0ZXh0SGVpZ2h0IC8gMiArIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZSArIHRleHRIZWlnaHQgLSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdhbHBoYWJldGljJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0Rm9udFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlbiBtaW5DaGFyLCBlbGxpcHNpcyB3aWxsIG5vdCBzaG93LCB3aGljaCBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGVsbGlwc2lzID0gcmV0cmlldmUoZWxsaXBzaXMsICcuLi4nKTtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZShvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICAgICAgICB2YXIgbWluQ2hhciA9IHJldHJpZXZlKG9wdGlvbnMubWluQ2hhciwgMCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIE90aGVyIGxhbmd1YWdlcz9cbiAgICAgICAgdmFyIGNuQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuICAgICAgICB2YXIgYXNjQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCdhJywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByZXRyaWV2ZShvcHRpb25zLnBsYWNlaG9sZGVyLCAnJyk7XG5cbiAgICAgICAgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAgICAgICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoID0gTWF0aC5tYXgoMCwgY29udGFpbmVyV2lkdGggLSAxKTsgLy8gUmVzZXJ2ZSBzb21lIGdhcC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGxpcHNpc1dpZHRoID0gZ2V0VGV4dFdpZHRoKGVsbGlwc2lzKTtcbiAgICAgICAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGVsbGlwc2lzID0gJyc7XG4gICAgICAgICAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gZWxsaXBzaXNXaWR0aDtcblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0TGluZSA9IHRleHRMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHRleHRMaW5lLmxlbmd0aCAqIGNvbnRlbnRXaWR0aCAvIGxpbmVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRMaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IHRleHRMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbiAmJiB3aWR0aCA8IGNvbnRlbnRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB3aWR0aCArPSAoMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcpID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250YWluID0ge1xuXG4gICAgICAgIGdldFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBnZXRUZXh0UmVjdCxcblxuICAgICAgICBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q6IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IHRydW5jYXRlVGV4dCxcblxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRleHRGb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRleHRDb250YWluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var OrdinalScale = __webpack_require__(179);\n    var IntervalScale = __webpack_require__(36);\n    __webpack_require__(180);\n    __webpack_require__(178);\n    var Scale = __webpack_require__(25);\n\n    var numberUtil = __webpack_require__(5);\n    var zrUtil = __webpack_require__(0);\n    var textContain = __webpack_require__(16);\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: scale.type === 'interval' ? model.get('minInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // 不同角的axis和label，不只是horizontal和vertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2F4aXNIZWxwZXIuanM/ZTMyNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgT3JkaW5hbFNjYWxlID0gcmVxdWlyZSgnLi4vc2NhbGUvT3JkaW5hbCcpO1xuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZSgnLi4vc2NhbGUvSW50ZXJ2YWwnKTtcbiAgICByZXF1aXJlKCcuLi9zY2FsZS9UaW1lJyk7XG4gICAgcmVxdWlyZSgnLi4vc2NhbGUvTG9nJyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi4vc2NhbGUvU2NhbGUnKTtcblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIGF4aXNIZWxwZXIgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdldCBheGlzIHNjYWxlIGV4dGVudCBiZWZvcmUgbmljZWQuXG4gICAgICogSXRlbSBvZiByZXR1cm5lZCBhcnJheSBjYW4gb25seSBiZSBudW1iZXIgKGluY2x1ZGluZyBJbmZpbml0eSBhbmQgTmFOKS5cbiAgICAgKi9cbiAgICBheGlzSGVscGVyLmdldFNjYWxlRXh0ZW50ID0gZnVuY3Rpb24gKHNjYWxlLCBtb2RlbCkge1xuICAgICAgICB2YXIgc2NhbGVUeXBlID0gc2NhbGUudHlwZTtcblxuICAgICAgICB2YXIgbWluID0gbW9kZWwuZ2V0TWluKCk7XG4gICAgICAgIHZhciBtYXggPSBtb2RlbC5nZXRNYXgoKTtcbiAgICAgICAgdmFyIGZpeE1pbiA9IG1pbiAhPSBudWxsO1xuICAgICAgICB2YXIgZml4TWF4ID0gbWF4ICE9IG51bGw7XG4gICAgICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IHNjYWxlLmdldEV4dGVudCgpO1xuXG4gICAgICAgIHZhciBheGlzRGF0YUxlbjtcbiAgICAgICAgdmFyIGJvdW5kYXJ5R2FwO1xuICAgICAgICB2YXIgc3BhbjtcbiAgICAgICAgaWYgKHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBheGlzRGF0YUxlbiA9IChtb2RlbC5nZXQoJ2RhdGEnKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm91bmRhcnlHYXAgPSBtb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGJvdW5kYXJ5R2FwKSkge1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5R2FwID0gW2JvdW5kYXJ5R2FwIHx8IDAsIGJvdW5kYXJ5R2FwIHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBib3VuZGFyeUdhcFswXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdCb29sZWFuIHR5cGUgZm9yIGJvdW5kYXJ5R2FwIGlzIG9ubHkgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYWxsb3dlZCBmb3Igb3JkaW5hbCBheGlzLiBQbGVhc2UgdXNlIHN0cmluZyBpbiAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdwZXJjZW50YWdlIGluc3RlYWQsIGUuZy4sIFwiMjAlXCIuIEN1cnJlbnRseSwgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYm91bmRhcnlHYXAgaXMgc2V0IHRvIGJlIDAuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5R2FwID0gWzAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgMSk7XG4gICAgICAgICAgICBib3VuZGFyeUdhcFsxXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzFdLCAxKTtcbiAgICAgICAgICAgIHNwYW4gPSAob3JpZ2luYWxFeHRlbnRbMV0gLSBvcmlnaW5hbEV4dGVudFswXSlcbiAgICAgICAgICAgICAgICB8fCBNYXRoLmFicyhvcmlnaW5hbEV4dGVudFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RpY2U6IFdoZW4gbWluL21heCBpcyBub3Qgc2V0ICh0aGF0IGlzLCB3aGVuIHRoZXJlIGFyZSBudWxsL3VuZGVmaW5lZCxcbiAgICAgICAgLy8gd2hpY2ggaXMgdGhlIG1vc3QgY29tbW9uIGNhc2UpLCB0aGVzZSBjYXNlcyBzaG91bGQgYmUgZW5zdXJlZDpcbiAgICAgICAgLy8gKDEpIEZvciAnb3JkaW5hbCcsIHNob3cgYWxsIGF4aXMuZGF0YS5cbiAgICAgICAgLy8gKDIpIEZvciBvdGhlcnM6XG4gICAgICAgIC8vICAgICAgKyBgYm91bmRhcnlHYXBgIGlzIGFwcGxpZWQgKGlmIG1pbi9tYXggc2V0LCBib3VuZGFyeUdhcCBpc1xuICAgICAgICAvLyAgICAgIGRpc2FibGVkKS5cbiAgICAgICAgLy8gICAgICArIElmIGBuZWVkQ3Jvc3NaZXJvYCwgbWluL21heCBzaG91bGQgYmUgemVybywgb3RoZXJ3aXNlLCBtaW4vbWF4IHNob3VsZFxuICAgICAgICAvLyAgICAgIGJlIHRoZSByZXN1bHQgdGhhdCBvcmlnaW5hbEV4dGVudCBlbmxhcmdlZCBieSBib3VuZGFyeUdhcC5cbiAgICAgICAgLy8gKDMpIElmIG5vIGRhdGEsIGl0IHNob3VsZCBiZSBlbnN1cmVkIHRoYXQgYHNjYWxlLnNldEJsYW5rYCBpcyBzZXQuXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gKDEpIFdoZW4gbWluL21heCBpcyAnZGF0YU1pbicgb3IgJ2RhdGFNYXgnLCBzaG91bGQgYm91bmRhcnlHYXAgYmUgYWJsZSB0byB1c2VkP1xuICAgICAgICAvLyAoMikgV2hlbiBgbmVlZENyb3NzWmVyb2AgYW5kIGFsbCBkYXRhIGlzIHBvc2l0aXZlL25lZ2F0aXZlLCBzaG91bGQgaXQgYmUgZW5zdXJlZFxuICAgICAgICAvLyB0aGF0IHRoZSByZXN1bHRzIHByb2Nlc3NlZCBieSBib3VuZGFyeUdhcCBhcmUgcG9zaXRpdmUvbmVnYXRpdmU/XG5cbiAgICAgICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtaW4gPSBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJ1xuICAgICAgICAgICAgICAgID8gKGF4aXNEYXRhTGVuID8gMCA6IE5hTilcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRXh0ZW50WzBdIC0gYm91bmRhcnlHYXBbMF0gKiBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4ID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICAgICA/IChheGlzRGF0YUxlbiA/IGF4aXNEYXRhTGVuIC0gMSA6IE5hTilcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRXh0ZW50WzFdICsgYm91bmRhcnlHYXBbMV0gKiBzcGFuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbiA9PT0gJ2RhdGFNaW4nKSB7XG4gICAgICAgICAgICBtaW4gPSBvcmlnaW5hbEV4dGVudFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ID09PSAnZGF0YU1heCcpIHtcbiAgICAgICAgICAgIG1heCA9IG9yaWdpbmFsRXh0ZW50WzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgKG1pbiA9PSBudWxsIHx8ICFpc0Zpbml0ZShtaW4pKSAmJiAobWluID0gTmFOKTtcbiAgICAgICAgKG1heCA9PSBudWxsIHx8ICFpc0Zpbml0ZShtYXgpKSAmJiAobWF4ID0gTmFOKTtcblxuICAgICAgICBzY2FsZS5zZXRCbGFuayh6clV0aWwuZXFOYU4obWluKSB8fCB6clV0aWwuZXFOYU4obWF4KSk7XG5cbiAgICAgICAgLy8gRXZhbHVhdGUgaWYgYXhpcyBuZWVkcyBjcm9zcyB6ZXJvXG4gICAgICAgIGlmIChtb2RlbC5nZXROZWVkQ3Jvc3NaZXJvKCkpIHtcbiAgICAgICAgICAgIC8vIEF4aXMgaXMgb3ZlciB6ZXJvIGFuZCBtaW4gaXMgbm90IHNldFxuICAgICAgICAgICAgaWYgKG1pbiA+IDAgJiYgbWF4ID4gMCAmJiAhZml4TWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF4aXMgaXMgdW5kZXIgemVybyBhbmQgbWF4IGlzIG5vdCBzZXRcbiAgICAgICAgICAgIGlmIChtaW4gPCAwICYmIG1heCA8IDAgJiYgIWZpeE1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9O1xuXG4gICAgYXhpc0hlbHBlci5uaWNlU2NhbGVFeHRlbnQgPSBmdW5jdGlvbiAoc2NhbGUsIG1vZGVsKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBheGlzSGVscGVyLmdldFNjYWxlRXh0ZW50KHNjYWxlLCBtb2RlbCk7XG4gICAgICAgIHZhciBmaXhNaW4gPSBtb2RlbC5nZXRNaW4oKSAhPSBudWxsO1xuICAgICAgICB2YXIgZml4TWF4ID0gbW9kZWwuZ2V0TWF4KCkgIT0gbnVsbDtcbiAgICAgICAgdmFyIHNwbGl0TnVtYmVyID0gbW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuXG4gICAgICAgIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykge1xuICAgICAgICAgICAgc2NhbGUuYmFzZSA9IG1vZGVsLmdldCgnbG9nQmFzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NhbGUuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgc2NhbGUubmljZUV4dGVudCh7XG4gICAgICAgICAgICBzcGxpdE51bWJlcjogc3BsaXROdW1iZXIsXG4gICAgICAgICAgICBmaXhNaW46IGZpeE1pbixcbiAgICAgICAgICAgIGZpeE1heDogZml4TWF4LFxuICAgICAgICAgICAgbWluSW50ZXJ2YWw6IHNjYWxlLnR5cGUgPT09ICdpbnRlcnZhbCcgPyBtb2RlbC5nZXQoJ21pbkludGVydmFsJykgOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHNvbWUgb25lIHNwZWNpZmllZCB0aGUgbWluLCBtYXguIEFuZCB0aGUgZGVmYXVsdCBjYWxjdWxhdGVkIGludGVydmFsXG4gICAgICAgIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZFxuICAgICAgICAvLyBpbiBhbmdsZSBheGlzIHdpdGggYW5nbGUgMCAtIDM2MC4gSW50ZXJ2YWwgY2FsY3VsYXRlZCBpbiBpbnRlcnZhbCBzY2FsZSBpcyBoYXJkXG4gICAgICAgIC8vIHRvIGJlIDYwLlxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gICAgICAgIGlmIChpbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbCAmJiBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNUeXBlXSBEZWZhdWx0IHJldHJpZXZlIGZyb20gbW9kZWwudHlwZVxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlLyp9XG4gICAgICovXG4gICAgYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwgPSBmdW5jdGlvbihtb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAgICAgYXhpc1R5cGUgPSBheGlzVHlwZSB8fCBtb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgaWYgKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbiBzY2FsZVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhdGVnb3J5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPcmRpbmFsU2NhbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5nZXRDYXRlZ29yaWVzKCksIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kZWQgc2NhbGUsIGxpa2UgdGltZSBhbmQgbG9nXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkuY3JlYXRlKG1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXhpcyBjb3JzcyAwXG4gICAgICovXG4gICAgYXhpc0hlbHBlci5pZkF4aXNDcm9zc1plcm8gPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgZGF0YUV4dGVudCA9IGF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICAgIHZhciBtaW4gPSBkYXRhRXh0ZW50WzBdO1xuICAgICAgICB2YXIgbWF4ID0gZGF0YUV4dGVudFsxXTtcbiAgICAgICAgcmV0dXJuICEoKG1pbiA+IDAgJiYgbWF4ID4gMCkgfHwgKG1pbiA8IDAgJiYgbWF4IDwgMCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0aWNrQ29vcmRzIEluIGF4aXMgc2VsZiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVsc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0F4aXNIb3Jpem9udGFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGF4aXNIZWxwZXIuZ2V0QXhpc0xhYmVsSW50ZXJ2YWwgPSBmdW5jdGlvbiAodGlja0Nvb3JkcywgbGFiZWxzLCBmb250LCBpc0F4aXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIOS4jeWQjOinkueahGF4aXPlkoxsYWJlbO+8jOS4jeWPquaYr2hvcml6b250YWzlkox2ZXJ0aWNhbC5cblxuICAgICAgICB2YXIgdGV4dFNwYWNlVGFrZW5SZWN0O1xuICAgICAgICB2YXIgYXV0b0xhYmVsSW50ZXJ2YWwgPSAwO1xuICAgICAgICB2YXIgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcblxuICAgICAgICB2YXIgc3RlcCA9IDE7XG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gNDApIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKGxhYmVscy5sZW5ndGggLyA0MCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tDb29yZHMubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrQ29vcmRzW2ldO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbGFiZWxzW2ldLCBmb250LCAnY2VudGVyJywgJ3RvcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWN0W2lzQXhpc0hvcml6b250YWwgPyAneCcgOiAneSddICs9IHRpY2tDb29yZDtcbiAgICAgICAgICAgIC8vIEZJWE1FIE1hZ2ljIG51bWJlciAxLjVcbiAgICAgICAgICAgIHJlY3RbaXNBeGlzSG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gKj0gMS4zO1xuICAgICAgICAgICAgaWYgKCF0ZXh0U3BhY2VUYWtlblJlY3QpIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3BhY2VUYWtlblJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzcGFjZSBmb3IgY3VycmVudCBsYWJlbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHRTcGFjZVRha2VuUmVjdC5pbnRlcnNlY3QocmVjdCkpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwrKztcbiAgICAgICAgICAgICAgICBhdXRvTGFiZWxJbnRlcnZhbCA9IE1hdGgubWF4KGF1dG9MYWJlbEludGVydmFsLCBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dFNwYWNlVGFrZW5SZWN0LnVuaW9uKHJlY3QpO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b0xhYmVsSW50ZXJ2YWwgPT09IDAgJiYgc3RlcCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXV0b0xhYmVsSW50ZXJ2YWwgKyAxKSAqIHN0ZXAgLSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXhpc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsRm9ybWF0dGVyXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgYXhpc0hlbHBlci5nZXRGb3JtYXR0ZWRMYWJlbHMgPSBmdW5jdGlvbiAoYXhpcywgbGFiZWxGb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGxhYmVscyA9IHNjYWxlLmdldFRpY2tzTGFiZWxzKCk7XG4gICAgICAgIHZhciB0aWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsYWJlbEZvcm1hdHRlciA9IChmdW5jdGlvbiAodHBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKCd7dmFsdWV9JywgdmFsICE9IG51bGwgPyB2YWwgOiAnJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKGxhYmVsRm9ybWF0dGVyKTtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIGVtcHR5IGFycmF5XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcChsYWJlbHMsIGxhYmVsRm9ybWF0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHRpY2tzLCBmdW5jdGlvbiAodGljaywgaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKFxuICAgICAgICAgICAgICAgICAgICBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzLCB0aWNrKSxcbiAgICAgICAgICAgICAgICAgICAgaWR4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZSA9IGZ1bmN0aW9uIChheGlzLCB2YWx1ZSkge1xuICAgICAgICAvLyBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gICAgICAgIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gICAgICAgIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLnNjYWxlLmdldExhYmVsKHZhbHVlKSA6IHZhbHVlO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGF4aXNIZWxwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29vcmQvYXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(7);\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvY3VydmUuanM/Y2ZiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciB2MkNyZWF0ZSA9IHZlYzIuY3JlYXRlO1xuICAgIHZhciB2MkRpc3RTcXVhcmUgPSB2ZWMyLmRpc3RTcXVhcmU7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDFlLTg7XG4gICAgdmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG5cbiAgICB2YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xuICAgIHZhciBPTkVfVEhJUkQgPSAxIC8gMztcblxuICAgIC8vIOS4tOaXtuWPmOmHj1xuICAgIHZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuICAgIC8vIHZhciBfdjMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpXG4gICAgICAgICAgICAgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiAoXG4gICAgICAgICAgICAoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXRcbiAgICAgICAgICAgICsgKHAzIC0gcDIpICogdCAqIHRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gICAgICAgIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gICAgICAgIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgICAgICAgdmFyIGMgPSAzICogKHAxICAtIHAwKTtcbiAgICAgICAgdmFyIGQgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICAgICAgICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICAgICAgICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuXG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHJvb3RzWzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjsgIC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7ICAvLyB0MSwgYSBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIHZhciB0MiA9IC1LIC8gMjsgIC8vIHQyLCB0M1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgICAgICAgICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICAgICAgICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgICAgICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9MSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuXG4gICAgICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICAgICAgICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcblxuICAgICAgICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7XG4gICAgICAgIC8vIFNlZzBcbiAgICAgICAgb3V0WzBdID0gcDA7XG4gICAgICAgIG91dFsxXSA9IHAwMTtcbiAgICAgICAgb3V0WzJdID0gcDAxMjtcbiAgICAgICAgb3V0WzNdID0gcDAxMjM7XG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzRdID0gcDAxMjM7XG4gICAgICAgIG91dFs1XSA9IHAxMjM7XG4gICAgICAgIG91dFs2XSA9IHAyMztcbiAgICAgICAgb3V0WzddID0gcDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gICAgICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICB4LCB5LCBvdXRcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gICAgICAgIHZhciBkID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG5cbiAgICAgICAgX3YwWzBdID0geDtcbiAgICAgICAgX3YwWzFdID0geTtcblxuICAgICAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcblxuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgICAgICAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgICAgICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgICAgICB2YXIgYyA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuICAgICAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcblxuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG5cbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbM10gPSBwMDEyO1xuICAgICAgICBvdXRbNF0gPSBwMTI7XG4gICAgICAgIG91dFs1XSA9IHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG5cbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICAgICAgICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgY3ViaWNBdDogY3ViaWNBdCxcblxuICAgICAgICBjdWJpY0Rlcml2YXRpdmVBdDogY3ViaWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgY3ViaWNSb290QXQ6IGN1YmljUm9vdEF0LFxuXG4gICAgICAgIGN1YmljRXh0cmVtYTogY3ViaWNFeHRyZW1hLFxuXG4gICAgICAgIGN1YmljU3ViZGl2aWRlOiBjdWJpY1N1YmRpdmlkZSxcblxuICAgICAgICBjdWJpY1Byb2plY3RQb2ludDogY3ViaWNQcm9qZWN0UG9pbnQsXG5cbiAgICAgICAgcXVhZHJhdGljQXQ6IHF1YWRyYXRpY0F0LFxuXG4gICAgICAgIHF1YWRyYXRpY0Rlcml2YXRpdmVBdDogcXVhZHJhdGljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIHF1YWRyYXRpY1Jvb3RBdDogcXVhZHJhdGljUm9vdEF0LFxuXG4gICAgICAgIHF1YWRyYXRpY0V4dHJlbXVtOiBxdWFkcmF0aWNFeHRyZW11bSxcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGU6IHF1YWRyYXRpY1N1YmRpdmlkZSxcblxuICAgICAgICBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ6IHF1YWRyYXRpY1Byb2plY3RQb2ludFxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = __webpack_require__(21);\n    var env = __webpack_require__(6);\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvZXZlbnQuanM/ZDJjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5LqL5Lu26L6F5Yqp57G7XG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9ldmVudFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICAgIHZhciBpc0RvbUxldmVsMiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgJiYgISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICAgICAgICAvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpIGRvbid0IGhhdmUgZ2V0Qm91bmRpbmdSZWN0XG4gICAgICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtsZWZ0OiAwLCB0b3A6IDB9O1xuICAgIH1cblxuICAgIC8vIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlXG4gICAgZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0LCBjYWxjdWxhdGUpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgVzNDIFdvcmtpbmcgRHJhZnQsIG9mZnNldFggYW5kIG9mZnNldFkgc2hvdWxkIGJlIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBwYWRkaW5nIGVkZ2Ugb2YgdGhlIHRhcmdldCBlbGVtZW50LiBUaGUgb25seSBicm93c2VyIHVzaW5nIHRoaXMgY29udmVudGlvblxuICAgICAgICAvLyBpcyBJRS4gV2Via2l0IHVzZXMgdGhlIGJvcmRlciBlZGdlLCBPcGVyYSB1c2VzIHRoZSBjb250ZW50IGVkZ2UsIGFuZCBGaXJlRm94IGRvZXNcbiAgICAgICAgLy8gbm90IHN1cHBvcnQgdGhlIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIChzZWUgaHR0cDovL3d3dy5qYWNrbG1vb3JlLmNvbS9ub3Rlcy9tb3VzZS1wb3NpdGlvbi8pXG4gICAgICAgIC8vIEluIHpyIHBhaW50ZXIuZG9tLCBwYWRkaW5nIGVkZ2UgZXF1YWxzIHRvIGJvcmRlciBlZGdlLlxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIFdoZW4gbW91c2Vtb3ZlIGV2ZW50IHRyaWdnZXJlZCBvbiBlYyB0b29sdGlwLCB0YXJnZXQgaXMgbm90IHpyIHBhaW50ZXIuZG9tLCBhbmRcbiAgICAgICAgLy8gb2Zmc2V0WC9ZIGlzIHJlbGF0aXZlIHRvIGUudGFyZ2V0LCB3aGVyZSB0aGUgY2FsY3VsYXRpb24gb2YgenJYL1kgdmlhIG9mZnNldFgvWVxuICAgICAgICAvLyBpcyB0b28gY29tcGxleC4gU28gY3NzLXRyYW5zZnJvbSBkb250IHN1cHBvcnQgaW4gdGhpcyBjYXNlIHRlbXBvcmFyaWx5LlxuICAgICAgICBpZiAoY2FsY3VsYXRlIHx8ICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXV0aW9uOiBJbiBGaXJlRm94LCBsYXllclgvbGF5ZXJZIE1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBjbG9zZXN0IHBvc2l0aW9uZWRcbiAgICAgICAgLy8gYW5jZXN0b3IgZWxlbWVudCwgc28gd2Ugc2hvdWxkIG1ha2Ugc3VyZSBlbCBpcyBwb3NpdGlvbmVkIChlLmcuLCBub3QgcG9zaXRpb246c3RhdGljKS5cbiAgICAgICAgLy8gQlRXMSwgV2Via2l0IGRvbid0IHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIEZGIGluIG5vbi1zaW1wbGUgY2FzZXMgKGxpa2UgYWRkXG4gICAgICAgIC8vIHpvb20tZmFjdG9yLCBvdmVyZmxvdyAvIG9wYWNpdHkgbGF5ZXJzLCB0cmFuc2Zvcm1zIC4uLilcbiAgICAgICAgLy8gQlRXMiwgKGV2Lm9mZnNldFkgfHwgZXYucGFnZVkgLSAkKGV2LnRhcmdldCkub2Zmc2V0KCkudG9wKSBpcyBub3QgY29ycmVjdCBpbiBwcmVzZXJ2ZS0zZC5cbiAgICAgICAgLy8gPGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84NTIzI2NvbW1lbnQ6MTQ+XG4gICAgICAgIC8vIEJUVzMsIEluIGZmLCBvZmZzZXRYL29mZnNldFkgaXMgYWx3YXlzIDAuXG4gICAgICAgIGVsc2UgaWYgKGVudi5icm93c2VyLmZpcmVmb3ggJiYgZS5sYXllclggIT0gbnVsbCAmJiBlLmxheWVyWCAhPT0gZS5vZmZzZXRYKSB7XG4gICAgICAgICAgICBvdXQuenJYID0gZS5sYXllclg7XG4gICAgICAgICAgICBvdXQuenJZID0gZS5sYXllclk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIElFNissIGNocm9tZSwgc2FmYXJpLCBvcGVyYS4gKFdoZW4gd2lsbCBmZiBzdXBwb3J0IG9mZnNldFg/KVxuICAgICAgICBlbHNlIGlmIChlLm9mZnNldFggIT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0LnpyWCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgIG91dC56clkgPSBlLm9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHNvbWUgb3RoZXIgZGV2aWNlLCBlLmcuLCBJT1Mgc2FmYXJpLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2VsbC1rbm93biBtZXRob2QgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBjc3MgdHJhbnNmb3JtLlxuICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgICAgICAgb3V0LnpyWCA9IGUuY2xpZW50WCAtIGJveC5sZWZ0O1xuICAgICAgICBvdXQuenJZID0gZS5jbGllbnRZIC0gYm94LnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlpoLmnpzlrZjlnKjnrKzkuInmlrnltYzlhaXnmoTkuIDkuptkb23op6blj5HnmoTkuovku7bvvIzmiJZ0b3VjaOS6i+S7tu+8jOmcgOimgei9rOaNouS4gOS4i+S6i+S7tuWdkOaghy5cbiAgICAgKiBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVFdmVudChlbCwgZSwgY2FsY3VsYXRlKSB7XG5cbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIGlmIChlLnpyWCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudFR5cGUgPSBlLnR5cGU7XG4gICAgICAgIHZhciBpc1RvdWNoID0gZXZlbnRUeXBlICYmIGV2ZW50VHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDA7XG5cbiAgICAgICAgaWYgKCFpc1RvdWNoKSB7XG4gICAgICAgICAgICBjbGllbnRUb0xvY2FsKGVsLCBlLCBlLCBjYWxjdWxhdGUpO1xuICAgICAgICAgICAgZS56ckRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnXG4gICAgICAgICAgICAgICAgPyBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgICAgICAgICAgICA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSwgY2FsY3VsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uLlxuICAgICAqIE5vdGljZTogZG8gbm90IGRvIHRoYXQgaW4genJlbmRlci4gVXBwZXIgYXBwbGljYXRpb25cbiAgICAgKiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2V2ZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgOiBldmVudOWvueixoVxuICAgICAqL1xuICAgIHZhciBzdG9wID0gaXNEb21MZXZlbDJcbiAgICAgICAgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2xpZW50VG9Mb2NhbDogY2xpZW50VG9Mb2NhbCxcbiAgICAgICAgbm9ybWFsaXplRXZlbnQ6IG5vcm1hbGl6ZUV2ZW50LFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyLFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiByZW1vdmVFdmVudExpc3RlbmVyLFxuXG4gICAgICAgIHN0b3A6IHN0b3AsXG4gICAgICAgIC8vIOWBmuWQkeS4iuWFvOWuuVxuICAgICAgICBEaXNwYXRjaGVyOiBFdmVudGZ1bFxuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

eval("\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzPzI0YzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG4gICAgLyoqXG4gICAgICogM3gy55+p6Zi15pON5L2c57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICAgICAqL1xuICAgIHZhciBtYXRyaXggPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgICAgICAgICAgIG1hdHJpeC5pZGVudGl0eShvdXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICovXG4gICAgICAgIGlkZW50aXR5IDogZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAxO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgb3V0WzRdID0gMDtcbiAgICAgICAgICAgIG91dFs1XSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi255+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBtWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gbVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IG1bNF07XG4gICAgICAgICAgICBvdXRbNV0gPSBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteebuOS5mFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAgICAgICAgICovXG4gICAgICAgIG11bCA6IGZ1bmN0aW9uIChvdXQsIG0xLCBtMikge1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gICAgICAgICAgICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gICAgICAgICAgICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gICAgICAgICAgICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICAgICAgICAgICAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICAgICAgICAgICAgb3V0WzBdID0gb3V0MDtcbiAgICAgICAgICAgIG91dFsxXSA9IG91dDE7XG4gICAgICAgICAgICBvdXRbMl0gPSBvdXQyO1xuICAgICAgICAgICAgb3V0WzNdID0gb3V0MztcbiAgICAgICAgICAgIG91dFs0XSA9IG91dDQ7XG4gICAgICAgICAgICBvdXRbNV0gPSBvdXQ1O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW5s+enu+WPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM107XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgcmFkKSB7XG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcbiAgICAgICAgICAgIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgICAgICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgICAgICAgICAgIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICAgICAgICAgICAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICAgICAgICAgICAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgICAgICAgICAgIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog57yp5pS+5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICB2YXIgdnggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHZ5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM10gKiB2eTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLpgIbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgaW52ZXJ0IDogZnVuY3Rpb24ob3V0LCBhKSB7XG5cbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuXG4gICAgICAgICAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgICAgICAgICBpZiAoIWRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICAgICAgICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICAgICAgICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgICAgICAgICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgICAgICAgICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hdHJpeDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

eval("/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzP2FiZjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIOS6i+S7tuWIhuWPkeWZqFxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgfTtcblxuICAgIEV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5Hlrprkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50ZnVsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = __webpack_require__(72);\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL3Rvb2wvY29sb3IuanM/OWFkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsWUFBWSxZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGdCQUFnQjtBQUNoQyx5Q0FBeUMsd0RBQXdEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci90b29sL2NvbG9yXG4gKi9cblxuXG4gICAgdmFyIExSVSA9IHJlcXVpcmUoJy4uL2NvcmUvTFJVJyk7XG5cbiAgICB2YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgICAgICd0cmFuc3BhcmVudCc6IFswLDAsMCwwXSwgJ2FsaWNlYmx1ZSc6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsMjM1LDIxNSwxXSwgJ2FxdWEnOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnYXF1YW1hcmluZSc6IFsxMjcsMjU1LDIxMiwxXSwgJ2F6dXJlJzogWzI0MCwyNTUsMjU1LDFdLFxuICAgICAgICAnYmVpZ2UnOiBbMjQ1LDI0NSwyMjAsMV0sICdiaXNxdWUnOiBbMjU1LDIyOCwxOTYsMV0sXG4gICAgICAgICdibGFjayc6IFswLDAsMCwxXSwgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwyMzUsMjA1LDFdLFxuICAgICAgICAnYmx1ZSc6IFswLDAsMjU1LDFdLCAnYmx1ZXZpb2xldCc6IFsxMzgsNDMsMjI2LDFdLFxuICAgICAgICAnYnJvd24nOiBbMTY1LDQyLDQyLDFdLCAnYnVybHl3b29kJzogWzIyMiwxODQsMTM1LDFdLFxuICAgICAgICAnY2FkZXRibHVlJzogWzk1LDE1OCwxNjAsMV0sICdjaGFydHJldXNlJzogWzEyNywyNTUsMCwxXSxcbiAgICAgICAgJ2Nob2NvbGF0ZSc6IFsyMTAsMTA1LDMwLDFdLCAnY29yYWwnOiBbMjU1LDEyNyw4MCwxXSxcbiAgICAgICAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwxNDksMjM3LDFdLCAnY29ybnNpbGsnOiBbMjU1LDI0OCwyMjAsMV0sXG4gICAgICAgICdjcmltc29uJzogWzIyMCwyMCw2MCwxXSwgJ2N5YW4nOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnZGFya2JsdWUnOiBbMCwwLDEzOSwxXSwgJ2RhcmtjeWFuJzogWzAsMTM5LDEzOSwxXSxcbiAgICAgICAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LDEzNCwxMSwxXSwgJ2RhcmtncmF5JzogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICAnZGFya2dyZWVuJzogWzAsMTAwLDAsMV0sICdkYXJrZ3JleSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtraGFraSc6IFsxODksMTgzLDEwNywxXSwgJ2RhcmttYWdlbnRhJzogWzEzOSwwLDEzOSwxXSxcbiAgICAgICAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LDEwNyw0NywxXSwgJ2RhcmtvcmFuZ2UnOiBbMjU1LDE0MCwwLDFdLFxuICAgICAgICAnZGFya29yY2hpZCc6IFsxNTMsNTAsMjA0LDFdLCAnZGFya3JlZCc6IFsxMzksMCwwLDFdLFxuICAgICAgICAnZGFya3NhbG1vbic6IFsyMzMsMTUwLDEyMiwxXSwgJ2RhcmtzZWFncmVlbic6IFsxNDMsMTg4LDE0MywxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsNjEsMTM5LDFdLCAnZGFya3NsYXRlZ3JheSc6IFs0Nyw3OSw3OSwxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsNzksNzksMV0sICdkYXJrdHVycXVvaXNlJzogWzAsMjA2LDIwOSwxXSxcbiAgICAgICAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LDAsMjExLDFdLCAnZGVlcHBpbmsnOiBbMjU1LDIwLDE0NywxXSxcbiAgICAgICAgJ2RlZXBza3libHVlJzogWzAsMTkxLDI1NSwxXSwgJ2RpbWdyYXknOiBbMTA1LDEwNSwxMDUsMV0sXG4gICAgICAgICdkaW1ncmV5JzogWzEwNSwxMDUsMTA1LDFdLCAnZG9kZ2VyYmx1ZSc6IFszMCwxNDQsMjU1LDFdLFxuICAgICAgICAnZmlyZWJyaWNrJzogWzE3OCwzNCwzNCwxXSwgJ2Zsb3JhbHdoaXRlJzogWzI1NSwyNTAsMjQwLDFdLFxuICAgICAgICAnZm9yZXN0Z3JlZW4nOiBbMzQsMTM5LDM0LDFdLCAnZnVjaHNpYSc6IFsyNTUsMCwyNTUsMV0sXG4gICAgICAgICdnYWluc2Jvcm8nOiBbMjIwLDIyMCwyMjAsMV0sICdnaG9zdHdoaXRlJzogWzI0OCwyNDgsMjU1LDFdLFxuICAgICAgICAnZ29sZCc6IFsyNTUsMjE1LDAsMV0sICdnb2xkZW5yb2QnOiBbMjE4LDE2NSwzMiwxXSxcbiAgICAgICAgJ2dyYXknOiBbMTI4LDEyOCwxMjgsMV0sICdncmVlbic6IFswLDEyOCwwLDFdLFxuICAgICAgICAnZ3JlZW55ZWxsb3cnOiBbMTczLDI1NSw0NywxXSwgJ2dyZXknOiBbMTI4LDEyOCwxMjgsMV0sXG4gICAgICAgICdob25leWRldyc6IFsyNDAsMjU1LDI0MCwxXSwgJ2hvdHBpbmsnOiBbMjU1LDEwNSwxODAsMV0sXG4gICAgICAgICdpbmRpYW5yZWQnOiBbMjA1LDkyLDkyLDFdLCAnaW5kaWdvJzogWzc1LDAsMTMwLDFdLFxuICAgICAgICAnaXZvcnknOiBbMjU1LDI1NSwyNDAsMV0sICdraGFraSc6IFsyNDAsMjMwLDE0MCwxXSxcbiAgICAgICAgJ2xhdmVuZGVyJzogWzIzMCwyMzAsMjUwLDFdLCAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsMjQwLDI0NSwxXSxcbiAgICAgICAgJ2xhd25ncmVlbic6IFsxMjQsMjUyLDAsMV0sICdsZW1vbmNoaWZmb24nOiBbMjU1LDI1MCwyMDUsMV0sXG4gICAgICAgICdsaWdodGJsdWUnOiBbMTczLDIxNiwyMzAsMV0sICdsaWdodGNvcmFsJzogWzI0MCwxMjgsMTI4LDFdLFxuICAgICAgICAnbGlnaHRjeWFuJzogWzIyNCwyNTUsMjU1LDFdLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLDI1MCwyMTAsMV0sXG4gICAgICAgICdsaWdodGdyYXknOiBbMjExLDIxMSwyMTEsMV0sICdsaWdodGdyZWVuJzogWzE0NCwyMzgsMTQ0LDFdLFxuICAgICAgICAnbGlnaHRncmV5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRwaW5rJzogWzI1NSwxODIsMTkzLDFdLFxuICAgICAgICAnbGlnaHRzYWxtb24nOiBbMjU1LDE2MCwxMjIsMV0sICdsaWdodHNlYWdyZWVuJzogWzMyLDE3OCwxNzAsMV0sXG4gICAgICAgICdsaWdodHNreWJsdWUnOiBbMTM1LDIwNiwyNTAsMV0sICdsaWdodHNsYXRlZ3JheSc6IFsxMTksMTM2LDE1MywxXSxcbiAgICAgICAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwxMzYsMTUzLDFdLCAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LDE5NiwyMjIsMV0sXG4gICAgICAgICdsaWdodHllbGxvdyc6IFsyNTUsMjU1LDIyNCwxXSwgJ2xpbWUnOiBbMCwyNTUsMCwxXSxcbiAgICAgICAgJ2xpbWVncmVlbic6IFs1MCwyMDUsNTAsMV0sICdsaW5lbic6IFsyNTAsMjQwLDIzMCwxXSxcbiAgICAgICAgJ21hZ2VudGEnOiBbMjU1LDAsMjU1LDFdLCAnbWFyb29uJzogWzEyOCwwLDAsMV0sXG4gICAgICAgICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwyMDUsMTcwLDFdLCAnbWVkaXVtYmx1ZSc6IFswLDAsMjA1LDFdLFxuICAgICAgICAnbWVkaXVtb3JjaGlkJzogWzE4Niw4NSwyMTEsMV0sICdtZWRpdW1wdXJwbGUnOiBbMTQ3LDExMiwyMTksMV0sXG4gICAgICAgICdtZWRpdW1zZWFncmVlbic6IFs2MCwxNzksMTEzLDFdLCAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywxMDQsMjM4LDFdLFxuICAgICAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwyNTAsMTU0LDFdLCAnbWVkaXVtdHVycXVvaXNlJzogWzcyLDIwOSwyMDQsMV0sXG4gICAgICAgICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LDIxLDEzMywxXSwgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwyNSwxMTIsMV0sXG4gICAgICAgICdtaW50Y3JlYW0nOiBbMjQ1LDI1NSwyNTAsMV0sICdtaXN0eXJvc2UnOiBbMjU1LDIyOCwyMjUsMV0sXG4gICAgICAgICdtb2NjYXNpbic6IFsyNTUsMjI4LDE4MSwxXSwgJ25hdmFqb3doaXRlJzogWzI1NSwyMjIsMTczLDFdLFxuICAgICAgICAnbmF2eSc6IFswLDAsMTI4LDFdLCAnb2xkbGFjZSc6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgICAgICAgJ29saXZlJzogWzEyOCwxMjgsMCwxXSwgJ29saXZlZHJhYic6IFsxMDcsMTQyLDM1LDFdLFxuICAgICAgICAnb3JhbmdlJzogWzI1NSwxNjUsMCwxXSwgJ29yYW5nZXJlZCc6IFsyNTUsNjksMCwxXSxcbiAgICAgICAgJ29yY2hpZCc6IFsyMTgsMTEyLDIxNCwxXSwgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LDIzMiwxNzAsMV0sXG4gICAgICAgICdwYWxlZ3JlZW4nOiBbMTUyLDI1MSwxNTIsMV0sICdwYWxldHVycXVvaXNlJzogWzE3NSwyMzgsMjM4LDFdLFxuICAgICAgICAncGFsZXZpb2xldHJlZCc6IFsyMTksMTEyLDE0NywxXSwgJ3BhcGF5YXdoaXAnOiBbMjU1LDIzOSwyMTMsMV0sXG4gICAgICAgICdwZWFjaHB1ZmYnOiBbMjU1LDIxOCwxODUsMV0sICdwZXJ1JzogWzIwNSwxMzMsNjMsMV0sXG4gICAgICAgICdwaW5rJzogWzI1NSwxOTIsMjAzLDFdLCAncGx1bSc6IFsyMjEsMTYwLDIyMSwxXSxcbiAgICAgICAgJ3Bvd2RlcmJsdWUnOiBbMTc2LDIyNCwyMzAsMV0sICdwdXJwbGUnOiBbMTI4LDAsMTI4LDFdLFxuICAgICAgICAncmVkJzogWzI1NSwwLDAsMV0sICdyb3N5YnJvd24nOiBbMTg4LDE0MywxNDMsMV0sXG4gICAgICAgICdyb3lhbGJsdWUnOiBbNjUsMTA1LDIyNSwxXSwgJ3NhZGRsZWJyb3duJzogWzEzOSw2OSwxOSwxXSxcbiAgICAgICAgJ3NhbG1vbic6IFsyNTAsMTI4LDExNCwxXSwgJ3NhbmR5YnJvd24nOiBbMjQ0LDE2NCw5NiwxXSxcbiAgICAgICAgJ3NlYWdyZWVuJzogWzQ2LDEzOSw4NywxXSwgJ3NlYXNoZWxsJzogWzI1NSwyNDUsMjM4LDFdLFxuICAgICAgICAnc2llbm5hJzogWzE2MCw4Miw0NSwxXSwgJ3NpbHZlcic6IFsxOTIsMTkyLDE5MiwxXSxcbiAgICAgICAgJ3NreWJsdWUnOiBbMTM1LDIwNiwyMzUsMV0sICdzbGF0ZWJsdWUnOiBbMTA2LDkwLDIwNSwxXSxcbiAgICAgICAgJ3NsYXRlZ3JheSc6IFsxMTIsMTI4LDE0NCwxXSwgJ3NsYXRlZ3JleSc6IFsxMTIsMTI4LDE0NCwxXSxcbiAgICAgICAgJ3Nub3cnOiBbMjU1LDI1MCwyNTAsMV0sICdzcHJpbmdncmVlbic6IFswLDI1NSwxMjcsMV0sXG4gICAgICAgICdzdGVlbGJsdWUnOiBbNzAsMTMwLDE4MCwxXSwgJ3Rhbic6IFsyMTAsMTgwLDE0MCwxXSxcbiAgICAgICAgJ3RlYWwnOiBbMCwxMjgsMTI4LDFdLCAndGhpc3RsZSc6IFsyMTYsMTkxLDIxNiwxXSxcbiAgICAgICAgJ3RvbWF0byc6IFsyNTUsOTksNzEsMV0sICd0dXJxdW9pc2UnOiBbNjQsMjI0LDIwOCwxXSxcbiAgICAgICAgJ3Zpb2xldCc6IFsyMzgsMTMwLDIzOCwxXSwgJ3doZWF0JzogWzI0NSwyMjIsMTc5LDFdLFxuICAgICAgICAnd2hpdGUnOiBbMjU1LDI1NSwyNTUsMV0sICd3aGl0ZXNtb2tlJzogWzI0NSwyNDUsMjQ1LDFdLFxuICAgICAgICAneWVsbG93JzogWzI1NSwyNTUsMCwxXSwgJ3llbGxvd2dyZWVuJzogWzE1NCwyMDUsNTAsMV1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMzYwID8gMzYwIDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgICAgIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlSW50KHN0ciwgMTApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgIGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoID4gMSkge1xuICAgICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggKiA2IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggKiAyIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgcCkge1xuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gICAgICAgIG91dFswXSA9IHI7IG91dFsxXSA9IGc7IG91dFsyXSA9IGI7IG91dFszXSA9IGE7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlSZ2JhKG91dCwgYSkge1xuICAgICAgICBvdXRbMF0gPSBhWzBdOyBvdXRbMV0gPSBhWzFdOyBvdXRbMl0gPSBhWzJdOyBvdXRbM10gPSBhWzNdO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB2YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xuICAgIHZhciBsYXN0UmVtb3ZlZEFyciA9IG51bGw7XG4gICAgZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAgICAgICAvLyBSZXVzZSByZW1vdmVkIGFycmF5XG4gICAgICAgIGlmIChsYXN0UmVtb3ZlZEFycikge1xuICAgICAgICAgICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RSZW1vdmVkQXJyID0gY29sb3JDYWNoZS5wdXQoY29sb3JTdHIsIGxhc3RSZW1vdmVkQXJyIHx8IChyZ2JhQXJyLnNsaWNlKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZShjb2xvclN0ciwgcmdiYUFycikge1xuICAgICAgICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG5cbiAgICAgICAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlSZ2JhKHJnYmFBcnIsIGNhY2hlZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb2xvclN0ciBtYXkgYmUgbm90IHN0cmluZ1xuICAgICAgICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICAgICAgICB2YXIgc3RyID0gY29sb3JTdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gICAgICAgIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHtcbiAgICAgICAgICAgIGNvcHlSZ2JhKHJnYmFBcnIsIGtDU1NDb2xvclRhYmxlW3N0cl0pO1xuICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFycixcbiAgICAgICAgICAgICAgICAgICAgKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFycixcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgICAgIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgICAgICAgICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zWzNdID0gcGFyc2VDc3NGbG9hdChwYXJhbXNbM10pO1xuICAgICAgICAgICAgICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSwgcmdiYSkge1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQoaHNsYVswXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuXG4gICAgICAgIHJnYmEgPSByZ2JhIHx8IFtdO1xuICAgICAgICBzZXRSZ2JhKHJnYmEsXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggLSAxIC8gMykgKiAyNTUpLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmdiYVszXSA9IGhzbGFbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICAgICAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJHQiBmcm9tIDAgdG8gMjU1XG4gICAgICAgIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgICAgICAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICAgICAgICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG5cbiAgICAgICAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47IC8vIERlbHRhIFJHQiB2YWx1ZVxuXG4gICAgICAgIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gICAgICAgIHZhciBIO1xuICAgICAgICB2YXIgUztcbiAgICAgICAgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBIID0gMDtcbiAgICAgICAgICAgIFMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKDIgLSB2TWF4IC0gdk1pbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWx0YVIgPSAoKCh2TWF4IC0gUikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhRyA9ICgoKHZNYXggLSBHKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgICAgICB2YXIgZGVsdGFCID0gKCgodk1heCAtIEIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcblxuICAgICAgICAgICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMSAvIDMpICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMiAvIDMpICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgICAgICAgICBIICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChIID4gMSkge1xuICAgICAgICAgICAgICAgIEggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gICAgICAgIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoc2xhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gKCgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IZXgoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyAoK2NvbG9yQXJyWzJdKSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBtYXBUb0NvbG9yIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB3aWxsIGJlIG51bGwvdW5kZWZpbmVkIGlmIGlucHV0IGlsbGVnYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmFzdE1hcFRvQ29sb3Iobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ID0gb3V0IHx8IFtdO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gICAgICAgIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgICAgICAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICAgICAgICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gICAgICAgIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgICAgICAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcblxuICAgICAgICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdyZ2JhJ1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmdWxsT3V0cHV0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICAgICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICAgICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyckNvbG9yIGxpa2UgWzEyLDMzLDQ0LDAuNF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQgY29sb3IuIChJZiBpbnB1dCBpbGxlZ2FsLCByZXR1cm4gdW5kZWZpbmVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgICAgICAgaWYgKCFhcnJDb2xvciB8fCAhYXJyQ29sb3IubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgbGlmdDogbGlmdCxcbiAgICAgICAgdG9IZXg6IHRvSGV4LFxuICAgICAgICBmYXN0TWFwVG9Db2xvcjogZmFzdE1hcFRvQ29sb3IsXG4gICAgICAgIG1hcFRvQ29sb3I6IG1hcFRvQ29sb3IsXG4gICAgICAgIG1vZGlmeUhTTDogbW9kaWZ5SFNMLFxuICAgICAgICBtb2RpZnlBbHBoYTogbW9kaWZ5QWxwaGEsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG4gICAgfTtcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvdG9vbC9jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var Model = __webpack_require__(9);\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n\n    var helper = {};\n\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    helper.collect = function (ecModel, api) {\n        var result = {\n            /**\n             * key: makeKey(axis.model)\n             * value: {\n             *      axis,\n             *      coordSys,\n             *      axisPointerModel,\n             *      triggerTooltip,\n             *      involveSeries,\n             *      snap,\n             *      seriesModels,\n             *      seriesDataCount\n             * }\n             */\n            axesInfo: {},\n            seriesInvolved: false,\n            /**\n             * key: makeKey(coordSys.model)\n             * value: Object: key makeKey(axis.model), value: axisInfo\n             */\n            coordSysAxesInfo: {},\n            coordSysMap: {}\n        };\n\n        collectAxesInfo(result, ecModel, api);\n\n        // Check seriesInvolved for performance, in case too many series in some chart.\n        result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n        return result;\n    };\n\n    function collectAxesInfo(result, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n        // links can only be set on global.\n        var linksOption = globalAxisPointerModel.get('link', true) || [];\n        var linkGroups = [];\n\n        // Collect axes info.\n        each(api.getCoordinateSystems(), function (coordSys) {\n            // Some coordinate system do not support axes, like geo.\n            if (!coordSys.axisPointerEnabled) {\n                return;\n            }\n\n            var coordSysKey = makeKey(coordSys.model);\n            var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n            result.coordSysMap[coordSysKey] = coordSys;\n\n            // Set tooltip (like 'cross') is a convienent way to show axisPointer\n            // for user. So we enable seting tooltip on coordSys model.\n            var coordSysModel = coordSys.model;\n            var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n            each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n            // If axis tooltip used, choose tooltip axis for each coordSys.\n            // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n            if (coordSys.getTooltipAxes\n                && globalTooltipModel\n                // If tooltip.showContent is set as false, tooltip will not\n                // show but axisPointer will show as normal.\n                && baseTooltipModel.get('show')\n            ) {\n                // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n                // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n                var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n                var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n                var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n                if (triggerAxis || cross) {\n                    each(tooltipAxes.baseAxes, curry(\n                        saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                    ));\n                }\n                if (cross) {\n                    each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n                }\n            }\n\n            // fromTooltip: true | false | 'cross'\n            // triggerTooltip: true | false | null\n            function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n                var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n                var axisPointerShow = axisPointerModel.get('show');\n                if (!axisPointerShow || (\n                    axisPointerShow === 'auto'\n                    && !fromTooltip\n                    && !isHandleTrigger(axisPointerModel)\n                )) {\n                    return;\n                }\n\n                if (triggerTooltip == null) {\n                    triggerTooltip = axisPointerModel.get('triggerTooltip');\n                }\n\n                axisPointerModel = fromTooltip\n                    ? makeAxisPointerModel(\n                        axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                        fromTooltip, triggerTooltip\n                    )\n                    : axisPointerModel;\n\n                var snap = axisPointerModel.get('snap');\n                var key = makeKey(axis.model);\n                var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n                // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n                var axisInfo = result.axesInfo[key] = {\n                    key: key,\n                    axis: axis,\n                    coordSys: coordSys,\n                    axisPointerModel: axisPointerModel,\n                    triggerTooltip: triggerTooltip,\n                    involveSeries: involveSeries,\n                    snap: snap,\n                    useHandle: isHandleTrigger(axisPointerModel),\n                    seriesModels: []\n                };\n                axesInfoInCoordSys[key] = axisInfo;\n                result.seriesInvolved |= involveSeries;\n\n                var groupIndex = getLinkGroupIndex(linksOption, axis);\n                if (groupIndex != null) {\n                    var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                    linkGroup.axesInfo[key] = axisInfo;\n                    linkGroup.mapper = linksOption[groupIndex].mapper;\n                    axisInfo.linkGroup = linkGroup;\n                }\n            }\n        });\n    }\n\n    function makeAxisPointerModel(\n        axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n    ) {\n        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n        var volatileOption = {};\n\n        each(\n            [\n                'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n                'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n            ],\n            function (field) {\n                volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n            }\n        );\n\n        // category axis do not auto snap, otherwise some tick that do not\n        // has value can not be hovered. value/time/log axis default snap if\n        // triggered from tooltip and trigger tooltip.\n        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n        // Compatibel with previous behavior, tooltip axis do not show label by default.\n        // Only these properties can be overrided from tooltip to axisPointer.\n        if (tooltipAxisPointerModel.get('type') === 'cross') {\n            volatileOption.type = 'line';\n        }\n        var labelOption = volatileOption.label || (volatileOption.label = {});\n        // Follow the convention, do not show label when triggered by tooltip by default.\n        labelOption.show == null && (labelOption.show = false);\n\n        if (fromTooltip === 'cross') {\n            // When 'cross', both axes show labels.\n            labelOption.show = true;\n            // If triggerTooltip, this is a base axis, which should better not use cross style\n            // (cross style is dashed by default)\n            if (!triggerTooltip) {\n                var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n                crossStyle && zrUtil.defaults(\n                    labelOption.textStyle || (labelOption.textStyle = {}),\n                    crossStyle.textStyle\n                );\n            }\n        }\n\n        return axis.model.getModel(\n            'axisPointer',\n            new Model(volatileOption, globalAxisPointerModel, ecModel)\n        );\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n        // Prepare data for axis trigger\n        ecModel.eachSeries(function (seriesModel) {\n\n            // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n            var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n            if (!coordSys\n                || seriesTooltipTrigger === 'none'\n                || seriesTooltipTrigger === false\n                || seriesTooltipTrigger === 'item'\n                || seriesTooltipShow === false\n                || seriesModel.get('axisPointer.show', true) === false\n            ) {\n                return;\n            }\n\n            each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n                var axis = axisInfo.axis;\n                if (coordSys.getAxis(axis.dim) === axis) {\n                    axisInfo.seriesModels.push(seriesModel);\n                    axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                    axisInfo.seriesDataCount += seriesModel.getData().count();\n                }\n            });\n\n        }, this);\n    }\n\n    /**\n     * For example:\n     * {\n     *     axisPointer: {\n     *         links: [{\n     *             xAxisIndex: [2, 4],\n     *             yAxisIndex: 'all'\n     *         }, {\n     *             xAxisId: ['a5', 'a7'],\n     *             xAxisName: 'xxx'\n     *         }]\n     *     }\n     * }\n     */\n    function getLinkGroupIndex(linksOption, axis) {\n        var axisModel = axis.model;\n        var dim = axis.dim;\n        for (var i = 0; i < linksOption.length; i++) {\n            var linkOption = linksOption[i] || {};\n            if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n                || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n                || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n            ) {\n                return i;\n            }\n        }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n        return linkPropValue === 'all'\n            || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0)\n            || linkPropValue === axisPropValue;\n    }\n\n    helper.fixValue = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        if (!axisInfo) {\n            return;\n        }\n\n        var axisPointerModel = axisInfo.axisPointerModel;\n        var scale = axisInfo.axis.scale;\n        var option = axisPointerModel.option;\n        var status = axisPointerModel.get('status');\n        var value = axisPointerModel.get('value');\n\n        // Parse init value for category and time axis.\n        if (value != null) {\n            value = scale.parse(value);\n        }\n\n        var useHandle = isHandleTrigger(axisPointerModel);\n        // If `handle` used, `axisPointer` will always be displayed, so value\n        // and status should be initialized.\n        if (status == null) {\n            option.status = useHandle ? 'show' : 'hide';\n        }\n\n        var extent = scale.getExtent().slice();\n        extent[0] > extent[1] && extent.reverse();\n\n        if (// Pick a value on axis when initializing.\n            value == null\n            // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n            // where we should re-pick a value to keep `handle` displaying normally.\n            || value > extent[1]\n        ) {\n            // Make handle displayed on the end of the axis when init, which looks better.\n            value = extent[1];\n        }\n        if (value < extent[0]) {\n            value = extent[0];\n        }\n\n        option.value = value;\n\n        if (useHandle) {\n            option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n        }\n    };\n\n    helper.getAxisInfo = function (axisModel) {\n        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    };\n\n    helper.getAxisPointerModel = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        return axisInfo && axisInfo.axisPointerModel;\n    };\n\n    function isHandleTrigger(axisPointerModel) {\n        return !!axisPointerModel.get('handle.show');\n    }\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @return {string} unique key\n     */\n    var makeKey = helper.makeKey = function (model) {\n        return model.type + '||' + model.id;\n    };\n\n    module.exports = helper;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9tb2RlbEhlbHBlci5qcz8xZmJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWIsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xuXG4gICAgdmFyIGhlbHBlciA9IHt9O1xuXG4gICAgLy8gQnVpbGQgYXhpc1BvaW50ZXJNb2RlbCwgbWVyZ2luIHRvb2x0aXAuYXhpc1BvaW50ZXIgbW9kZWwgZm9yIGVhY2ggYXhpcy5cbiAgICAvLyBhbGxBeGVzSW5mbyBzaG91bGQgYmUgdXBkYXRlZCB3aGVuIHNldE9wdGlvbiBwZXJmb3JtZWQuXG4gICAgaGVscGVyLmNvbGxlY3QgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGtleTogbWFrZUtleShheGlzLm1vZGVsKVxuICAgICAgICAgICAgICogdmFsdWU6IHtcbiAgICAgICAgICAgICAqICAgICAgYXhpcyxcbiAgICAgICAgICAgICAqICAgICAgY29vcmRTeXMsXG4gICAgICAgICAgICAgKiAgICAgIGF4aXNQb2ludGVyTW9kZWwsXG4gICAgICAgICAgICAgKiAgICAgIHRyaWdnZXJUb29sdGlwLFxuICAgICAgICAgICAgICogICAgICBpbnZvbHZlU2VyaWVzLFxuICAgICAgICAgICAgICogICAgICBzbmFwLFxuICAgICAgICAgICAgICogICAgICBzZXJpZXNNb2RlbHMsXG4gICAgICAgICAgICAgKiAgICAgIHNlcmllc0RhdGFDb3VudFxuICAgICAgICAgICAgICogfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBheGVzSW5mbzoge30sXG4gICAgICAgICAgICBzZXJpZXNJbnZvbHZlZDogZmFsc2UsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGtleTogbWFrZUtleShjb29yZFN5cy5tb2RlbClcbiAgICAgICAgICAgICAqIHZhbHVlOiBPYmplY3Q6IGtleSBtYWtlS2V5KGF4aXMubW9kZWwpLCB2YWx1ZTogYXhpc0luZm9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29vcmRTeXNBeGVzSW5mbzoge30sXG4gICAgICAgICAgICBjb29yZFN5c01hcDoge31cbiAgICAgICAgfTtcblxuICAgICAgICBjb2xsZWN0QXhlc0luZm8ocmVzdWx0LCBlY01vZGVsLCBhcGkpO1xuXG4gICAgICAgIC8vIENoZWNrIHNlcmllc0ludm9sdmVkIGZvciBwZXJmb3JtYW5jZSwgaW4gY2FzZSB0b28gbWFueSBzZXJpZXMgaW4gc29tZSBjaGFydC5cbiAgICAgICAgcmVzdWx0LnNlcmllc0ludm9sdmVkICYmIGNvbGxlY3RTZXJpZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBnbG9iYWxUb29sdGlwTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndG9vbHRpcCcpO1xuICAgICAgICB2YXIgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpO1xuICAgICAgICAvLyBsaW5rcyBjYW4gb25seSBiZSBzZXQgb24gZ2xvYmFsLlxuICAgICAgICB2YXIgbGlua3NPcHRpb24gPSBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLmdldCgnbGluaycsIHRydWUpIHx8IFtdO1xuICAgICAgICB2YXIgbGlua0dyb3VwcyA9IFtdO1xuXG4gICAgICAgIC8vIENvbGxlY3QgYXhlcyBpbmZvLlxuICAgICAgICBlYWNoKGFwaS5nZXRDb29yZGluYXRlU3lzdGVtcygpLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgY29vcmRpbmF0ZSBzeXN0ZW0gZG8gbm90IHN1cHBvcnQgYXhlcywgbGlrZSBnZW8uXG4gICAgICAgICAgICBpZiAoIWNvb3JkU3lzLmF4aXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvb3JkU3lzS2V5ID0gbWFrZUtleShjb29yZFN5cy5tb2RlbCk7XG4gICAgICAgICAgICB2YXIgYXhlc0luZm9JbkNvb3JkU3lzID0gcmVzdWx0LmNvb3JkU3lzQXhlc0luZm9bY29vcmRTeXNLZXldID0ge307XG4gICAgICAgICAgICByZXN1bHQuY29vcmRTeXNNYXBbY29vcmRTeXNLZXldID0gY29vcmRTeXM7XG5cbiAgICAgICAgICAgIC8vIFNldCB0b29sdGlwIChsaWtlICdjcm9zcycpIGlzIGEgY29udmllbmVudCB3YXkgdG8gc2hvdyBheGlzUG9pbnRlclxuICAgICAgICAgICAgLy8gZm9yIHVzZXIuIFNvIHdlIGVuYWJsZSBzZXRpbmcgdG9vbHRpcCBvbiBjb29yZFN5cyBtb2RlbC5cbiAgICAgICAgICAgIHZhciBjb29yZFN5c01vZGVsID0gY29vcmRTeXMubW9kZWw7XG4gICAgICAgICAgICB2YXIgYmFzZVRvb2x0aXBNb2RlbCA9IGNvb3JkU3lzTW9kZWwuZ2V0TW9kZWwoJ3Rvb2x0aXAnLCBnbG9iYWxUb29sdGlwTW9kZWwpO1xuXG4gICAgICAgICAgICBlYWNoKGNvb3JkU3lzLmdldEF4ZXMoKSwgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgZmFsc2UsIG51bGwpKTtcblxuICAgICAgICAgICAgLy8gSWYgYXhpcyB0b29sdGlwIHVzZWQsIGNob29zZSB0b29sdGlwIGF4aXMgZm9yIGVhY2ggY29vcmRTeXMuXG4gICAgICAgICAgICAvLyBOb3RpY2UgdGhpcyBjYXNlOiBjb29yZFN5cyBpcyBgZ3JpZGAgYnV0IG5vdCBgY2FydGVzaWFuMkRgIGhlcmUuXG4gICAgICAgICAgICBpZiAoY29vcmRTeXMuZ2V0VG9vbHRpcEF4ZXNcbiAgICAgICAgICAgICAgICAmJiBnbG9iYWxUb29sdGlwTW9kZWxcbiAgICAgICAgICAgICAgICAvLyBJZiB0b29sdGlwLnNob3dDb250ZW50IGlzIHNldCBhcyBmYWxzZSwgdG9vbHRpcCB3aWxsIG5vdFxuICAgICAgICAgICAgICAgIC8vIHNob3cgYnV0IGF4aXNQb2ludGVyIHdpbGwgc2hvdyBhcyBub3JtYWwuXG4gICAgICAgICAgICAgICAgJiYgYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIGxvZ2ljLiBCdXQgc2VyaWVzLnRvb2x0aXAudHJpZ2dlcjogJ2F4aXMnXG4gICAgICAgICAgICAgICAgLy8gb3Igc2VyaWVzLmRhdGFbbl0udG9vbHRpcC50cmlnZ2VyOiAnYXhpcycgYXJlIG5vdCBzdXBwb3J0IGFueSBtb3JlLlxuICAgICAgICAgICAgICAgIHZhciB0cmlnZ2VyQXhpcyA9IGJhc2VUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJykgPT09ICdheGlzJztcbiAgICAgICAgICAgICAgICB2YXIgY3Jvc3MgPSBiYXNlVG9vbHRpcE1vZGVsLmdldCgnYXhpc1BvaW50ZXIudHlwZScpID09PSAnY3Jvc3MnO1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwQXhlcyA9IGNvb3JkU3lzLmdldFRvb2x0aXBBeGVzKGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdheGlzUG9pbnRlci5heGlzJykpO1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyQXhpcyB8fCBjcm9zcykge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKHRvb2x0aXBBeGVzLmJhc2VBeGVzLCBjdXJyeShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVUb29sdGlwQXhpc0luZm8sIGNyb3NzID8gJ2Nyb3NzJyA6IHRydWUsIHRyaWdnZXJBeGlzXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaCh0b29sdGlwQXhlcy5vdGhlckF4ZXMsIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sICdjcm9zcycsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmcm9tVG9vbHRpcDogdHJ1ZSB8IGZhbHNlIHwgJ2Nyb3NzJ1xuICAgICAgICAgICAgLy8gdHJpZ2dlclRvb2x0aXA6IHRydWUgfCBmYWxzZSB8IG51bGxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNhdmVUb29sdGlwQXhpc0luZm8oZnJvbVRvb2x0aXAsIHRyaWdnZXJUb29sdGlwLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzLm1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyU2hvdyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFheGlzUG9pbnRlclNob3cgfHwgKFxuICAgICAgICAgICAgICAgICAgICBheGlzUG9pbnRlclNob3cgPT09ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICAmJiAhZnJvbVRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKVxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyVG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJUb29sdGlwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJUb29sdGlwJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXhpc1BvaW50ZXJNb2RlbCA9IGZyb21Ub29sdGlwXG4gICAgICAgICAgICAgICAgICAgID8gbWFrZUF4aXNQb2ludGVyTW9kZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLCBiYXNlVG9vbHRpcE1vZGVsLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVRvb2x0aXAsIHRyaWdnZXJUb29sdGlwXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBheGlzUG9pbnRlck1vZGVsO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNuYXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc25hcCcpO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBtYWtlS2V5KGF4aXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHZhciBpbnZvbHZlU2VyaWVzID0gdHJpZ2dlclRvb2x0aXAgfHwgc25hcCB8fCBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiByZXN1bHQuYXhlc0luZm9ba2V5XSBleGlzdCwgb3ZlcnJpZGUgaXQgKHRvb2x0aXAgaGFzIGhpZ2hlciBwcmlvcml0eSkuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNJbmZvID0gcmVzdWx0LmF4ZXNJbmZvW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICBheGlzOiBheGlzLFxuICAgICAgICAgICAgICAgICAgICBjb29yZFN5czogY29vcmRTeXMsXG4gICAgICAgICAgICAgICAgICAgIGF4aXNQb2ludGVyTW9kZWw6IGF4aXNQb2ludGVyTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJUb29sdGlwOiB0cmlnZ2VyVG9vbHRpcCxcbiAgICAgICAgICAgICAgICAgICAgaW52b2x2ZVNlcmllczogaW52b2x2ZVNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgICAgICAgICAgICAgdXNlSGFuZGxlOiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCksXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF4ZXNJbmZvSW5Db29yZFN5c1trZXldID0gYXhpc0luZm87XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNlcmllc0ludm9sdmVkIHw9IGludm9sdmVTZXJpZXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGdldExpbmtHcm91cEluZGV4KGxpbmtzT3B0aW9uLCBheGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rR3JvdXAgPSBsaW5rR3JvdXBzW2dyb3VwSW5kZXhdIHx8IChsaW5rR3JvdXBzW2dyb3VwSW5kZXhdID0ge2F4ZXNJbmZvOiB7fX0pO1xuICAgICAgICAgICAgICAgICAgICBsaW5rR3JvdXAuYXhlc0luZm9ba2V5XSA9IGF4aXNJbmZvO1xuICAgICAgICAgICAgICAgICAgICBsaW5rR3JvdXAubWFwcGVyID0gbGlua3NPcHRpb25bZ3JvdXBJbmRleF0ubWFwcGVyO1xuICAgICAgICAgICAgICAgICAgICBheGlzSW5mby5saW5rR3JvdXAgPSBsaW5rR3JvdXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXhpc1BvaW50ZXJNb2RlbChcbiAgICAgICAgYXhpcywgYmFzZVRvb2x0aXBNb2RlbCwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCwgZnJvbVRvb2x0aXAsIHRyaWdnZXJUb29sdGlwXG4gICAgKSB7XG4gICAgICAgIHZhciB0b29sdGlwQXhpc1BvaW50ZXJNb2RlbCA9IGJhc2VUb29sdGlwTW9kZWwuZ2V0TW9kZWwoJ2F4aXNQb2ludGVyJyk7XG4gICAgICAgIHZhciB2b2xhdGlsZU9wdGlvbiA9IHt9O1xuXG4gICAgICAgIGVhY2goXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3R5cGUnLCAnc25hcCcsICdsaW5lU3R5bGUnLCAnc2hhZG93U3R5bGUnLCAnbGFiZWwnLFxuICAgICAgICAgICAgICAgICdhbmltYXRpb24nLCAnYW5pbWF0aW9uRHVyYXRpb25VcGRhdGUnLCAnYW5pbWF0aW9uRWFzaW5nVXBkYXRlJywgJ3onXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdm9sYXRpbGVPcHRpb25bZmllbGRdID0genJVdGlsLmNsb25lKHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldChmaWVsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNhdGVnb3J5IGF4aXMgZG8gbm90IGF1dG8gc25hcCwgb3RoZXJ3aXNlIHNvbWUgdGljayB0aGF0IGRvIG5vdFxuICAgICAgICAvLyBoYXMgdmFsdWUgY2FuIG5vdCBiZSBob3ZlcmVkLiB2YWx1ZS90aW1lL2xvZyBheGlzIGRlZmF1bHQgc25hcCBpZlxuICAgICAgICAvLyB0cmlnZ2VyZWQgZnJvbSB0b29sdGlwIGFuZCB0cmlnZ2VyIHRvb2x0aXAuXG4gICAgICAgIHZvbGF0aWxlT3B0aW9uLnNuYXAgPSBheGlzLnR5cGUgIT09ICdjYXRlZ29yeScgJiYgISF0cmlnZ2VyVG9vbHRpcDtcblxuICAgICAgICAvLyBDb21wYXRpYmVsIHdpdGggcHJldmlvdXMgYmVoYXZpb3IsIHRvb2x0aXAgYXhpcyBkbyBub3Qgc2hvdyBsYWJlbCBieSBkZWZhdWx0LlxuICAgICAgICAvLyBPbmx5IHRoZXNlIHByb3BlcnRpZXMgY2FuIGJlIG92ZXJyaWRlZCBmcm9tIHRvb2x0aXAgdG8gYXhpc1BvaW50ZXIuXG4gICAgICAgIGlmICh0b29sdGlwQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgdm9sYXRpbGVPcHRpb24udHlwZSA9ICdsaW5lJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFiZWxPcHRpb24gPSB2b2xhdGlsZU9wdGlvbi5sYWJlbCB8fCAodm9sYXRpbGVPcHRpb24ubGFiZWwgPSB7fSk7XG4gICAgICAgIC8vIEZvbGxvdyB0aGUgY29udmVudGlvbiwgZG8gbm90IHNob3cgbGFiZWwgd2hlbiB0cmlnZ2VyZWQgYnkgdG9vbHRpcCBieSBkZWZhdWx0LlxuICAgICAgICBsYWJlbE9wdGlvbi5zaG93ID09IG51bGwgJiYgKGxhYmVsT3B0aW9uLnNob3cgPSBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGZyb21Ub29sdGlwID09PSAnY3Jvc3MnKSB7XG4gICAgICAgICAgICAvLyBXaGVuICdjcm9zcycsIGJvdGggYXhlcyBzaG93IGxhYmVscy5cbiAgICAgICAgICAgIGxhYmVsT3B0aW9uLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgLy8gSWYgdHJpZ2dlclRvb2x0aXAsIHRoaXMgaXMgYSBiYXNlIGF4aXMsIHdoaWNoIHNob3VsZCBiZXR0ZXIgbm90IHVzZSBjcm9zcyBzdHlsZVxuICAgICAgICAgICAgLy8gKGNyb3NzIHN0eWxlIGlzIGRhc2hlZCBieSBkZWZhdWx0KVxuICAgICAgICAgICAgaWYgKCF0cmlnZ2VyVG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHZhciBjcm9zc1N0eWxlID0gdm9sYXRpbGVPcHRpb24ubGluZVN0eWxlID0gdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCdjcm9zc1N0eWxlJyk7XG4gICAgICAgICAgICAgICAgY3Jvc3NTdHlsZSAmJiB6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsT3B0aW9uLnRleHRTdHlsZSB8fCAobGFiZWxPcHRpb24udGV4dFN0eWxlID0ge30pLFxuICAgICAgICAgICAgICAgICAgICBjcm9zc1N0eWxlLnRleHRTdHlsZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXhpcy5tb2RlbC5nZXRNb2RlbChcbiAgICAgICAgICAgICdheGlzUG9pbnRlcicsXG4gICAgICAgICAgICBuZXcgTW9kZWwodm9sYXRpbGVPcHRpb24sIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFNlcmllc0luZm8ocmVzdWx0LCBlY01vZGVsKSB7XG4gICAgICAgIC8vIFByZXBhcmUgZGF0YSBmb3IgYXhpcyB0cmlnZ2VyXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcblxuICAgICAgICAgICAgLy8gTm90aWNlIHRoaXMgY2FzZTogdGhpcyBjb29yZFN5cyBpcyBgY2FydGVzaWFuMkRgIGJ1dCBub3QgYGdyaWRgLlxuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNUb29sdGlwVHJpZ2dlciA9IHNlcmllc01vZGVsLmdldCgndG9vbHRpcC50cmlnZ2VyJywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgc2VyaWVzVG9vbHRpcFNob3cgPSBzZXJpZXNNb2RlbC5nZXQoJ3Rvb2x0aXAuc2hvdycsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFjb29yZFN5c1xuICAgICAgICAgICAgICAgIHx8IHNlcmllc1Rvb2x0aXBUcmlnZ2VyID09PSAnbm9uZSdcbiAgICAgICAgICAgICAgICB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gJ2l0ZW0nXG4gICAgICAgICAgICAgICAgfHwgc2VyaWVzVG9vbHRpcFNob3cgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgfHwgc2VyaWVzTW9kZWwuZ2V0KCdheGlzUG9pbnRlci5zaG93JywgdHJ1ZSkgPT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVhY2gocmVzdWx0LmNvb3JkU3lzQXhlc0luZm9bbWFrZUtleShjb29yZFN5cy5tb2RlbCldLCBmdW5jdGlvbiAoYXhpc0luZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkU3lzLmdldEF4aXMoYXhpcy5kaW0pID09PSBheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNJbmZvLnNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ID09IG51bGwgJiYgKGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCA9IDApO1xuICAgICAgICAgICAgICAgICAgICBheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgKz0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGV4YW1wbGU6XG4gICAgICoge1xuICAgICAqICAgICBheGlzUG9pbnRlcjoge1xuICAgICAqICAgICAgICAgbGlua3M6IFt7XG4gICAgICogICAgICAgICAgICAgeEF4aXNJbmRleDogWzIsIDRdLFxuICAgICAqICAgICAgICAgICAgIHlBeGlzSW5kZXg6ICdhbGwnXG4gICAgICogICAgICAgICB9LCB7XG4gICAgICogICAgICAgICAgICAgeEF4aXNJZDogWydhNScsICdhNyddLFxuICAgICAqICAgICAgICAgICAgIHhBeGlzTmFtZTogJ3h4eCdcbiAgICAgKiAgICAgICAgIH1dXG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TGlua0dyb3VwSW5kZXgobGlua3NPcHRpb24sIGF4aXMpIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICAgIHZhciBkaW0gPSBheGlzLmRpbTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rc09wdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmtPcHRpb24gPSBsaW5rc09wdGlvbltpXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc0lkJ10sIGF4aXNNb2RlbC5pZClcbiAgICAgICAgICAgICAgICB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc0luZGV4J10sIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleClcbiAgICAgICAgICAgICAgICB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc05hbWUnXSwgYXhpc01vZGVsLm5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUHJvcEluTGluayhsaW5rUHJvcFZhbHVlLCBheGlzUHJvcFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsaW5rUHJvcFZhbHVlID09PSAnYWxsJ1xuICAgICAgICAgICAgfHwgKHpyVXRpbC5pc0FycmF5KGxpbmtQcm9wVmFsdWUpICYmIHpyVXRpbC5pbmRleE9mKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpID49IDApXG4gICAgICAgICAgICB8fCBsaW5rUHJvcFZhbHVlID09PSBheGlzUHJvcFZhbHVlO1xuICAgIH1cblxuICAgIGhlbHBlci5maXhWYWx1ZSA9IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGF4aXNJbmZvID0gaGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG4gICAgICAgIGlmICghYXhpc0luZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpc0luZm8uYXhpcy5zY2FsZTtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgICAgICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpO1xuICAgICAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcblxuICAgICAgICAvLyBQYXJzZSBpbml0IHZhbHVlIGZvciBjYXRlZ29yeSBhbmQgdGltZSBheGlzLlxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBzY2FsZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXNlSGFuZGxlID0gaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAvLyBJZiBgaGFuZGxlYCB1c2VkLCBgYXhpc1BvaW50ZXJgIHdpbGwgYWx3YXlzIGJlIGRpc3BsYXllZCwgc28gdmFsdWVcbiAgICAgICAgLy8gYW5kIHN0YXR1cyBzaG91bGQgYmUgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmIChzdGF0dXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uLnN0YXR1cyA9IHVzZUhhbmRsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRlbnQgPSBzY2FsZS5nZXRFeHRlbnQoKS5zbGljZSgpO1xuICAgICAgICBleHRlbnRbMF0gPiBleHRlbnRbMV0gJiYgZXh0ZW50LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoLy8gUGljayBhIHZhbHVlIG9uIGF4aXMgd2hlbiBpbml0aWFsaXppbmcuXG4gICAgICAgICAgICB2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICAvLyBJZiBib3RoIGBoYW5kbGVgIGFuZCBgZGF0YVpvb21gIGFyZSB1c2VkLCB2YWx1ZSBtYXkgYmUgb3V0IG9mIGF4aXMgZXh0ZW50LFxuICAgICAgICAgICAgLy8gd2hlcmUgd2Ugc2hvdWxkIHJlLXBpY2sgYSB2YWx1ZSB0byBrZWVwIGBoYW5kbGVgIGRpc3BsYXlpbmcgbm9ybWFsbHkuXG4gICAgICAgICAgICB8fCB2YWx1ZSA+IGV4dGVudFsxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIE1ha2UgaGFuZGxlIGRpc3BsYXllZCBvbiB0aGUgZW5kIG9mIHRoZSBheGlzIHdoZW4gaW5pdCwgd2hpY2ggbG9va3MgYmV0dGVyLlxuICAgICAgICAgICAgdmFsdWUgPSBleHRlbnRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgZXh0ZW50WzBdKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGV4dGVudFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh1c2VIYW5kbGUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zdGF0dXMgPSBheGlzSW5mby5heGlzLnNjYWxlLmlzQmxhbmsoKSA/ICdoaWRlJyA6ICdzaG93JztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBoZWxwZXIuZ2V0QXhpc0luZm8gPSBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBjb29yZFN5c0F4ZXNJbmZvID0gKGF4aXNNb2RlbC5lY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKSB8fCB7fSkuY29vcmRTeXNBeGVzSW5mbztcbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzQXhlc0luZm8gJiYgY29vcmRTeXNBeGVzSW5mby5heGVzSW5mb1ttYWtlS2V5KGF4aXNNb2RlbCldO1xuICAgIH07XG5cbiAgICBoZWxwZXIuZ2V0QXhpc1BvaW50ZXJNb2RlbCA9IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGF4aXNJbmZvID0gaGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG4gICAgICAgIHJldHVybiBheGlzSW5mbyAmJiBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICByZXR1cm4gISFheGlzUG9pbnRlck1vZGVsLmdldCgnaGFuZGxlLnNob3cnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdW5pcXVlIGtleVxuICAgICAqL1xuICAgIHZhciBtYWtlS2V5ID0gaGVscGVyLm1ha2VLZXkgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLnR5cGUgKyAnfHwnICsgbW9kZWwuaWQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL21vZGVsSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

eval("// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = __webpack_require__(0);\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qcz8wZmI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyBQYXJzZSBzaGFkb3cgc3R5bGVcbi8vIFRPRE8gT25seSBzaGFsbG93IHBhdGggc3VwcG9ydFxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAvLyBOb3JtYWxpemVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNbaV1bMV0pIHtcbiAgICAgICAgICAgICAgIHByb3BlcnRpZXNbaV1bMV0gPSBwcm9wZXJ0aWVzW2ldWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhjbHVkZXMsIGluY2x1ZGVzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnRpZXNbaV1bMV07XG4gICAgICAgICAgICAgICAgaWYgKChleGNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihleGNsdWRlcywgcHJvcE5hbWUpID49IDApXG4gICAgICAgICAgICAgICAgICAgIHx8IChpbmNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihpbmNsdWRlcywgcHJvcE5hbWUpIDwgMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFNoYWxsb3cocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVtwcm9wZXJ0aWVzW2ldWzBdXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = __webpack_require__(12);\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL1NjYWxlLmpzP2E5MDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAvLyBTY2FsZSBjbGFzcyBtYW5hZ2VtZW50XG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvU2NhbGVcbiAqL1xuXG5cbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzZXR0aW5nXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNjYWxlKHNldHRpbmcpIHtcbiAgICAgICAgdGhpcy5fc2V0dGluZyA9IHNldHRpbmcgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dGVudFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RlcCBpcyBjYWxjdWxhdGVkIGluIGFkanVzdEV4dGVudFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gMDtcblxuICAgICAgICB0aGlzLmluaXQgJiYgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlUHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBpbnB1dCB2YWwgdG8gdmFsaWQgaW5uZXIgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8ucGFyc2UgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIC8vIE5vdGljZTogVGhpcyB3b3VsZCBiZSBhIHRyYXAgaGVyZSwgSWYgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICAgIC8vIG9mIHRoaXMgbWV0aG9kIGRlcGVuZHMgb24gZXh0ZW50LCBhbmQgdGhpcyBtZXRob2QgaXMgdXNlZFxuICAgICAgICAvLyBiZWZvcmUgZXh0ZW50IHNldCAobGlrZSBpbiBkYXRhWm9vbSksIGl0IHdvdWxkIGJlIHdyb25nLlxuICAgICAgICAvLyBOZXZlcnRoZWxlc3MsIHBhcnNlIGRvZXMgbm90IGRlcGVuZCBvbiBleHRlbnQgZ2VuZXJhbGx5LlxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBzY2FsZVByb3RvLmdldFNldHRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ1tuYW1lXTtcbiAgICB9O1xuXG4gICAgc2NhbGVQcm90by5jb250YWluID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICByZXR1cm4gdmFsID49IGV4dGVudFswXSAmJiB2YWwgPD0gZXh0ZW50WzFdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdmFsdWUgdG8gbGluZWFyIFswLCAxXSwgcmV0dXJuIDAuNSBpZiBleHRlbnQgc3BhbiBpcyAwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgaWYgKGV4dGVudFsxXSA9PT0gZXh0ZW50WzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmFsIC0gZXh0ZW50WzBdKSAvIChleHRlbnRbMV0gLSBleHRlbnRbMF0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBub3JtYWxpemVkIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnNjYWxlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICByZXR1cm4gdmFsICogKGV4dGVudFsxXSAtIGV4dGVudFswXSkgKyBleHRlbnRbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBleHRlbnQgZnJvbSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3RoZXJcbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnVuaW9uRXh0ZW50ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgIG90aGVyWzBdIDwgZXh0ZW50WzBdICYmIChleHRlbnRbMF0gPSBvdGhlclswXSk7XG4gICAgICAgIG90aGVyWzFdID4gZXh0ZW50WzFdICYmIChleHRlbnRbMV0gPSBvdGhlclsxXSk7XG4gICAgICAgIC8vIG5vdCBzZXRFeHRlbnQgYmVjYXVzZSBpbiBsb2cgYXhpcyBpdCBtYXkgdHJhbnNmb3JtZWQgdG8gcG93ZXJcbiAgICAgICAgLy8gdGhpcy5zZXRFeHRlbnQoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8udW5pb25FeHRlbnRGcm9tRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBkaW0pIHtcbiAgICAgICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldERhdGFFeHRlbnQoZGltLCB0cnVlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBleHRlbnRcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLmdldEV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZXh0ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8uc2V0RXh0ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHRoaXNFeHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgIGlmICghaXNOYU4oc3RhcnQpKSB7XG4gICAgICAgICAgICB0aGlzRXh0ZW50WzBdID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTihlbmQpKSB7XG4gICAgICAgICAgICB0aGlzRXh0ZW50WzFdID0gZW5kO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8uZ2V0VGlja3NMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbHMucHVzaCh0aGlzLmdldExhYmVsKHRpY2tzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBheGlzIGV4dGVudCBkZXBlbmRzIG9uIGRhdGEgYW5kIG5vIGRhdGEgZXhpc3RzLFxuICAgICAqIGF4aXMgdGlja3Mgc2hvdWxkIG5vdCBiZSBkcmF3biwgd2hpY2ggaXMgbmFtZWQgJ2JsYW5rJy5cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLmlzQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0JsYW5rO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGF4aXMgZXh0ZW50IGRlcGVuZHMgb24gZGF0YSBhbmQgbm8gZGF0YSBleGlzdHMsXG4gICAgICogYXhpcyB0aWNrcyBzaG91bGQgbm90IGJlIGRyYXduLCB3aGljaCBpcyBuYW1lZCAnYmxhbmsnLlxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8uc2V0QmxhbmsgPSBmdW5jdGlvbiAoaXNCbGFuaykge1xuICAgICAgICB0aGlzLl9pc0JsYW5rID0gaXNCbGFuaztcbiAgICB9O1xuXG5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoU2NhbGUpO1xuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoU2NhbGUsIHtcbiAgICAgICAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNjYWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL1NjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

eval("\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbmZpZy5qcz84YmMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICB2YXIgZHByID0gMTtcbiAgICAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWfpu5jorqTphY3nva7poblcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAqL1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gICAgICAgICAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICAgICAgICAgKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRlYnVnTW9kZTogMCxcblxuICAgICAgICAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW86IGRwclxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var Element = __webpack_require__(68);\n    var BoundingRect = __webpack_require__(11);\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qcz82Njk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICBHcm91cC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdyb3VwLFxuXG4gICAgICAgIGlzR3JvdXA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpc1xuICAgICAgICAgICAgICAgICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgICAgICAgICB2YXIgcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgdG1wTWF0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vIFRoZSBib3VuZGluZ1JlY3QgY2FjbHVhdGVkIGJ5IHRyYW5zZm9ybWluZyBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIC8vIHJlY3QgbWF5IGJlIGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgYnVuZGluZ1JlY3Qgd2hlbiByb3RhdGlvblxuICAgICAgICAgICAgICAgIC8vIGlzIHVzZWQuIChDb25zaWRlciBhIGNpcmNsZSByb3RhdGVkIGFnaW5zdCBpdHMgY2VudGVyLCB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgYm91bmRpbmdSZWN0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGF0IG5vdCBiZVxuICAgICAgICAgICAgICAgIC8vIHJvdGF0ZWQuKSBCdXQgd2UgY2FuIG5vdCBmaW5kIGJldHRlciBhcHByb2FjaCB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWwgYm91bmRpbmdSZWN0IHlldCwgY29uc2lkZXJpbmcgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCB0bXBSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0IHx8IHRtcFJlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = __webpack_require__(18);\n    var vec2 = __webpack_require__(7);\n    var bbox = __webpack_require__(197);\n    var BoundingRect = __webpack_require__(11);\n    var dpr = __webpack_require__(26).devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzPzg5MTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFvRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixpQkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG4gLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxuXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBiYm94ID0gcmVxdWlyZSgnLi9iYm94Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIGRwciA9IHJlcXVpcmUoJy4uL2NvbmZpZycpLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgQ01EID0ge1xuICAgICAgICBNOiAxLFxuICAgICAgICBMOiAyLFxuICAgICAgICBDOiAzLFxuICAgICAgICBROiA0LFxuICAgICAgICBBOiA1LFxuICAgICAgICBaOiA2LFxuICAgICAgICAvLyBSZWN0XG4gICAgICAgIFI6IDdcbiAgICB9O1xuXG4gICAgLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbiAgICAvLyAgICAgTTogMyxcbiAgICAvLyAgICAgTDogMyxcbiAgICAvLyAgICAgQzogNyxcbiAgICAvLyAgICAgUTogNSxcbiAgICAvLyAgICAgQTogOSxcbiAgICAvLyAgICAgUjogNSxcbiAgICAvLyAgICAgWjogMVxuICAgIC8vIH07XG5cbiAgICB2YXIgbWluID0gW107XG4gICAgdmFyIG1heCA9IFtdO1xuICAgIHZhciBtaW4yID0gW107XG4gICAgdmFyIG1heDIgPSBbXTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgdmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuXG4gICAgICAgIHRoaXMuX3NhdmVEYXRhID0gIShub3RTYXZlRGF0YSB8fCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdHggPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlv6vpgJ/orqHnrpdQYXRo5YyF5Zu055uS77yI5bm25LiN5piv5pyA5bCP5YyF5Zu055uS77yJXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIFBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcblxuICAgICAgICBfeGk6IDAsXG4gICAgICAgIF95aTogMCxcblxuICAgICAgICBfeDA6IDAsXG4gICAgICAgIF95MDogMCxcbiAgICAgICAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gICAgICAgIF91eDogMCxcbiAgICAgICAgX3V5OiAwLFxuXG4gICAgICAgIF9sZW46IDAsXG5cbiAgICAgICAgX2xpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIF9kYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIF9kYXNoSWR4OiAwLFxuXG4gICAgICAgIF9kYXNoU3VtOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgICAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG5cbiAgICAgICAgICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTtcblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgICAgICAgICAvLyB4aSwgeWkg6K6w5b2V5b2T5YmN54K5LCB4MCwgeTAg5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnlm57liLDotbflp4vngrnjgIJcbiAgICAgICAgICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgICAgICAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcbiAgICAgICAgICAgIHRoaXMuX3gwID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0geTtcblxuICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBleGNlZWRVbml0ID0gbWF0aEFicyh4IC0gdGhpcy5feGkpID4gdGhpcy5fdXhcbiAgICAgICAgICAgICAgICB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eVxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9sZW4gPCA1O1xuXG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95aSA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDM7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MjtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKFxuICAgICAgICAgICAgICAgIENNRC5BLCBjeCwgY3ksIHIsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgMCwgYW50aWNsb2Nrd2lzZSA/IDAgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95MDtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDA7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAgICAgICAqIHN0cm9rZSDlkIzmoLdcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAobGluZURhc2ggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaFN1bSArPSBsaW5lRGFzaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT0gbGVuKSAmJiBoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGVuID0gbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5ICYmICh0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBlbmRQYXRoRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbb2Zmc2V0KytdID0gYXBwZW5kUGF0aERhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGVuID0gb2Zmc2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDloavlhYUgUGF0aCDmlbDmja7jgIJcbiAgICAgICAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBhZGREYXRhOiBmdW5jdGlvbiAoY21kKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGFbdGhpcy5fbGVuKytdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmVlZHMganMgaW1wbGVtZW50ZWQgZGFzaGVkIGxpbmVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgeCA9IHgwO1xuICAgICAgICAgICAgdmFyIHkgPSB5MDtcbiAgICAgICAgICAgIHZhciBkYXNoO1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgICAgIGR4IC89IGRpc3Q7XG4gICAgICAgICAgICBkeSAvPSBkaXN0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICAgICAgICAgIHkgLT0gb2Zmc2V0ICogZHk7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZHggPiAwICYmIHggPD0geDEpIHx8IChkeCA8IDAgJiYgeCA+PSB4MSlcbiAgICAgICAgICAgIHx8IChkeCA9PSAwICYmICgoZHkgPiAwICYmIHkgPD0geTEpIHx8IChkeSA8IDAgJiYgeSA+PSB5MSkpKSkge1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICAgICAgICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgaWYgKChkeCA+IDAgJiYgeCA8IHgwKSB8fCAoZHggPCAwICYmIHggPiB4MCkgfHwgKGR5ID4gMCAmJiB5IDwgeTApIHx8IChkeSA8IDAgJiYgeSA+IHkwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcbiAgICAgICAgICAgICAgICAgICAgZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksXG4gICAgICAgICAgICAgICAgICAgIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cbiAgICAgICAgICAgIGR4ID0geCAtIHgxO1xuICAgICAgICAgICAgZHkgPSB5IC0geTE7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgICAgICAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIHZhciBkeDtcbiAgICAgICAgICAgIHZhciBkeTtcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICAgICAgICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcbiAgICAgICAgICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgICAgICAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgICAgICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuICAgICAgICAgICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICB3aGlsZSAodCA8PSAxKSB7XG5cbiAgICAgICAgICAgICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgICAgICAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG4gICAgICAgICAgICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcbiAgICAgICAgICAgIChpZHggJSAyICE9PSAwKSAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgICAgICAgICBkeCA9IHgzIC0geDtcbiAgICAgICAgICAgIGR5ID0geTMgLSB5O1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgIHZhciB4MyA9IHgyO1xuICAgICAgICAgICAgdmFyIHkzID0geTI7XG4gICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICAgICAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUN1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21BcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBmcm9tTGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4MCwgeTAsIHgwICsgd2lkdGgsIHkwICsgaGVpZ2h0LCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbmlvblxuICAgICAgICAgICAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGRhdGFcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICAgICAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHgwLCB5MDtcbiAgICAgICAgICAgIHZhciB4aSwgeWk7XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIHZhciB1eCA9IHRoaXMuX3V4O1xuICAgICAgICAgICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZFtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gKHJ4ID4gcnkpID8gcnggOiByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSAocnggPiByeSkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVkgPSAocnggPiByeSkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VsbGlwc2UgPSBNYXRoLmFicyhyeCAtIHJ5KSA+IDFlLTM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhQcm94eS5DTUQgPSBDTUQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGhQcm94eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(230),\n  /* template */\n  __webpack_require__(266),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.list.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.list.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-caa94782\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-caa94782\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0LnZ1ZT85ZWUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcGtzLmxpc3QudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1jYWE5NDc4MlxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3MubGlzdC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MubGlzdC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5saXN0LnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1jYWE5NDc4MlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWNhYTk0NzgyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL0Nvb3JkaW5hdGVTeXN0ZW0uanM/YjJhNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzID0ge307XG5cbiAgICBmdW5jdGlvbiBDb29yZGluYXRlU3lzdGVtTWFuYWdlcigpIHtcblxuICAgICAgICB0aGlzLl9jb29yZGluYXRlU3lzdGVtcyA9IFtdO1xuICAgIH1cblxuICAgIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIsXG5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9ycywgZnVuY3Rpb24gKGNyZWF0ZXIsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IGNyZWF0ZXIuY3JlYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbXMgPSBjb29yZGluYXRlU3lzdGVtcy5jb25jYXQobGlzdCB8fCBbXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMgPSBjb29yZGluYXRlU3lzdGVtcztcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBNVVNUIGhhdmVcbiAgICAgICAgICAgICAgICBjb29yZFN5cy51cGRhdGUgJiYgY29vcmRTeXMudXBkYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb29yZGluYXRlU3lzdGVtczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAodHlwZSwgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3IpIHtcbiAgICAgICAgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdID0gY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3I7XG4gICAgfTtcblxuICAgIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var List = __webpack_require__(61);\n    var completeDimensions = __webpack_require__(62);\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n    var CoordinateSystem = __webpack_require__(31);\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // 多个散点图系列在同一个地区的时候\n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5LmpzPzNhMzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgTGlzdCA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvTGlzdCcpO1xuICAgIHZhciBjb21wbGV0ZURpbWVuc2lvbnMgPSByZXF1aXJlKCcuLi8uLi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgQ29vcmRpbmF0ZVN5c3RlbSA9IHJlcXVpcmUoJy4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgICB2YXIgZ2V0RGF0YUl0ZW1WYWx1ZSA9IG1vZGVsVXRpbC5nZXREYXRhSXRlbVZhbHVlO1xuICAgIHZhciBjb252ZXJEYXRhVmFsdWUgPSBtb2RlbFV0aWwuY29udmVyRGF0YVZhbHVlO1xuXG4gICAgZnVuY3Rpb24gZmlyc3REYXRhTm90TnVsbChkYXRhKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCAmJiBkYXRhW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVtpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWZOZWVkQ29tcGxldGVPcmRpbmFsRGF0YShkYXRhKSB7XG4gICAgICAgIHZhciBzYW1wbGVJdGVtID0gZmlyc3REYXRhTm90TnVsbChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZUl0ZW0gIT0gbnVsbFxuICAgICAgICAgICAgJiYgIXpyVXRpbC5pc0FycmF5KGdldERhdGFJdGVtVmFsdWUoc2FtcGxlSXRlbSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBsaXN0IGZyb20gb3B0aW9uIGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVMaXN0RnJvbUFycmF5KGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgIC8vIElmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRTeXNOYW1lID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG4gICAgICAgIHZhciBjcmVhdG9yID0gY3JlYXRvcnNbY29vcmRTeXNOYW1lXTtcbiAgICAgICAgdmFyIHJlZ2lzdGVyZWRDb29yZFN5cyA9IENvb3JkaW5hdGVTeXN0ZW0uZ2V0KGNvb3JkU3lzTmFtZSk7XG4gICAgICAgIHZhciBjb21wbGV0ZURpbU9wdCA9IHtcbiAgICAgICAgICAgIGVuY29kZURlZjogc2VyaWVzTW9kZWwuZ2V0KCdlbmNvZGUnKSxcbiAgICAgICAgICAgIGRpbXNEZWY6IHNlcmllc01vZGVsLmdldCgnZGltZW5zaW9ucycpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgdmFyIGF4ZXNJbmZvID0gY3JlYXRvciAmJiBjcmVhdG9yKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCk7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gYXhlc0luZm8gJiYgYXhlc0luZm8uZGltZW5zaW9ucztcbiAgICAgICAgaWYgKCFkaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAvLyBHZXQgZGltZW5zaW9ucyBmcm9tIHJlZ2lzdGVyZWQgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSAocmVnaXN0ZXJlZENvb3JkU3lzICYmIChcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkQ29vcmRTeXMuZ2V0RGltZW5zaW9uc0luZm9cbiAgICAgICAgICAgICAgICAgICAgPyByZWdpc3RlcmVkQ29vcmRTeXMuZ2V0RGltZW5zaW9uc0luZm8oKVxuICAgICAgICAgICAgICAgICAgICA6IHJlZ2lzdGVyZWRDb29yZFN5cy5kaW1lbnNpb25zLnNsaWNlKClcbiAgICAgICAgICAgICkpIHx8IFsneCcsICd5J107XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKGRpbWVuc2lvbnMsIGRhdGEsIGNvbXBsZXRlRGltT3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYXRlZ29yeUluZGV4ID0gYXhlc0luZm8gPyBheGVzSW5mby5jYXRlZ29yeUluZGV4IDogLTE7XG5cbiAgICAgICAgdmFyIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25zLCBzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgdmFyIG5hbWVMaXN0ID0gY3JlYXRlTmFtZUxpc3QoYXhlc0luZm8sIGRhdGEpO1xuXG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0ge307XG4gICAgICAgIHZhciBkaW1WYWx1ZUdldHRlciA9IChjYXRlZ29yeUluZGV4ID49IDAgJiYgaWZOZWVkQ29tcGxldGVPcmRpbmFsRGF0YShkYXRhKSlcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGl0ZW1PcHQsIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uKGl0ZW1PcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGRhdGFJbmRleCBhcyBvcmRpbmFsIHZhbHVlIGluIGNhdGVnb3J5QXhpc1xuICAgICAgICAgICAgICAgIHJldHVybiBkaW1JbmRleCA9PT0gY2F0ZWdvcnlJbmRleFxuICAgICAgICAgICAgICAgICAgICA/IGRhdGFJbmRleFxuICAgICAgICAgICAgICAgICAgICA6IGNvbnZlckRhdGFWYWx1ZShnZXREYXRhSXRlbVZhbHVlKGl0ZW1PcHQpLCBkaW1lbnNpb25zW2RpbUluZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChpdGVtT3B0LCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0RGF0YUl0ZW1WYWx1ZShpdGVtT3B0KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gY29udmVyRGF0YVZhbHVlKHZhbHVlICYmIHZhbHVlW2RpbUluZGV4XSwgZGltZW5zaW9uc1tkaW1JbmRleF0pO1xuICAgICAgICAgICAgICAgIC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oaXRlbU9wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0gYXhlc0luZm8gJiYgYXhlc0luZm8uY2F0ZWdvcnlBeGVzTW9kZWxzO1xuICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeUF4ZXNNb2RlbHMgJiYgY2F0ZWdvcnlBeGVzTW9kZWxzW2RpbU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGdpdmVuIHZhbHVlIGlzIGEgY2F0ZWdvcnkgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGF6eSBnZXQgY2F0ZWdvcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllc1tkaW1OYW1lXSA9IGNhdGVnb3JpZXNbZGltTmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0uZ2V0Q2F0ZWdvcmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0genJVdGlsLmluZGV4T2YoY2F0ZWdvcmllc1tkaW1OYW1lXSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPCAwICYmICFpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBzb21lIG9uZSB3cml0ZSAnMScsICcyJyBpc3RlYWQgb2YgMSwgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9ICt2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gZmFsc2U7XG4gICAgICAgIGxpc3QuaW5pdERhdGEoZGF0YSwgbmFtZUxpc3QsIGRpbVZhbHVlR2V0dGVyKTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N0YWNrYWJsZShheGlzVHlwZSkge1xuICAgICAgICByZXR1cm4gYXhpc1R5cGUgIT09ICdjYXRlZ29yeScgJiYgYXhpc1R5cGUgIT09ICd0aW1lJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREaW1UeXBlQnlBeGlzKGF4aXNUeXBlKSB7XG4gICAgICAgIHJldHVybiBheGlzVHlwZSA9PT0gJ2NhdGVnb3J5J1xuICAgICAgICAgICAgPyAnb3JkaW5hbCdcbiAgICAgICAgICAgIDogYXhpc1R5cGUgPT09ICd0aW1lJ1xuICAgICAgICAgICAgPyAndGltZSdcbiAgICAgICAgICAgIDogJ2Zsb2F0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVycyBmb3IgZWFjaCBjb29yZCBzeXN0ZW0uXG4gICAgICovXG4gICAgdmFyIGNyZWF0b3JzID0ge1xuXG4gICAgICAgIGNhcnRlc2lhbjJkOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGNvbXBsZXRlRGltT3B0KSB7XG5cbiAgICAgICAgICAgIHZhciBheGVzTW9kZWxzID0genJVdGlsLm1hcChbJ3hBeGlzJywgJ3lBeGlzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICAgICAgbWFpblR5cGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSWQnKVxuICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMV07XG5cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF4QXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneEF4aXMgXCInICsgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd4QXhpc0luZGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ3hBeGlzSWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgKSArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF5QXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneUF4aXMgXCInICsgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd4QXhpc0luZGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ3lBeGlzSWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgKSArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4QXhpc1R5cGUgPSB4QXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgICAgICAgICAgdmFyIHlBeGlzVHlwZSA9IHlBeGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3gnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHhBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoeEF4aXNUeXBlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneScsXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHR3byBjYXRlZ29yeSBheGVzXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoeUF4aXNUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2thYmxlOiBpc1N0YWNrYWJsZSh5QXhpc1R5cGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmFyIGlzWEF4aXNDYXRlb2dyeSA9IHhBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgICAgICAgIHZhciBpc1lBeGlzQ2F0ZWdvcnkgPSB5QXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG5cbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgY29tcGxldGVEaW1PcHQpO1xuXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0ge307XG4gICAgICAgICAgICBpZiAoaXNYQXhpc0NhdGVvZ3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnggPSB4QXhpc01vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzWUF4aXNDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVscy55ID0geUF4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUluZGV4OiBpc1hBeGlzQ2F0ZW9ncnkgPyAwIDogKGlzWUF4aXNDYXRlZ29yeSA/IDEgOiAtMSksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2luZ2xlQXhpczogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuXG4gICAgICAgICAgICB2YXIgc2luZ2xlQXhpc01vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiAnc2luZ2xlQXhpcycsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHNlcmllc01vZGVsLmdldCgnc2luZ2xlQXhpc0luZGV4JyksXG4gICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldCgnc2luZ2xlQXhpc0lkJylcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghc2luZ2xlQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2luZ2xlQXhpcyBzaG91bGQgYmUgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNpbmdsZUF4aXNUeXBlID0gc2luZ2xlQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgICAgICAgICAgdmFyIGlzQ2F0ZWdvcnkgPSBzaW5nbGVBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcblxuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzaW5nbGUnLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoc2luZ2xlQXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoc2luZ2xlQXhpc1R5cGUpXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG5cbiAgICAgICAgICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpc0NhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnNpbmdsZSA9IHNpbmdsZUF4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5SW5kZXg6IGlzQ2F0ZWdvcnkgPyAwIDogLTEsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9sYXI6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpIHtcbiAgICAgICAgICAgIHZhciBwb2xhck1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiAncG9sYXInLFxuICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ3BvbGFySW5kZXgnKSxcbiAgICAgICAgICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhcklkJylcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICB2YXIgYW5nbGVBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ2FuZ2xlQXhpcycpO1xuICAgICAgICAgICAgdmFyIHJhZGl1c0F4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgncmFkaXVzQXhpcycpO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghYW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmdsZUF4aXMgb3B0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJhZGl1c0F4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl1c0F4aXMgb3B0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhZGl1c0F4aXNUeXBlID0gcmFkaXVzQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlQXhpc1R5cGUgPSBhbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcblxuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyhyYWRpdXNBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUocmFkaXVzQXhpc1R5cGUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoYW5nbGVBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoYW5nbGVBeGlzVHlwZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGlzQW5nbGVBeGlzQ2F0ZW9ncnkgPSBhbmdsZUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgICAgdmFyIGlzUmFkaXVzQXhpc0NhdGVvZ3J5ID0gcmFkaXVzQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG5cbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgY29tcGxldGVEaW1PcHQpO1xuXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0ge307XG4gICAgICAgICAgICBpZiAoaXNSYWRpdXNBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMucmFkaXVzID0gcmFkaXVzQXhpc01vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQW5nbGVBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMuYW5nbGUgPSBhbmdsZUF4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUluZGV4OiBpc0FuZ2xlQXhpc0NhdGVvZ3J5ID8gMSA6IChpc1JhZGl1c0F4aXNDYXRlb2dyeSA/IDAgOiAtMSksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2VvOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGNvbXBsZXRlRGltT3B0KSB7XG4gICAgICAgICAgICAvLyBUT0RPIFJlZ2lvblxuICAgICAgICAgICAgLy8g5aSa5Liq5pWj54K55Zu+57O75YiX5Zyo5ZCM5LiA5Liq5Zyw5Yy655qE5pe25YCZXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGNvbXBsZXRlRGltZW5zaW9ucyhbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG5nJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGF0J31cbiAgICAgICAgICAgICAgICBdLCBkYXRhLCBjb21wbGV0ZURpbU9wdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTmFtZUxpc3QocmVzdWx0LCBkYXRhKSB7XG4gICAgICAgIHZhciBuYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIHZhciBjYXRlZ29yeURpbSA9IHJlc3VsdCAmJiByZXN1bHQuZGltZW5zaW9uc1tyZXN1bHQuY2F0ZWdvcnlJbmRleF07XG4gICAgICAgIHZhciBjYXRlZ29yeUF4aXNNb2RlbDtcbiAgICAgICAgaWYgKGNhdGVnb3J5RGltKSB7XG4gICAgICAgICAgICBjYXRlZ29yeUF4aXNNb2RlbCA9IHJlc3VsdC5jYXRlZ29yeUF4ZXNNb2RlbHNbY2F0ZWdvcnlEaW0ubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIFR3byBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IGNhdGVnb3J5QXhpc01vZGVsLmdldENhdGVnb3JpZXMoKTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBPcmRlcmVkIGRhdGEgaXMgZ2l2ZW4gZXhwbGljaXRseSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gW1szLCAwLjJdLCBbMSwgMC4zXSwgWzIsIDAuMTVdXVxuICAgICAgICAgICAgICAgIC8vIG9yIGdpdmVuIHNjYXR0ZXIgZGF0YSxcbiAgICAgICAgICAgICAgICAvLyBwaWNrIHRoZSBjYXRlZ29yeVxuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNBcnJheShkYXRhWzBdKSAmJiBkYXRhWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0W2ldID0gY2F0ZWdvcmllc1tkYXRhW2ldW3Jlc3VsdC5jYXRlZ29yeUluZGV4IHx8IDBdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBjYXRlZ29yaWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lTGlzdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUxpc3RGcm9tQXJyYXk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var formatUtil = __webpack_require__(10);\n    var zrUtil = __webpack_require__(0);\n\n    var helper = {};\n\n    var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single'];\n    // Supported coords.\n    var COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n\n    /**\n     * @param {string} coordType\n     * @return {boolean}\n     */\n    helper.isCoordSupported = function (coordType) {\n        return zrUtil.indexOf(COORDS, coordType) >= 0;\n    };\n\n    /**\n     * Create \"each\" method to iterate names.\n     *\n     * @pubilc\n     * @param  {Array.<string>} names\n     * @param  {Array.<string>=} attrs\n     * @return {Function}\n     */\n    helper.createNameEach = function (names, attrs) {\n        names = names.slice();\n        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n        attrs = (attrs || []).slice();\n        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n\n        return function (callback, context) {\n            zrUtil.each(names, function (name, index) {\n                var nameObj = {name: name, capital: capitalNames[index]};\n\n                for (var j = 0; j < attrs.length; j++) {\n                    nameObj[attrs[j]] = name + capitalAttrs[j];\n                }\n\n                callback.call(context, nameObj);\n            });\n        };\n    };\n\n    /**\n     * Iterate each dimension name.\n     *\n     * @public\n     * @param {Function} callback The parameter is like:\n     *                            {\n     *                                name: 'angle',\n     *                                capital: 'Angle',\n     *                                axis: 'angleAxis',\n     *                                axisIndex: 'angleAixs',\n     *                                index: 'angleIndex'\n     *                            }\n     * @param {Object} context\n     */\n    helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\n    /**\n     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n     * dataZoomModels and 'links' make up one or more graphics.\n     * This function finds the graphic where the source dataZoomModel is in.\n     *\n     * @public\n     * @param {Function} forEachNode Node iterator.\n     * @param {Function} forEachEdgeType edgeType iterator\n     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n     */\n    helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {\n\n        return function (sourceNode) {\n            var result = {\n                nodes: [],\n                records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n            };\n\n            forEachEdgeType(function (edgeType) {\n                result.records[edgeType.name] = {};\n            });\n\n            if (!sourceNode) {\n                return result;\n            }\n\n            absorb(sourceNode, result);\n\n            var existsLink;\n            do {\n                existsLink = false;\n                forEachNode(processSingleNode);\n            }\n            while (existsLink);\n\n            function processSingleNode(node) {\n                if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n                    absorb(node, result);\n                    existsLink = true;\n                }\n            }\n\n            return result;\n        };\n\n        function isNodeAbsorded(node, result) {\n            return zrUtil.indexOf(result.nodes, node) >= 0;\n        }\n\n        function isLinked(node, result) {\n            var hasLink = false;\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] && (hasLink = true);\n                });\n            });\n            return hasLink;\n        }\n\n        function absorb(node, result) {\n            result.nodes.push(node);\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] = true;\n                });\n            });\n        }\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oZWxwZXIuanM/MTM0NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLGdCQUFnQjtBQUNoQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFNBQVMsa0NBQWtDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICB2YXIgQVhJU19ESU1TID0gWyd4JywgJ3knLCAneicsICdyYWRpdXMnLCAnYW5nbGUnLCAnc2luZ2xlJ107XG4gICAgLy8gU3VwcG9ydGVkIGNvb3Jkcy5cbiAgICB2YXIgQ09PUkRTID0gWydjYXJ0ZXNpYW4yZCcsICdwb2xhcicsICdzaW5nbGVBeGlzJ107XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmRUeXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoZWxwZXIuaXNDb29yZFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChjb29yZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5pbmRleE9mKENPT1JEUywgY29vcmRUeXBlKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgXCJlYWNoXCIgbWV0aG9kIHRvIGl0ZXJhdGUgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcHViaWxjXG4gICAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59IG5hbWVzXG4gICAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz49fSBhdHRyc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGhlbHBlci5jcmVhdGVOYW1lRWFjaCA9IGZ1bmN0aW9uIChuYW1lcywgYXR0cnMpIHtcbiAgICAgICAgbmFtZXMgPSBuYW1lcy5zbGljZSgpO1xuICAgICAgICB2YXIgY2FwaXRhbE5hbWVzID0genJVdGlsLm1hcChuYW1lcywgZm9ybWF0VXRpbC5jYXBpdGFsRmlyc3QpO1xuICAgICAgICBhdHRycyA9IChhdHRycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIGNhcGl0YWxBdHRycyA9IHpyVXRpbC5tYXAoYXR0cnMsIGZvcm1hdFV0aWwuY2FwaXRhbEZpcnN0KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVPYmogPSB7bmFtZTogbmFtZSwgY2FwaXRhbDogY2FwaXRhbE5hbWVzW2luZGV4XX07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVPYmpbYXR0cnNbal1dID0gbmFtZSArIGNhcGl0YWxBdHRyc1tqXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG5hbWVPYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgZWFjaCBkaW1lbnNpb24gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgcGFyYW1ldGVyIGlzIGxpa2U6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW5nbGUnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBpdGFsOiAnQW5nbGUnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzOiAnYW5nbGVBeGlzJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4OiAnYW5nbGVBaXhzJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6ICdhbmdsZUluZGV4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqL1xuICAgIGhlbHBlci5lYWNoQXhpc0RpbSA9IGhlbHBlci5jcmVhdGVOYW1lRWFjaChBWElTX0RJTVMsIFsnYXhpc0luZGV4JywgJ2F4aXMnLCAnaW5kZXgnLCAnaWQnXSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0b3cgZGF0YVpvb21Nb2RlbHMgaGFzIHRoZSBzYW1lIGF4aXMgY29udHJvbGxlZCwgd2Ugc2F5IHRoYXQgdGhleSBhcmUgJ2xpbmtlZCcuXG4gICAgICogZGF0YVpvb21Nb2RlbHMgYW5kICdsaW5rcycgbWFrZSB1cCBvbmUgb3IgbW9yZSBncmFwaGljcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBncmFwaGljIHdoZXJlIHRoZSBzb3VyY2UgZGF0YVpvb21Nb2RlbCBpcyBpbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JFYWNoTm9kZSBOb2RlIGl0ZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvckVhY2hFZGdlVHlwZSBlZGdlVHlwZSBpdGVyYXRvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVkZ2VJZEdldHRlciBHaXZpbmcgbm9kZSBhbmQgZWRnZVR5cGUsIHJldHVybiBhbiBhcnJheSBvZiBlZGdlIGlkLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBJbnB1dDogc291cmNlTm9kZSwgT3V0cHV0OiBMaWtlIHtub2RlczogW10sIGRpbXM6IHt9fVxuICAgICAqL1xuICAgIGhlbHBlci5jcmVhdGVMaW5rZWROb2Rlc0ZpbmRlciA9IGZ1bmN0aW9uIChmb3JFYWNoTm9kZSwgZm9yRWFjaEVkZ2VUeXBlLCBlZGdlSWRHZXR0ZXIpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHJlY29yZHM6IHt9IC8vIGtleTogZWRnZVR5cGUubmFtZSwgdmFsdWU6IE9iamVjdCAoa2V5OiBlZGdlIGlkLCB2YWx1ZTogYm9vbGVhbikuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3JFYWNoRWRnZVR5cGUoZnVuY3Rpb24gKGVkZ2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhYnNvcmIoc291cmNlTm9kZSwgcmVzdWx0KTtcblxuICAgICAgICAgICAgdmFyIGV4aXN0c0xpbms7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZXhpc3RzTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvckVhY2hOb2RlKHByb2Nlc3NTaW5nbGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChleGlzdHNMaW5rKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1NpbmdsZU5vZGUobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlQWJzb3JkZWQobm9kZSwgcmVzdWx0KSAmJiBpc0xpbmtlZChub2RlLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFic29yYihub2RlLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBleGlzdHNMaW5rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaXNOb2RlQWJzb3JkZWQobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YocmVzdWx0Lm5vZGVzLCBub2RlKSA+PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNMaW5rZWQobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgaGFzTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGVkZ2VJZEdldHRlcihub2RlLCBlZGdlVHlwZSkgfHwgW10sIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV1bZWRnZUlkXSAmJiAoaGFzTGluayA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaGFzTGluaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFic29yYihub2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGVkZ2VJZEdldHRlcihub2RlLCBlZGdlVHlwZSkgfHwgW10sIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV1bZWRnZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2RhdGEvRGF0YURpZmZlci5qcz9kMTJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRLZXlHZXR0ZXIoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEYXRhRGlmZmVyKG9sZEFyciwgbmV3QXJyLCBvbGRLZXlHZXR0ZXIsIG5ld0tleUdldHRlcikge1xuICAgICAgICB0aGlzLl9vbGQgPSBvbGRBcnI7XG4gICAgICAgIHRoaXMuX25ldyA9IG5ld0FycjtcblxuICAgICAgICB0aGlzLl9vbGRLZXlHZXR0ZXIgPSBvbGRLZXlHZXR0ZXIgfHwgZGVmYXVsdEtleUdldHRlcjtcbiAgICAgICAgdGhpcy5fbmV3S2V5R2V0dGVyID0gbmV3S2V5R2V0dGVyIHx8IGRlZmF1bHRLZXlHZXR0ZXI7XG4gICAgfVxuXG4gICAgRGF0YURpZmZlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERhdGFEaWZmZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYWRkIGEgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fYWRkID0gZnVuYztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHVwZGF0ZSBhIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiByZW1vdmUgYSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUgPSBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9sZEFyciA9IHRoaXMuX29sZDtcbiAgICAgICAgICAgIHZhciBuZXdBcnIgPSB0aGlzLl9uZXc7XG4gICAgICAgICAgICB2YXIgb2xkS2V5R2V0dGVyID0gdGhpcy5fb2xkS2V5R2V0dGVyO1xuICAgICAgICAgICAgdmFyIG5ld0tleUdldHRlciA9IHRoaXMuX25ld0tleUdldHRlcjtcblxuICAgICAgICAgICAgdmFyIG9sZERhdGFJbmRleE1hcCA9IHt9O1xuICAgICAgICAgICAgdmFyIG5ld0RhdGFJbmRleE1hcCA9IHt9O1xuICAgICAgICAgICAgdmFyIG9sZERhdGFLZXlBcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBuZXdEYXRhS2V5QXJyID0gW107XG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgaW5pdEluZGV4TWFwKG9sZEFyciwgb2xkRGF0YUluZGV4TWFwLCBvbGREYXRhS2V5QXJyLCBvbGRLZXlHZXR0ZXIpO1xuICAgICAgICAgICAgaW5pdEluZGV4TWFwKG5ld0FyciwgbmV3RGF0YUluZGV4TWFwLCBuZXdEYXRhS2V5QXJyLCBuZXdLZXlHZXR0ZXIpO1xuXG4gICAgICAgICAgICAvLyBUcmF2ZWwgYnkgaW52ZXJ0ZWQgb3JkZXIgdG8gbWFrZSBzdXJlIG9yZGVyIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICAvLyB3aGVuIGR1cGxpY2F0ZSBrZXlzIGV4aXN0cyAoY29uc2lkZXIgbmV3RGF0YUluZGV4LnBvcCgpIGJlbG93KS5cbiAgICAgICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLCB0aGVzZSBjb2RlIGJlbG93IGRvIG5vdCBsb29rIG5lYXQuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IG9sZERhdGFLZXlBcnJbaV07XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IG5ld0RhdGFJbmRleE1hcFtrZXldO1xuXG4gICAgICAgICAgICAgICAgLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBiZWxvdy5cbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhlcmUgaXMgZHVwbGljYXRlIGtleSAoZm9yIGV4YW1wbGUsIHVzZSBkYXRhSXRlbS5uYW1lIGFzIGtleSkuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBtYWtlIHN1cmUgZXZlcnkgaXRlbSBpbiBuZXdBcnIgYW5kIG9sZEFyciBjYW4gYmUgdmlzaXRlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGlkeC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9PT0gMSAmJiAobmV3RGF0YUluZGV4TWFwW2tleV0gPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeC51bnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhSW5kZXhNYXBba2V5XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlICYmIHRoaXMuX3VwZGF0ZShpZHgsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlICYmIHRoaXMuX3JlbW92ZShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YUtleUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBuZXdEYXRhS2V5QXJyW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhSW5kZXhNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gbmV3RGF0YUluZGV4TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gaWR4Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkICYmIHRoaXMuX2FkZChpZHhbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXRJbmRleE1hcChhcnIsIG1hcCwga2V5QXJyLCBrZXlHZXR0ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEFkZCBwcmVmaXggdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuICAgICAgICAgICAgdmFyIGtleSA9ICdfZWNfJyArIGtleUdldHRlcihhcnJbaV0sIGkpO1xuICAgICAgICAgICAgdmFyIGV4aXN0ZW5jZSA9IG1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAga2V5QXJyLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBtYXBba2V5XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2tleV0gPSBleGlzdGVuY2UgPSBbZXhpc3RlbmNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpc3RlbmNlLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERhdGFEaWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvZGF0YS9EYXRhRGlmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var formatUtil = __webpack_require__(10);\n    var classUtil = __webpack_require__(12);\n    var modelUtil = __webpack_require__(4);\n    var ComponentModel = __webpack_require__(13);\n    var colorPaletteMixin = __webpack_require__(63);\n    var env = __webpack_require__(6);\n    var layout = __webpack_require__(15);\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL1Nlcmllcy5qcz8zMWY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLHVDQUF1QztBQUMxRCxvQkFBb0IsT0FBTyxFQUFFLDBCQUEwQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGNsYXNzVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG4gICAgdmFyIGNvbG9yUGFsZXR0ZU1peGluID0gcmVxdWlyZSgnLi9taXhpbi9jb2xvclBhbGV0dGUnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vdXRpbC9sYXlvdXQnKTtcblxuICAgIHZhciBzZXQgPSBjbGFzc1V0aWwuc2V0O1xuICAgIHZhciBnZXQgPSBjbGFzc1V0aWwuZ2V0O1xuICAgIHZhciBlbmNvZGVIVE1MID0gZm9ybWF0VXRpbC5lbmNvZGVIVE1MO1xuICAgIHZhciBhZGRDb21tYXMgPSBmb3JtYXRVdGlsLmFkZENvbW1hcztcblxuICAgIHZhciBTZXJpZXNNb2RlbCA9IENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5fX2Jhc2VfXycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgc2VyaWVzSW5kZXg6IDAsXG5cbiAgICAgICAgLy8gY29vZGluYXRlU3lzdGVtIHdpbGwgYmUgaW5qZWN0ZWQgaW4gdGhlIGVjaGFydHMvQ29vcmRpbmF0ZVN5c3RlbVxuICAgICAgICBjb29yZGluYXRlU3lzdGVtOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0T3B0aW9uOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHByb3ZpZGVkIGZvciBsZWdlbmRcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBsZWdlbmREYXRhUHJvdmlkZXI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjY2VzcyBwYXRoIG9mIGNvbG9yIGZvciB2aXN1YWxcbiAgICAgICAgICovXG4gICAgICAgIHZpc3VhbENvbG9yQWNjZXNzUGF0aDogJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAgICAgICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXRNb2RlOiBudWxsLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IHRoaXMuY29tcG9uZW50SW5kZXg7XG5cbiAgICAgICAgICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoZGF0YSwgJ2dldEluaXRpYWxEYXRhIHJldHVybmVkIGludmFsaWQgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdHxtb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWV8bW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcsIGRhdGEpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSByZXZlcnNlIHRoZSBvcmRlciAobWFrZSBkYXRhIGZpcnN0bHksIGFuZCB0aGVuIG1ha2VcbiAgICAgICAgICAgIC8vIGRhdGFCZWZvcmVQcm9jZXNzZWQgYnkgY2xvbmVTaGFsbG93KSwgY2xvbmVTaGFsbG93IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIGRhdGEuZ3JhcGguZGF0YSAhPT0gZGF0YSB3aGVuIHVzaW5nXG4gICAgICAgICAgICAvLyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoIG9yIG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZS5cbiAgICAgICAgICAgIC8vIFNlZSBtb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9saW5rTGlzdFxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsIGZvciBtZXJnZSBkZWZhdWx0IGFuZCB0aGVtZSB0byBvcHRpb25cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25cbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZURlZmF1bHRBbmRUaGVtZTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGVcbiAgICAgICAgICAgICAgICA/IGxheW91dC5nZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UoXG4gICAgICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0VGhlbWUoKS5nZXQodGhpcy5zdWJUeXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgICAgICAgIC8vIEZJWE1FIFNldCBsYWJlbCBpbiBtZXJnZU9wdGlvblxuICAgICAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24ubGFiZWwsIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TKTtcblxuICAgICAgICAgICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgbmV3U2VyaWVzT3B0aW9uID0genJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBuZXdTZXJpZXNPcHRpb24sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShuZXdTZXJpZXNPcHRpb24uZGF0YSk7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgbmV3U2VyaWVzT3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCk7XG4gICAgICAgICAgICAvLyBUT0RPIE1lcmdlIGRhdGE/XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcsIGRhdGEuY2xvbmVTaGFsbG93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGxEYXRhVGV4dFN0eWxlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBkYXRhIGxhYmVsIGVtcGhhc2lzIGBwb3NpdGlvbmAgYW5kIGBzaG93YFxuICAgICAgICAgICAgLy8gRklYTUUgVHJlZSBzdHJ1Y3R1cmUgZGF0YSA/XG4gICAgICAgICAgICAvLyBGSVhNRSBQZXJmb3JtYW5jZSA/XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBkYXRhW2ldLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKGRhdGFbaV0ubGFiZWwsIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdCBhIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSByZWxhdGVkIG9wdGlvbiBpbiBzZXJpZXNcbiAgICAgICAgICogTXVzdCBiZSBvdmVyd3JpdHRlblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhOiBmdW5jdGlvbiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0KHRoaXMsICdkYXRhJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVR5cGUgPT0gbnVsbCA/IGRhdGEgOiBkYXRhLmdldExpbmtlZERhdGEoZGF0YVR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGF0YSBiZWZvcmUgcHJvY2Vzc2VkXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXN1bHQgaXMgdGhlIHNhbWUgYXMgZGltZW5zaW9ucyBvZiBzZXJpZXMgZGF0YS5cbiAgICAgICAgICogQnV0IGluIHNvbWUgc2VyaWVzIGRhdGEgZGltZW5zaW9ucyBhcmUgZGlmZmVyZW50IGZyb20gY29vcmQgZGltZW5zaW9ucyAoaS5lLlxuICAgICAgICAgKiBjYW5kbGVzdGljayBhbmQgYm94cGxvdCkuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSB0aG9zZSBjYXNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uIGNhbiBiZSBvbmUtdG8tbWFueVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmREaW1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMgb24gdGhlIGF4aXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb29yZERpbVRvRGF0YURpbTogZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxVdGlsLmNvb3JkRGltVG9EYXRhRGltKHRoaXMuZ2V0RGF0YSgpLCBjb29yZERpbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgZGF0YSBkaW1lbnNpb24gdG8gY29vcmQgZGltZW5zaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGFEaW1cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YURpbVRvQ29vcmREaW06IGZ1bmN0aW9uIChkYXRhRGltKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxVdGlsLmRhdGFEaW1Ub0Nvb3JkRGltKHRoaXMuZ2V0RGF0YSgpLCBkYXRhRGltKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGJhc2UgYXhpcyBpZiBoYXMgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIGhhcyBheGlzLlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHVzZSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgKiBDYW4gYmUgb3ZlcnJpZGVkIGZvciBzb21lIGNoYXJ0LlxuICAgICAgICAgKiBAcmV0dXJuIHt0eXBlfSBkZXNjcmlwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFzZUF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHRvb2x0aXAgZm9ybWF0dGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXRUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmVydGlhbGx5ID0genJVdGlsLnJlZHVjZSh2YWx1ZSwgZnVuY3Rpb24gKHZlcnRpYWxseSwgdmFsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpYWxseSB8PSBkaW1JdGVtICYmIGRpbUl0ZW0udG9vbHRpcCAhPT0gZmFsc2UgJiYgZGltSXRlbS50b29sdGlwTmFtZSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwRGltcyA9IG1vZGVsVXRpbC5vdGhlckRpbVRvRGF0YURpbShkYXRhLCAndG9vbHRpcCcpO1xuXG4gICAgICAgICAgICAgICAgdG9vbHRpcERpbXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8genJVdGlsLmVhY2godG9vbHRpcERpbXMsIGZ1bmN0aW9uIChkaW1JZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVhY2hJdGVtKGRhdGEuZ2V0KGRpbUlkeCwgZGF0YUluZGV4KSwgZGltSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgYWxsIGRpbXMgaXMgdXNlZCBvbiB0b29sdGlwLlxuICAgICAgICAgICAgICAgICAgICA6IHpyVXRpbC5lYWNoKHZhbHVlLCBzZXRFYWNoSXRlbSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRFYWNoSXRlbSh2YWwsIGRpbUlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1JZHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBgZGltSW5mby50b29sdGlwYCBpcyBub3Qgc2V0LCBzaG93IHRvb2x0aXAuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGltSW5mbyB8fCBkaW1JbmZvLm90aGVyRGltcy50b29sdGlwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1UeXBlID0gZGltSW5mby50eXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsU3RyID0gKHZlcnRpYWxseSA/ICctICcgKyAoZGltSW5mby50b29sdGlwTmFtZSB8fCBkaW1JbmZvLm5hbWUpICsgJzogJyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoZGltVHlwZSA9PT0gJ29yZGluYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWwgKyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGltVHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobXVsdGlwbGVTZXJpZXMgPyAnJyA6IGZvcm1hdFV0aWwuZm9ybWF0VGltZSgneXl5eS9NTS9kZCBoaDptbTpzcycsIHZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRDb21tYXModmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsU3RyICYmIHJlc3VsdC5wdXNoKGVuY29kZUhUTUwodmFsU3RyKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2ZXJ0aWFsbHkgPyAnPGJyLz4nIDogJycpICsgcmVzdWx0LmpvaW4odmVydGlhbGx5ID8gJzxici8+JyA6ICcsICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdldCh0aGlzLCAnZGF0YScpO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB6clV0aWwuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIDogZW5jb2RlSFRNTChhZGRDb21tYXModmFsdWUpKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuICAgICAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChjb2xvcikgJiYgY29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gKGNvbG9yLmNvbG9yU3RvcHNbMF0gfHwge30pLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sb3IgPSBjb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuXG4gICAgICAgICAgICB2YXIgY29sb3JFbCA9IGZvcm1hdFV0aWwuZ2V0VG9vbHRpcE1hcmtlcihjb2xvcik7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChzZXJpZXNOYW1lID09PSAnXFwwLScpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3Qgc2hvdyAnLSdcbiAgICAgICAgICAgICAgICBzZXJpZXNOYW1lID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJpZXNOYW1lID0gc2VyaWVzTmFtZVxuICAgICAgICAgICAgICAgID8gZW5jb2RlSFRNTChzZXJpZXNOYW1lKSArICghbXVsdGlwbGVTZXJpZXMgPyAnPGJyLz4nIDogJzogJylcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuICFtdWx0aXBsZVNlcmllc1xuICAgICAgICAgICAgICAgID8gc2VyaWVzTmFtZSArIGNvbG9yRWxcbiAgICAgICAgICAgICAgICAgICAgKyAobmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmNvZGVIVE1MKG5hbWUpICsgJzogJyArIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNvbG9yRWwgKyBzZXJpZXNOYW1lICsgZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXREYXRhKCkuY291bnQoKSA+IHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVGhyZXNob2xkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25FbmFibGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2RhdGEnLCBnZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnKS5jbG9uZVNoYWxsb3coKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29sb3JGcm9tUGFsZXR0ZTogZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yUGFsZXR0ZU1peGluLmdldENvbG9yRnJvbVBhbGV0dGUuY2FsbCh0aGlzLCBuYW1lLCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBlY01vZGVsLmdldENvbG9yRnJvbVBhbGV0dGUobmFtZSwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGF0YSBpbmRpY2VzIGZvciBzaG93IHRvb2x0aXAgY29udGVudC4gU2VlIHRvb2x0aXAuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gZGltXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvc2luZ2xlL1NpbmdsZUF4aXN9IGJhc2VBeGlzXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0ge2RhdGFJbmRpY2VzLCBuZXN0ZXN0VmFsdWV9LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpc1Rvb2x0aXBEYXRhOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgdG9vbHRpcC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFBvaW50IG9mIHRvb2x0aXAuIG51bGwvdW5kZWZpbmVkIGNhbiBiZSByZXR1cm5lZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldFRvb2x0aXBQb3NpdGlvbjogbnVsbFxuICAgIH0pO1xuXG4gICAgenJVdGlsLm1peGluKFNlcmllc01vZGVsLCBtb2RlbFV0aWwuZGF0YUZvcm1hdE1peGluKTtcbiAgICB6clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIGNvbG9yUGFsZXR0ZU1peGluKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU2VyaWVzTW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvbW9kZWwvU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = __webpack_require__(5);\n    var formatUtil = __webpack_require__(10);\n    var Scale = __webpack_require__(25);\n    var helper = __webpack_require__(64);\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         */\n        niceTicks: function (splitNumber, minInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval);\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval=false]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL0ludGVydmFsLmpzPzc0YTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJ2YWwgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9JbnRlcnZhbFxuICovXG5cblxuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG4gICAgdmFyIGhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XG5cbiAgICB2YXIgcm91bmROdW1iZXIgPSBudW1iZXJVdGlsLnJvdW5kO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL0ludGVydmFsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEludGVydmFsU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdpbnRlcnZhbCcsXG5cbiAgICAgICAgX2ludGVydmFsOiAwLFxuXG4gICAgICAgIF9pbnRlcnZhbFByZWNpc2lvbjogMixcblxuICAgICAgICBzZXRFeHRlbnQ6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIC8vc3RhcnQsZW5kIG1heSBiZSBhIE51bWJlciBsaWtlICcyNScsc28uLi5cbiAgICAgICAgICAgIGlmICghaXNOYU4oc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0V4dGVudFswXSA9IHBhcnNlRmxvYXQoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05hTihlbmQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0V4dGVudFsxXSA9IHBhcnNlRmxvYXQoZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmlvbkV4dGVudDogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgb3RoZXJbMF0gPCBleHRlbnRbMF0gJiYgKGV4dGVudFswXSA9IG90aGVyWzBdKTtcbiAgICAgICAgICAgIG90aGVyWzFdID4gZXh0ZW50WzFdICYmIChleHRlbnRbMV0gPSBvdGhlclsxXSk7XG5cbiAgICAgICAgICAgIC8vIHVuaW9uRXh0ZW50IG1heSBjYWxsZWQgYnkgaXQncyBzdWIgY2xhc3Nlc1xuICAgICAgICAgICAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUuc2V0RXh0ZW50LmNhbGwodGhpcywgZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGludGVydmFsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRJbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVydmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgaW50ZXJ2YWxcbiAgICAgICAgICovXG4gICAgICAgIHNldEludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyBEcm9wcGVkIGF1dG8gY2FsY3VsYXRlZCBuaWNlRXh0ZW50IGFuZCB1c2UgdXNlciBzZXR0ZWQgZXh0ZW50XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdXNlciB3YW4ndCB0byBzZXQgYm90aCBpbnRlcnZhbCwgbWluLCBtYXggdG8gZ2V0IGEgYmV0dGVyIHJlc3VsdFxuICAgICAgICAgICAgdGhpcy5fbmljZUV4dGVudCA9IHRoaXMuX2V4dGVudC5zbGljZSgpO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IGhlbHBlci5nZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIuaW50ZXJ2YWxTY2FsZUdldFRpY2tzKFxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVydmFsLCB0aGlzLl9leHRlbnQsIHRoaXMuX25pY2VFeHRlbnQsIHRoaXMuX2ludGVydmFsUHJlY2lzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdC5wcmVjaXNpb25dIElmICdhdXRvJywgdXNlIG5pY2UgcHJlc2lzaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQucGFkXSByZXR1cm5zIDEuNTAgYnV0IG5vdCAxLjUgaWYgcHJlY2lzaW9uIGlzIDIuXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsOiBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gb3B0ICYmIG9wdC5wcmVjaXNpb247XG5cbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZShkYXRhKSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgbW9yZSBwcmVjaXNlIHRoZW4gdGljay5cbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKDEpIElmIGBwcmVjaXNpb25gIGlzIHNldCwgMTIuMDA1IHNob3VsZCBiZSBkaXNwbGF5IGFzICcxMi4wMDUwMCcuXG4gICAgICAgICAgICAvLyAoMikgVXNlIHJvdW5kTnVtYmVyICh0b0ZpeGVkKSB0byBhdm9pZCBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgJzMuNWUtNycuXG4gICAgICAgICAgICBkYXRhID0gcm91bmROdW1iZXIoZGF0YSwgcHJlY2lzaW9uLCB0cnVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuYWRkQ29tbWFzKGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgaW50ZXJ2YWwgYW5kIGV4dGVudCBvZiBpbnRlcnZhbHMgZm9yIG5pY2UgdGlja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzcGxpdE51bWJlciA9IDVdIERlc2lyZWQgbnVtYmVyIG9mIHRpY2tzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluSW50ZXJ2YWxdXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlVGlja3M6IGZ1bmN0aW9uIChzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHNwbGl0TnVtYmVyID0gc3BsaXROdW1iZXIgfHwgNTtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoc3BhbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2VyIG1heSBzZXQgYXhpcyBtaW4gMCBhbmQgZGF0YSBhcmUgYWxsIG5lZ2F0aXZlXG4gICAgICAgICAgICAvLyBGSVhNRSBJZiBpdCBuZWVkcyB0byByZXZlcnNlID9cbiAgICAgICAgICAgIGlmIChzcGFuIDwgMCkge1xuICAgICAgICAgICAgICAgIHNwYW4gPSAtc3BhbjtcbiAgICAgICAgICAgICAgICBleHRlbnQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGVscGVyLmludGVydmFsU2NhbGVOaWNlVGlja3MoZXh0ZW50LCBzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IHJlc3VsdC5pbnRlcnZhbFByZWNpc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gcmVzdWx0LmludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5fbmljZUV4dGVudCA9IHJlc3VsdC5uaWNlVGlja0V4dGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTmljZSBleHRlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3BsaXROdW1iZXIgPSA1XSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZpeE1pbj1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZpeE1heD1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0Lm1pbkludGVydmFsPWZhbHNlXVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZUV4dGVudDogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIC8vIElmIGV4dGVudCBzdGFydCBhbmQgZW5kIGFyZSBzYW1lLCBleHBhbmQgdGhlbVxuICAgICAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudFswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgZXh0ZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRTaXplID0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgZm93bGxvd2luZyBjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgQXhpcyBoYXMgYmVlbiBmaXhlZCBtYXggMTAwXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgUGx1cyBkYXRhIGFyZSBhbGwgMTAwIGFuZCBheGlzIGV4dGVudCBhcmUgWzEwMCwgMTAwXS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRvIHRoZSBib3RoIHNpZGUgd2lsbCBjYXVzZSBleHBhbmRlZCBtYXggaXMgbGFyZ2VyIHRoYW4gZml4ZWQgbWF4LlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyBvbmx5IGV4cGFuZCB0byB0aGUgc21hbGxlciBzaWRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudFsxXSArPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudFswXSAtPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudFswXSAtPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShzcGFuKSkge1xuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5uaWNlVGlja3Mob3B0LnNwbGl0TnVtYmVyLCBvcHQubWluSW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICAvLyB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG5cbiAgICAgICAgICAgIGlmICghb3B0LmZpeE1pbikge1xuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHQuZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gcm91bmROdW1iZXIoTWF0aC5jZWlsKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBJbnRlcnZhbFNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW50ZXJ2YWxTY2FsZTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL0ludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var clazz = __webpack_require__(12);\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvY29tcG9uZW50LmpzPzQ2MGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYixvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNsYXp6ID0gcmVxdWlyZSgnLi9jbGF6eicpO1xuXG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gY2xhenoucGFyc2VDbGFzc1R5cGU7XG5cbiAgICB2YXIgYmFzZSA9IDA7XG5cbiAgICB2YXIgY29tcG9uZW50VXRpbCA9IHt9O1xuXG4gICAgdmFyIERFTElNSVRFUiA9ICdfJztcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb21wb25lbnRVdGlsLmdldFVJRCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIC8vIENvbnNpZGVyaW5nIHRoZSBjYXNlIG9mIGNyb3NzaW5nIGpzIGNvbnRleHQsXG4gICAgICAgIC8vIHVzZSBNYXRoLnJhbmRvbSB0byBtYWtlIGlkIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZS5cbiAgICAgICAgcmV0dXJuIFsodHlwZSB8fCAnJyksIGJhc2UrKywgTWF0aC5yYW5kb20oKV0uam9pbihERUxJTUlURVIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBjb21wb25lbnRVdGlsLmVuYWJsZVN1YlR5cGVEZWZhdWx0ZXIgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG5cbiAgICAgICAgdmFyIHN1YlR5cGVEZWZhdWx0ZXJzID0ge307XG5cbiAgICAgICAgZW50aXR5LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZWZhdWx0ZXIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGUubWFpbl0gPSBkZWZhdWx0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5LmRldGVybWluZVN1YlR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgb3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG9wdGlvbi50eXBlO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVNYWluID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkubWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5Lmhhc1N1YlR5cGVzKGNvbXBvbmVudFR5cGUpICYmIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGVNYWluXSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZU1haW5dKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVG9wb2xvZ2ljYWwgdHJhdmVsIG9uIEFjdGl2aXR5IE5ldHdvcmsgKEFjdGl2aXR5IE9uIFZlcnRpY2VzKS5cbiAgICAgKiBEZXBlbmRlbmNpZXMgaXMgZGVmaW5lZCBpbiBNb2RlbC5wcm90b3R5cGUuZGVwZW5kZW5jaWVzLCBsaWtlIFsneEF4aXMnLCAneUF4aXMnXS5cbiAgICAgKlxuICAgICAqIElmICd4QXhpcycgb3IgJ3lBeGlzJyBpcyBhYnNlbnQgaW4gY29tcG9uZW50VHlwZUxpc3QsIGp1c3QgaWdub3JlIGl0IGluIHRvcG9sb2d5LlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgaXMgY2lyY2xlIGRlcGVuZGVuY2V5LCBFcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWwgPSBmdW5jdGlvbiAoZW50aXR5LCBkZXBlbmRlbmN5R2V0dGVyKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gdGFyZ2V0TmFtZUxpc3QgVGFyZ2V0IENvbXBvbmVudCB0eXBlIGxpc3QuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBbJ2FhJywgJ2JiJywgJ2FhLnh4J11cbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZnVsbE5hbWVMaXN0IEJ5IHdoaWNoIHdlIGNhbiBidWlsZCBkZXBlbmRlbmN5IGdyYXBoLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBQYXJhbXM6IGNvbXBvbmVudFR5cGUsIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgU2NvcGUgb2YgY2FsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBlbnRpdHkudG9wb2xvZ2ljYWxUcmF2ZWwgPSBmdW5jdGlvbiAodGFyZ2V0TmFtZUxpc3QsIGZ1bGxOYW1lTGlzdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0TmFtZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCk7XG4gICAgICAgICAgICB2YXIgZ3JhcGggPSByZXN1bHQuZ3JhcGg7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSByZXN1bHQubm9FbnRyeUxpc3Q7XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXROYW1lU2V0ID0ge307XG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROYW1lU2V0W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJDb21wb25lbnRUeXBlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJWZXJ0ZXggPSBncmFwaFtjdXJyQ29tcG9uZW50VHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5UYXJnZXROYW1lU2V0ID0gISF0YXJnZXROYW1lU2V0W2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJblRhcmdldE5hbWVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBjdXJyQ29tcG9uZW50VHlwZSwgY3VyclZlcnRleC5vcmlnaW5hbERlcHMuc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXROYW1lU2V0W2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goXG4gICAgICAgICAgICAgICAgICAgIGN1cnJWZXJ0ZXguc3VjY2Vzc29yLFxuICAgICAgICAgICAgICAgICAgICBpc0luVGFyZ2V0TmFtZVNldCA/IHJlbW92ZUVkZ2VBbmRBZGQgOiByZW1vdmVFZGdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgenJVdGlsLmVhY2godGFyZ2V0TmFtZVNldCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY2xlIGRlcGVuZGVuY3kgbWF5IGV4aXN0cycpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudC0tO1xuICAgICAgICAgICAgICAgIGlmIChncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN1Y2NDb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTogbGVnZW5kIGRlcGVuZHMgb24gc2VyaWVzLCBhbmQgd2UgY2FsbFxuICAgICAgICAgICAgLy8gY2hhcnQuc2V0T3B0aW9uKHtzZXJpZXM6IFsuLi5dfSksIHdoZXJlIG9ubHkgc2VyaWVzIGlzIGluIG9wdGlvbi5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlICdyZW1vdmVFZGdlQW5kQWRkJywgbGVnZW5kTW9kZWwubWVyZ2VPcHRpb24gd2lsbFxuICAgICAgICAgICAgLy8gbm90IGJlIGNhbGxlZCwgYnV0IG9ubHkgc2VyZWlzLm1lcmdlT3B0aW9uIGlzIGNhbGxlZC4gVGh1cyBsZWdlbmRcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gY2hhbmNlIHRvIHVwZGF0ZSBpdHMgbG9jYWwgcmVjb3JkIGFib3V0IHNlcmllcyAobGlrZSB3aGljaFxuICAgICAgICAgICAgLy8gbmFtZSBvZiBzZXJpZXMgaXMgYXZhaWxhYmxlIGluIGxlZ2VuZCkuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVFZGdlQW5kQWRkKHN1Y2NDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TmFtZVNldFtzdWNjQ29tcG9uZW50VHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXBuZGVuY3lHcmFwaDoge09iamVjdH1cbiAgICAgICAgICoga2V5OiBjb25wb25lbnRUeXBlLFxuICAgICAgICAgKiB2YWx1ZToge1xuICAgICAgICAgKiAgICAgc3VjY2Vzc29yOiBbY29ucG9uZW50VHlwZXMuLi5dLFxuICAgICAgICAgKiAgICAgb3JpZ2luYWxEZXBzOiBbY29ucG9uZW50VHlwZXMuLi5dLFxuICAgICAgICAgKiAgICAgZW50cnlDb3VudDoge251bWJlcn1cbiAgICAgICAgICogfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCkge1xuICAgICAgICAgICAgdmFyIGdyYXBoID0ge307XG4gICAgICAgICAgICB2YXIgbm9FbnRyeUxpc3QgPSBbXTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2goZnVsbE5hbWVMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNJdGVtID0gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRGVwcyA9IHRoaXNJdGVtLm9yaWdpbmFsRGVwcyA9IGRlcGVuZGVuY3lHZXR0ZXIobmFtZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCk7XG4gICAgICAgICAgICAgICAgdGhpc0l0ZW0uZW50cnlDb3VudCA9IGF2YWlsYWJsZURlcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzSXRlbS5lbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vRW50cnlMaXN0LnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goYXZhaWxhYmxlRGVwcywgZnVuY3Rpb24gKGRlcGVuZGVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHRoaXNJdGVtLnByZWRlY2Vzc29yLCBkZXBlbmRlbnROYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNJdGVtLnByZWRlY2Vzc29yLnB1c2goZGVwZW5kZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRJdGVtID0gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgZGVwZW5kZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaW5kZXhPZih0aGF0SXRlbS5zdWNjZXNzb3IsIGRlcGVuZGVudE5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdEl0ZW0uc3VjY2Vzc29yLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge2dyYXBoOiBncmFwaCwgbm9FbnRyeUxpc3Q6IG5vRW50cnlMaXN0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghZ3JhcGhbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBncmFwaFtuYW1lXSA9IHtwcmVkZWNlc3NvcjogW10sIHN1Y2Nlc3NvcjogW119O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyYXBoW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlRGVwZW5kZW5jaWVzKG9yaWdpbmFsRGVwcywgZnVsbE5hbWVMaXN0KSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IFtdO1xuICAgICAgICAgICAgenJVdGlsLmVhY2gob3JpZ2luYWxEZXBzLCBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmluZGV4T2YoZnVsbE5hbWVMaXN0LCBkZXApID49IDAgJiYgYXZhaWxhYmxlRGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVEZXBzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50VXRpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi91dGlsL2NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Symbol factory\n\n\n    var graphic = __webpack_require__(2);\n    var BoundingRect = __webpack_require__(11);\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvc3ltYm9sLmpzP2FjNWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gU3ltYm9sIGZhY3RvcnlcblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuL2dyYXBoaWMnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWFuZ2xlIHNoYXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFRyaWFuZ2xlID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gICAgICAgIHR5cGU6ICd0cmlhbmdsZScsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIGN5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSArIGhlaWdodCk7XG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlhbW9uZCBzaGFwZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBEaWFtb25kID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gICAgICAgIHR5cGU6ICdkaWFtb25kJyxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGN4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQaW4gc2hhcGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgUGluID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gICAgICAgIHR5cGU6ICdwaW4nLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8geCwgeSBvbiB0aGUgY3VzcFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoIC8gNSAqIDM7XG4gICAgICAgICAgICAvLyBIZWlnaHQgbXVzdCBiZSBsYXJnZXIgdGhhbiB3aWR0aFxuICAgICAgICAgICAgdmFyIGggPSBNYXRoLm1heCh3LCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHIgPSB3IC8gMjtcblxuICAgICAgICAgICAgLy8gRGlzdCBvbiB5IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxuICAgICAgICAgICAgdmFyIGR5ID0gciAqIHIgLyAoaCAtIHIpO1xuICAgICAgICAgICAgdmFyIGN5ID0geSAtIGggKyByICsgZHk7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyByKTtcbiAgICAgICAgICAgIC8vIERpc3Qgb24geCB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguY29zKGFuZ2xlKSAqIHI7XG5cbiAgICAgICAgICAgIHZhciB0YW5YID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgdmFyIHRhblkgPSBNYXRoLmNvcyhhbmdsZSk7XG5cbiAgICAgICAgICAgIHBhdGguYXJjKFxuICAgICAgICAgICAgICAgIHgsIGN5LCByLFxuICAgICAgICAgICAgICAgIE1hdGguUEkgLSBhbmdsZSxcbiAgICAgICAgICAgICAgICBNYXRoLlBJICogMiArIGFuZ2xlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgY3BMZW4gPSByICogMC42O1xuICAgICAgICAgICAgdmFyIGNwTGVuMiA9IHIgKiAwLjc7XG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIGR4IC0gdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxuICAgICAgICAgICAgICAgIHgsIHkgLSBjcExlbjIsXG4gICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxuICAgICAgICAgICAgICAgIHggLSBkeCArIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbixcbiAgICAgICAgICAgICAgICB4IC0gZHgsIGN5ICsgZHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJvdyBzaGFwZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBBcnJvdyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuXG4gICAgICAgIHR5cGU6ICdhcnJvdycsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgZHggPSB3aWR0aCAvIDMgKiAyO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIGhlaWdodCAvIDQgKiAzKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIGR4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBvZiBwYXRoIGNvbnRydWN0b3JzXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGg+fVxuICAgICAqL1xuICAgIHZhciBzeW1ib2xDdG9ycyA9IHtcbiAgICAgICAgbGluZTogZ3JhcGhpYy5MaW5lLFxuXG4gICAgICAgIHJlY3Q6IGdyYXBoaWMuUmVjdCxcblxuICAgICAgICByb3VuZFJlY3Q6IGdyYXBoaWMuUmVjdCxcblxuICAgICAgICBzcXVhcmU6IGdyYXBoaWMuUmVjdCxcblxuICAgICAgICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxuXG4gICAgICAgIGRpYW1vbmQ6IERpYW1vbmQsXG5cbiAgICAgICAgcGluOiBQaW4sXG5cbiAgICAgICAgYXJyb3c6IEFycm93LFxuXG4gICAgICAgIHRyaWFuZ2xlOiBUcmlhbmdsZVxuICAgIH07XG5cbiAgICB2YXIgc3ltYm9sU2hhcGVNYWtlcnMgPSB7XG5cbiAgICAgICAgbGluZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgc2hhcGUueDEgPSB4O1xuICAgICAgICAgICAgc2hhcGUueTEgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICBzaGFwZS54MiA9IHggKyB3O1xuICAgICAgICAgICAgc2hhcGUueTIgPSB5ICsgaCAvIDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS54ID0geDtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfSxcblxuICAgICAgICByb3VuZFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgc2hhcGUueCA9IHg7XG4gICAgICAgICAgICBzaGFwZS55ID0geTtcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHcsIGgpO1xuICAgICAgICAgICAgc2hhcGUueCA9IHg7XG4gICAgICAgICAgICBzaGFwZS55ID0geTtcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IHNpemU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGluOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfSxcblxuICAgICAgICBhcnJvdzogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xuICAgICAgICAgICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN5bWJvbEJ1aWxkUHJveGllcyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc3ltYm9sQ3RvcnMpIHtcbiAgICAgICAgaWYgKHN5bWJvbEN0b3JzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgc3ltYm9sQ3RvcnNbbmFtZV0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTeW1ib2wgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcblxuICAgICAgICB0eXBlOiAnc3ltYm9sJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgc3ltYm9sVHlwZTogJycsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlID09PSAncGluJyAmJiBzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFBvc2l0aW9uID0gWyc1MCUnLCAnNDAlJ107XG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xuICAgICAgICAgICAgdmFyIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xuICAgICAgICAgICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCByZWN0XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSAncmVjdCc7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW1ib2xTaGFwZU1ha2Vyc1tzeW1ib2xUeXBlXShcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sLmJ1aWxkUGF0aChjdHgsIHByb3h5U3ltYm9sLnNoYXBlLCBpbkJ1bmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFByb3ZpZGUgc2V0Q29sb3IgaGVscGVyIG1ldGhvZCB0byBhdm9pZCBkZXRlcm1pbmUgaWYgc2V0IHRoZSBmaWxsIG9yIHN0cm9rZSBvdXRzaWRlXG4gICAgdmFyIHN5bWJvbFBhdGhTZXRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIGlmIChzeW1ib2xTaGFwZSAmJiBzeW1ib2xTaGFwZS5zeW1ib2xUeXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX19pc0VtcHR5QnJ1c2gpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsID0gJyNmZmYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5Yik5pat5Zu+5b2i6buY6K6k5piv5aGr5YWF6L+Y5piv5o+P6L6577yM5L2/55SoIG9ubHlTdHJva2UgP1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLmZpbGwgJiYgKHN5bWJvbFN0eWxlLmZpbGwgPSBjb2xvcik7XG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlICYmIChzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3ltYm9sVXRpbCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFN1cHBvcnQgaW1hZ2Ugb2JqZWN0LCBEeW5hbWljSW1hZ2UuXG5cbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gc3ltYm9sVHlwZS5zdWJzdHIoNSwgMSkudG9Mb3dlckNhc2UoKSArIHN5bWJvbFR5cGUuc3Vic3RyKDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGg7XG5cbiAgICAgICAgICAgIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHN5bWJvbFR5cGUuc2xpY2UoOCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IGdyYXBoaWMubWFrZVBhdGgoc3ltYm9sVHlwZS5zbGljZSg3KSwge30sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZTogc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcblxuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvciA9IHN5bWJvbFBhdGhTZXRDb2xvcjtcblxuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gc3ltYm9sVXRpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi91dGlsL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

eval("// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcz80NGM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcblxuICAgIHZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xuXG4gICAgdmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG4gICAgZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgICAgICAgdmFyIHIgPSAwO1xuXG4gICAgICAgIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgICAgICByIHw9IG4gJiAxO1xuICAgICAgICAgICAgbiA+Pj0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuICsgcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gICAgICAgIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydW5IaSAtIGxvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldmVyc2VSdW4oYXJyYXksIGxvLCBoaSkge1xuICAgICAgICBoaS0tO1xuXG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICAgICAgICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgICAgICAgICAgYXJyYXlbaGktLV0gPSB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBzdGFydCwgY29tcGFyZSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcblxuICAgICAgICAgICAgdmFyIGxlZnQgPSBsbztcbiAgICAgICAgICAgIHZhciByaWdodCA9IHN0YXJ0O1xuICAgICAgICAgICAgdmFyIG1pZDtcblxuICAgICAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgICAgICAgIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gc3RhcnQgLSBsZWZ0O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAzXSA9IGFycmF5W2xlZnQgKyAyXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPiAwKSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCsrO1xuICAgICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcblxuICAgICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgICAgICAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHJ1blN0YXJ0O1xuICAgICAgICB2YXIgcnVuTGVuZ3RoO1xuICAgICAgICB2YXIgc3RhY2tTaXplID0gMDtcblxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgICAgICAgICAgdG1wU3RvcmFnZUxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXAgPSBbXTtcblxuICAgICAgICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuXG4gICAgICAgIHJ1blN0YXJ0ID0gW107XG4gICAgICAgIHJ1bkxlbmd0aCA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1c2hSdW4oX3J1blN0YXJ0LCBfcnVuTGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5TdGFydFtzdGFja1NpemVdID0gX3J1blN0YXJ0O1xuICAgICAgICAgICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgICAgICAgICAgc3RhY2tTaXplICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZVJ1bnMoKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgICAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVuTGVuZ3RoW25dID4gcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2VBdChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZvcmNlTWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+IDAgJiYgcnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydDEgPSBydW5TdGFydFtpXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGgxID0gcnVuTGVuZ3RoW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGgyID0gcnVuTGVuZ3RoW2kgKyAxXTtcblxuICAgICAgICAgICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICAgICAgICAgIGlmIChpID09PSBzdGFja1NpemUgLSAzKSB7XG4gICAgICAgICAgICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgICAgICAgICAgIHJ1bkxlbmd0aFtpICsgMV0gPSBydW5MZW5ndGhbaSArIDJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFja1NpemUtLTtcblxuICAgICAgICAgICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBrO1xuICAgICAgICAgICAgbGVuZ3RoMSAtPSBrO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcblxuICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG4gICAgICAgICAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlSGlnaCAoc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgICAgICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgICAgICAgIHZhciBjdXN0b21EZXN0ID0gMDtcblxuICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY291bnQyID0gbGVuZ3RoMiAtIGdhbGxvcExlZnQoYXJyYXlbY3Vyc29yMV0sIHRtcCwgMCwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICAgICAgICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICAgICAgICAgICAgbWluR2FsbG9wID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lcmdlUnVucyA9IG1lcmdlUnVucztcbiAgICAgICAgdGhpcy5mb3JjZU1lcmdlUnVucyA9IGZvcmNlTWVyZ2VSdW5zO1xuICAgICAgICB0aGlzLnB1c2hSdW4gPSBwdXNoUnVuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICAgICAgICBpZiAoIWxvKSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoaSkge1xuICAgICAgICAgICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICAgICAgICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgICAgICAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgICAgICAgICAgdHMubWVyZ2VSdW5zKCk7XG5cbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgICAgICAgICBsbyArPSBydW5MZW5ndGg7XG4gICAgICAgIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgICAgICAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var Style = __webpack_require__(77);\n\n    var Element = __webpack_require__(68);\n    var RectText = __webpack_require__(206);\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanM/ZmYzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9TdHlsZScpO1xuXG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi9taXhpbi9SZWN0VGV4dCcpO1xuICAgIC8vIHZhciBTdGF0ZWZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vU3RhdGVmdWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnc3R5bGUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSk7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgIC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cbiAgICAgICAgdGhpcy5fX2NsaXBQYXRocyA9IFtdO1xuXG4gICAgICAgIC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgICAgICAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAgICAgICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGludmlzaWJsZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6MjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPr+aLluaLvVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjdWxsaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgICAgICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvZ3Jlc3NpdmU6IC0xLFxuXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzMkRSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gSW50ZXJmYWNlXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgICAgICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i55qE5YyF5Zu055uS5LiKXG4gICAgICAgICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH6K6w5Zu+5b2i5YWD57Sg5Li66ISP77yM5bm25LiU5Zyo5LiL5LiA5bin6YeN57uYXG4gICAgICAgICAqIE1hcmsgZGlzcGxheWFibGUgZWxlbWVudCBkaXJ0eSBhbmQgcmVmcmVzaCBuZXh0IGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAgICAgICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuICEoXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgICAgICAgLy8gICAgICk7XG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcblxuICAgIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpO1xuICAgIC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

eval("\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanM/MWIwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKi9cbiAgICB2YXIgR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JTdG9wcykge1xuXG4gICAgICAgIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG4gICAgfTtcblxuICAgIEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG5cbiAgICAgICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG5cbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JhZGllbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 42 */,
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(237),\n  /* template */\n  __webpack_require__(262),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.panel.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.panel.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-a40cb89a\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-a40cb89a\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbC52dWU/OGRlZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy5wYW5lbC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWE0MGNiODlhXFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Brcy5wYW5lbC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MucGFuZWwudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MucGFuZWwudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWE0MGNiODlhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtYTQwY2I4OWFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnBhbmVsLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(239),\n  /* template */\n  __webpack_require__(271),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.panelList.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.panelList.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-f305981e\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-f305981e\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbExpc3QudnVlPzdiM2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3MucGFuZWxMaXN0LnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZjMwNTk4MWVcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLnBhbmVsTGlzdC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MucGFuZWxMaXN0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gcGtzLnBhbmVsTGlzdC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZjMwNTk4MWVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1mMzA1OTgxZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MucGFuZWxMaXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var symbolUtil = __webpack_require__(38);\n    var graphic = __webpack_require__(2);\n    var numberUtil = __webpack_require__(5);\n    var labelHelper = __webpack_require__(112);\n\n    function getSymbolSize(data, idx) {\n        var symbolSize = data.getItemVisual(idx, 'symbolSize');\n        return symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n    }\n\n    function getScale(symbolSize) {\n        return [symbolSize[0] / 2, symbolSize[1] / 2];\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        graphic.initProps(symbolPath, {\n            scale: getScale(symbolSize)\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = getSymbolSize(data, idx);\n\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx, symbolSize);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            symbolPath.silent = false;\n            graphic.updateProps(symbolPath, {\n                scale: getScale(symbolSize)\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n        var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n            cursorStyle = itemModel.getShallow('cursor');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        cursorStyle && symbolPath.attr('cursor', cursorStyle);\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        var valueDim = labelHelper.findLabelValueDim(data);\n        labelHelper.setTextToStyle(\n            data, idx, valueDim, elStyle, seriesModel, labelModel, color\n        );\n        labelHelper.setTextToStyle(\n            data, idx, valueDim, hoverItemStyle, seriesModel, hoverLabelModel, color\n        );\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        var scale = getScale(symbolSize);\n\n        if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n            var onEmphasis = function() {\n                var ratio = scale[1] / scale[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(scale[0] * 1.1, scale[0] + 3),\n                        Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: scale\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = symbolPath.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2wuanM/ODM0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBIiwiZmlsZSI6IjQ1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbFxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3ltYm9sJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIGxhYmVsSGVscGVyID0gcmVxdWlyZSgnLi9sYWJlbEhlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3ltYm9sU2l6ZShkYXRhLCBpZHgpIHtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpO1xuICAgICAgICByZXR1cm4gc3ltYm9sU2l6ZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICA/IHN5bWJvbFNpemUuc2xpY2UoKVxuICAgICAgICAgICAgOiBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTY2FsZShzeW1ib2xTaXplKSB7XG4gICAgICAgIHJldHVybiBbc3ltYm9sU2l6ZVswXSAvIDIsIHN5bWJvbFNpemVbMV0gLyAyXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2x9XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3ltYm9sKGRhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gZHJpZnRTeW1ib2woZHgsIGR5KSB7XG4gICAgICAgIHRoaXMucGFyZW50LmRyaWZ0KGR4LCBkeSk7XG4gICAgfVxuXG4gICAgc3ltYm9sUHJvdG8uX2NyZWF0ZVN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHBhdGhzIGNyZWF0ZWQgYmVmb3JlXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIC8vIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXG4gICAgICAgIC8vICAgICBzeW1ib2xUeXBlLCAtMC41LCAtMC41LCAxLCAxLCBjb2xvclxuICAgICAgICAvLyApO1xuICAgICAgICAvLyBJZiB3aWR0aC9oZWlnaHQgYXJlIHNldCB0b28gc21hbGwgKGUuZy4sIHNldCB0byAxKSBvbiBpb3MxMFxuICAgICAgICAvLyBhbmQgbWFjT1MgU2llcnJhLCBhIGNpcmNsZSBzdHJva2UgYmVjb21lIGEgcmVjdCwgbm8gbWF0dGVyIHdoYXRcbiAgICAgICAgLy8gdGhlIHNjYWxlIGlzIHNldC4gU28gd2Ugc2V0IHdpZHRoL2hlaWdodCBhcyAyLiBTZWUgIzQxNTAuXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICBzeW1ib2xUeXBlLCAtMSwgLTEsIDIsIDIsIGNvbG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5hdHRyKHtcbiAgICAgICAgICAgIHoyOiAxMDAsXG4gICAgICAgICAgICBjdWxsaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGU6IFswLCAwXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV3cml0ZSBkcmlmdCBtZXRob2RcbiAgICAgICAgc3ltYm9sUGF0aC5kcmlmdCA9IGRyaWZ0U3ltYm9sO1xuXG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICAgICAgICAgIHNjYWxlOiBnZXRTY2FsZShzeW1ib2xTaXplKVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgdGhpcy5fc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGU7XG5cbiAgICAgICAgdGhpcy5hZGQoc3ltYm9sUGF0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0b0xhc3RGcmFtZVxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnN0b3BTeW1ib2xBbmltYXRpb24gPSBmdW5jdGlvbiAodG9MYXN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZEF0KDApLnN0b3BBbmltYXRpb24odG9MYXN0RnJhbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3ltYm9sIHBhdGggZWxlbWVudFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmdldFN5bWJvbFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBzY2FsZShha2EsIGN1cnJlbnQgc3ltYm9sIHNpemUpLlxuICAgICAqIEluY2x1ZGluZyB0aGUgY2hhbmdlIGNhdXNlZCBieSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKS5zY2FsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0IHN5bWJvbFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZEF0KDApLnRyaWdnZXIoJ2VtcGhhc2lzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25wbGF5IHN5bWJvbFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkQXQoMCkudHJpZ2dlcignbm9ybWFsJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gelxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnNldFogPSBmdW5jdGlvbiAoemxldmVsLCB6KSB7XG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgICBzeW1ib2xQYXRoLnpsZXZlbCA9IHpsZXZlbDtcbiAgICAgICAgc3ltYm9sUGF0aC56ID0gejtcbiAgICB9O1xuXG4gICAgc3ltYm9sUHJvdG8uc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24gKGRyYWdnYWJsZSkge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgc3ltYm9sUGF0aC5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICAgIHN5bWJvbFBhdGguY3Vyc29yID0gZHJhZ2dhYmxlID8gJ21vdmUnIDogJ3BvaW50ZXInO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3ltYm9sIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgICAgICB0aGlzLnNpbGVudCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnO1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBnZXRTeW1ib2xTaXplKGRhdGEsIGlkeCk7XG5cbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgIT09IHRoaXMuX3N5bWJvbFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNpbGVudCA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xQYXRoLCB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IGdldFNjYWxlKHN5bWJvbFNpemUpXG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVDb21tb24oZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSk7XG4gICAgICAgIHRoaXMuX3Nlcmllc01vZGVsID0gc2VyaWVzTW9kZWw7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBjb21tb24gcHJvcGVydGllc1xuICAgIHZhciBub3JtYWxTdHlsZUFjY2Vzc1BhdGggPSBbJ2l0ZW1TdHlsZScsICdub3JtYWwnXTtcbiAgICB2YXIgZW1waGFzaXNTdHlsZUFjY2Vzc1BhdGggPSBbJ2l0ZW1TdHlsZScsICdlbXBoYXNpcyddO1xuICAgIHZhciBub3JtYWxMYWJlbEFjY2Vzc1BhdGggPSBbJ2xhYmVsJywgJ25vcm1hbCddO1xuICAgIHZhciBlbXBoYXNpc0xhYmVsQWNjZXNzUGF0aCA9IFsnbGFiZWwnLCAnZW1waGFzaXMnXTtcblxuICAgIHN5bWJvbFByb3RvLl91cGRhdGVDb21tb24gPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSkge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIC8vIFJlc2V0IHN0eWxlXG4gICAgICAgIGlmIChzeW1ib2xQYXRoLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoe1xuICAgICAgICAgICAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWVzU2NvcGUgPSBzZXJpZXNTY29wZSB8fCBudWxsO1xuXG4gICAgICAgIHZhciBpdGVtU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5pdGVtU3R5bGU7XG4gICAgICAgIHZhciBob3Zlckl0ZW1TdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVySXRlbVN0eWxlO1xuICAgICAgICB2YXIgc3ltYm9sUm90YXRlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sUm90YXRlO1xuICAgICAgICB2YXIgc3ltYm9sT2Zmc2V0ID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sT2Zmc2V0O1xuICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxhYmVsTW9kZWw7XG4gICAgICAgIHZhciBob3ZlckxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckxhYmVsTW9kZWw7XG4gICAgICAgIHZhciBob3ZlckFuaW1hdGlvbiA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyQW5pbWF0aW9uO1xuICAgICAgICB2YXIgY3Vyc29yU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5jdXJzb3JTdHlsZTtcblxuICAgICAgICBpZiAoIXNlcmllc1Njb3BlIHx8IGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG5cbiAgICAgICAgICAgIC8vIENvbG9yIG11c3QgYmUgZXhjbHVkZWQuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHN5bWJvbCBwcm92aWRlIHNldENvbG9yIGluZGl2aWR1YWxseSB0byBzZXQgZmlsbCBhbmQgc3Ryb2tlXG4gICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwobm9ybWFsU3R5bGVBY2Nlc3NQYXRoKS5nZXRJdGVtU3R5bGUoWydjb2xvciddKTtcbiAgICAgICAgICAgIGhvdmVySXRlbVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKGVtcGhhc2lzU3R5bGVBY2Nlc3NQYXRoKS5nZXRJdGVtU3R5bGUoKTtcblxuICAgICAgICAgICAgc3ltYm9sUm90YXRlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFJvdGF0ZScpO1xuICAgICAgICAgICAgc3ltYm9sT2Zmc2V0ID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbE9mZnNldCcpO1xuXG4gICAgICAgICAgICBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKG5vcm1hbExhYmVsQWNjZXNzUGF0aCk7XG4gICAgICAgICAgICBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoZW1waGFzaXNMYWJlbEFjY2Vzc1BhdGgpO1xuICAgICAgICAgICAgaG92ZXJBbmltYXRpb24gPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnaG92ZXJBbmltYXRpb24nKTtcbiAgICAgICAgICAgIGN1cnNvclN0eWxlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2N1cnNvcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG92ZXJJdGVtU3R5bGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBob3Zlckl0ZW1TdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxTdHlsZSA9IHN5bWJvbFBhdGguc3R5bGU7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5hdHRyKCdyb3RhdGlvbicsIChzeW1ib2xSb3RhdGUgfHwgMCkgKiBNYXRoLlBJIC8gMTgwIHx8IDApO1xuXG4gICAgICAgIGlmIChzeW1ib2xPZmZzZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbFBhdGguYXR0cigncG9zaXRpb24nLCBbXG4gICAgICAgICAgICAgICAgbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzBdLCBzeW1ib2xTaXplWzBdKSxcbiAgICAgICAgICAgICAgICBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMV0sIHN5bWJvbFNpemVbMV0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnNvclN0eWxlICYmIHN5bWJvbFBhdGguYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpO1xuXG4gICAgICAgIC8vIFBFTkRJTkcgc2V0Q29sb3IgYmVmb3JlIHNldFN0eWxlISEhXG4gICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IoY29sb3IpO1xuXG4gICAgICAgIHN5bWJvbFBhdGguc2V0U3R5bGUoaXRlbVN0eWxlKTtcblxuICAgICAgICB2YXIgb3BhY2l0eSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5Jyk7XG4gICAgICAgIGlmIChvcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsU3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVEaW0gPSBsYWJlbEhlbHBlci5maW5kTGFiZWxWYWx1ZURpbShkYXRhKTtcbiAgICAgICAgbGFiZWxIZWxwZXIuc2V0VGV4dFRvU3R5bGUoXG4gICAgICAgICAgICBkYXRhLCBpZHgsIHZhbHVlRGltLCBlbFN0eWxlLCBzZXJpZXNNb2RlbCwgbGFiZWxNb2RlbCwgY29sb3JcbiAgICAgICAgKTtcbiAgICAgICAgbGFiZWxIZWxwZXIuc2V0VGV4dFRvU3R5bGUoXG4gICAgICAgICAgICBkYXRhLCBpZHgsIHZhbHVlRGltLCBob3Zlckl0ZW1TdHlsZSwgc2VyaWVzTW9kZWwsIGhvdmVyTGFiZWxNb2RlbCwgY29sb3JcbiAgICAgICAgKTtcblxuICAgICAgICBzeW1ib2xQYXRoLm9mZignbW91c2VvdmVyJylcbiAgICAgICAgICAgIC5vZmYoJ21vdXNlb3V0JylcbiAgICAgICAgICAgIC5vZmYoJ2VtcGhhc2lzJylcbiAgICAgICAgICAgIC5vZmYoJ25vcm1hbCcpO1xuXG4gICAgICAgIHN5bWJvbFBhdGguaG92ZXJTdHlsZSA9IGhvdmVySXRlbVN0eWxlO1xuXG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShzeW1ib2xQYXRoKTtcblxuICAgICAgICB2YXIgc2NhbGUgPSBnZXRTY2FsZShzeW1ib2xTaXplKTtcblxuICAgICAgICBpZiAoaG92ZXJBbmltYXRpb24gJiYgc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBvbkVtcGhhc2lzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gc2NhbGVbMV0gLyBzY2FsZVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVUbyh7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChzY2FsZVswXSAqIDEuMSwgc2NhbGVbMF0gKyAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHNjYWxlWzFdICogMS4xLCBzY2FsZVsxXSArIDMgKiByYXRpbylcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sIDQwMCwgJ2VsYXN0aWNPdXQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25Ob3JtYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVUbyh7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgICAgICAgICAgIH0sIDQwMCwgJ2VsYXN0aWNPdXQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzeW1ib2xQYXRoLm9uKCdtb3VzZW92ZXInLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbClcbiAgICAgICAgICAgICAgICAub24oJ2VtcGhhc2lzJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgICAgICAub24oJ25vcm1hbCcsIG9uTm9ybWFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzeW1ib2xQcm90by5mYWRlT3V0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgICAvLyBBdm9pZCBtaXN0YWtlbiBob3ZlciB3aGVuIGZhZGluZyBvdXRcbiAgICAgICAgdGhpcy5zaWxlbnQgPSBzeW1ib2xQYXRoLnNpbGVudCA9IHRydWU7XG4gICAgICAgIC8vIE5vdCBzaG93IHRleHQgd2hlbiBhbmltYXRpbmdcbiAgICAgICAgc3ltYm9sUGF0aC5zdHlsZS50ZXh0ID0gJyc7XG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sUGF0aCwge1xuICAgICAgICAgICAgc2NhbGU6IFswLCAwXVxuICAgICAgICB9LCB0aGlzLl9zZXJpZXNNb2RlbCwgdGhpcy5kYXRhSW5kZXgsIGNiKTtcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFN5bWJvbCwgZ3JhcGhpYy5Hcm91cCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n\n    /**\n     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object} {point: [x, y], el: ...} point Will not be null.\n     */\n    module.exports = function (finder, ecModel) {\n        var point = [];\n        var seriesIndex = finder.seriesIndex;\n        var seriesModel;\n        if (seriesIndex == null || !(\n            seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n        )) {\n            return {point: []};\n        }\n\n        var data = seriesModel.getData();\n        var dataIndex = modelUtil.queryDataIndex(data, finder);\n        if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n            return {point: []};\n        }\n\n        var el = data.getItemGraphicEl(dataIndex);\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (seriesModel.getTooltipPosition) {\n            point = seriesModel.getTooltipPosition(dataIndex) || [];\n        }\n        else if (coordSys && coordSys.dataToPoint) {\n            point = coordSys.dataToPoint(\n                data.getValues(\n                    zrUtil.map(coordSys.dimensions, function (dim) {\n                        return seriesModel.coordDimToDataDim(dim)[0];\n                    }), dataIndex, true\n                )\n            ) || [];\n        }\n        else if (el) {\n            // Use graphic bounding rect\n            var rect = el.getBoundingRect().clone();\n            rect.applyTransform(el.transform);\n            point = [\n                rect.x + rect.width / 2,\n                rect.y + rect.height / 2\n            ];\n        }\n\n        return {point: point, el: el};\n    };\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzPzRlNmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPLGtCQUFrQjtBQUN4QyxlQUFlLDRCQUE0QjtBQUMzQyxnQkFBZ0IsT0FBTyxFQUFFLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQiIsImZpbGUiOiI0Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmluZGVyIGNvbnRhaW5zIHtzZXJpZXNJbmRleCwgZGF0YUluZGV4LCBkYXRhSW5kZXhJbnNpZGV9XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb2ludDogW3gsIHldLCBlbDogLi4ufSBwb2ludCBXaWxsIG5vdCBiZSBudWxsLlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZpbmRlciwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBbXTtcbiAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gZmluZGVyLnNlcmllc0luZGV4O1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWw7XG4gICAgICAgIGlmIChzZXJpZXNJbmRleCA9PSBudWxsIHx8ICEoXG4gICAgICAgICAgICBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleClcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtwb2ludDogW119O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgZmluZGVyKTtcbiAgICAgICAgaWYgKGRhdGFJbmRleCA9PSBudWxsIHx8IHpyVXRpbC5pc0FycmF5KGRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7cG9pbnQ6IFtdfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgIGlmIChzZXJpZXNNb2RlbC5nZXRUb29sdGlwUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0VG9vbHRpcFBvc2l0aW9uKGRhdGFJbmRleCkgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGF0YVRvUG9pbnQpIHtcbiAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRWYWx1ZXMoXG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tYXAoY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGRpbSlbMF07XG4gICAgICAgICAgICAgICAgICAgIH0pLCBkYXRhSW5kZXgsIHRydWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHx8IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsKSB7XG4gICAgICAgICAgICAvLyBVc2UgZ3JhcGhpYyBib3VuZGluZyByZWN0XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICBwb2ludCA9IFtcbiAgICAgICAgICAgICAgICByZWN0LnggKyByZWN0LndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge3BvaW50OiBwb2ludCwgZWw6IGVsfTtcbiAgICB9O1xuXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var env = __webpack_require__(6);\n    var zrUtil = __webpack_require__(0);\n    var get = __webpack_require__(4).makeGetter();\n\n    var each = zrUtil.each;\n\n    var globalListener = {};\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Function} handler\n     *      param: {string} currTrigger\n     *      param: {Array.<number>} point\n     */\n    globalListener.register = function (key, api, handler) {\n        if (env.node) {\n            return;\n        }\n\n        var zr = api.getZr();\n        get(zr).records || (get(zr).records = {});\n\n        initGlobalListeners(zr, api);\n\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\n        record.handler = handler;\n    };\n\n    function initGlobalListeners(zr, api) {\n        if (get(zr).initialized) {\n            return;\n        }\n\n        get(zr).initialized = true;\n\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\n        // useHandler('mouseout', onLeave);\n        useHandler('globalout', onLeave);\n\n        function useHandler(eventType, cb) {\n            zr.on(eventType, function (e) {\n                var dis = makeDispatchAction(api);\n\n                each(get(zr).records, function (record) {\n                    record && cb(record, e, dis.dispatchAction);\n                });\n\n                dispatchTooltipFinally(dis.pendings, api);\n            });\n        }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n        var showLen = pendings.showTip.length;\n        var hideLen = pendings.hideTip.length;\n\n        var actuallyPayload;\n        if (showLen) {\n            actuallyPayload = pendings.showTip[showLen - 1];\n        }\n        else if (hideLen) {\n            actuallyPayload = pendings.hideTip[hideLen - 1];\n        }\n        if (actuallyPayload) {\n            actuallyPayload.dispatchAction = null;\n            api.dispatchAction(actuallyPayload);\n        }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n        record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n        record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n        var pendings = {\n            showTip: [],\n            hideTip: []\n        };\n        // FIXME\n        // better approach?\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n        // So we have to add \"final stage\" to merge those dispatched actions.\n        var dispatchAction = function (payload) {\n            var pendingList = pendings[payload.type];\n            if (pendingList) {\n                pendingList.push(payload);\n            }\n            else {\n                payload.dispatchAction = dispatchAction;\n                api.dispatchAction(payload);\n            }\n        };\n\n        return {\n            dispatchAction: dispatchAction,\n            pendings: pendings\n        };\n    }\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    globalListener.unregister = function (key, api) {\n        if (env.node) {\n            return;\n        }\n        var zr = api.getZr();\n        var record = (get(zr).records || {})[key];\n        if (record) {\n            get(zr).records[key] = null;\n        }\n    };\n\n    module.exports = globalListener;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lci5qcz9hZjI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsU0FBUztBQUN4QixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBnZXQgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJykubWFrZUdldHRlcigpO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogICAgICBwYXJhbToge3N0cmluZ30gY3VyclRyaWdnZXJcbiAgICAgKiAgICAgIHBhcmFtOiB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICovXG4gICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5LCBhcGksIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICAgICAgZ2V0KHpyKS5yZWNvcmRzIHx8IChnZXQoenIpLnJlY29yZHMgPSB7fSk7XG5cbiAgICAgICAgaW5pdEdsb2JhbExpc3RlbmVycyh6ciwgYXBpKTtcblxuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0KHpyKS5yZWNvcmRzW2tleV0gfHwgKGdldCh6cikucmVjb3Jkc1trZXldID0ge30pO1xuICAgICAgICByZWNvcmQuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSkge1xuICAgICAgICBpZiAoZ2V0KHpyKS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0KHpyKS5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgdXNlSGFuZGxlcignY2xpY2snLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ2NsaWNrJykpO1xuICAgICAgICB1c2VIYW5kbGVyKCdtb3VzZW1vdmUnLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ21vdXNlbW92ZScpKTtcbiAgICAgICAgLy8gdXNlSGFuZGxlcignbW91c2VvdXQnLCBvbkxlYXZlKTtcbiAgICAgICAgdXNlSGFuZGxlcignZ2xvYmFsb3V0Jywgb25MZWF2ZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlSGFuZGxlcihldmVudFR5cGUsIGNiKSB7XG4gICAgICAgICAgICB6ci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcyA9IG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpO1xuXG4gICAgICAgICAgICAgICAgZWFjaChnZXQoenIpLnJlY29yZHMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkICYmIGNiKHJlY29yZCwgZSwgZGlzLmRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoVG9vbHRpcEZpbmFsbHkoZGlzLnBlbmRpbmdzLCBhcGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KHBlbmRpbmdzLCBhcGkpIHtcbiAgICAgICAgdmFyIHNob3dMZW4gPSBwZW5kaW5ncy5zaG93VGlwLmxlbmd0aDtcbiAgICAgICAgdmFyIGhpZGVMZW4gPSBwZW5kaW5ncy5oaWRlVGlwLmxlbmd0aDtcblxuICAgICAgICB2YXIgYWN0dWFsbHlQYXlsb2FkO1xuICAgICAgICBpZiAoc2hvd0xlbikge1xuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3Muc2hvd1RpcFtzaG93TGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGlkZUxlbikge1xuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3MuaGlkZVRpcFtoaWRlTGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdHVhbGx5UGF5bG9hZCkge1xuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbihhY3R1YWxseVBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25MZWF2ZShyZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgICAgIHJlY29yZC5oYW5kbGVyKCdsZWF2ZScsIG51bGwsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb0VudGVyKGN1cnJUcmlnZ2VyLCByZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgICAgIHJlY29yZC5oYW5kbGVyKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSkge1xuICAgICAgICB2YXIgcGVuZGluZ3MgPSB7XG4gICAgICAgICAgICBzaG93VGlwOiBbXSxcbiAgICAgICAgICAgIGhpZGVUaXA6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIGJldHRlciBhcHByb2FjaD9cbiAgICAgICAgLy8gJ3Nob3dUaXAnIGFuZCAnaGlkZVRpcCcgY2FuIGJlIHRyaWdnZXJlZCBieSBheGlzUG9pbnRlciBhbmQgdG9vbHRpcCxcbiAgICAgICAgLy8gd2hpY2ggbWF5IGJlIGNvbmZsaWN0LCAoYXhpc1BvaW50ZXIgY2FsbCBzaG93VGlwIGJ1dCB0b29sdGlwIGNhbGwgaGlkZVRpcCk7XG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gYWRkIFwiZmluYWwgc3RhZ2VcIiB0byBtZXJnZSB0aG9zZSBkaXNwYXRjaGVkIGFjdGlvbnMuXG4gICAgICAgIHZhciBkaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ0xpc3QgPSBwZW5kaW5nc1twYXlsb2FkLnR5cGVdO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdMaXN0KSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0xpc3QucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBkaXNwYXRjaEFjdGlvbjtcbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uOiBkaXNwYXRjaEFjdGlvbixcbiAgICAgICAgICAgIHBlbmRpbmdzOiBwZW5kaW5nc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICovXG4gICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChrZXksIGFwaSkge1xuICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICAgICAgdmFyIHJlY29yZCA9IChnZXQoenIpLnJlY29yZHMgfHwge30pW2tleV07XG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGdldCh6cikucmVjb3Jkc1trZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbExpc3RlbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var textContain = __webpack_require__(16);\n    var formatUtil = __webpack_require__(10);\n    var matrix = __webpack_require__(20);\n    var axisHelper = __webpack_require__(17);\n    var AxisBuilder = __webpack_require__(49);\n\n    var helper = {};\n\n    /**\n     * @param {module:echarts/model/Model} axisPointerModel\n     */\n    helper.buildElStyle = function (axisPointerModel) {\n        var axisPointerType = axisPointerModel.get('type');\n        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n        var style;\n        if (axisPointerType === 'line') {\n            style = styleModel.getLineStyle();\n            style.fill = null;\n        }\n        else if (axisPointerType === 'shadow') {\n            style = styleModel.getAreaStyle();\n            style.stroke = null;\n        }\n        return style;\n    };\n\n    /**\n     * @param {Function} labelPos {align, verticalAlign, position}\n     */\n    helper.buildLabelElOption = function (\n        elOption, axisModel, axisPointerModel, api, labelPos\n    ) {\n        var value = axisPointerModel.get('value');\n        var text = helper.getValueLabel(\n            value, axisModel.axis, axisModel.ecModel,\n            axisPointerModel.get('seriesDataIndices'),\n            {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            }\n        );\n        var labelModel = axisPointerModel.getModel('label');\n        var textStyleModel = labelModel.getModel('textStyle');\n        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n\n        var font = textStyleModel.getFont();\n        var textRect = textContain.getBoundingRect(\n            text, font, labelPos.textAlign, labelPos.textBaseline\n        );\n\n        var position = labelPos.position;\n        var width = textRect.width + paddings[1] + paddings[3];\n        var height = textRect.height + paddings[0] + paddings[2];\n\n        // Adjust by align.\n        var align = labelPos.align;\n        align === 'right' && (position[0] -= width);\n        align === 'center' && (position[0] -= width / 2);\n        var verticalAlign = labelPos.verticalAlign;\n        verticalAlign === 'bottom' && (position[1] -= height);\n        verticalAlign === 'middle' && (position[1] -= height / 2);\n\n        // Not overflow ec container\n        confineInContainer(position, width, height, api);\n\n        var bgColor = labelModel.get('backgroundColor');\n        if (!bgColor || bgColor === 'auto') {\n            bgColor = axisModel.get('axisLine.lineStyle.color');\n        }\n\n        elOption.label = {\n            shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n            position: position.slice(),\n            style: {\n                text: text,\n                textFont: font,\n                textFill: textStyleModel.getTextColor(),\n                textPosition: 'inside',\n                fill: bgColor,\n                stroke: labelModel.get('borderColor') || 'transparent',\n                lineWidth: labelModel.get('borderWidth') || 0,\n                shadowBlur: labelModel.get('shadowBlur'),\n                shadowColor: labelModel.get('shadowColor'),\n                shadowOffsetX: labelModel.get('shadowOffsetX'),\n                shadowOffsetY: labelModel.get('shadowOffsetY')\n            },\n            // Lable should be over axisPointer.\n            z2: 10\n        };\n    };\n\n    // Do not overflow ec container\n    function confineInContainer(position, width, height, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        position[0] = Math.min(position[0] + width, viewWidth) - width;\n        position[1] = Math.min(position[1] + height, viewHeight) - height;\n        position[0] = Math.max(position[0], 0);\n        position[1] = Math.max(position[1], 0);\n    }\n\n    /**\n     * @param {number} value\n     * @param {module:echarts/coord/Axis} axis\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} opt\n     * @param {Array.<Object>} seriesDataIndices\n     * @param {number|string} opt.precision 'auto' or a number\n     * @param {string|Function} opt.formatter label formatter\n     */\n    helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) {\n        var text = axis.scale.getLabel(\n            // If `precision` is set, width can be fixed (like '12.00500'), which\n            // helps to debounce when when moving label.\n            value, {precision: opt.precision}\n        );\n        var formatter = opt.formatter;\n\n        if (formatter) {\n            var params = {\n                value: axisHelper.getAxisRawValue(axis, value),\n                seriesData: []\n            };\n            zrUtil.each(seriesDataIndices, function (idxItem) {\n                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                var dataIndex = idxItem.dataIndexInside;\n                var dataParams = series && series.getDataParams(dataIndex);\n                dataParams && params.seriesData.push(dataParams);\n            });\n\n            if (zrUtil.isString(formatter)) {\n                text = formatter.replace('{value}', text);\n            }\n            else if (zrUtil.isFunction(formatter)) {\n                text = formatter(params);\n            }\n        }\n\n        return text;\n    };\n\n    /**\n     * @param {module:echarts/coord/Axis} axis\n     * @param {number} value\n     * @param {Object} layoutInfo {\n     *  rotation, position, labelOffset, labelDirection, labelMargin\n     * }\n     */\n    helper.getTransformedPosition = function (axis, value, layoutInfo) {\n        var transform = matrix.create();\n        matrix.rotate(transform, transform, layoutInfo.rotation);\n        matrix.translate(transform, transform, layoutInfo.position);\n\n        return graphic.applyTransform([\n            axis.dataToCoord(value),\n            (layoutInfo.labelOffset || 0)\n                + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n        ], transform);\n    };\n\n    helper.buildCartesianSingleLabelElOption = function (\n        value, elOption, layoutInfo, axisModel, axisPointerModel, api\n    ) {\n        var textLayout = AxisBuilder.innerTextLayout(\n            layoutInfo.rotation, 0, layoutInfo.labelDirection\n        );\n        layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n        helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n            position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n            align: textLayout.textAlign,\n            verticalAlign: textLayout.textVerticalAlign\n        });\n    };\n\n    /**\n     * @param {Array.<number>} p1\n     * @param {Array.<number>} p2\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeLineShape = function (p1, p2, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x1: p1[xDimIndex],\n            y1: p1[1 - xDimIndex],\n            x2: p2[xDimIndex],\n            y2: p2[1 - xDimIndex]\n        };\n    };\n\n    /**\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeRectShape = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    };\n\n    helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci92aWV3SGVscGVyLmpzPzg4ZDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsNEVBQTRFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsY0FBYztBQUM3QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vY29vcmQvYXhpc0hlbHBlcicpO1xuICAgIHZhciBBeGlzQnVpbGRlciA9IHJlcXVpcmUoJy4uL2F4aXMvQXhpc0J1aWxkZXInKTtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNQb2ludGVyTW9kZWxcbiAgICAgKi9cbiAgICBoZWxwZXIuYnVpbGRFbFN0eWxlID0gZnVuY3Rpb24gKGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgIHZhciBzdHlsZU1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbChheGlzUG9pbnRlclR5cGUgKyAnU3R5bGUnKTtcbiAgICAgICAgdmFyIHN0eWxlO1xuICAgICAgICBpZiAoYXhpc1BvaW50ZXJUeXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcbiAgICAgICAgICAgIHN0eWxlLmZpbGwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ3NoYWRvdycpIHtcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKTtcbiAgICAgICAgICAgIHN0eWxlLnN0cm9rZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsYWJlbFBvcyB7YWxpZ24sIHZlcnRpY2FsQWxpZ24sIHBvc2l0aW9ufVxuICAgICAqL1xuICAgIGhlbHBlci5idWlsZExhYmVsRWxPcHRpb24gPSBmdW5jdGlvbiAoXG4gICAgICAgIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgbGFiZWxQb3NcbiAgICApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7XG4gICAgICAgIHZhciB0ZXh0ID0gaGVscGVyLmdldFZhbHVlTGFiZWwoXG4gICAgICAgICAgICB2YWx1ZSwgYXhpc01vZGVsLmF4aXMsIGF4aXNNb2RlbC5lY01vZGVsLFxuICAgICAgICAgICAgYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3Nlcmllc0RhdGFJbmRpY2VzJyksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwucHJlY2lzaW9uJyksXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwuZm9ybWF0dGVyJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdsYWJlbCcpO1xuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgdmFyIHBhZGRpbmdzID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShsYWJlbE1vZGVsLmdldCgncGFkZGluZycpIHx8IDApO1xuXG4gICAgICAgIHZhciBmb250ID0gdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpO1xuICAgICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICB0ZXh0LCBmb250LCBsYWJlbFBvcy50ZXh0QWxpZ24sIGxhYmVsUG9zLnRleHRCYXNlbGluZVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGxhYmVsUG9zLnBvc2l0aW9uO1xuICAgICAgICB2YXIgd2lkdGggPSB0ZXh0UmVjdC53aWR0aCArIHBhZGRpbmdzWzFdICsgcGFkZGluZ3NbM107XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQgKyBwYWRkaW5nc1swXSArIHBhZGRpbmdzWzJdO1xuXG4gICAgICAgIC8vIEFkanVzdCBieSBhbGlnbi5cbiAgICAgICAgdmFyIGFsaWduID0gbGFiZWxQb3MuYWxpZ247XG4gICAgICAgIGFsaWduID09PSAncmlnaHQnICYmIChwb3NpdGlvblswXSAtPSB3aWR0aCk7XG4gICAgICAgIGFsaWduID09PSAnY2VudGVyJyAmJiAocG9zaXRpb25bMF0gLT0gd2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBsYWJlbFBvcy52ZXJ0aWNhbEFsaWduO1xuICAgICAgICB2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJyAmJiAocG9zaXRpb25bMV0gLT0gaGVpZ2h0KTtcbiAgICAgICAgdmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHBvc2l0aW9uWzFdIC09IGhlaWdodCAvIDIpO1xuXG4gICAgICAgIC8vIE5vdCBvdmVyZmxvdyBlYyBjb250YWluZXJcbiAgICAgICAgY29uZmluZUluQ29udGFpbmVyKHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0LCBhcGkpO1xuXG4gICAgICAgIHZhciBiZ0NvbG9yID0gbGFiZWxNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICBpZiAoIWJnQ29sb3IgfHwgYmdDb2xvciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBiZ0NvbG9yID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbE9wdGlvbi5sYWJlbCA9IHtcbiAgICAgICAgICAgIHNoYXBlOiB7eDogMCwgeTogMCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgcjogbGFiZWxNb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbi5zbGljZSgpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIHRleHRGb250OiBmb250LFxuICAgICAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnLFxuICAgICAgICAgICAgICAgIGZpbGw6IGJnQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsYWJlbE1vZGVsLmdldCgnYm9yZGVyQ29sb3InKSB8fCAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogbGFiZWxNb2RlbC5nZXQoJ2JvcmRlcldpZHRoJykgfHwgMCxcbiAgICAgICAgICAgICAgICBzaGFkb3dCbHVyOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93Qmx1cicpLFxuICAgICAgICAgICAgICAgIHNoYWRvd0NvbG9yOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93Q29sb3InKSxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRYOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93T2Zmc2V0WCcpLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IGxhYmVsTW9kZWwuZ2V0KCdzaGFkb3dPZmZzZXRZJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBMYWJsZSBzaG91bGQgYmUgb3ZlciBheGlzUG9pbnRlci5cbiAgICAgICAgICAgIHoyOiAxMFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBEbyBub3Qgb3ZlcmZsb3cgZWMgY29udGFpbmVyXG4gICAgZnVuY3Rpb24gY29uZmluZUluQ29udGFpbmVyKHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0LCBhcGkpIHtcbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgdmlld0hlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgICAgICAgcG9zaXRpb25bMF0gPSBNYXRoLm1pbihwb3NpdGlvblswXSArIHdpZHRoLCB2aWV3V2lkdGgpIC0gd2lkdGg7XG4gICAgICAgIHBvc2l0aW9uWzFdID0gTWF0aC5taW4ocG9zaXRpb25bMV0gKyBoZWlnaHQsIHZpZXdIZWlnaHQpIC0gaGVpZ2h0O1xuICAgICAgICBwb3NpdGlvblswXSA9IE1hdGgubWF4KHBvc2l0aW9uWzBdLCAwKTtcbiAgICAgICAgcG9zaXRpb25bMV0gPSBNYXRoLm1heChwb3NpdGlvblsxXSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBheGlzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gc2VyaWVzRGF0YUluZGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdC5wcmVjaXNpb24gJ2F1dG8nIG9yIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IG9wdC5mb3JtYXR0ZXIgbGFiZWwgZm9ybWF0dGVyXG4gICAgICovXG4gICAgaGVscGVyLmdldFZhbHVlTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUsIGF4aXMsIGVjTW9kZWwsIHNlcmllc0RhdGFJbmRpY2VzLCBvcHQpIHtcbiAgICAgICAgdmFyIHRleHQgPSBheGlzLnNjYWxlLmdldExhYmVsKFxuICAgICAgICAgICAgLy8gSWYgYHByZWNpc2lvbmAgaXMgc2V0LCB3aWR0aCBjYW4gYmUgZml4ZWQgKGxpa2UgJzEyLjAwNTAwJyksIHdoaWNoXG4gICAgICAgICAgICAvLyBoZWxwcyB0byBkZWJvdW5jZSB3aGVuIHdoZW4gbW92aW5nIGxhYmVsLlxuICAgICAgICAgICAgdmFsdWUsIHtwcmVjaXNpb246IG9wdC5wcmVjaXNpb259XG4gICAgICAgICk7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBvcHQuZm9ybWF0dGVyO1xuXG4gICAgICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGF4aXNIZWxwZXIuZ2V0QXhpc1Jhd1ZhbHVlKGF4aXMsIHZhbHVlKSxcbiAgICAgICAgICAgICAgICBzZXJpZXNEYXRhOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoaWR4SXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGlkeEl0ZW0uZGF0YUluZGV4SW5zaWRlO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhUGFyYW1zID0gc2VyaWVzICYmIHNlcmllcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgZGF0YVBhcmFtcyAmJiBwYXJhbXMuc2VyaWVzRGF0YS5wdXNoKGRhdGFQYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcoZm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzRnVuY3Rpb24oZm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXR0ZXIocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0F4aXN9IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0SW5mbyB7XG4gICAgICogIHJvdGF0aW9uLCBwb3NpdGlvbiwgbGFiZWxPZmZzZXQsIGxhYmVsRGlyZWN0aW9uLCBsYWJlbE1hcmdpblxuICAgICAqIH1cbiAgICAgKi9cbiAgICBoZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIChheGlzLCB2YWx1ZSwgbGF5b3V0SW5mbykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICBtYXRyaXgucm90YXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBsYXlvdXRJbmZvLnJvdGF0aW9uKTtcbiAgICAgICAgbWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgbGF5b3V0SW5mby5wb3NpdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW1xuICAgICAgICAgICAgYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSksXG4gICAgICAgICAgICAobGF5b3V0SW5mby5sYWJlbE9mZnNldCB8fCAwKVxuICAgICAgICAgICAgICAgICsgKGxheW91dEluZm8ubGFiZWxEaXJlY3Rpb24gfHwgMSkgKiAobGF5b3V0SW5mby5sYWJlbE1hcmdpbiB8fCAwKVxuICAgICAgICBdLCB0cmFuc2Zvcm0pO1xuICAgIH07XG5cbiAgICBoZWxwZXIuYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uID0gZnVuY3Rpb24gKFxuICAgICAgICB2YWx1ZSwgZWxPcHRpb24sIGxheW91dEluZm8sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpXG4gICAgKSB7XG4gICAgICAgIHZhciB0ZXh0TGF5b3V0ID0gQXhpc0J1aWxkZXIuaW5uZXJUZXh0TGF5b3V0KFxuICAgICAgICAgICAgbGF5b3V0SW5mby5yb3RhdGlvbiwgMCwgbGF5b3V0SW5mby5sYWJlbERpcmVjdGlvblxuICAgICAgICApO1xuICAgICAgICBsYXlvdXRJbmZvLmxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLm1hcmdpbicpO1xuICAgICAgICBoZWxwZXIuYnVpbGRMYWJlbEVsT3B0aW9uKGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwge1xuICAgICAgICAgICAgcG9zaXRpb246IGhlbHBlci5nZXRUcmFuc2Zvcm1lZFBvc2l0aW9uKGF4aXNNb2RlbC5heGlzLCB2YWx1ZSwgbGF5b3V0SW5mbyksXG4gICAgICAgICAgICBhbGlnbjogdGV4dExheW91dC50ZXh0QWxpZ24sXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiB0ZXh0TGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwMVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4RGltSW5kZXg9MF0gb3IgMVxuICAgICAqL1xuICAgIGhlbHBlci5tYWtlTGluZVNoYXBlID0gZnVuY3Rpb24gKHAxLCBwMiwgeERpbUluZGV4KSB7XG4gICAgICAgIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDE6IHAxW3hEaW1JbmRleF0sXG4gICAgICAgICAgICB5MTogcDFbMSAtIHhEaW1JbmRleF0sXG4gICAgICAgICAgICB4MjogcDJbeERpbUluZGV4XSxcbiAgICAgICAgICAgIHkyOiBwMlsxIC0geERpbUluZGV4XVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB4eVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHdoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4RGltSW5kZXg9MF0gb3IgMVxuICAgICAqL1xuICAgIGhlbHBlci5tYWtlUmVjdFNoYXBlID0gZnVuY3Rpb24gKHh5LCB3aCwgeERpbUluZGV4KSB7XG4gICAgICAgIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeHlbeERpbUluZGV4XSxcbiAgICAgICAgICAgIHk6IHh5WzEgLSB4RGltSW5kZXhdLFxuICAgICAgICAgICAgd2lkdGg6IHdoW3hEaW1JbmRleF0sXG4gICAgICAgICAgICBoZWlnaHQ6IHdoWzEgLSB4RGltSW5kZXhdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGhlbHBlci5tYWtlU2VjdG9yU2hhcGUgPSBmdW5jdGlvbiAoY3gsIGN5LCByMCwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgIHIwOiByMCxcbiAgICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci92aWV3SGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var formatUtil = __webpack_require__(10);\n    var graphic = __webpack_require__(2);\n    var Model = __webpack_require__(9);\n    var numberUtil = __webpack_require__(5);\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = __webpack_require__(7);\n    var matrix = __webpack_require__(20);\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.scale.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = (\n                retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n            ) * PI / 180;\n\n            var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelStr = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.textVerticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function'\n                            ? textColor(\n                                // (1) In category axis with data zoom, tick is not the original\n                                // index of axis.data. So tick should not be exposed to user\n                                // in category axis.\n                                // (2) Compatible with previous version, which always returns labelStr.\n                                // But in interval scale labelStr is like '223,445', which maked\n                                // user repalce ','. So we modify it to return original val but remain\n                                // it as 'string' to avoid error in replacing.\n                                axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                                index\n                            )\n                            : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelStr;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            fixMinMaxLabelShow(axisModel, textEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.textVerticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, textEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n        var firstLabel = textEls[0];\n        var nextLabel = textEls[1];\n        var lastLabel = textEls[textEls.length - 1];\n        var prevLabel = textEls[textEls.length - 2];\n\n        if (showMinLabel === false) {\n            firstLabel.ignore = true;\n        }\n        else if (axisModel.getMin() != null && isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            showMinLabel ? (nextLabel.ignore = true) : (firstLabel.ignore = true);\n        }\n\n        if (showMaxLabel === false) {\n            lastLabel.ignore = true;\n        }\n        else if (axisModel.getMax() != null && isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            showMaxLabel ? (prevLabel.ignore = true) : (lastLabel.ignore = true);\n        }\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNCdWlsZGVyLmpzP2JkN2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RCxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIHJlbVJhZGlhbiA9IG51bWJlclV0aWwucmVtUmFkaWFuO1xuICAgIHZhciBpc1JhZGlhbkFyb3VuZFplcm8gPSBudW1iZXJVdGlsLmlzUmFkaWFuQXJvdW5kWmVybztcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciByZXRyaWV2ZSA9IHpyVXRpbC5yZXRyaWV2ZTtcblxuICAgIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBldmVudERhdGEgPSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBheGlzTW9kZWwubWFpblR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnREYXRhW2F4aXNNb2RlbC5tYWluVHlwZSArICdJbmRleCddID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuICAgICAgICByZXR1cm4gZXZlbnREYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmluYWwgYXhpcyBpcyB0cmFuc2xhdGVkIGFuZCByb3RhdGVkIGZyb20gYSBcInN0YW5kYXJkIGF4aXNcIi5cbiAgICAgKiBTbyBvcHQucG9zaXRpb24gYW5kIG9wdC5yb3RhdGlvbiBpcyByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEEgc3RhbmRhcmQgYXhpcyBpcyBhbmQgYXhpcyBmcm9tIFswLCAwXSB0byBbMCwgYXhpc0V4dGVudFsxXV0sXG4gICAgICogZm9yIGV4YW1wbGU6ICgwLCAwKSAtLS0tLS0tLS0tLS0+ICgwLCA1MClcbiAgICAgKlxuICAgICAqIG5hbWVEaXJlY3Rpb24gb3IgdGlja0RpcmVjdGlvbiBvciBsYWJlbERpcmVjdGlvbiBpcyAxIG1lYW5zIHRpY2tcbiAgICAgKiBvciBsYWJlbCBpcyBiZWxvdyB0aGUgc3RhbmRhcmQgYXhpcywgd2hlcmVhcyBpcyAtMSBtZWFucyBhYm92ZVxuICAgICAqIHRoZSBzdGFuZGFyZCBheGlzLiBsYWJlbE9mZnNldCBtZWFucyBvZmZzZXQgYmV0d2VlbiBsYWJlbCBhbmQgYXhpcyxcbiAgICAgKiB3aGljaCBpcyB1c2VmdWwgd2hlbiAnb25aZXJvJywgd2hlcmUgYXhpc0xhYmVsIGlzIGluIHRoZSBncmlkIGFuZFxuICAgICAqIGxhYmVsIGluIG91dHNpZGUgZ3JpZC5cbiAgICAgKlxuICAgICAqIFRpcHM6IGxpa2UgYWx3YXlzLFxuICAgICAqIHBvc2l0aXZlIHJvdGF0aW9uIHJlcHJlc2VudHMgYW50aWNsb2Nrd2lzZSwgYW5kIG5lZ2F0aXZlIHJvdGF0aW9uXG4gICAgICogcmVwcmVzZW50cyBjbG9ja3dpc2UuXG4gICAgICogVGhlIGRpcmVjdGlvbiBvZiBwb3NpdGlvbiBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBkaXJlY3Rpb25cbiAgICAgKiBvZiBzY3JlZW4gY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIERvIG5vdCBuZWVkIHRvIGNvbnNpZGVyIGF4aXMgJ2ludmVyc2UnLCB3aGljaCBpcyBhdXRvIHByb2Nlc3NlZCBieVxuICAgICAqIGF4aXMgZXh0ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF4aXNNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgU3RhbmRhcmQgYXhpcyBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG9wdC5wb3NpdGlvbiBbeCwgeV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0LnJvdGF0aW9uIGJ5IHJhZGlhblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0Lm5hbWVEaXJlY3Rpb249MV0gMSBvciAtMSBVc2VkIHdoZW4gbmFtZUxvY2F0aW9uIGlzICdtaWRkbGUnLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnRpY2tEaXJlY3Rpb249MV0gMSBvciAtMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsRGlyZWN0aW9uPTFdIDEgb3IgLTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbE9mZnNldD0wXSBVc2VmdWxsIHdoZW4gb25aZXJvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmF4aXNMYWJlbFNob3ddIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmF4aXNOYW1lXSBkZWZhdWx0IGdldCBmcm9tIGF4aXNNb2RlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5heGlzTmFtZUF2YWlsYWJsZVdpZHRoXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsUm90YXRlXSBieSBkZWdyZWUsIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsSW50ZXJ2YWxdIERlZmF1bHQgbGFiZWwgaW50ZXJ2YWwgd2hlbiBsYWJlbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsIGZyb20gbW9kZWwgaXMgbnVsbCBvciAnYXV0bycuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3Ryb2tlQ29udGFpblRocmVzaG9sZF0gRGVmYXVsdCBsYWJlbCBpbnRlcnZhbCB3aGVuIGxhYmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubmFtZVRydW5jYXRlTWF4V2lkdGhdXG4gICAgICovXG4gICAgdmFyIEF4aXNCdWlsZGVyID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgb3B0KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHQgPSBvcHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5heGlzTW9kZWwgPSBheGlzTW9kZWw7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxuICAgICAgICB6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICBvcHQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgbmFtZURpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICB0aWNrRGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgIGxhYmVsRGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuXG4gICAgICAgIC8vIEZJWE1FIE5vdCB1c2UgYSBzZXBlcmF0ZSB0ZXh0IGdyb3VwP1xuICAgICAgICB2YXIgZHVtYkdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoe1xuICAgICAgICAgICAgcG9zaXRpb246IG9wdC5wb3NpdGlvbi5zbGljZSgpLFxuICAgICAgICAgICAgcm90YXRpb246IG9wdC5yb3RhdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGlzLmdyb3VwLmFkZChkdW1iR3JvdXApO1xuICAgICAgICAvLyB0aGlzLl9kdW1iR3JvdXAgPSBkdW1iR3JvdXA7XG5cbiAgICAgICAgZHVtYkdyb3VwLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSBkdW1iR3JvdXAudHJhbnNmb3JtO1xuXG4gICAgICAgIHRoaXMuX2R1bWJHcm91cCA9IGR1bWJHcm91cDtcbiAgICB9O1xuXG4gICAgQXhpc0J1aWxkZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBeGlzQnVpbGRlcixcblxuICAgICAgICBoYXNCdWlsZGVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhYnVpbGRlcnNbbmFtZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgYnVpbGRlcnNbbmFtZV0uY2FsbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHcm91cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgYnVpbGRlcnMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBheGlzTGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuXG4gICAgICAgICAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLnNob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuYXhpc01vZGVsLmF4aXMuZ2V0RXh0ZW50KCk7XG5cbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgICAgICAgICB2YXIgcHQxID0gW2V4dGVudFswXSwgMF07XG4gICAgICAgICAgICB2YXIgcHQyID0gW2V4dGVudFsxXSwgMF07XG4gICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgbWF0cml4KTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MiwgcHQyLCBtYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuXG4gICAgICAgICAgICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGFuaWQ6ICdsaW5lJyxcblxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgICAgICAgICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgICAgICAgICAgICAgIHgyOiBwdDJbMF0sXG4gICAgICAgICAgICAgICAgICAgIHkyOiBwdDJbMV1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICB7bGluZUNhcDogJ3JvdW5kJ30sXG4gICAgICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xpbmUubGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IG9wdC5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDUsXG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIHoyOiAxXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc1RpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnYXhpc1RpY2suc2hvdycpIHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGlja01vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpO1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuXG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSB0aWNrTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgICAgICAgICAgdmFyIHRpY2tMZW4gPSB0aWNrTW9kZWwuZ2V0KCdsZW5ndGgnKTtcblxuICAgICAgICAgICAgdmFyIHRpY2tJbnRlcnZhbCA9IGdldEludGVydmFsKHRpY2tNb2RlbCwgb3B0LmxhYmVsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3Jkcyh0aWNrTW9kZWwuZ2V0KCdhbGlnbldpdGhMYWJlbCcpKTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcblxuICAgICAgICAgICAgdmFyIHB0MSA9IFtdO1xuICAgICAgICAgICAgdmFyIHB0MiA9IFtdO1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgb3JkaW5hbCBzY2FsZSBzdXBwb3J0IHRpY2sgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaSwgdGlja0ludGVydmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tDb29yZCA9IHRpY2tzQ29vcmRzW2ldO1xuXG4gICAgICAgICAgICAgICAgcHQxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgIHB0MVsxXSA9IDA7XG4gICAgICAgICAgICAgICAgcHQyWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgIHB0MlsxXSA9IG9wdC50aWNrRGlyZWN0aW9uICogdGlja0xlbjtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgbWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDIsIHB0MiwgbWF0cml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGljayBsaW5lLCBOb3QgdXNlIGdyb3VwIHRyYW5zZm9ybSB0byBoYXZlIGJldHRlciBsaW5lIGRyYXdcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYW5pZDogJ3RpY2tfJyArIHRpY2tzW2ldLFxuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogcHQxWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTE6IHB0MVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBwdDJbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5MjogcHQyWzFdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHoyOiAyLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc0xhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgICAgICAgICAgdmFyIHNob3cgPSByZXRyaWV2ZShvcHQuYXhpc0xhYmVsU2hvdywgYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnNob3cnKSk7XG5cbiAgICAgICAgICAgIGlmICghc2hvdyB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpO1xuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgbGFiZWxNYXJnaW4gPSBsYWJlbE1vZGVsLmdldCgnbWFyZ2luJyk7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gYXhpc01vZGVsLmdldEZvcm1hdHRlZExhYmVscygpO1xuXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGxhYmVsIHJvdGF0ZS5cbiAgICAgICAgICAgIHZhciBsYWJlbFJvdGF0aW9uID0gKFxuICAgICAgICAgICAgICAgIHJldHJpZXZlKG9wdC5sYWJlbFJvdGF0ZSwgbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpKSB8fCAwXG4gICAgICAgICAgICApICogUEkgLyAxODA7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbExheW91dCA9IGlubmVyVGV4dExheW91dChvcHQucm90YXRpb24sIGxhYmVsUm90YXRpb24sIG9wdC5sYWJlbERpcmVjdGlvbik7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlEYXRhID0gYXhpc01vZGVsLmdldCgnZGF0YScpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEVscyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNpbGVudCA9IGlzU2lsZW50KGF4aXNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlckV2ZW50ID0gYXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50Jyk7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRpY2tzLCBmdW5jdGlvbiAodGlja1ZhbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaW5kZXgsIG9wdC5sYWJlbEludGVydmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpdGVtVGV4dFN0eWxlTW9kZWwgPSB0ZXh0U3R5bGVNb2RlbDtcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnlEYXRhICYmIGNhdGVnb3J5RGF0YVt0aWNrVmFsXSAmJiBjYXRlZ29yeURhdGFbdGlja1ZhbF0udGV4dFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UZXh0U3R5bGVNb2RlbCA9IG5ldyBNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5RGF0YVt0aWNrVmFsXS50ZXh0U3R5bGUsIHRleHRTdHlsZU1vZGVsLCBheGlzTW9kZWwuZWNNb2RlbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbG9yID0gaXRlbVRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICAgICAgICAgICAgICAgIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMuZGF0YVRvQ29vcmQodGlja1ZhbCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgdGlja0Nvb3JkLFxuICAgICAgICAgICAgICAgICAgICBvcHQubGFiZWxPZmZzZXQgKyBvcHQubGFiZWxEaXJlY3Rpb24gKiBsYWJlbE1hcmdpblxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsU3RyID0gYXhpcy5zY2FsZS5nZXRMYWJlbCh0aWNrVmFsKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGFuaWQ6ICdsYWJlbF8nICsgdGlja1ZhbCxcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWxzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogaXRlbVRleHRTdHlsZU1vZGVsLmdldCgnYWxpZ24nLCB0cnVlKSB8fCBsYWJlbExheW91dC50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogaXRlbVRleHRTdHlsZU1vZGVsLmdldCgnYmFzZWxpbmUnLCB0cnVlKSB8fCBsYWJlbExheW91dC50ZXh0VmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGb250OiBpdGVtVGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdHlwZW9mIHRleHRDb2xvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGV4dENvbG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoMSkgSW4gY2F0ZWdvcnkgYXhpcyB3aXRoIGRhdGEgem9vbSwgdGljayBpcyBub3QgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4IG9mIGF4aXMuZGF0YS4gU28gdGljayBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXRlZ29yeSBheGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoMikgQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb24sIHdoaWNoIGFsd2F5cyByZXR1cm5zIGxhYmVsU3RyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaW4gaW50ZXJ2YWwgc2NhbGUgbGFiZWxTdHIgaXMgbGlrZSAnMjIzLDQ0NScsIHdoaWNoIG1ha2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZXIgcmVwYWxjZSAnLCcuIFNvIHdlIG1vZGlmeSBpdCB0byByZXR1cm4gb3JpZ2luYWwgdmFsIGJ1dCByZW1haW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgYXMgJ3N0cmluZycgdG8gYXZvaWQgZXJyb3IgaW4gcmVwbGFjaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBsYWJlbFN0ciA6IGF4aXMudHlwZSA9PT0gJ3ZhbHVlJyA/IHRpY2tWYWwgKyAnJyA6IHRpY2tWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGV4dENvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiBzaWxlbnQsXG4gICAgICAgICAgICAgICAgICAgIHoyOiAxMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gUGFjayBkYXRhIGZvciBtb3VzZSBldmVudFxuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhLnRhcmdldFR5cGUgPSAnYXhpc0xhYmVsJztcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YS52YWx1ZSA9IGxhYmVsU3RyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgdGhpcy5fZHVtYkdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgICAgICAgICAgICAgIHRleHRFbC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgICAgIHRleHRFbHMucHVzaCh0ZXh0RWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRleHRFbCk7XG5cbiAgICAgICAgICAgICAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBmaXhNaW5NYXhMYWJlbFNob3coYXhpc01vZGVsLCB0ZXh0RWxzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHJldHJpZXZlKG9wdC5heGlzTmFtZSwgYXhpc01vZGVsLmdldCgnbmFtZScpKTtcblxuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmFtZUxvY2F0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZUxvY2F0aW9uJyk7XG4gICAgICAgICAgICB2YXIgbmFtZURpcmVjdGlvbiA9IG9wdC5uYW1lRGlyZWN0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCduYW1lVGV4dFN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgZ2FwID0gYXhpc01vZGVsLmdldCgnbmFtZUdhcCcpIHx8IDA7XG5cbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmF4aXNNb2RlbC5heGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGdhcFNpZ25hbCA9IGV4dGVudFswXSA+IGV4dGVudFsxXSA/IC0xIDogMTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBbXG4gICAgICAgICAgICAgICAgbmFtZUxvY2F0aW9uID09PSAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgID8gZXh0ZW50WzBdIC0gZ2FwU2lnbmFsICogZ2FwXG4gICAgICAgICAgICAgICAgICAgIDogbmFtZUxvY2F0aW9uID09PSAnZW5kJ1xuICAgICAgICAgICAgICAgICAgICA/IGV4dGVudFsxXSArIGdhcFNpZ25hbCAqIGdhcFxuICAgICAgICAgICAgICAgICAgICA6IChleHRlbnRbMF0gKyBleHRlbnRbMV0pIC8gMiwgLy8gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBsYWJlbE9mZnNldC5cbiAgICAgICAgICAgICAgICBuYW1lTG9jYXRpb24gPT09ICdtaWRkbGUnID8gb3B0LmxhYmVsT2Zmc2V0ICsgbmFtZURpcmVjdGlvbiAqIGdhcCA6IDBcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHZhciBsYWJlbExheW91dDtcblxuICAgICAgICAgICAgdmFyIG5hbWVSb3RhdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ25hbWVSb3RhdGUnKTtcbiAgICAgICAgICAgIGlmIChuYW1lUm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5hbWVSb3RhdGlvbiA9IG5hbWVSb3RhdGlvbiAqIFBJIC8gMTgwOyAvLyBUbyByYWRpYW4uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBheGlzTmFtZUF2YWlsYWJsZVdpZHRoO1xuXG4gICAgICAgICAgICBpZiAobmFtZUxvY2F0aW9uID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgICAgIGxhYmVsTGF5b3V0ID0gaW5uZXJUZXh0TGF5b3V0KFxuICAgICAgICAgICAgICAgICAgICBvcHQucm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG5hbWVSb3RhdGlvbiAhPSBudWxsID8gbmFtZVJvdGF0aW9uIDogb3B0LnJvdGF0aW9uLCAvLyBBZGFwdCB0byBheGlzLlxuICAgICAgICAgICAgICAgICAgICBuYW1lRGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVsTGF5b3V0ID0gZW5kVGV4dExheW91dChcbiAgICAgICAgICAgICAgICAgICAgb3B0LCBuYW1lTG9jYXRpb24sIG5hbWVSb3RhdGlvbiB8fCAwLCBleHRlbnRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IG9wdC5heGlzTmFtZUF2YWlsYWJsZVdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChheGlzTmFtZUF2YWlsYWJsZVdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IE1hdGguYWJzKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCAvIE1hdGguc2luKGxhYmVsTGF5b3V0LnJvdGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAhaXNGaW5pdGUoYXhpc05hbWVBdmFpbGFibGVXaWR0aCkgJiYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0Rm9udCA9IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKTtcblxuICAgICAgICAgICAgdmFyIHRydW5jYXRlT3B0ID0gYXhpc01vZGVsLmdldCgnbmFtZVRydW5jYXRlJywgdHJ1ZSkgfHwge307XG4gICAgICAgICAgICB2YXIgZWxsaXBzaXMgPSB0cnVuY2F0ZU9wdC5lbGxpcHNpcztcbiAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IHJldHJpZXZlKFxuICAgICAgICAgICAgICAgIG9wdC5uYW1lVHJ1bmNhdGVNYXhXaWR0aCwgdHJ1bmNhdGVPcHQubWF4V2lkdGgsIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgdHJ1bmNhdGVkVGV4dCA9IChlbGxpcHNpcyAhPSBudWxsICYmIG1heFdpZHRoICE9IG51bGwpXG4gICAgICAgICAgICAgICAgPyBmb3JtYXRVdGlsLnRydW5jYXRlVGV4dChcbiAgICAgICAgICAgICAgICAgICAgbmFtZSwgbWF4V2lkdGgsIHRleHRGb250LCBlbGxpcHNpcyxcbiAgICAgICAgICAgICAgICAgICAge21pbkNoYXI6IDIsIHBsYWNlaG9sZGVyOiB0cnVuY2F0ZU9wdC5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBuYW1lO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIG1haW5UeXBlID0gYXhpc01vZGVsLm1haW5UeXBlO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlOiBtYWluVHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvcm1hdHRlclBhcmFtc1ttYWluVHlwZSArICdJbmRleCddID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuXG4gICAgICAgICAgICB2YXIgdGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG5cbiAgICAgICAgICAgICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pZDogJ25hbWUnLFxuXG4gICAgICAgICAgICAgICAgX19mdWxsVGV4dDogbmFtZSxcbiAgICAgICAgICAgICAgICBfX3RydW5jYXRlZFRleHQ6IHRydW5jYXRlZFRleHQsXG5cbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0cnVuY2F0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dEZvbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBsYWJlbExheW91dC50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBsYWJlbExheW91dC50ZXh0VmVydGljYWxBbGlnblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICAgICAgICAgICAgc2lsZW50OiBpc1NpbGVudChheGlzTW9kZWwpLFxuICAgICAgICAgICAgICAgIHoyOiAxLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6ICh0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdylcbiAgICAgICAgICAgICAgICAgICAgPyB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJQYXJhbXM6IGZvcm1hdHRlclBhcmFtc1xuICAgICAgICAgICAgICAgICAgICB9LCB0b29sdGlwT3B0KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoYXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhID0gbWFrZUF4aXNFdmVudERhdGFCYXNlKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNOYW1lJztcbiAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgdGhpcy5fZHVtYkdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgICAgICAgICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZCh0ZXh0RWwpO1xuXG4gICAgICAgICAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc1JvdGF0aW9uIGluIHJhZGlhblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0Um90YXRpb24gaW4gcmFkaWFuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0ge1xuICAgICAqICByb3RhdGlvbiwgLy8gYWNjb3JkaW5nIHRvIGF4aXNcbiAgICAgKiAgdGV4dEFsaWduLFxuICAgICAqICB0ZXh0VmVydGljYWxBbGlnblxuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgaW5uZXJUZXh0TGF5b3V0ID0gQXhpc0J1aWxkZXIuaW5uZXJUZXh0TGF5b3V0ID0gZnVuY3Rpb24gKGF4aXNSb3RhdGlvbiwgdGV4dFJvdGF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uRGlmZiA9IHJlbVJhZGlhbih0ZXh0Um90YXRpb24gLSBheGlzUm90YXRpb24pO1xuICAgICAgICB2YXIgdGV4dEFsaWduO1xuICAgICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICAgICAgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYpKSB7IC8vIExhYmVsIGlzIHBhcmFsbGVsIHdpdGggYXhpcyBsaW5lLlxuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSkpIHsgLy8gTGFiZWwgaXMgaW52ZXJzZSBwYXJhbGxlbCB3aXRoIGF4aXMgbGluZS5cbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG5cbiAgICAgICAgICAgIGlmIChyb3RhdGlvbkRpZmYgPiAwICYmIHJvdGF0aW9uRGlmZiA8IFBJKSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25EaWZmLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZW5kVGV4dExheW91dChvcHQsIHRleHRQb3NpdGlvbiwgdGV4dFJvdGF0ZSwgZXh0ZW50KSB7XG4gICAgICAgIHZhciByb3RhdGlvbkRpZmYgPSByZW1SYWRpYW4odGV4dFJvdGF0ZSAtIG9wdC5yb3RhdGlvbik7XG4gICAgICAgIHZhciB0ZXh0QWxpZ247XG4gICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcbiAgICAgICAgdmFyIGludmVyc2UgPSBleHRlbnRbMF0gPiBleHRlbnRbMV07XG4gICAgICAgIHZhciBvbkxlZnQgPSAodGV4dFBvc2l0aW9uID09PSAnc3RhcnQnICYmICFpbnZlcnNlKVxuICAgICAgICAgICAgfHwgKHRleHRQb3NpdGlvbiAhPT0gJ3N0YXJ0JyAmJiBpbnZlcnNlKTtcblxuICAgICAgICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJIC8gMikpIHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gb25MZWZ0ID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSAqIDEuNSkpIHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gb25MZWZ0ID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGlmIChyb3RhdGlvbkRpZmYgPCBQSSAqIDEuNSAmJiByb3RhdGlvbkRpZmYgPiBQSSAvIDIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBvbkxlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25EaWZmLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NpbGVudChheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBPcHQgPSBheGlzTW9kZWwuZ2V0KCd0b29sdGlwJyk7XG4gICAgICAgIHJldHVybiBheGlzTW9kZWwuZ2V0KCdzaWxlbnQnKVxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgbW91c2UgY3Vyc29yLCBhZGQgdGhlc2UgcmVzdHJpY3Rpb25zLlxuICAgICAgICAgICAgfHwgIShcbiAgICAgICAgICAgICAgICBheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSB8fCAodG9vbHRpcE9wdCAmJiB0b29sdGlwT3B0LnNob3cpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeE1pbk1heExhYmVsU2hvdyhheGlzTW9kZWwsIHRleHRFbHMpIHtcbiAgICAgICAgLy8gSWYgbWluIG9yIG1heCBhcmUgdXNlciBzZXQsIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAgICAgLy8gSWYgdGhlIHRpY2sgb24gbWluKG1heCkgYXJlIG92ZXJsYXAgb24gdGhlaXIgbmVpZ2hib3VyIHRpY2tcbiAgICAgICAgLy8gSWYgdGhleSBhcmUgb3ZlcmxhcHBlZCwgd2UgbmVlZCB0byBoaWRlIHRoZSBtaW4obWF4KSB0aWNrIGxhYmVsXG4gICAgICAgIHZhciBzaG93TWluTGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzTGFiZWwuc2hvd01pbkxhYmVsJyk7XG4gICAgICAgIHZhciBzaG93TWF4TGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzTGFiZWwuc2hvd01heExhYmVsJyk7XG4gICAgICAgIHZhciBmaXJzdExhYmVsID0gdGV4dEVsc1swXTtcbiAgICAgICAgdmFyIG5leHRMYWJlbCA9IHRleHRFbHNbMV07XG4gICAgICAgIHZhciBsYXN0TGFiZWwgPSB0ZXh0RWxzW3RleHRFbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBwcmV2TGFiZWwgPSB0ZXh0RWxzW3RleHRFbHMubGVuZ3RoIC0gMl07XG5cbiAgICAgICAgaWYgKHNob3dNaW5MYWJlbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZpcnN0TGFiZWwuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChheGlzTW9kZWwuZ2V0TWluKCkgIT0gbnVsbCAmJiBpc1R3b0xhYmVsT3ZlcmxhcHBlZChmaXJzdExhYmVsLCBuZXh0TGFiZWwpKSB7XG4gICAgICAgICAgICBzaG93TWluTGFiZWwgPyAobmV4dExhYmVsLmlnbm9yZSA9IHRydWUpIDogKGZpcnN0TGFiZWwuaWdub3JlID0gdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd01heExhYmVsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbGFzdExhYmVsLmlnbm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXhpc01vZGVsLmdldE1heCgpICE9IG51bGwgJiYgaXNUd29MYWJlbE92ZXJsYXBwZWQocHJldkxhYmVsLCBsYXN0TGFiZWwpKSB7XG4gICAgICAgICAgICBzaG93TWF4TGFiZWwgPyAocHJldkxhYmVsLmlnbm9yZSA9IHRydWUpIDogKGxhc3RMYWJlbC5pZ25vcmUgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVHdvTGFiZWxPdmVybGFwcGVkKGN1cnJlbnQsIG5leHQsIGxhYmVsTGF5b3V0KSB7XG4gICAgICAgIC8vIGN1cnJlbnQgYW5kIG5leHQgaGFzIHRoZSBzYW1lIHJvdGF0aW9uLlxuICAgICAgICB2YXIgZmlyc3RSZWN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgIHZhciBuZXh0UmVjdCA9IG5leHQgJiYgbmV4dC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuXG4gICAgICAgIGlmICghZmlyc3RSZWN0IHx8ICFuZXh0UmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiBjaGVja2luZyBpbnRlcnNlY3Qgb2YgdHdvIHJvdGF0ZWQgbGFiZWxzLCB3ZSB1c2UgbVJvdGF0aW9uQmFja1xuICAgICAgICAvLyB0byBhdm9pZCB0aGF0IGJvdW5kaW5nUmVjdCBpcyBlbmxhcmdlIHdoZW4gdXNpbmcgYGJvdW5kaW5nUmVjdC5hcHBseVRyYW5zZm9ybWAuXG4gICAgICAgIHZhciBtUm90YXRpb25CYWNrID0gbWF0cml4LmlkZW50aXR5KFtdKTtcbiAgICAgICAgbWF0cml4LnJvdGF0ZShtUm90YXRpb25CYWNrLCBtUm90YXRpb25CYWNrLCAtY3VycmVudC5yb3RhdGlvbik7XG5cbiAgICAgICAgZmlyc3RSZWN0LmFwcGx5VHJhbnNmb3JtKG1hdHJpeC5tdWwoW10sIG1Sb3RhdGlvbkJhY2ssIGN1cnJlbnQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSkpO1xuICAgICAgICBuZXh0UmVjdC5hcHBseVRyYW5zZm9ybShtYXRyaXgubXVsKFtdLCBtUm90YXRpb25CYWNrLCBuZXh0LmdldExvY2FsVHJhbnNmb3JtKCkpKTtcblxuICAgICAgICByZXR1cm4gZmlyc3RSZWN0LmludGVyc2VjdChuZXh0UmVjdCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdmFyIGlmSWdub3JlT25UaWNrID0gQXhpc0J1aWxkZXIuaWZJZ25vcmVPblRpY2sgPSBmdW5jdGlvbiAoYXhpcywgaSwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIHJhd1RpY2s7XG4gICAgICAgIHZhciBzY2FsZSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIHJldHVybiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICB0eXBlb2YgaW50ZXJ2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdUaWNrID0gc2NhbGUuZ2V0VGlja3MoKVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICFpbnRlcnZhbChyYXdUaWNrLCBzY2FsZS5nZXRMYWJlbChyYXdUaWNrKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IGkgJSAoaW50ZXJ2YWwgKyAxKVxuICAgICAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhciBnZXRJbnRlcnZhbCA9IEF4aXNCdWlsZGVyLmdldEludGVydmFsID0gZnVuY3Rpb24gKG1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcbiAgICAgICAgaWYgKGludGVydmFsID09IG51bGwgfHwgaW50ZXJ2YWwgPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXNCdWlsZGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var axisPointerModelHelper = __webpack_require__(23);\n\n    /**\n     * Base class of AxisView.\n     */\n    var AxisView = __webpack_require__(1).extendComponentView({\n\n        type: 'axis',\n\n        /**\n         * @private\n         */\n        _axisPointer: null,\n\n        /**\n         * @protected\n         * @type {string}\n         */\n        axisPointerClass: null,\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n            // FIXME\n            // This process should proformed after coordinate systems updated\n            // (axis scale updated), and should be performed each time update.\n            // So put it here temporarily, although it is not appropriate to\n            // put a model-writing procedure in `view`.\n            this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n            AxisView.superApply(this, 'render', arguments);\n\n            updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n        },\n\n        /**\n         * Action handler.\n         * @public\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} payload\n         */\n        updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n            updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            var axisPointer = this._axisPointer;\n            axisPointer && axisPointer.remove(api);\n            AxisView.superApply(this, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            disposeAxisPointer(this, api);\n            AxisView.superApply(this, 'dispose', arguments);\n        }\n\n    });\n\n    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n        if (!Clazz) {\n            return;\n        }\n        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n        axisPointerModel\n            ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n                .render(axisModel, axisPointerModel, api, forceRender)\n            : disposeAxisPointer(axisView, api);\n    }\n\n    function disposeAxisPointer(axisView, ecModel, api) {\n        var axisPointer = axisView._axisPointer;\n        axisPointer && axisPointer.dispose(ecModel, api);\n        axisView._axisPointer = null;\n    }\n\n    var axisPointerClazz = [];\n\n    AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (__DEV__) {\n            if (axisPointerClazz[type]) {\n                throw new Error('axisPointer ' + type + ' exists');\n            }\n        }\n        axisPointerClazz[type] = clazz;\n    };\n\n    AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n    };\n\n    module.exports = AxisView;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNWaWV3LmpzPzg3ODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5Q0FBeUM7QUFDNUQsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciA9IHJlcXVpcmUoJy4uL2F4aXNQb2ludGVyL21vZGVsSGVscGVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNsYXNzIG9mIEF4aXNWaWV3LlxuICAgICAqL1xuICAgIHZhciBBeGlzVmlldyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnYXhpcycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYXhpc1BvaW50ZXI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGF4aXNQb2ludGVyQ2xhc3M6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBUaGlzIHByb2Nlc3Mgc2hvdWxkIHByb2Zvcm1lZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbXMgdXBkYXRlZFxuICAgICAgICAgICAgLy8gKGF4aXMgc2NhbGUgdXBkYXRlZCksIGFuZCBzaG91bGQgYmUgcGVyZm9ybWVkIGVhY2ggdGltZSB1cGRhdGUuXG4gICAgICAgICAgICAvLyBTbyBwdXQgaXQgaGVyZSB0ZW1wb3JhcmlseSwgYWx0aG91Z2ggaXQgaXMgbm90IGFwcHJvcHJpYXRlIHRvXG4gICAgICAgICAgICAvLyBwdXQgYSBtb2RlbC13cml0aW5nIHByb2NlZHVyZSBpbiBgdmlld2AuXG4gICAgICAgICAgICB0aGlzLmF4aXNQb2ludGVyQ2xhc3MgJiYgYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5maXhWYWx1ZShheGlzTW9kZWwpO1xuXG4gICAgICAgICAgICBBeGlzVmlldy5zdXBlckFwcGx5KHRoaXMsICdyZW5kZXInLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB1cGRhdGVBeGlzUG9pbnRlcih0aGlzLCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdGlvbiBoYW5kbGVyLlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUF4aXNQb2ludGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZvcmNlKSB7XG4gICAgICAgICAgICB1cGRhdGVBeGlzUG9pbnRlcih0aGlzLCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyID0gdGhpcy5fYXhpc1BvaW50ZXI7XG4gICAgICAgICAgICBheGlzUG9pbnRlciAmJiBheGlzUG9pbnRlci5yZW1vdmUoYXBpKTtcbiAgICAgICAgICAgIEF4aXNWaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZGlzcG9zZUF4aXNQb2ludGVyKHRoaXMsIGFwaSk7XG4gICAgICAgICAgICBBeGlzVmlldy5zdXBlckFwcGx5KHRoaXMsICdkaXNwb3NlJywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVBeGlzUG9pbnRlcihheGlzVmlldywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIGZvcmNlUmVuZGVyKSB7XG4gICAgICAgIHZhciBDbGF6eiA9IEF4aXNWaWV3LmdldEF4aXNQb2ludGVyQ2xhc3MoYXhpc1ZpZXcuYXhpc1BvaW50ZXJDbGFzcyk7XG4gICAgICAgIGlmICghQ2xhenopIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZ2V0QXhpc1BvaW50ZXJNb2RlbChheGlzTW9kZWwpO1xuICAgICAgICBheGlzUG9pbnRlck1vZGVsXG4gICAgICAgICAgICA/IChheGlzVmlldy5fYXhpc1BvaW50ZXIgfHwgKGF4aXNWaWV3Ll9heGlzUG9pbnRlciA9IG5ldyBDbGF6eigpKSlcbiAgICAgICAgICAgICAgICAucmVuZGVyKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCBmb3JjZVJlbmRlcilcbiAgICAgICAgICAgIDogZGlzcG9zZUF4aXNQb2ludGVyKGF4aXNWaWV3LCBhcGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3Bvc2VBeGlzUG9pbnRlcihheGlzVmlldywgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBheGlzUG9pbnRlciA9IGF4aXNWaWV3Ll9heGlzUG9pbnRlcjtcbiAgICAgICAgYXhpc1BvaW50ZXIgJiYgYXhpc1BvaW50ZXIuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgICAgICBheGlzVmlldy5fYXhpc1BvaW50ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBheGlzUG9pbnRlckNsYXp6ID0gW107XG5cbiAgICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MgPSBmdW5jdGlvbiAodHlwZSwgY2xhenopIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmIChheGlzUG9pbnRlckNsYXp6W3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGlzUG9pbnRlciAnICsgdHlwZSArICcgZXhpc3RzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXhpc1BvaW50ZXJDbGF6elt0eXBlXSA9IGNsYXp6O1xuICAgIH07XG5cbiAgICBBeGlzVmlldy5nZXRBeGlzUG9pbnRlckNsYXNzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgJiYgYXhpc1BvaW50ZXJDbGF6elt0eXBlXTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BeGlzVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n\n    var helper = {};\n\n    /**\n     * @param {Object} opt {labelInside}\n     * @return {Object} {\n     *  position, rotation, labelDirection, labelOffset,\n     *  tickDirection, labelRotate, labelInterval, z2\n     * }\n     */\n    helper.layout = function (gridModel, axisModel, opt) {\n        opt = opt || {};\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        layout.labelOffset = axis.onZero ? posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero : 0;\n\n        if (axisModel.get('axisTick.inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotate = axisModel.get('axisLabel.rotate');\n        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    };\n\n    module.exports = helper;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL2NhcnRlc2lhbkF4aXNIZWxwZXIuanM/NDEwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxPQUFPLE1BQU07QUFDNUIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0Isb0VBQW9FO0FBQ3BGLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjUxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IHtsYWJlbEluc2lkZX1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtcbiAgICAgKiAgcG9zaXRpb24sIHJvdGF0aW9uLCBsYWJlbERpcmVjdGlvbiwgbGFiZWxPZmZzZXQsXG4gICAgICogIHRpY2tEaXJlY3Rpb24sIGxhYmVsUm90YXRlLCBsYWJlbEludGVydmFsLCB6MlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBoZWxwZXIubGF5b3V0ID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgYXhpc01vZGVsLCBvcHQpIHtcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgICAgICB2YXIgbGF5b3V0ID0ge307XG5cbiAgICAgICAgdmFyIHJhd0F4aXNQb3NpdGlvbiA9IGF4aXMucG9zaXRpb247XG4gICAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzLm9uWmVybyA/ICdvblplcm8nIDogcmF3QXhpc1Bvc2l0aW9uO1xuICAgICAgICB2YXIgYXhpc0RpbSA9IGF4aXMuZGltO1xuXG4gICAgICAgIC8vIFtsZWZ0LCByaWdodCwgdG9wLCBib3R0b21dXG4gICAgICAgIHZhciByZWN0ID0gZ3JpZC5nZXRSZWN0KCk7XG4gICAgICAgIHZhciByZWN0Qm91bmQgPSBbcmVjdC54LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcblxuICAgICAgICB2YXIgYXhpc09mZnNldCA9IGF4aXNNb2RlbC5nZXQoJ29mZnNldCcpIHx8IDA7XG5cbiAgICAgICAgdmFyIHBvc01hcCA9IHtcbiAgICAgICAgICAgIHg6IHsgdG9wOiByZWN0Qm91bmRbMl0gLSBheGlzT2Zmc2V0LCBib3R0b206IHJlY3RCb3VuZFszXSArIGF4aXNPZmZzZXQgfSxcbiAgICAgICAgICAgIHk6IHsgbGVmdDogcmVjdEJvdW5kWzBdIC0gYXhpc09mZnNldCwgcmlnaHQ6IHJlY3RCb3VuZFsxXSArIGF4aXNPZmZzZXQgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHBvc01hcC54Lm9uWmVybyA9IE1hdGgubWF4KE1hdGgubWluKGdldFplcm8oJ3knKSwgcG9zTWFwLnguYm90dG9tKSwgcG9zTWFwLngudG9wKTtcbiAgICAgICAgcG9zTWFwLnkub25aZXJvID0gTWF0aC5tYXgoTWF0aC5taW4oZ2V0WmVybygneCcpLCBwb3NNYXAueS5yaWdodCksIHBvc01hcC55LmxlZnQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFplcm8oZGltLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciB0aGVBeGlzID0gZ3JpZC5nZXRBeGlzKGRpbSk7XG4gICAgICAgICAgICByZXR1cm4gdGhlQXhpcy50b0dsb2JhbENvb3JkKHRoZUF4aXMuZGF0YVRvQ29vcmQoMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXhpcyBwb3NpdGlvblxuICAgICAgICBsYXlvdXQucG9zaXRpb24gPSBbXG4gICAgICAgICAgICBheGlzRGltID09PSAneScgPyBwb3NNYXAueVtheGlzUG9zaXRpb25dIDogcmVjdEJvdW5kWzBdLFxuICAgICAgICAgICAgYXhpc0RpbSA9PT0gJ3gnID8gcG9zTWFwLnhbYXhpc1Bvc2l0aW9uXSA6IHJlY3RCb3VuZFszXVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEF4aXMgcm90YXRpb25cbiAgICAgICAgbGF5b3V0LnJvdGF0aW9uID0gTWF0aC5QSSAvIDIgKiAoYXhpc0RpbSA9PT0gJ3gnID8gMCA6IDEpO1xuXG4gICAgICAgIC8vIFRpY2sgYW5kIGxhYmVsIGRpcmVjdGlvbiwgeCB5IGlzIGF4aXNEaW1cbiAgICAgICAgdmFyIGRpck1hcCA9IHt0b3A6IC0xLCBib3R0b206IDEsIGxlZnQ6IC0xLCByaWdodDogMX07XG5cbiAgICAgICAgbGF5b3V0LmxhYmVsRGlyZWN0aW9uID0gbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSBsYXlvdXQubmFtZURpcmVjdGlvbiA9IGRpck1hcFtyYXdBeGlzUG9zaXRpb25dO1xuICAgICAgICBsYXlvdXQubGFiZWxPZmZzZXQgPSBheGlzLm9uWmVybyA/IHBvc01hcFtheGlzRGltXVtyYXdBeGlzUG9zaXRpb25dIC0gcG9zTWFwW2F4aXNEaW1dLm9uWmVybyA6IDA7XG5cbiAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLmluc2lkZScpKSB7XG4gICAgICAgICAgICBsYXlvdXQudGlja0RpcmVjdGlvbiA9IC1sYXlvdXQudGlja0RpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoenJVdGlsLnJldHJpZXZlKG9wdC5sYWJlbEluc2lkZSwgYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLmluc2lkZScpKSkge1xuICAgICAgICAgICAgbGF5b3V0LmxhYmVsRGlyZWN0aW9uID0gLWxheW91dC5sYWJlbERpcmVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwZWNpYWwgbGFiZWwgcm90YXRpb25cbiAgICAgICAgdmFyIGxhYmVsUm90YXRlID0gYXhpc01vZGVsLmdldCgnYXhpc0xhYmVsLnJvdGF0ZScpO1xuICAgICAgICBsYXlvdXQubGFiZWxSb3RhdGUgPSBheGlzUG9zaXRpb24gPT09ICd0b3AnID8gLWxhYmVsUm90YXRlIDogbGFiZWxSb3RhdGU7XG5cbiAgICAgICAgLy8gbGFiZWwgaW50ZXJ2YWwgd2hlbiBhdXRvIG1vZGUuXG4gICAgICAgIGxheW91dC5sYWJlbEludGVydmFsID0gYXhpcy5nZXRMYWJlbEludGVydmFsKCk7XG5cbiAgICAgICAgLy8gT3ZlciBzcGxpdExpbmUgYW5kIHNwbGl0QXJlYVxuICAgICAgICBsYXlvdXQuejIgPSAxO1xuXG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom model\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var env = __webpack_require__(6);\n    var echarts = __webpack_require__(1);\n    var modelUtil = __webpack_require__(4);\n    var helper = __webpack_require__(33);\n    var AxisProxy = __webpack_require__(127);\n    var each = zrUtil.each;\n    var eachAxisDim = helper.eachAxisDim;\n\n    var DataZoomModel = echarts.extendComponentModel({\n\n        type: 'dataZoom',\n\n        dependencies: [\n            'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'\n        ],\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            zlevel: 0,\n            z: 4,                   // Higher than normal component (z: 2).\n            orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n            xAxisIndex: null,       // Default the first horizontal category axis.\n            yAxisIndex: null,       // Default the first vertical category axis.\n\n            filterMode: 'filter',   // Possible values: 'filter' or 'empty' or 'weakFilter'.\n                                    // 'filter': data items which are out of window will be removed. This option is\n                                    //          applicable when filtering outliers. For each data item, it will be\n                                    //          filtered if one of the relevant dimensions is out of the window.\n                                    // 'weakFilter': data items which are out of window will be removed. This option\n                                    //          is applicable when filtering outliers. For each data item, it will be\n                                    //          filtered only if all  of the relevant dimensions are out of the same\n                                    //          side of the window.\n                                    // 'empty': data items which are out of window will be set to empty.\n                                    //          This option is applicable when user should not neglect\n                                    //          that there are some data items out of window.\n                                    // 'none': Do not filter.\n                                    // Taking line chart as an example, line will be broken in\n                                    // the filtered points when filterModel is set to 'empty', but\n                                    // be connected when set to 'filter'.\n\n            throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n                                    // default 100. Do not throttle when use null/undefined.\n                                    // If animation === true and animationDurationUpdate > 0,\n                                    // default value is 100, otherwise 20.\n            start: 0,               // Start percent. 0 ~ 100\n            end: 100,               // End percent. 0 ~ 100\n            startValue: null,       // Start value. If startValue specified, start is ignored.\n            endValue: null,         // End value. If endValue specified, end is ignored.\n            minSpan: null,          // 0 ~ 100\n            maxSpan: null,          // 0 ~ 100\n            minValueSpan: null,     // The range of dataZoom can not be smaller than that.\n            maxValueSpan: null      // The range of dataZoom can not be larger than that.\n        },\n\n        /**\n         * @override\n         */\n        init: function (option, parentModel, ecModel) {\n\n            /**\n             * key like x_0, y_1\n             * @private\n             * @type {Object}\n             */\n            this._dataIntervalByAxis = {};\n\n            /**\n             * @private\n             */\n            this._dataInfo = {};\n\n            /**\n             * key like x_0, y_1\n             * @private\n             */\n            this._axisProxies = {};\n\n            /**\n             * @readOnly\n             */\n            this.textStyleModel;\n\n            /**\n             * @private\n             */\n            this._autoThrottle = true;\n\n            /**\n             * 'percent' or 'value'\n             * @private\n             */\n            this._rangePropMode = ['percent', 'percent'];\n\n            var rawOption = retrieveRaw(option);\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function (newOption) {\n            var rawOption = retrieveRaw(newOption);\n\n            //FIX #2591\n            zrUtil.merge(this.option, newOption, true);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @protected\n         */\n        doInit: function (rawOption) {\n            var thisOption = this.option;\n\n            // Disable realtime view update if canvas is not supported.\n            if (!env.canvasSupported) {\n                thisOption.realtime = false;\n            }\n\n            this._setDefaultThrottle(rawOption);\n\n            updateRangeUse(this, rawOption);\n\n            each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n                // start/end has higher priority over startValue/endValue if they\n                // both set, but we should make chart.setOption({endValue: 1000})\n                // effective, rather than chart.setOption({endValue: 1000, end: null}).\n                if (this._rangePropMode[index] === 'value') {\n                    thisOption[names[0]] = null;\n                }\n                // Otherwise do nothing and use the merge result.\n            }, this);\n\n            this.textStyleModel = this.getModel('textStyle');\n\n            this._resetTarget();\n\n            this._giveAxisProxies();\n        },\n\n        /**\n         * @private\n         */\n        _giveAxisProxies: function () {\n            var axisProxies = this._axisProxies;\n\n            this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n                var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\n                // If exists, share axisProxy with other dataZoomModels.\n                var axisProxy = axisModel.__dzAxisProxy || (\n                    // Use the first dataZoomModel as the main model of axisProxy.\n                    axisModel.__dzAxisProxy = new AxisProxy(\n                        dimNames.name, axisIndex, this, ecModel\n                    )\n                );\n                // FIXME\n                // dispose __dzAxisProxy\n\n                axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetTarget: function () {\n            var thisOption = this.option;\n\n            var autoMode = this._judgeAutoMode();\n\n            eachAxisDim(function (dimNames) {\n                var axisIndexName = dimNames.axisIndex;\n                thisOption[axisIndexName] = modelUtil.normalizeToArray(\n                    thisOption[axisIndexName]\n                );\n            }, this);\n\n            if (autoMode === 'axisIndex') {\n                this._autoSetAxisIndex();\n            }\n            else if (autoMode === 'orient') {\n                this._autoSetOrient();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _judgeAutoMode: function () {\n            // Auto set only works for setOption at the first time.\n            // The following is user's reponsibility. So using merged\n            // option is OK.\n            var thisOption = this.option;\n\n            var hasIndexSpecified = false;\n            eachAxisDim(function (dimNames) {\n                // When user set axisIndex as a empty array, we think that user specify axisIndex\n                // but do not want use auto mode. Because empty array may be encountered when\n                // some error occured.\n                if (thisOption[dimNames.axisIndex] != null) {\n                    hasIndexSpecified = true;\n                }\n            }, this);\n\n            var orient = thisOption.orient;\n\n            if (orient == null && hasIndexSpecified) {\n                return 'orient';\n            }\n            else if (!hasIndexSpecified) {\n                if (orient == null) {\n                    thisOption.orient = 'horizontal';\n                }\n                return 'axisIndex';\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetAxisIndex: function () {\n            var autoAxisIndex = true;\n            var orient = this.get('orient', true);\n            var thisOption = this.option;\n            var dependentModels = this.dependentModels;\n\n            if (autoAxisIndex) {\n                // Find axis that parallel to dataZoom as default.\n                var dimName = orient === 'vertical' ? 'y' : 'x';\n\n                if (dependentModels[dimName + 'Axis'].length) {\n                    thisOption[dimName + 'AxisIndex'] = [0];\n                    autoAxisIndex = false;\n                }\n                else {\n                    each(dependentModels.singleAxis, function (singleAxisModel) {\n                        if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n                            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n                            autoAxisIndex = false;\n                        }\n                    });\n                }\n            }\n\n            if (autoAxisIndex) {\n                // Find the first category axis as default. (consider polar)\n                eachAxisDim(function (dimNames) {\n                    if (!autoAxisIndex) {\n                        return;\n                    }\n                    var axisIndices = [];\n                    var axisModels = this.dependentModels[dimNames.axis];\n                    if (axisModels.length && !axisIndices.length) {\n                        for (var i = 0, len = axisModels.length; i < len; i++) {\n                            if (axisModels[i].get('type') === 'category') {\n                                axisIndices.push(i);\n                            }\n                        }\n                    }\n                    thisOption[dimNames.axisIndex] = axisIndices;\n                    if (axisIndices.length) {\n                        autoAxisIndex = false;\n                    }\n                }, this);\n            }\n\n            if (autoAxisIndex) {\n                // FIXME\n                // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），\n                // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？\n\n                // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n                // dataZoom component auto adopts series that reference to\n                // both xAxis and yAxis which type is 'value'.\n                this.ecModel.eachSeries(function (seriesModel) {\n                    if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n                        eachAxisDim(function (dimNames) {\n                            var axisIndices = thisOption[dimNames.axisIndex];\n\n                            var axisIndex = seriesModel.get(dimNames.axisIndex);\n                            var axisId = seriesModel.get(dimNames.axisId);\n\n                            var axisModel = seriesModel.ecModel.queryComponents({\n                                mainType: dimNames.axis,\n                                index: axisIndex,\n                                id: axisId\n                            })[0];\n\n                            if (__DEV__) {\n                                if (!axisModel) {\n                                    throw new Error(\n                                        dimNames.axis + ' \"' + zrUtil.retrieve(\n                                            axisIndex,\n                                            axisId,\n                                            0\n                                        ) + '\" not found'\n                                    );\n                                }\n                            }\n                            axisIndex = axisModel.componentIndex;\n\n                            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n                                axisIndices.push(axisIndex);\n                            }\n                        });\n                    }\n                }, this);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetOrient: function () {\n            var dim;\n\n            // Find the first axis\n            this.eachTargetAxis(function (dimNames) {\n                !dim && (dim = dimNames.name);\n            }, this);\n\n            this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n        },\n\n        /**\n         * @private\n         */\n        _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n            // FIXME\n            // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。\n            // 例如series.type === scatter时。\n\n            var is = true;\n            eachAxisDim(function (dimNames) {\n                var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n                var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n                if (!axisModel || axisModel.get('type') !== axisType) {\n                    is = false;\n                }\n            }, this);\n            return is;\n        },\n\n        /**\n         * @private\n         */\n        _setDefaultThrottle: function (rawOption) {\n            // When first time user set throttle, auto throttle ends.\n            if (rawOption.hasOwnProperty('throttle')) {\n                this._autoThrottle = false;\n            }\n            if (this._autoThrottle) {\n                var globalOption = this.ecModel.option;\n                this.option.throttle =\n                    (globalOption.animation && globalOption.animationDurationUpdate > 0)\n                    ? 100 : 20;\n            }\n        },\n\n        /**\n         * @public\n         */\n        getFirstTargetAxisModel: function () {\n            var firstAxisModel;\n            eachAxisDim(function (dimNames) {\n                if (firstAxisModel == null) {\n                    var indices = this.get(dimNames.axisIndex);\n                    if (indices.length) {\n                        firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n                    }\n                }\n            }, this);\n\n            return firstAxisModel;\n        },\n\n        /**\n         * @public\n         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n         */\n        eachTargetAxis: function (callback, context) {\n            var ecModel = this.ecModel;\n            eachAxisDim(function (dimNames) {\n                each(\n                    this.get(dimNames.axisIndex),\n                    function (axisIndex) {\n                        callback.call(context, dimNames, axisIndex, this, ecModel);\n                    },\n                    this\n                );\n            }, this);\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n         */\n        getAxisProxy: function (dimName, axisIndex) {\n            return this._axisProxies[dimName + '_' + axisIndex];\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/model/Model} If not found, return null/undefined.\n         */\n        getAxisModel: function (dimName, axisIndex) {\n            var axisProxy = this.getAxisProxy(dimName, axisIndex);\n            return axisProxy && axisProxy.getAxisModel();\n        },\n\n        /**\n         * If not specified, set to undefined.\n         *\n         * @public\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         * @param {boolean} [ignoreUpdateRangeUsg=false]\n         */\n        setRawRange: function (opt, ignoreUpdateRangeUsg) {\n            each(['start', 'end', 'startValue', 'endValue'], function (name) {\n                // If any of those prop is null/undefined, we should alos set\n                // them, because only one pair between start/end and\n                // startValue/endValue can work.\n                this.option[name] = opt[name];\n            }, this);\n\n            !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n        },\n\n        /**\n         * @public\n         * @return {Array.<number>} [startPercent, endPercent]\n         */\n        getPercentRange: function () {\n            var axisProxy = this.findRepresentativeAxisProxy();\n            if (axisProxy) {\n                return axisProxy.getDataPercentWindow();\n            }\n        },\n\n        /**\n         * @public\n         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n         *\n         * @param {string} [axisDimName]\n         * @param {number} [axisIndex]\n         * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n         */\n        getValueRange: function (axisDimName, axisIndex) {\n            if (axisDimName == null && axisIndex == null) {\n                var axisProxy = this.findRepresentativeAxisProxy();\n                if (axisProxy) {\n                    return axisProxy.getDataValueWindow();\n                }\n            }\n            else {\n                return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n            }\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n         *      corresponding to the axisModel\n         * @return {module:echarts/component/dataZoom/AxisProxy}\n         */\n        findRepresentativeAxisProxy: function (axisModel) {\n            if (axisModel) {\n                return axisModel.__dzAxisProxy;\n            }\n\n            // Find the first hosted axisProxy\n            var axisProxies = this._axisProxies;\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n\n            // If no hosted axis find not hosted axisProxy.\n            // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n            // and the option.start or option.end settings are different. The percentRange\n            // should follow axisProxy.\n            // (We encounter this problem in toolbox data zoom.)\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getRangePropMode: function () {\n            return this._rangePropMode.slice();\n        }\n    });\n\n    function retrieveRaw(option) {\n        var ret = {};\n        each(\n            ['start', 'end', 'startValue', 'endValue', 'throttle'],\n            function (name) {\n                option.hasOwnProperty(name) && (ret[name] = option[name]);\n            }\n        );\n        return ret;\n    }\n\n    function updateRangeUse(dataZoomModel, rawOption) {\n        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n            var rangePropMode = dataZoomModel._rangePropMode;\n            if (rawOption[names[0]] != null) {\n                rangePropMode[index] = 'percent';\n            }\n            else if (rawOption[names[1]] != null) {\n                rangePropMode[index] = 'value';\n            }\n            // else remain its original setting.\n        });\n    }\n\n    module.exports = DataZoomModel;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsLmpzP2E4NTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlFQUFpRSxlQUFlO0FBQ2hGLDJEQUEyRCwwQkFBMEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLDRDQUE0QztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBEYXRhIHpvb20gbW9kZWxcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcbiAgICB2YXIgQXhpc1Byb3h5ID0gcmVxdWlyZSgnLi9BeGlzUHJveHknKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBlYWNoQXhpc0RpbSA9IGhlbHBlci5lYWNoQXhpc0RpbTtcblxuICAgIHZhciBEYXRhWm9vbU1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ2RhdGFab29tJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgICAgICAgICd4QXhpcycsICd5QXhpcycsICd6QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3NlcmllcydcbiAgICAgICAgXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogNCwgICAgICAgICAgICAgICAgICAgLy8gSGlnaGVyIHRoYW4gbm9ybWFsIGNvbXBvbmVudCAoejogMikuXG4gICAgICAgICAgICBvcmllbnQ6IG51bGwsICAgICAgICAgICAvLyBEZWZhdWx0IGF1dG8gYnkgYXhpc0luZGV4LiBQb3NzaWJsZSB2YWx1ZTogJ2hvcml6b250YWwnLCAndmVydGljYWwnLlxuICAgICAgICAgICAgeEF4aXNJbmRleDogbnVsbCwgICAgICAgLy8gRGVmYXVsdCB0aGUgZmlyc3QgaG9yaXpvbnRhbCBjYXRlZ29yeSBheGlzLlxuICAgICAgICAgICAgeUF4aXNJbmRleDogbnVsbCwgICAgICAgLy8gRGVmYXVsdCB0aGUgZmlyc3QgdmVydGljYWwgY2F0ZWdvcnkgYXhpcy5cblxuICAgICAgICAgICAgZmlsdGVyTW9kZTogJ2ZpbHRlcicsICAgLy8gUG9zc2libGUgdmFsdWVzOiAnZmlsdGVyJyBvciAnZW1wdHknIG9yICd3ZWFrRmlsdGVyJy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdmaWx0ZXInOiBkYXRhIGl0ZW1zIHdoaWNoIGFyZSBvdXQgb2Ygd2luZG93IHdpbGwgYmUgcmVtb3ZlZC4gVGhpcyBvcHRpb24gaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgZmlsdGVyZWQgaWYgb25lIG9mIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGlzIG91dCBvZiB0aGUgd2luZG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ3dlYWtGaWx0ZXInOiBkYXRhIGl0ZW1zIHdoaWNoIGFyZSBvdXQgb2Ygd2luZG93IHdpbGwgYmUgcmVtb3ZlZC4gVGhpcyBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIGlzIGFwcGxpY2FibGUgd2hlbiBmaWx0ZXJpbmcgb3V0bGllcnMuIEZvciBlYWNoIGRhdGEgaXRlbSwgaXQgd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgZmlsdGVyZWQgb25seSBpZiBhbGwgIG9mIHRoZSByZWxldmFudCBkaW1lbnNpb25zIGFyZSBvdXQgb2YgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIHNpZGUgb2YgdGhlIHdpbmRvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdlbXB0eSc6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSBzZXQgdG8gZW1wdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICBUaGlzIG9wdGlvbiBpcyBhcHBsaWNhYmxlIHdoZW4gdXNlciBzaG91bGQgbm90IG5lZ2xlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIHRoYXQgdGhlcmUgYXJlIHNvbWUgZGF0YSBpdGVtcyBvdXQgb2Ygd2luZG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ25vbmUnOiBEbyBub3QgZmlsdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFraW5nIGxpbmUgY2hhcnQgYXMgYW4gZXhhbXBsZSwgbGluZSB3aWxsIGJlIGJyb2tlbiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZpbHRlcmVkIHBvaW50cyB3aGVuIGZpbHRlck1vZGVsIGlzIHNldCB0byAnZW1wdHknLCBidXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIGNvbm5lY3RlZCB3aGVuIHNldCB0byAnZmlsdGVyJy5cblxuICAgICAgICAgICAgdGhyb3R0bGU6IG51bGwsICAgICAgICAgLy8gRGlzcGF0Y2ggYWN0aW9uIGJ5IHRoZSBmaXhlZCByYXRlLCBhdm9pZCBmcmVxdWVuY3kuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IDEwMC4gRG8gbm90IHRocm90dGxlIHdoZW4gdXNlIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW5pbWF0aW9uID09PSB0cnVlIGFuZCBhbmltYXRpb25EdXJhdGlvblVwZGF0ZSA+IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlIGlzIDEwMCwgb3RoZXJ3aXNlIDIwLlxuICAgICAgICAgICAgc3RhcnQ6IDAsICAgICAgICAgICAgICAgLy8gU3RhcnQgcGVyY2VudC4gMCB+IDEwMFxuICAgICAgICAgICAgZW5kOiAxMDAsICAgICAgICAgICAgICAgLy8gRW5kIHBlcmNlbnQuIDAgfiAxMDBcbiAgICAgICAgICAgIHN0YXJ0VmFsdWU6IG51bGwsICAgICAgIC8vIFN0YXJ0IHZhbHVlLiBJZiBzdGFydFZhbHVlIHNwZWNpZmllZCwgc3RhcnQgaXMgaWdub3JlZC5cbiAgICAgICAgICAgIGVuZFZhbHVlOiBudWxsLCAgICAgICAgIC8vIEVuZCB2YWx1ZS4gSWYgZW5kVmFsdWUgc3BlY2lmaWVkLCBlbmQgaXMgaWdub3JlZC5cbiAgICAgICAgICAgIG1pblNwYW46IG51bGwsICAgICAgICAgIC8vIDAgfiAxMDBcbiAgICAgICAgICAgIG1heFNwYW46IG51bGwsICAgICAgICAgIC8vIDAgfiAxMDBcbiAgICAgICAgICAgIG1pblZhbHVlU3BhbjogbnVsbCwgICAgIC8vIFRoZSByYW5nZSBvZiBkYXRhWm9vbSBjYW4gbm90IGJlIHNtYWxsZXIgdGhhbiB0aGF0LlxuICAgICAgICAgICAgbWF4VmFsdWVTcGFuOiBudWxsICAgICAgLy8gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGtleSBsaWtlIHhfMCwgeV8xXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGF0YUludGVydmFsQnlBeGlzID0ge307XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGF0YUluZm8gPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBrZXkgbGlrZSB4XzAsIHlfMVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fYXhpc1Byb3hpZXMgPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50ZXh0U3R5bGVNb2RlbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hdXRvVGhyb3R0bGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICdwZXJjZW50JyBvciAndmFsdWUnXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9yYW5nZVByb3BNb2RlID0gWydwZXJjZW50JywgJ3BlcmNlbnQnXTtcblxuICAgICAgICAgICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG9wdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgdGhpcy5kb0luaXQocmF3T3B0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgICAgICAgICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG5ld09wdGlvbik7XG5cbiAgICAgICAgICAgIC8vRklYICMyNTkxXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG5ld09wdGlvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZG9Jbml0KHJhd09wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRvSW5pdDogZnVuY3Rpb24gKHJhd09wdGlvbikge1xuICAgICAgICAgICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgICAgICAgICAgLy8gRGlzYWJsZSByZWFsdGltZSB2aWV3IHVwZGF0ZSBpZiBjYW52YXMgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXNPcHRpb24ucmVhbHRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0RGVmYXVsdFRocm90dGxlKHJhd09wdGlvbik7XG5cbiAgICAgICAgICAgIHVwZGF0ZVJhbmdlVXNlKHRoaXMsIHJhd09wdGlvbik7XG5cbiAgICAgICAgICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0L2VuZCBoYXMgaGlnaGVyIHByaW9yaXR5IG92ZXIgc3RhcnRWYWx1ZS9lbmRWYWx1ZSBpZiB0aGV5XG4gICAgICAgICAgICAgICAgLy8gYm90aCBzZXQsIGJ1dCB3ZSBzaG91bGQgbWFrZSBjaGFydC5zZXRPcHRpb24oe2VuZFZhbHVlOiAxMDAwfSlcbiAgICAgICAgICAgICAgICAvLyBlZmZlY3RpdmUsIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yYW5nZVByb3BNb2RlW2luZGV4XSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uW25hbWVzWzBdXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3RoaW5nIGFuZCB1c2UgdGhlIG1lcmdlIHJlc3VsdC5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnRleHRTdHlsZU1vZGVsID0gdGhpcy5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2dpdmVBeGlzUHJveGllcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2dpdmVBeGlzUHJveGllczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXNQcm94aWVzID0gdGhpcy5fYXhpc1Byb3hpZXM7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5kZXBlbmRlbnRNb2RlbHNbZGltTmFtZXMuYXhpc11bYXhpc0luZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGV4aXN0cywgc2hhcmUgYXhpc1Byb3h5IHdpdGggb3RoZXIgZGF0YVpvb21Nb2RlbHMuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQcm94eSA9IGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5IHx8IChcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBkYXRhWm9vbU1vZGVsIGFzIHRoZSBtYWluIG1vZGVsIG9mIGF4aXNQcm94eS5cbiAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltTmFtZXMubmFtZSwgYXhpc0luZGV4LCB0aGlzLCBlY01vZGVsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gZGlzcG9zZSBfX2R6QXhpc1Byb3h5XG5cbiAgICAgICAgICAgICAgICBheGlzUHJveGllc1tkaW1OYW1lcy5uYW1lICsgJ18nICsgYXhpc0luZGV4XSA9IGF4aXNQcm94eTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Jlc2V0VGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuXG4gICAgICAgICAgICB2YXIgYXV0b01vZGUgPSB0aGlzLl9qdWRnZUF1dG9Nb2RlKCk7XG5cbiAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzSW5kZXhOYW1lID0gZGltTmFtZXMuYXhpc0luZGV4O1xuICAgICAgICAgICAgICAgIHRoaXNPcHRpb25bYXhpc0luZGV4TmFtZV0gPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShcbiAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbltheGlzSW5kZXhOYW1lXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGF1dG9Nb2RlID09PSAnYXhpc0luZGV4Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9TZXRBeGlzSW5kZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGF1dG9Nb2RlID09PSAnb3JpZW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9TZXRPcmllbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9qdWRnZUF1dG9Nb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBBdXRvIHNldCBvbmx5IHdvcmtzIGZvciBzZXRPcHRpb24gYXQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHVzZXIncyByZXBvbnNpYmlsaXR5LiBTbyB1c2luZyBtZXJnZWRcbiAgICAgICAgICAgIC8vIG9wdGlvbiBpcyBPSy5cbiAgICAgICAgICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG5cbiAgICAgICAgICAgIHZhciBoYXNJbmRleFNwZWNpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIHNldCBheGlzSW5kZXggYXMgYSBlbXB0eSBhcnJheSwgd2UgdGhpbmsgdGhhdCB1c2VyIHNwZWNpZnkgYXhpc0luZGV4XG4gICAgICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCB3YW50IHVzZSBhdXRvIG1vZGUuIEJlY2F1c2UgZW1wdHkgYXJyYXkgbWF5IGJlIGVuY291bnRlcmVkIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBzb21lIGVycm9yIG9jY3VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0luZGV4U3BlY2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG9yaWVudCA9IHRoaXNPcHRpb24ub3JpZW50O1xuXG4gICAgICAgICAgICBpZiAob3JpZW50ID09IG51bGwgJiYgaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29yaWVudCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbi5vcmllbnQgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnYXhpc0luZGV4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hdXRvU2V0QXhpc0luZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXV0b0F4aXNJbmRleCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXQoJ29yaWVudCcsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbnRNb2RlbHMgPSB0aGlzLmRlcGVuZGVudE1vZGVscztcblxuICAgICAgICAgICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGF4aXMgdGhhdCBwYXJhbGxlbCB0byBkYXRhWm9vbSBhcyBkZWZhdWx0LlxuICAgICAgICAgICAgICAgIHZhciBkaW1OYW1lID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVudE1vZGVsc1tkaW1OYW1lICsgJ0F4aXMnXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbltkaW1OYW1lICsgJ0F4aXNJbmRleCddID0gWzBdO1xuICAgICAgICAgICAgICAgICAgICBhdXRvQXhpc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGRlcGVuZGVudE1vZGVscy5zaW5nbGVBeGlzLCBmdW5jdGlvbiAoc2luZ2xlQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCAmJiBzaW5nbGVBeGlzTW9kZWwuZ2V0KCdvcmllbnQnLCB0cnVlKSA9PT0gb3JpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbi5zaW5nbGVBeGlzSW5kZXggPSBbc2luZ2xlQXhpc01vZGVsLmNvbXBvbmVudEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvQXhpc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBjYXRlZ29yeSBheGlzIGFzIGRlZmF1bHQuIChjb25zaWRlciBwb2xhcilcbiAgICAgICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRvQXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNJbmRpY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWxzID0gdGhpcy5kZXBlbmRlbnRNb2RlbHNbZGltTmFtZXMuYXhpc107XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzTW9kZWxzLmxlbmd0aCAmJiAhYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXhpc01vZGVscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzTW9kZWxzW2ldLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XSA9IGF4aXNJbmRpY2VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvQXhpc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIOi/memHjOaYr+WFvOWuuWVjMueahOWGmeazle+8iOayoeaMh+WumnhBeGlzSW5kZXjlkox5QXhpc0luZGV45pe25oqKc2NhdHRlcuWSjOWPjOaVsOWAvOi9tOaKmOafsee6s+WFpWRhdGFab29t5o6n5Yi277yJ77yMXG4gICAgICAgICAgICAgICAgLy8g5L2G5piv5a6e6ZmF5piv5ZCm6ZyA6KaBR3JpZC5qcyNnZXRTY2FsZUJ5T3B0aW9u5p2l5Yik5pat77yI6ICD6JmRdGltZe+8jGxvZ+etiWF4aXMgdHlwZe+8ie+8n1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYm90aCBkYXRhWm9vbS54QXhpc0luZGV4IGFuZCBkYXRhWm9vbS55QXhpc0luZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICAgICAgICAgICAgLy8gZGF0YVpvb20gY29tcG9uZW50IGF1dG8gYWRvcHRzIHNlcmllcyB0aGF0IHJlZmVyZW5jZSB0b1xuICAgICAgICAgICAgICAgIC8vIGJvdGggeEF4aXMgYW5kIHlBeGlzIHdoaWNoIHR5cGUgaXMgJ3ZhbHVlJy5cbiAgICAgICAgICAgICAgICB0aGlzLmVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2VyaWVzSGFzQWxsQXhlc1R5cGVPZihzZXJpZXNNb2RlbCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzSW5kaWNlcyA9IHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc0lkID0gc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWVzLmF4aXNJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogZGltTmFtZXMuYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGF4aXNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGF4aXNJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1OYW1lcy5heGlzICsgJyBcIicgKyB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArICdcIiBub3QgZm91bmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaW5kZXhPZihheGlzSW5kaWNlcywgYXhpc0luZGV4KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGljZXMucHVzaChheGlzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYXV0b1NldE9yaWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpbTtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYXhpc1xuICAgICAgICAgICAgdGhpcy5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAhZGltICYmIChkaW0gPSBkaW1OYW1lcy5uYW1lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5vcmllbnQgPSBkaW0gPT09ICd5JyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaXNTZXJpZXNIYXNBbGxBeGVzVHlwZU9mOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGF4aXNUeXBlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8g6ZyA6KaBc2VyaWVz55qEeEF4aXNJbmRleOWSjHlBeGlzSW5kZXjpg73pppblhYjoh6rliqjorr7nva7kuIrjgIJcbiAgICAgICAgICAgIC8vIOS+i+WmgnNlcmllcy50eXBlID09PSBzY2F0dGVy5pe244CCXG5cbiAgICAgICAgICAgIHZhciBpcyA9IHRydWU7XG4gICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzQXhpc0luZGV4ID0gc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdW3Nlcmllc0F4aXNJbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCB8fCBheGlzTW9kZWwuZ2V0KCd0eXBlJykgIT09IGF4aXNUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0RGVmYXVsdFRocm90dGxlOiBmdW5jdGlvbiAocmF3T3B0aW9uKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGZpcnN0IHRpbWUgdXNlciBzZXQgdGhyb3R0bGUsIGF1dG8gdGhyb3R0bGUgZW5kcy5cbiAgICAgICAgICAgIGlmIChyYXdPcHRpb24uaGFzT3duUHJvcGVydHkoJ3Rocm90dGxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvVGhyb3R0bGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hdXRvVGhyb3R0bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsT3B0aW9uID0gdGhpcy5lY01vZGVsLm9wdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9XG4gICAgICAgICAgICAgICAgICAgIChnbG9iYWxPcHRpb24uYW5pbWF0aW9uICYmIGdsb2JhbE9wdGlvbi5hbmltYXRpb25EdXJhdGlvblVwZGF0ZSA+IDApXG4gICAgICAgICAgICAgICAgICAgID8gMTAwIDogMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpcnN0VGFyZ2V0QXhpc01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBeGlzTW9kZWw7XG4gICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RBeGlzTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtpbmRpY2VzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlyc3RBeGlzTW9kZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgcGFyYW06IGF4aXNNb2RlbCwgZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaFRhcmdldEF4aXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBlYWNoKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldChkaW1OYW1lcy5heGlzSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGRpbU5hbWVzLCBheGlzSW5kZXgsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHl9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpc1Byb3h5OiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXhpc1Byb3hpZXNbZGltTmFtZSArICdfJyArIGF4aXNJbmRleF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1OYW1lXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBheGlzSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpc01vZGVsOiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXhpc1Byb3h5ID0gdGhpcy5nZXRBeGlzUHJveHkoZGltTmFtZSwgYXhpc0luZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBheGlzUHJveHkgJiYgYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBzZXQgdG8gdW5kZWZpbmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kVmFsdWVdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVVwZGF0ZVJhbmdlVXNnPWZhbHNlXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmF3UmFuZ2U6IGZ1bmN0aW9uIChvcHQsIGlnbm9yZVVwZGF0ZVJhbmdlVXNnKSB7XG4gICAgICAgICAgICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhvc2UgcHJvcCBpcyBudWxsL3VuZGVmaW5lZCwgd2Ugc2hvdWxkIGFsb3Mgc2V0XG4gICAgICAgICAgICAgICAgLy8gdGhlbSwgYmVjYXVzZSBvbmx5IG9uZSBwYWlyIGJldHdlZW4gc3RhcnQvZW5kIGFuZFxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0VmFsdWUvZW5kVmFsdWUgY2FuIHdvcmsuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25bbmFtZV0gPSBvcHRbbmFtZV07XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgIWlnbm9yZVVwZGF0ZVJhbmdlVXNnICYmIHVwZGF0ZVJhbmdlVXNlKHRoaXMsIG9wdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFtzdGFydFBlcmNlbnQsIGVuZFBlcmNlbnRdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQZXJjZW50UmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuICAgICAgICAgICAgaWYgKGF4aXNQcm94eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVBlcmNlbnRXaW5kb3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgY2hhcnQuZ2V0TW9kZWwoKS5nZXRDb21wb25lbnQoJ2RhdGFab29tJykuZ2V0VmFsdWVSYW5nZSgneScsIDApO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNEaW1OYW1lXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2F4aXNJbmRleF1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFtzdGFydFZhbHVlLCBlbmRWYWx1ZV0gdmFsdWUgY2FuIG9ubHkgYmUgJy0nIG9yIGZpbml0ZSBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZVJhbmdlOiBmdW5jdGlvbiAoYXhpc0RpbU5hbWUsIGF4aXNJbmRleCkge1xuICAgICAgICAgICAgaWYgKGF4aXNEaW1OYW1lID09IG51bGwgJiYgYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1Byb3h5ID0gdGhpcy5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKTtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhpc1Byb3h5KGF4aXNEaW1OYW1lLCBheGlzSW5kZXgpLmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtheGlzTW9kZWxdIElmIGF4aXNNb2RlbCBnaXZlbiwgZmluZCBheGlzUHJveHlcbiAgICAgICAgICogICAgICBjb3JyZXNwb25kaW5nIHRvIHRoZSBheGlzTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0F4aXNQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eTogZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBheGlzTW9kZWwuX19kekF4aXNQcm94eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgaG9zdGVkIGF4aXNQcm94eVxuICAgICAgICAgICAgdmFyIGF4aXNQcm94aWVzID0gdGhpcy5fYXhpc1Byb3hpZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXhpc1Byb3hpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBheGlzUHJveGllc1trZXldLmhvc3RlZEJ5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheGlzUHJveGllc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gaG9zdGVkIGF4aXMgZmluZCBub3QgaG9zdGVkIGF4aXNQcm94eS5cbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTogZGF0YVpvb21Nb2RlbDEgYW5kIGRhdGFab29tTW9kZWwyIGNvbnRyb2wgdGhlIHNhbWUgYXhpcyxcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgb3B0aW9uLnN0YXJ0IG9yIG9wdGlvbi5lbmQgc2V0dGluZ3MgYXJlIGRpZmZlcmVudC4gVGhlIHBlcmNlbnRSYW5nZVxuICAgICAgICAgICAgLy8gc2hvdWxkIGZvbGxvdyBheGlzUHJveHkuXG4gICAgICAgICAgICAvLyAoV2UgZW5jb3VudGVyIHRoaXMgcHJvYmxlbSBpbiB0b29sYm94IGRhdGEgem9vbS4pXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXhpc1Byb3hpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmFuZ2VQcm9wTW9kZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlUHJvcE1vZGUuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSYXcob3B0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZWFjaChcbiAgICAgICAgICAgIFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnLCAndGhyb3R0bGUnXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmhhc093blByb3BlcnR5KG5hbWUpICYmIChyZXRbbmFtZV0gPSBvcHRpb25bbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlVXNlKGRhdGFab29tTW9kZWwsIHJhd09wdGlvbikge1xuICAgICAgICBlYWNoKFtbJ3N0YXJ0JywgJ3N0YXJ0VmFsdWUnXSwgWydlbmQnLCAnZW5kVmFsdWUnXV0sIGZ1bmN0aW9uIChuYW1lcywgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVByb3BNb2RlID0gZGF0YVpvb21Nb2RlbC5fcmFuZ2VQcm9wTW9kZTtcbiAgICAgICAgICAgIGlmIChyYXdPcHRpb25bbmFtZXNbMF1dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByYW5nZVByb3BNb2RlW2luZGV4XSA9ICdwZXJjZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJhd09wdGlvbltuYW1lc1sxXV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJhbmdlUHJvcE1vZGVbaW5kZXhdID0gJ3ZhbHVlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgcmVtYWluIGl0cyBvcmlnaW5hbCBzZXR0aW5nLlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERhdGFab29tTW9kZWw7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var ComponentView = __webpack_require__(67);\n\n    module.exports = ComponentView.extend({\n\n        type: 'dataZoom',\n\n        render: function (dataZoomModel, ecModel, api, payload) {\n            this.dataZoomModel = dataZoomModel;\n            this.ecModel = ecModel;\n            this.api = api;\n        },\n\n        /**\n         * Find the first target coordinate system.\n         *\n         * @protected\n         * @return {Object} {\n         *                   grid: [\n         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n         *                       ...\n         *                   ],  // cartesians must not be null/undefined.\n         *                   polar: [\n         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n         *                       ...\n         *                   ],  // polars must not be null/undefined.\n         *                   singleAxis: [\n         *                       {model: coord0, axisModels: [], coordIndex: 0}\n         *                   ]\n         */\n        getTargetCoordInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var ecModel = this.ecModel;\n            var coordSysLists = {};\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n                if (axisModel) {\n                    var coordModel = axisModel.getCoordSysModel();\n                    coordModel && save(\n                        coordModel,\n                        axisModel,\n                        coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []),\n                        coordModel.componentIndex\n                    );\n                }\n            }, this);\n\n            function save(coordModel, axisModel, store, coordIndex) {\n                var item;\n                for (var i = 0; i < store.length; i++) {\n                    if (store[i].model === coordModel) {\n                        item = store[i];\n                        break;\n                    }\n                }\n                if (!item) {\n                    store.push(item = {\n                        model: coordModel, axisModels: [], coordIndex: coordIndex\n                    });\n                }\n                item.axisModels.push(axisModel);\n            }\n\n            return coordSysLists;\n        }\n\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbVZpZXcuanM/ZTVlYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esa0NBQWtDLHlEQUF5RDtBQUMzRixrQ0FBa0MseURBQXlEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBa0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUsiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy9Db21wb25lbnQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50Vmlldy5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdkYXRhWm9vbScsXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFab29tTW9kZWwgPSBkYXRhWm9vbU1vZGVsO1xuICAgICAgICAgICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICAgICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBmaXJzdCB0YXJnZXQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIGdyaWQ6IFtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbYXhpczEsIGF4aXMzXSwgY29vcmRJbmRleDogMX0sXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMSwgYXhpc01vZGVsczogW2F4aXMwLCBheGlzMl0sIGNvb3JkSW5kZXg6IDB9LFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBjYXJ0ZXNpYW5zIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICBwb2xhcjogW1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzNF0sIGNvb3JkSW5kZXg6IDB9LFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBwb2xhcnMgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIHNpbmdsZUF4aXM6IFtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbXSwgY29vcmRJbmRleDogMH1cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGFyZ2V0Q29vcmRJbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzTGlzdHMgPSB7fTtcblxuICAgICAgICAgICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudChkaW1OYW1lcy5heGlzLCBheGlzSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgICAgICAgICAgICAgICAgICBjb29yZE1vZGVsICYmIHNhdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXNMaXN0c1tjb29yZE1vZGVsLm1haW5UeXBlXSB8fCAoY29vcmRTeXNMaXN0c1tjb29yZE1vZGVsLm1haW5UeXBlXSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc2F2ZShjb29yZE1vZGVsLCBheGlzTW9kZWwsIHN0b3JlLCBjb29yZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmVbaV0ubW9kZWwgPT09IGNvb3JkTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBzdG9yZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogY29vcmRNb2RlbCwgYXhpc01vZGVsczogW10sIGNvb3JkSW5kZXg6IGNvb3JkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uYXhpc01vZGVscy5wdXNoKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5c0xpc3RzO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file History manager.\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var each = zrUtil.each;\n\n    var ATTR = '\\0_ec_hist_store';\n\n    var history = {\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n         */\n        push: function (ecModel, newSnapshot) {\n            var store = giveStore(ecModel);\n\n            // If previous dataZoom can not be found,\n            // complete an range with current range.\n            each(newSnapshot, function (batchItem, dataZoomId) {\n                var i = store.length - 1;\n                for (; i >= 0; i--) {\n                    var snapshot = store[i];\n                    if (snapshot[dataZoomId]) {\n                        break;\n                    }\n                }\n                if (i < 0) {\n                    // No origin range set, create one by current range.\n                    var dataZoomModel = ecModel.queryComponents(\n                        {mainType: 'dataZoom', subType: 'select', id: dataZoomId}\n                    )[0];\n                    if (dataZoomModel) {\n                        var percentRange = dataZoomModel.getPercentRange();\n                        store[0][dataZoomId] = {\n                            dataZoomId: dataZoomId,\n                            start: percentRange[0],\n                            end: percentRange[1]\n                        };\n                    }\n                }\n            });\n\n            store.push(newSnapshot);\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object} snapshot\n         */\n        pop: function (ecModel) {\n            var store = giveStore(ecModel);\n            var head = store[store.length - 1];\n            store.length > 1 && store.pop();\n\n            // Find top for all dataZoom.\n            var snapshot = {};\n            each(head, function (batchItem, dataZoomId) {\n                for (var i = store.length - 1; i >= 0; i--) {\n                    var batchItem = store[i][dataZoomId];\n                    if (batchItem) {\n                        snapshot[dataZoomId] = batchItem;\n                        break;\n                    }\n                }\n            });\n\n            return snapshot;\n        },\n\n        /**\n         * @public\n         */\n        clear: function (ecModel) {\n            ecModel[ATTR] = null;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {number} records. always >= 1.\n         */\n        count: function (ecModel) {\n            return giveStore(ecModel).length;\n        }\n\n    };\n\n    /**\n     * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n     * History length of each dataZoom may be different.\n     * this._history[0] is used to store origin range.\n     * @type {Array.<Object>}\n     */\n    function giveStore(ecModel) {\n        var store = ecModel[ATTR];\n        if (!store) {\n            store = ecModel[ATTR] = [{}];\n        }\n        return store;\n    }\n\n    module.exports = history;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oaXN0b3J5LmpzP2E3MmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixPQUFPLGNBQWM7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QixtQkFBbUI7QUFDckQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEhpc3RvcnkgbWFuYWdlci5cbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIHZhciBBVFRSID0gJ1xcMF9lY19oaXN0X3N0b3JlJztcblxuICAgIHZhciBoaXN0b3J5ID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTbmFwc2hvdCB7ZGF0YVpvb21JZCwgYmF0Y2g6IFtwYXlsb2FkSW5mbywgLi4uXX1cbiAgICAgICAgICovXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIChlY01vZGVsLCBuZXdTbmFwc2hvdCkge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGVjTW9kZWwpO1xuXG4gICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBkYXRhWm9vbSBjYW4gbm90IGJlIGZvdW5kLFxuICAgICAgICAgICAgLy8gY29tcGxldGUgYW4gcmFuZ2Ugd2l0aCBjdXJyZW50IHJhbmdlLlxuICAgICAgICAgICAgZWFjaChuZXdTbmFwc2hvdCwgZnVuY3Rpb24gKGJhdGNoSXRlbSwgZGF0YVpvb21JZCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gc3RvcmVbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbmFwc2hvdFtkYXRhWm9vbUlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIG9yaWdpbiByYW5nZSBzZXQsIGNyZWF0ZSBvbmUgYnkgY3VycmVudCByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFab29tTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgc3ViVHlwZTogJ3NlbGVjdCcsIGlkOiBkYXRhWm9vbUlkfVxuICAgICAgICAgICAgICAgICAgICApWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnRSYW5nZSA9IGRhdGFab29tTW9kZWwuZ2V0UGVyY2VudFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVswXVtkYXRhWm9vbUlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhWm9vbUlkOiBkYXRhWm9vbUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwZXJjZW50UmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwZXJjZW50UmFuZ2VbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3RvcmUucHVzaChuZXdTbmFwc2hvdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBzbmFwc2hvdFxuICAgICAgICAgKi9cbiAgICAgICAgcG9wOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGVjTW9kZWwpO1xuICAgICAgICAgICAgdmFyIGhlYWQgPSBzdG9yZVtzdG9yZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHN0b3JlLmxlbmd0aCA+IDEgJiYgc3RvcmUucG9wKCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdG9wIGZvciBhbGwgZGF0YVpvb20uXG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSB7fTtcbiAgICAgICAgICAgIGVhY2goaGVhZCwgZnVuY3Rpb24gKGJhdGNoSXRlbSwgZGF0YVpvb21JZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdG9yZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2hJdGVtID0gc3RvcmVbaV1bZGF0YVpvb21JZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90W2RhdGFab29tSWRdID0gYmF0Y2hJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIGVjTW9kZWxbQVRUUl0gPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gcmVjb3Jkcy4gYWx3YXlzID49IDEuXG4gICAgICAgICAqL1xuICAgICAgICBjb3VudDogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBnaXZlU3RvcmUoZWNNb2RlbCkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW3trZXk6IGRhdGFab29tSWQsIHZhbHVlOiB7ZGF0YVpvb21JZCwgcmFuZ2V9fSwgLi4uXVxuICAgICAqIEhpc3RvcnkgbGVuZ3RoIG9mIGVhY2ggZGF0YVpvb20gbWF5IGJlIGRpZmZlcmVudC5cbiAgICAgKiB0aGlzLl9oaXN0b3J5WzBdIGlzIHVzZWQgdG8gc3RvcmUgb3JpZ2luIHJhbmdlLlxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnaXZlU3RvcmUoZWNNb2RlbCkge1xuICAgICAgICB2YXIgc3RvcmUgPSBlY01vZGVsW0FUVFJdO1xuICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICBzdG9yZSA9IGVjTW9kZWxbQVRUUl0gPSBbe31dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhpc3Rvcnk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n\n    __webpack_require__(60);\n\n    __webpack_require__(118);\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9ncmlkU2ltcGxlLmpzPzg3NjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIHJlcXVpcmUoJy4uL2Nvb3JkL2NhcnRlc2lhbi9HcmlkJyk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMnKTtcblxuICAgIC8vIEdyaWQgdmlld1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2dyaWQnLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgIGlmIChncmlkTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBncmlkTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgICAgICAgICAgICAgICB9LCBncmlkTW9kZWwuZ2V0SXRlbVN0eWxlKCkpLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHoyOiAtMVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgZ3JpZCB3aGVuIG5lZWRcbiAgICAgICAgaWYgKG9wdGlvbi54QXhpcyAmJiBvcHRpb24ueUF4aXMgJiYgIW9wdGlvbi5ncmlkKSB7XG4gICAgICAgICAgICBvcHRpb24uZ3JpZCA9IHt9O1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWRTaW1wbGUuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n    // List layout\n    var layout = __webpack_require__(15);\n    var formatUtil = __webpack_require__(10);\n    var graphic = __webpack_require__(2);\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qcz85OWU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjU2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgLy8gTGlzdCBsYXlvdXRcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uR3JvdXAoZ3JvdXAsIG1vZGVsLCBhcGkpIHtcbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uRWxlbWVudChcbiAgICAgICAgICAgIGdyb3VwLCBtb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2RlbC5nZXQoJ3BhZGRpbmcnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGF5b3V0IGxpc3QgbGlrZSBjb21wb25lbnQuXG4gICAgICAgICAqIEl0IHdpbGwgYm94IGxheW91dCBlYWNoIGl0ZW1zIGluIGdyb3VwIG9mIGNvbXBvbmVudCBhbmQgdGhlbiBwb3NpdGlvbiB0aGUgd2hvbGUgZ3JvdXAgaW4gdGhlIHZpZXdwb3J0XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JvdXAvR3JvdXB9IGdyb3VwXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb21wb25lbnRNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogZnVuY3Rpb24gKGdyb3VwLCBjb21wb25lbnRNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KGNvbXBvbmVudE1vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICB9LCBjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKSk7XG4gICAgICAgICAgICBsYXlvdXQuYm94KFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLmdldCgnb3JpZW50JyksXG4gICAgICAgICAgICAgICAgZ3JvdXAsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwuZ2V0KCdpdGVtR2FwJyksXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcG9zaXRpb25Hcm91cChncm91cCwgY29tcG9uZW50TW9kZWwsIGFwaSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQmFja2dyb3VuZDogZnVuY3Rpb24gKGdyb3VwLCBjb21wb25lbnRNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLmdldCgncGFkZGluZycpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gY29tcG9uZW50TW9kZWwuZ2V0SXRlbVN0eWxlKFsnY29sb3InLCAnb3BhY2l0eSddKTtcbiAgICAgICAgICAgIHN0eWxlLmZpbGwgPSBjb21wb25lbnRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICB4OiBib3VuZGluZ1JlY3QueCAtIHBhZGRpbmdbM10sXG4gICAgICAgICAgICAgICAgICAgIHk6IGJvdW5kaW5nUmVjdC55IC0gcGFkZGluZ1swXSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCArIHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBwYWRkaW5nWzBdICsgcGFkZGluZ1syXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6MjogLTFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcblxuICAgICAgICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2xpc3RDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var numberUtil = __webpack_require__(5);\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = __webpack_require__(0);\n    var axisHelper = __webpack_require__(17);\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getModel('textStyle').getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL0F4aXMuanM/NmRkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgbGluZWFyTWFwID0gbnVtYmVyVXRpbC5saW5lYXJNYXA7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi9heGlzSGVscGVyJyk7XG5cbiAgICBmdW5jdGlvbiBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBuVGljaykge1xuICAgICAgICB2YXIgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgdmFyIGxlbiA9IG5UaWNrO1xuICAgICAgICB2YXIgbWFyZ2luID0gc2l6ZSAvIGxlbiAvIDI7XG4gICAgICAgIGV4dGVudFswXSArPSBtYXJnaW47XG4gICAgICAgIGV4dGVudFsxXSAtPSBtYXJnaW47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbGl6ZWRFeHRlbnQgPSBbMCwgMV07XG4gICAgLyoqXG4gICAgICogQG5hbWUgbW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuQXhpc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBBeGlzID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGV4dGVudCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIGRpbWVuc2lvbi4gU3VjaCBhcyAneCcsICd5JywgJ3onLCAnYW5nbGUnLCAncmFkaXVzJ1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaW0gPSBkaW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgc2NhbGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlLyp9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgMF07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzdWFsbHkgdHJ1ZSB3aGVuIGF4aXMgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CYW5kID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYWJlbEludGVydmFsO1xuICAgIH07XG5cbiAgICBBeGlzLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQXhpcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYXhpcyBleHRlbnQgY29udGFpbiBnaXZlbiBjb29yZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29vcmRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkID49IG1pbiAmJiBjb29yZCA8PSBtYXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGF4aXMgZXh0ZW50IGNvbnRhaW4gZ2l2ZW4gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbkRhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluKHRoaXMuZGF0YVRvQ29vcmQoZGF0YSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29vcmQgZXh0ZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcHJlY2lzaW9uIHVzZWQgZm9yIGZvcm1hdHRpbmdcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2RhdGFFeHRlbnRdXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBpeGVsUHJlY2lzaW9uOiBmdW5jdGlvbiAoZGF0YUV4dGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclV0aWwuZ2V0UGl4ZWxQcmVjaXNpb24oXG4gICAgICAgICAgICAgICAgZGF0YUV4dGVudCB8fCB0aGlzLnNjYWxlLmdldEV4dGVudCgpLFxuICAgICAgICAgICAgICAgIHRoaXMuX2V4dGVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGNvb3JkIGV4dGVudFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IHN0YXJ0O1xuICAgICAgICAgICAgZXh0ZW50WzFdID0gZW5kO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGRhdGEgdG8gY29vcmQuIERhdGEgaXMgdGhlIHJhbmsgaWYgaXQgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRhdGEgPSBzY2FsZS5ub3JtYWxpemUoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFuZCAmJiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxpbmVhck1hcChkYXRhLCBub3JtYWxpemVkRXh0ZW50LCBleHRlbnQsIGNsYW1wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBjb29yZCB0byBkYXRhLiBEYXRhIGlzIHRoZSByYW5rIGlmIGl0IGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAoY29vcmQsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIHNjYWxlLmNvdW50KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdCA9IGxpbmVhck1hcChjb29yZCwgZXh0ZW50LCBub3JtYWxpemVkRXh0ZW50LCBjbGFtcCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnNjYWxlKHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHBpeGVsIHBvaW50IHRvIGRhdGEgaW4gYXhpc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gZGVyaXZlZCBjbGFzcyBpZiBuZWNlc3NhcnkuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlja3NDb29yZHM6IGZ1bmN0aW9uIChhbGlnbldpdGhMYWJlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub25CYW5kICYmICFhbGlnbldpdGhMYWJlbCkge1xuICAgICAgICAgICAgICAgIHZhciBiYW5kcyA9IHRoaXMuZ2V0QmFuZHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMucHVzaChiYW5kc1tpXVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYW5kc1tpIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLnB1c2goYmFuZHNbaSAtIDFdWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvb3JkcyBvZiBsYWJlbHMgYXJlIG9uIHRoZSB0aWNrcyBvciBvbiB0aGUgbWlkZGxlIG9mIGJhbmRzXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWxzQ29vcmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLnNjYWxlLmdldFRpY2tzKCksIHRoaXMuZGF0YVRvQ29vcmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYmFuZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGF4aXMgaGFzIGxhYmVscyBbMSwgMiwgMywgNF0uIEJhbmRzIG9uIHRoZSBheGlzIGFyZVxuICAgICAgICAgKiB8LS0tMS0tLXwtLS0yLS0tfC0tLTMtLS18LS0tNC0tLXwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgIC8vIEZJWE1FIFNpdHVhdGlvbiB3aGVuIGxhYmVscyBpcyBvbiB0aWNrc1xuICAgICAgICBnZXRCYW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICB2YXIgYmFuZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLnNjYWxlLmNvdW50KCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBleHRlbnRbMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBlbmQgLSBzdGFydDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGJhbmRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBzcGFuICogaSAvIGxlbiArIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBzcGFuICogKGkgKyAxKSAvIGxlbiArIHN0YXJ0XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFuZHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB3aWR0aCBvZiBiYW5kXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJhbmRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXNFeHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBkYXRhRXh0ZW50WzFdIC0gZGF0YUV4dGVudFswXSArICh0aGlzLm9uQmFuZCA/IDEgOiAwKTtcbiAgICAgICAgICAgIC8vIEZpeCAjMjcyOCwgYXZvaWQgTmFOIHdoZW4gb25seSBvbmUgZGF0YS5cbiAgICAgICAgICAgIGxlbiA9PT0gMCAmJiAobGVuID0gMSk7XG5cbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2l6ZSkgLyBsZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBpbnRlcnZhbCBvZiB0aGUgYXhpcyBsYWJlbC5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWxJbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsSW50ZXJ2YWwgPSB0aGlzLl9sYWJlbEludGVydmFsO1xuICAgICAgICAgICAgaWYgKCFsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGxhYmVsTW9kZWwuZ2V0KCdpbnRlcnZhbCcpO1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiBpbnRlcnZhbCA9PT0gJ2F1dG8nKSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEludGVydmFsID0gaW50ZXJ2YWwgPT09ICdhdXRvJyA/IDAgOiBpbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0hvcml6b250YWwpe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEludGVydmFsID0gYXhpc0hlbHBlci5nZXRBeGlzTGFiZWxJbnRlcnZhbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxJbnRlcnZhbCA9IGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQXhpcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb29yZC9BeGlzLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var axisHelper = __webpack_require__(17);\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis && min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis && max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENvbW1vbk1peGluLmpzPzcwOTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi9heGlzSGVscGVyJyk7XG5cbiAgICBmdW5jdGlvbiBnZXROYW1lKG9iaikge1xuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG9iaikgJiYgb2JqLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICsgJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0IGxhYmVsc1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvcm1hdHRlZExhYmVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF4aXNIZWxwZXIuZ2V0Rm9ybWF0dGVkTGFiZWxzKFxuICAgICAgICAgICAgICAgIHRoaXMuYXhpcyxcbiAgICAgICAgICAgICAgICB0aGlzLmdldCgnYXhpc0xhYmVsLmZvcm1hdHRlcicpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2F0ZWdvcmllc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCd0eXBlJykgPT09ICdjYXRlZ29yeSdcbiAgICAgICAgICAgICAgICAmJiB6clV0aWwubWFwKHRoaXMuZ2V0KCdkYXRhJyksIGdldE5hbWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9yaWdpblxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfSBtaW4gdmFsdWUgb3IgJ2RhdGFNaW4nIG9yIG51bGwvdW5kZWZpbmVkIChtZWFucyBhdXRvKSBvciBOYU5cbiAgICAgICAgICovXG4gICAgICAgIGdldE1pbjogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICAgICAgdmFyIG1pbiA9ICghb3JpZ2luICYmIG9wdGlvbi5yYW5nZVN0YXJ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgPyBvcHRpb24ucmFuZ2VTdGFydCA6IG9wdGlvbi5taW47XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmF4aXMgJiYgbWluICE9IG51bGwgJiYgbWluICE9PSAnZGF0YU1pbicgJiYgIXpyVXRpbC5lcU5hTihtaW4pKSB7XG4gICAgICAgICAgICAgICAgbWluID0gdGhpcy5heGlzLnNjYWxlLnBhcnNlKG1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9yaWdpblxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfSBtYXggdmFsdWUgb3IgJ2RhdGFNYXgnIG9yIG51bGwvdW5kZWZpbmVkIChtZWFucyBhdXRvKSBvciBOYU5cbiAgICAgICAgICovXG4gICAgICAgIGdldE1heDogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICAgICAgdmFyIG1heCA9ICghb3JpZ2luICYmIG9wdGlvbi5yYW5nZUVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgID8gb3B0aW9uLnJhbmdlRW5kIDogb3B0aW9uLm1heDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYXhpcyAmJiBtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4JyAmJiAhenJVdGlsLmVxTmFOKG1heCkpIHtcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLmF4aXMuc2NhbGUucGFyc2UobWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXROZWVkQ3Jvc3NaZXJvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICByZXR1cm4gKG9wdGlvbi5yYW5nZVN0YXJ0ICE9IG51bGwgfHwgb3B0aW9uLnJhbmdlRW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgPyBmYWxzZSA6ICFvcHRpb24uc2NhbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIGF4aXMgbW9kZWwgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IGNvb3JkaW5hdGUgc3lzdGVtIG1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb29yZFN5c01vZGVsOiB6clV0aWwubm9vcCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlU3RhcnQgQ2FuIG9ubHkgYmUgZmluaXRlIG51bWJlciBvciBudWxsL3VuZGVmaW5lZCBvciBOYU4uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZUVuZCBDYW4gb25seSBiZSBmaW5pdGUgbnVtYmVyIG9yIG51bGwvdW5kZWZpbmVkIG9yIE5hTi5cbiAgICAgICAgICovXG4gICAgICAgIHNldFJhbmdlOiBmdW5jdGlvbiAocmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLnJhbmdlU3RhcnQgPSByYW5nZVN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmFuZ2VFbmQgPSByYW5nZUVuZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgcmFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0UmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlU3RhcnQgYW5kIHJhbmdlRW5kIGlzIHJlYWRvbmx5LlxuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmFuZ2VTdGFydCA9IHRoaXMub3B0aW9uLnJhbmdlRW5kID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var ComponentModel = __webpack_require__(13);\n    var zrUtil = __webpack_require__(0);\n    var axisModelCreator = __webpack_require__(158);\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, __webpack_require__(58));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanM/NmQxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL0NvbXBvbmVudCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc01vZGVsQ3JlYXRvciA9IHJlcXVpcmUoJy4uL2F4aXNNb2RlbENyZWF0b3InKTtcblxuICAgIHZhciBBeGlzTW9kZWwgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4yZEF4aXMnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRH1cbiAgICAgICAgICovXG4gICAgICAgIGF4aXM6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ2luaXQnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFJhbmdlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEF4aXNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdtZXJnZU9wdGlvbicsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UmFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ3Jlc3RvcmVEYXRhJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRSYW5nZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29vcmRTeXNNb2RlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiAnZ3JpZCcsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMub3B0aW9uLmdyaWRJbmRleCxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5vcHRpb24uZ3JpZElkXG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzVHlwZShheGlzRGltLCBvcHRpb24pIHtcbiAgICAgICAgLy8gRGVmYXVsdCBheGlzIHdpdGggZGF0YSBpcyBjYXRlZ29yeSBheGlzXG4gICAgICAgIHJldHVybiBvcHRpb24udHlwZSB8fCAob3B0aW9uLmRhdGEgPyAnY2F0ZWdvcnknIDogJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgenJVdGlsLm1lcmdlKEF4aXNNb2RlbC5wcm90b3R5cGUsIHJlcXVpcmUoJy4uL2F4aXNNb2RlbENvbW1vbk1peGluJykpO1xuXG4gICAgdmFyIGV4dHJhT3B0aW9uID0ge1xuICAgICAgICAvLyBncmlkSW5kZXg6IDAsXG4gICAgICAgIC8vIGdyaWRJZDogJycsXG5cbiAgICAgICAgLy8gT2Zmc2V0IGlzIGZvciBtdWx0aXBsZSBheGlzIG9uIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgIG9mZnNldDogMFxuICAgIH07XG5cbiAgICBheGlzTW9kZWxDcmVhdG9yKCd4JywgQXhpc01vZGVsLCBnZXRBeGlzVHlwZSwgZXh0cmFPcHRpb24pO1xuICAgIGF4aXNNb2RlbENyZWF0b3IoJ3knLCBBeGlzTW9kZWwsIGdldEF4aXNUeXBlLCBleHRyYU9wdGlvbik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXNNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = __webpack_require__(15);\n    var axisHelper = __webpack_require__(17);\n\n    var zrUtil = __webpack_require__(0);\n    var Cartesian2D = __webpack_require__(161);\n    var Axis2D = __webpack_require__(159);\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    // 依赖 GridModel, AxisModel 做预处理\n    __webpack_require__(162);\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this.model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.axisPointerEnabled = true;\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this.model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (\n                        axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis)\n                    )) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis.scale, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis.scale, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this.model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api, ignoreContainLabel) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (!ignoreContainLabel && gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    /**\n     * @return {Array.<module:echarts/coord/Axis>}\n     */\n    gridProto.getAxes = function () {\n        return this._axesList.slice();\n    };\n\n    /**\n     * Usage:\n     *      grid.getCartesian(xAxisIndex, yAxisIndex);\n     *      grid.getCartesian(xAxisIndex);\n     *      grid.getCartesian(null, yAxisIndex);\n     *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n     *\n     * @param {number|Object} [xAxisIndex]\n     * @param {number} [yAxisIndex]\n     */\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n\n        if (zrUtil.isObject(xAxisIndex)) {\n            yAxisIndex = xAxisIndex.yAxisIndex;\n            xAxisIndex = xAxisIndex.xAxisIndex;\n        }\n        // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n            if (coordList[i].getAxis('x').index === xAxisIndex\n                || coordList[i].getAxis('y').index === yAxisIndex\n            ) {\n                return coordList[i];\n            }\n        }\n    };\n\n    gridProto.getCartesians = function () {\n        return this._coordsList.slice();\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n                cartesian.model = gridModel;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n     * @return {Object} {baseAxes: [], otherAxes: []}\n     */\n    gridProto.getTooltipAxes = function (dim) {\n        var baseAxes = [];\n        var otherAxes = [];\n\n        each(this.getCartesians(), function (cartesian) {\n            var baseAxis = (dim != null && dim !== 'auto')\n                ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n            var otherAxis = cartesian.getOtherAxis(baseAxis);\n            zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n            zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n        });\n\n        return {baseAxes: baseAxes, otherAxes: otherAxes};\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            // dataSampling requires axis extent, so resize\n            // should be performed in create stage.\n            grid.resize(gridModel, api, true);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\n\n    __webpack_require__(31).register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLmpzPzhkMWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLDRCQUE0QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTyxFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiI2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JpZCBpcyBhIHJlZ2lvbiB3aGljaCBjb250YWlucyBhdCBtb3N0IDQgY2FydGVzaWFuIHN5c3RlbXNcbiAqXG4gKiBUT0RPIERlZmF1bHQgY2FydGVzaWFuXG4gKi9cbnZhciBmYWN0b3J5ID0gZXhwb3J0cztcblxuICAgIHZhciBsYXlvdXQgPSByZXF1aXJlKCcuLi8uLi91dGlsL2xheW91dCcpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vY29vcmQvYXhpc0hlbHBlcicpO1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBDYXJ0ZXNpYW4yRCA9IHJlcXVpcmUoJy4vQ2FydGVzaWFuMkQnKTtcbiAgICB2YXIgQXhpczJEID0gcmVxdWlyZSgnLi9BeGlzMkQnKTtcblxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG5cbiAgICB2YXIgaWZBeGlzQ3Jvc3NaZXJvID0gYXhpc0hlbHBlci5pZkF4aXNDcm9zc1plcm87XG4gICAgdmFyIG5pY2VTY2FsZUV4dGVudCA9IGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50O1xuXG4gICAgLy8g5L6d6LWWIEdyaWRNb2RlbCwgQXhpc01vZGVsIOWBmumihOWkhOeQhlxuICAgIHJlcXVpcmUoJy4vR3JpZE1vZGVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXhpcyBpcyB1c2VkIGluIHRoZSBzcGVjaWZpZWQgZ3JpZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXhpc1VzZWRJblRoZUdyaWQoYXhpc01vZGVsLCBncmlkTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCkgPT09IGdyaWRNb2RlbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbFVuaW9uUmVjdChheGlzKSB7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICAgICAgICB2YXIgbGFiZWxzID0gYXhpc01vZGVsLmdldEZvcm1hdHRlZExhYmVscygpO1xuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbC50ZXh0U3R5bGUnKTtcbiAgICAgICAgdmFyIHJlY3Q7XG4gICAgICAgIHZhciBzdGVwID0gMTtcbiAgICAgICAgdmFyIGxhYmVsQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuICAgICAgICBpZiAobGFiZWxDb3VudCA+IDQwKSB7XG4gICAgICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uIGZvciBsYXJnZSBhbW91bnQgb2YgbGFiZWxzXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5jZWlsKGxhYmVsQ291bnQgLyA0MCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgIGlmICghYXhpcy5pc0xhYmVsSWdub3JlZChpKSkge1xuICAgICAgICAgICAgICAgIHZhciBzaW5nbGVSZWN0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dFJlY3QobGFiZWxzW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBjb25zaWRlciBsYWJlbCByb3RhdGVcbiAgICAgICAgICAgICAgICByZWN0ID8gcmVjdC51bmlvbihzaW5nbGVSZWN0KSA6IChyZWN0ID0gc2luZ2xlUmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR3JpZChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29vcmRzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb29yZHNMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9heGVzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9heGVzTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2luaXRDYXJ0ZXNpYW4oZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgICAgIHRoaXMubW9kZWwgPSBncmlkTW9kZWw7XG4gICAgfVxuXG4gICAgdmFyIGdyaWRQcm90byA9IEdyaWQucHJvdG90eXBlO1xuXG4gICAgZ3JpZFByb3RvLnR5cGUgPSAnZ3JpZCc7XG5cbiAgICBncmlkUHJvdG8uYXhpc1BvaW50ZXJFbmFibGVkID0gdHJ1ZTtcblxuICAgIGdyaWRQcm90by5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICB9O1xuXG4gICAgZ3JpZFByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcblxuICAgICAgICB2YXIgYXhlc01hcCA9IHRoaXMuX2F4ZXNNYXA7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlU2NhbGUoZWNNb2RlbCwgdGhpcy5tb2RlbCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaWZBeGlzQ2FuTm90T25aZXJvKG90aGVyQXhpc0RpbSkge1xuICAgICAgICAgICAgdmFyIGF4ZXMgPSBheGVzTWFwW290aGVyQXhpc0RpbV07XG4gICAgICAgICAgICBmb3IgKHZhciBpZHggaW4gYXhlcykge1xuICAgICAgICAgICAgICAgIGlmIChheGVzLmhhc093blByb3BlcnR5KGlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBheGVzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCBheGlzLnR5cGUgPT09ICd0aW1lJyB8fCAhaWZBeGlzQ3Jvc3NaZXJvKGF4aXMpXG4gICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcykge1xuICAgICAgICAgICAgbmljZVNjYWxlRXh0ZW50KHhBeGlzLnNjYWxlLCB4QXhpcy5tb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICAgICAgICBuaWNlU2NhbGVFeHRlbnQoeUF4aXMuc2NhbGUsIHlBeGlzLm1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpeCBjb25maWd1cmF0aW9uXG4gICAgICAgIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICAgICAgICAgIC8vIG9uWmVybyBjYW4gbm90IGJlIGVuYWJsZWQgaW4gdGhlc2UgdHdvIHNpdHVhdGlvbnNcbiAgICAgICAgICAgIC8vIDEuIFdoZW4gYW55IG90aGVyIGF4aXMgaXMgYSBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICAvLyAyLiBXaGVuIGFueSBvdGhlciBheGlzIG5vdCBhY3Jvc3MgMCBwb2ludFxuICAgICAgICAgICAgaWYgKGlmQXhpc0Nhbk5vdE9uWmVybygneScpKSB7XG4gICAgICAgICAgICAgICAgeEF4aXMub25aZXJvID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICAgICAgICBpZiAoaWZBeGlzQ2FuTm90T25aZXJvKCd4JykpIHtcbiAgICAgICAgICAgICAgICB5QXhpcy5vblplcm8gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzaXplIGFnYWluIGlmIGNvbnRhaW5MYWJlbCBpcyBlbmFibGVkXG4gICAgICAgIC8vIEZJWE1FIEl0IG1heSBjYXVzZSBnZXR0aW5nIHdyb25nIGdyaWQgc2l6ZSBpbiBkYXRhIHByb2Nlc3Npbmcgc3RhZ2VcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5tb2RlbCwgYXBpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoZSBncmlkXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICovXG4gICAgZ3JpZFByb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGFwaSwgaWdub3JlQ29udGFpbkxhYmVsKSB7XG5cbiAgICAgICAgdmFyIGdyaWRSZWN0ID0gbGF5b3V0LmdldExheW91dFJlY3QoXG4gICAgICAgICAgICBncmlkTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY3QgPSBncmlkUmVjdDtcblxuICAgICAgICB2YXIgYXhlc0xpc3QgPSB0aGlzLl9heGVzTGlzdDtcblxuICAgICAgICBhZGp1c3RBeGVzKCk7XG5cbiAgICAgICAgLy8gTWludXMgbGFiZWwgc2l6ZVxuICAgICAgICBpZiAoIWlnbm9yZUNvbnRhaW5MYWJlbCAmJiBncmlkTW9kZWwuZ2V0KCdjb250YWluTGFiZWwnKSkge1xuICAgICAgICAgICAgZWFjaChheGVzTGlzdCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXMubW9kZWwuZ2V0KCdheGlzTGFiZWwuaW5zaWRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsVW5pb25SZWN0ID0gZ2V0TGFiZWxVbmlvblJlY3QoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFVuaW9uUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGF4aXMuaXNIb3Jpem9udGFsKCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gYXhpcy5tb2RlbC5nZXQoJ2F4aXNMYWJlbC5tYXJnaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0W2RpbV0gLT0gbGFiZWxVbmlvblJlY3RbZGltXSArIG1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0LnkgKz0gbGFiZWxVbmlvblJlY3QuaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0LnggKz0gbGFiZWxVbmlvblJlY3Qud2lkdGggKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWRqdXN0QXhlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRqdXN0QXhlcygpIHtcbiAgICAgICAgICAgIGVhY2goYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVudCA9IGlzSG9yaXpvbnRhbCA/IFswLCBncmlkUmVjdC53aWR0aF0gOiBbMCwgZ3JpZFJlY3QuaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYXhpcy5pbnZlcnNlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgYXhpcy5zZXRFeHRlbnQoZXh0ZW50W2lkeF0sIGV4dGVudFsxIC0gaWR4XSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBpc0hvcml6b250YWwgPyBncmlkUmVjdC54IDogZ3JpZFJlY3QueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAgICAgKiBAcGFyYW0ge25kdW1iZXJ9IFtheGlzSW5kZXhdXG4gICAgICovXG4gICAgZ3JpZFByb3RvLmdldEF4aXMgPSBmdW5jdGlvbiAoYXhpc1R5cGUsIGF4aXNJbmRleCkge1xuICAgICAgICB2YXIgYXhlc01hcE9uRGltID0gdGhpcy5fYXhlc01hcFtheGlzVHlwZV07XG4gICAgICAgIGlmIChheGVzTWFwT25EaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGF4aXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBmaXJzdCBheGlzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBheGVzTWFwT25EaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4ZXNNYXBPbkRpbS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4ZXNNYXBPbkRpbVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBheGVzTWFwT25EaW1bYXhpc0luZGV4XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpcz59XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9heGVzTGlzdC5zbGljZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2FnZTpcbiAgICAgKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHhBeGlzSW5kZXgsIHlBeGlzSW5kZXgpO1xuICAgICAqICAgICAgZ3JpZC5nZXRDYXJ0ZXNpYW4oeEF4aXNJbmRleCk7XG4gICAgICogICAgICBncmlkLmdldENhcnRlc2lhbihudWxsLCB5QXhpc0luZGV4KTtcbiAgICAgKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHt4QXhpc0luZGV4OiAuLi4sIHlBeGlzSW5kZXg6IC4uLn0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBbeEF4aXNJbmRleF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3lBeGlzSW5kZXhdXG4gICAgICovXG4gICAgZ3JpZFByb3RvLmdldENhcnRlc2lhbiA9IGZ1bmN0aW9uICh4QXhpc0luZGV4LCB5QXhpc0luZGV4KSB7XG4gICAgICAgIGlmICh4QXhpc0luZGV4ICE9IG51bGwgJiYgeUF4aXNJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29vcmRzTWFwW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHhBeGlzSW5kZXgpKSB7XG4gICAgICAgICAgICB5QXhpc0luZGV4ID0geEF4aXNJbmRleC55QXhpc0luZGV4O1xuICAgICAgICAgICAgeEF4aXNJbmRleCA9IHhBeGlzSW5kZXgueEF4aXNJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIG9ubHkgeEF4aXNJbmRleCBvciB5QXhpc0luZGV4IGdpdmVuLCBmaW5kIGl0cyBmaXJzdCBjYXJ0ZXNpYW4uXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjb29yZExpc3QgPSB0aGlzLl9jb29yZHNMaXN0OyBpIDwgY29vcmRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29vcmRMaXN0W2ldLmdldEF4aXMoJ3gnKS5pbmRleCA9PT0geEF4aXNJbmRleFxuICAgICAgICAgICAgICAgIHx8IGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd5JykuaW5kZXggPT09IHlBeGlzSW5kZXhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ3JpZFByb3RvLmdldENhcnRlc2lhbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb29yZHNMaXN0LnNsaWNlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzXG4gICAgICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2ZpbmRDb252ZXJ0VGFyZ2V0KGVjTW9kZWwsIGZpbmRlcik7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5jYXJ0ZXNpYW5cbiAgICAgICAgICAgID8gdGFyZ2V0LmNhcnRlc2lhbi5kYXRhVG9Qb2ludCh2YWx1ZSlcbiAgICAgICAgICAgIDogdGFyZ2V0LmF4aXNcbiAgICAgICAgICAgID8gdGFyZ2V0LmF4aXMudG9HbG9iYWxDb29yZCh0YXJnZXQuYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSkpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzXG4gICAgICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZWNNb2RlbCwgZmluZGVyKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNhcnRlc2lhblxuICAgICAgICAgICAgPyB0YXJnZXQuY2FydGVzaWFuLnBvaW50VG9EYXRhKHZhbHVlKVxuICAgICAgICAgICAgOiB0YXJnZXQuYXhpc1xuICAgICAgICAgICAgPyB0YXJnZXQuYXhpcy5jb29yZFRvRGF0YSh0YXJnZXQuYXhpcy50b0xvY2FsQ29vcmQodmFsdWUpKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBncmlkUHJvdG8uX2ZpbmRDb252ZXJ0VGFyZ2V0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlcikge1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gICAgICAgIHZhciB4QXhpc01vZGVsID0gZmluZGVyLnhBeGlzTW9kZWxcbiAgICAgICAgICAgIHx8IChzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCd4QXhpcycpWzBdKTtcbiAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBmaW5kZXIueUF4aXNNb2RlbFxuICAgICAgICAgICAgfHwgKHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3lBeGlzJylbMF0pO1xuICAgICAgICB2YXIgZ3JpZE1vZGVsID0gZmluZGVyLmdyaWRNb2RlbDtcbiAgICAgICAgdmFyIGNvb3Jkc0xpc3QgPSB0aGlzLl9jb29yZHNMaXN0O1xuICAgICAgICB2YXIgY2FydGVzaWFuO1xuICAgICAgICB2YXIgYXhpcztcblxuICAgICAgICBpZiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB6clV0aWwuaW5kZXhPZihjb29yZHNMaXN0LCBjYXJ0ZXNpYW4pIDwgMCAmJiAoY2FydGVzaWFuID0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeEF4aXNNb2RlbCAmJiB5QXhpc01vZGVsKSB7XG4gICAgICAgICAgICBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbih4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4QXhpc01vZGVsKSB7XG4gICAgICAgICAgICBheGlzID0gdGhpcy5nZXRBeGlzKCd4JywgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneScsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvd2VzdCBwcmlvcml0eS5cbiAgICAgICAgZWxzZSBpZiAoZ3JpZE1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgaWYgKGdyaWQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW4gPSB0aGlzLl9jb29yZHNMaXN0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtjYXJ0ZXNpYW46IGNhcnRlc2lhbiwgYXhpczogYXhpc307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzXG4gICAgICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgY29vcmQgPSB0aGlzLl9jb29yZHNMaXN0WzBdO1xuICAgICAgICBpZiAoY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZC5jb250YWluUG9pbnQocG9pbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgY2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ3JpZFByb3RvLl9pbml0Q2FydGVzaWFuID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBheGlzUG9zaXRpb25Vc2VkID0ge1xuICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgICAgYm90dG9tOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBheGVzTWFwID0ge1xuICAgICAgICAgICAgeDoge30sXG4gICAgICAgICAgICB5OiB7fVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXhlc0NvdW50ID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvLy8gQ3JlYXRlIGF4aXNcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd4QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd4JyksIHRoaXMpO1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3lBeGlzJywgY3JlYXRlQXhpc0NyZWF0b3IoJ3knKSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFheGVzQ291bnQueCB8fCAhYXhlc0NvdW50LnkpIHtcbiAgICAgICAgICAgIC8vIFJvbGwgYmFjayB3aGVuIHRoZXJlIG5vIGVpdGhlciB4IG9yIHkgYXhpc1xuICAgICAgICAgICAgdGhpcy5fYXhlc01hcCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2F4ZXNNYXAgPSBheGVzTWFwO1xuXG4gICAgICAgIC8vLyBDcmVhdGUgY2FydGVzaWFuMmRcbiAgICAgICAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcywgeEF4aXNJbmRleCkge1xuICAgICAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcywgeUF4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAneCcgKyB4QXhpc0luZGV4ICsgJ3knICsgeUF4aXNJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgY2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjJEKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW4uZ3JpZCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLm1vZGVsID0gZ3JpZE1vZGVsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY29vcmRzTWFwW2tleV0gPSBjYXJ0ZXNpYW47XG4gICAgICAgICAgICAgICAgdGhpcy5fY29vcmRzTGlzdC5wdXNoKGNhcnRlc2lhbik7XG5cbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW4uYWRkQXhpcyh4QXhpcyk7XG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLmFkZEF4aXMoeUF4aXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUF4aXNDcmVhdG9yKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGF4aXNNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQb3NpdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNUeXBlID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb24gIT09ICd0b3AnICYmIGF4aXNQb3NpdGlvbiAhPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYm90dG9tIG9mIFhcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9IGF4aXNQb3NpdGlvbiA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXNQb3NpdGlvbiAhPT0gJ2xlZnQnICYmIGF4aXNQb3NpdGlvbiAhPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBsZWZ0IG9mIFlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSBheGlzUG9zaXRpb24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uVXNlZFtheGlzUG9zaXRpb25dID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBheGlzID0gbmV3IEF4aXMyRChcbiAgICAgICAgICAgICAgICAgICAgYXhpc1R5cGUsIGF4aXNIZWxwZXIuY3JlYXRlU2NhbGVCeU1vZGVsKGF4aXNNb2RlbCksXG4gICAgICAgICAgICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLmdldCgndHlwZScpLFxuICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb25cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzQ2F0ZWdvcnkgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICAgICAgYXhpcy5vbkJhbmQgPSBpc0NhdGVnb3J5ICYmIGF4aXNNb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgICAgICAgICAgICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuXG4gICAgICAgICAgICAgICAgYXhpcy5vblplcm8gPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5vblplcm8nKTtcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBheGlzIGludG8gYXhpc01vZGVsXG4gICAgICAgICAgICAgICAgYXhpc01vZGVsLmF4aXMgPSBheGlzO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5qZWN0IGF4aXNNb2RlbCBpbnRvIGF4aXNcbiAgICAgICAgICAgICAgICBheGlzLm1vZGVsID0gYXhpc01vZGVsO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5qZWN0IGdyaWQgaW5mbyBheGlzXG4gICAgICAgICAgICAgICAgYXhpcy5ncmlkID0gdGhpcztcblxuICAgICAgICAgICAgICAgIC8vIEluZGV4IG9mIGF4aXMsIGNhbiBiZSB1c2VkIGFzIGtleVxuICAgICAgICAgICAgICAgIGF4aXMuaW5kZXggPSBpZHg7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9heGVzTGlzdC5wdXNoKGF4aXMpO1xuXG4gICAgICAgICAgICAgICAgYXhlc01hcFtheGlzVHlwZV1baWR4XSA9IGF4aXM7XG4gICAgICAgICAgICAgICAgYXhlc0NvdW50W2F4aXNUeXBlXSsrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2FydGVzaWFuIHByb3BlcnRpZXMgZnJvbSBzZXJpZXNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb259IG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ3JpZFByb3RvLl91cGRhdGVTY2FsZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBncmlkTW9kZWwpIHtcbiAgICAgICAgLy8gUmVzZXQgc2NhbGVcbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5fYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICBheGlzLnNjYWxlLnNldEV4dGVudChJbmZpbml0eSwgLUluZmluaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0NhcnRlc2lhbjJEKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHZhciBheGVzTW9kZWxzID0gZmluZEF4ZXNNb2RlbHMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpO1xuICAgICAgICAgICAgICAgIHZhciB4QXhpc01vZGVsID0gYXhlc01vZGVsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzQXhpc1VzZWRJblRoZUdyaWQoeEF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaXNBeGlzVXNlZEluVGhlR3JpZCh5QXhpc01vZGVsLCBncmlkTW9kZWwsIGVjTW9kZWwpXG4gICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNhcnRlc2lhbiA9IHRoaXMuZ2V0Q2FydGVzaWFuKFxuICAgICAgICAgICAgICAgICAgICB4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKCd5Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pb25FeHRlbnQoZGF0YSwgeEF4aXMsIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pb25FeHRlbnQoZGF0YSwgeUF4aXMsIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVuaW9uRXh0ZW50KGRhdGEsIGF4aXMsIHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBlYWNoKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGF4aXMuZGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgIGF4aXMuc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YShkYXRhLCBkaW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkaW1dICd4JyBvciAneScgb3IgJ2F1dG8nIG9yIG51bGwvdW5kZWZpbmVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7YmFzZUF4ZXM6IFtdLCBvdGhlckF4ZXM6IFtdfVxuICAgICAqL1xuICAgIGdyaWRQcm90by5nZXRUb29sdGlwQXhlcyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgdmFyIGJhc2VBeGVzID0gW107XG4gICAgICAgIHZhciBvdGhlckF4ZXMgPSBbXTtcblxuICAgICAgICBlYWNoKHRoaXMuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSAoZGltICE9IG51bGwgJiYgZGltICE9PSAnYXV0bycpXG4gICAgICAgICAgICAgICAgPyBjYXJ0ZXNpYW4uZ2V0QXhpcyhkaW0pIDogY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgb3RoZXJBeGlzID0gY2FydGVzaWFuLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgICAgICB6clV0aWwuaW5kZXhPZihiYXNlQXhlcywgYmFzZUF4aXMpIDwgMCAmJiBiYXNlQXhlcy5wdXNoKGJhc2VBeGlzKTtcbiAgICAgICAgICAgIHpyVXRpbC5pbmRleE9mKG90aGVyQXhlcywgb3RoZXJBeGlzKSA8IDAgJiYgb3RoZXJBeGVzLnB1c2gob3RoZXJBeGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtiYXNlQXhlczogYmFzZUF4ZXMsIG90aGVyQXhlczogb3RoZXJBeGVzfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBjb29yZEJhc2UpIHtcbiAgICAgICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgYXhpc0V4dGVudFN1bSA9IGF4aXNFeHRlbnRbMF0gKyBheGlzRXh0ZW50WzFdO1xuXG4gICAgICAgIC8vIEZhc3QgdHJhbnNmb3JtXG4gICAgICAgIGF4aXMudG9HbG9iYWxDb29yZCA9IGF4aXMuZGltID09PSAneCdcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkICsgY29vcmRCYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXhpc0V4dGVudFN1bSAtIGNvb3JkICsgY29vcmRCYXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgYXhpcy50b0xvY2FsQ29vcmQgPSBheGlzLmRpbSA9PT0gJ3gnXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZCAtIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNFeHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGF4ZXNUeXBlcyA9IFsneEF4aXMnLCAneUF4aXMnXTtcbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcChheGVzVHlwZXMsIGZ1bmN0aW9uIChheGlzVHlwZSkge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoYXhpc1R5cGUpWzBdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihheGlzVHlwZSArICcgXCInICsgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0luZGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoYXhpc1R5cGUgKyAnSWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgKSArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXhpc01vZGVsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0NhcnRlc2lhbjJEKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ2NhcnRlc2lhbjJkJztcbiAgICB9XG5cbiAgICBHcmlkLmNyZWF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIGdyaWRzID0gW107XG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZ3JpZCcsIGZ1bmN0aW9uIChncmlkTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBuZXcgR3JpZChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICBncmlkLm5hbWUgPSAnZ3JpZF8nICsgaWR4O1xuICAgICAgICAgICAgLy8gZGF0YVNhbXBsaW5nIHJlcXVpcmVzIGF4aXMgZXh0ZW50LCBzbyByZXNpemVcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBwZXJmb3JtZWQgaW4gY3JlYXRlIHN0YWdlLlxuICAgICAgICAgICAgZ3JpZC5yZXNpemUoZ3JpZE1vZGVsLCBhcGksIHRydWUpO1xuXG4gICAgICAgICAgICBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGdyaWQ7XG5cbiAgICAgICAgICAgIGdyaWRzLnB1c2goZ3JpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluamVjdCB0aGUgY29vcmRpbmF0ZVN5c3RlbXMgaW50byBzZXJpZXNNb2RlbFxuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ2FydGVzaWFuMkQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgICAgICAgIHZhciB4QXhpc01vZGVsID0gYXhlc01vZGVsc1swXTtcbiAgICAgICAgICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcblxuICAgICAgICAgICAgdmFyIGdyaWRNb2RlbCA9IHhBeGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghZ3JpZE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdHcmlkIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpc01vZGVsLmdldCgnZ3JpZEluZGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5nZXQoJ2dyaWRJZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeEF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCkgIT09IHlBeGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneEF4aXMgYW5kIHlBeGlzIG11c3QgdXNlIHRoZSBzYW1lIGdyaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncmlkID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgICAgICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBncmlkLmdldENhcnRlc2lhbihcbiAgICAgICAgICAgICAgICB4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ3JpZHM7XG4gICAgfTtcblxuICAgIC8vIEZvciBkZWNpZGluZyB3aGljaCBkaW1lbnNpb25zIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGxpc3QgZGF0YVxuICAgIEdyaWQuZGltZW5zaW9ucyA9IEdyaWQucHJvdG90eXBlLmRpbWVuc2lvbnMgPSBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuZGltZW5zaW9ucztcblxuICAgIHJlcXVpcmUoJy4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW0nKS5yZWdpc3RlcignY2FydGVzaWFuMmQnLCBHcmlkKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JpZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vR3JpZC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = __webpack_require__(9);\n    var DataDiffer = __webpack_require__(34);\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2RhdGEvTGlzdC5qcz85ODQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscURBQXFEO0FBQ3JELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjYxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaXN0IGZvciBkYXRhIHN0b3JhZ2VcbiAqIEBtb2R1bGUgZWNoYXJ0cy9kYXRhL0xpc3RcbiAqL1xuXG5cbiAgICB2YXIgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGdsb2JhbE9iaiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93O1xuICAgIHZhciBGbG9hdDY0QXJyYXkgPSB0eXBlb2YgZ2xvYmFsT2JqLkZsb2F0NjRBcnJheSA9PT0gVU5ERUZJTkVEXG4gICAgICAgID8gQXJyYXkgOiBnbG9iYWxPYmouRmxvYXQ2NEFycmF5O1xuICAgIHZhciBJbnQzMkFycmF5ID0gdHlwZW9mIGdsb2JhbE9iai5JbnQzMkFycmF5ID09PSBVTkRFRklORURcbiAgICAgICAgPyBBcnJheSA6IGdsb2JhbE9iai5JbnQzMkFycmF5O1xuXG4gICAgdmFyIGRhdGFDdG9ycyA9IHtcbiAgICAgICAgJ2Zsb2F0JzogRmxvYXQ2NEFycmF5LFxuICAgICAgICAnaW50JzogSW50MzJBcnJheSxcbiAgICAgICAgLy8gT3JkaW5hbCBkYXRhIHR5cGUgY2FuIGJlIHN0cmluZyBvciBpbnRcbiAgICAgICAgJ29yZGluYWwnOiBBcnJheSxcbiAgICAgICAgJ251bWJlcic6IEFycmF5LFxuICAgICAgICAndGltZSc6IEFycmF5XG4gICAgfTtcblxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIERhdGFEaWZmZXIgPSByZXF1aXJlKCcuL0RhdGFEaWZmZXInKTtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcblxuICAgIHZhciBUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ3N0YWNrZWRPbicsICdoYXNJdGVtT3B0aW9uJywgJ19uYW1lTGlzdCcsICdfaWRMaXN0JywgJ19yYXdEYXRhJ1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiB0cmFuc2ZlclByb3BlcnRpZXMoYSwgYikge1xuICAgICAgICB6clV0aWwuZWFjaChUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUy5jb25jYXQoYi5fX3dyYXBwZWRNZXRob2RzIHx8IFtdKSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhW3Byb3BOYW1lXSA9IGJbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhLl9fd3JhcHBlZE1ldGhvZHMgPSBiLl9fd3JhcHBlZE1ldGhvZHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGVmYXVsdERhdGFQcm92aWRlcihkYXRhQXJyYXkpIHtcbiAgICAgICAgdGhpcy5fYXJyYXkgPSBkYXRhQXJyYXkgfHwgW107XG4gICAgfVxuXG4gICAgRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUucHVyZSA9IGZhbHNlO1xuXG4gICAgRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgfTtcbiAgICBEZWZhdWx0RGF0YVByb3ZpZGVyLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbaWR4XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2RhdGEvTGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nfE9iamVjdD59IGRpbWVuc2lvbnNcbiAgICAgKiAgICAgIEZvciBleGFtcGxlLCBbJ3NvbWVEaW1OYW1lJywge25hbWU6ICdzb21lRGltTmFtZScsIHR5cGU6ICdzb21lRGltVHlwZSd9LCAuLi5dLlxuICAgICAqICAgICAgRGltZW5zaW9ucyBzaG91bGQgYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGhvc3RNb2RlbFxuICAgICAqL1xuICAgIHZhciBMaXN0ID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGhvc3RNb2RlbCkge1xuXG4gICAgICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IFsneCcsICd5J107XG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9zID0ge307XG4gICAgICAgIHZhciBkaW1lbnNpb25OYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25OYW1lO1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbkluZm8gPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGltZW5zaW9uc1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25OYW1lID0gZGltZW5zaW9uc1tpXTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkaW1lbnNpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb29yZERpbTogZGltZW5zaW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmREaW1JbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2thYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBjYW4gYmUgJ2Zsb2F0JywgJ2ludCcsICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgaXMgbnVtYmVyLCBQcmVjaXNpb24gb2YgZmxvYXQgbWF5IG5vdCBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mbyA9IGRpbWVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uTmFtZSA9IGRpbWVuc2lvbkluZm8ubmFtZTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvLnR5cGUgPSBkaW1lbnNpb25JbmZvLnR5cGUgfHwgJ251bWJlcic7XG4gICAgICAgICAgICAgICAgaWYgKCFkaW1lbnNpb25JbmZvLmNvb3JkRGltKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm8uY29vcmREaW0gPSBkaW1lbnNpb25OYW1lO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvLmNvb3JkRGltSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpbWVuc2lvbkluZm8ub3RoZXJEaW1zID0gZGltZW5zaW9uSW5mby5vdGhlckRpbXMgfHwge307XG4gICAgICAgICAgICBkaW1lbnNpb25OYW1lcy5wdXNoKGRpbWVuc2lvbk5hbWUpO1xuICAgICAgICAgICAgZGltZW5zaW9uSW5mb3NbZGltZW5zaW9uTmFtZV0gPSBkaW1lbnNpb25JbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25OYW1lcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5mb21hdGlvbiBvZiBlYWNoIGRhdGEgZGltZW5zaW9uLCBsaWtlIGRhdGEgdHlwZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RpbWVuc2lvbkluZm9zID0gZGltZW5zaW9uSW5mb3M7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG9zdE1vZGVsID0gaG9zdE1vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2VzIHN0b3JlcyB0aGUgaW5kaWNlcyBvZiBkYXRhIHN1YnNldCBhZnRlciBmaWx0ZXJlZC5cbiAgICAgICAgICogVGhpcyBkYXRhIHN1YnNldCB3aWxsIGJlIHVzZWQgaW4gY2hhcnQuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSBzdG9yYWdlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPGtleSwgVHlwZWRBcnJheXxBcnJheT59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdG9yYWdlID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25hbWVMaXN0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pZExpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxzIG9mIGRhdGEgb3B0aW9uIGlzIHN0b3JlZCBzcGFyc2UgZm9yIG9wdGltaXppbmcgbWVtb3J5IGNvc3RcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcHRpb25Nb2RlbHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrZWRPbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdsb2JhbCB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92aXN1YWwgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2xvYmVsIGxheW91dCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGF5b3V0ID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZW0gdmlzdWFsIHByb3BlcnRpZXMgYWZ0ZXIgdmlzdWFsIGNvZGluZ1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVtIGxheW91dCBwcm9wZXJ0aWVzIGFmdGVyIGxheW91dFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtTGF5b3V0cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaGljIGVsZW1uZW50c1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ3JhcGhpY0VscyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5fE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yYXdEYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50O1xuICAgIH07XG5cbiAgICB2YXIgbGlzdFByb3RvID0gTGlzdC5wcm90b3R5cGU7XG5cbiAgICBsaXN0UHJvdG8udHlwZSA9ICdsaXN0JztcblxuICAgIC8qKlxuICAgICAqIElmIGVhY2ggZGF0YSBpdGVtIGhhcyBpdCdzIG93biBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaGFzSXRlbU9wdGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGltZW5zaW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRpbVxuICAgICAqICAgICAgICBEaW1lbnNpb24gY2FuIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcbiAgICAgKiAgICAgICAgT3IgYSBvcmRpbmFsIG51bWJlci4gRm9yIGV4YW1wbGUgZ2V0RGltZW5zaW9uSW5mbygwKSB3aWxsIHJldHVybiAneCcgb3IgJ2xuZycgb3IgJ3JhZGl1cydcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNyZXRlIGRpbSBuYW1lLlxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGlmICghaXNOYU4oZGltKSkge1xuICAgICAgICAgICAgZGltID0gdGhpcy5kaW1lbnNpb25zW2RpbV0gfHwgZGltO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0eXBlIGFuZCBzdGFja2FibGUgaW5mbyBvZiBwYXJ0aWN1bGFyIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGltXG4gICAgICogICAgICAgIERpbWVuc2lvbiBjYW4gYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICAgICAqICAgICAgICBPciBhIG9yZGluYWwgbnVtYmVyLiBGb3IgZXhhbXBsZSBnZXREaW1lbnNpb25JbmZvKDApIHdpbGwgcmV0dXJuICd4JyBvciAnbG5nJyBvciAncmFkaXVzJ1xuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXREaW1lbnNpb25JbmZvID0gZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICByZXR1cm4genJVdGlsLmNsb25lKHRoaXMuX2RpbWVuc2lvbkluZm9zW3RoaXMuZ2V0RGltZW5zaW9uKGRpbSldKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBmcm9tIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8bnVtYmVyfEFycmF5Pn0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtuYW1lTGlzdF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZGltVmFsdWVHZXR0ZXJdIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkgPT4gbnVtYmVyXG4gICAgICovXG4gICAgbGlzdFByb3RvLmluaXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIG5hbWVMaXN0LCBkaW1WYWx1ZUdldHRlcikge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcblxuICAgICAgICB2YXIgaXNEYXRhQXJyYXkgPSB6clV0aWwuaXNBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKGlzRGF0YUFycmF5KSB7XG4gICAgICAgICAgICBkYXRhID0gbmV3IERlZmF1bHREYXRhUHJvdmlkZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmICghaXNEYXRhQXJyYXkgJiYgKHR5cGVvZiBkYXRhLmdldEl0ZW0gIT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGF0YS5jb3VudCAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5hdmxpZCBkYXRhIHByb3ZpZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmF3RGF0YSA9IGRhdGE7XG5cbiAgICAgICAgLy8gQ2xlYXJcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlID0ge307XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzID0gW107XG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICAgIHZhciBkaW1lbnNpb25JbmZvTWFwID0gdGhpcy5fZGltZW5zaW9uSW5mb3M7XG5cbiAgICAgICAgdmFyIHNpemUgPSBkYXRhLmNvdW50KCk7XG5cbiAgICAgICAgdmFyIGlkTGlzdCA9IFtdO1xuICAgICAgICB2YXIgbmFtZVJlcGVhdENvdW50ID0ge307XG4gICAgICAgIHZhciBuYW1lRGltSWR4O1xuXG4gICAgICAgIG5hbWVMaXN0ID0gbmFtZUxpc3QgfHwgW107XG5cbiAgICAgICAgLy8gSW5pdCBzdG9yYWdlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpbUluZm8gPSBkaW1lbnNpb25JbmZvTWFwW2RpbWVuc2lvbnNbaV1dO1xuICAgICAgICAgICAgZGltSW5mby5vdGhlckRpbXMuaXRlbU5hbWUgPT09IDAgJiYgKG5hbWVEaW1JZHggPSBpKTtcbiAgICAgICAgICAgIHZhciBEYXRhQ3RvciA9IGRhdGFDdG9yc1tkaW1JbmZvLnR5cGVdO1xuICAgICAgICAgICAgc3RvcmFnZVtkaW1lbnNpb25zW2ldXSA9IG5ldyBEYXRhQ3RvcihzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFkaW1WYWx1ZUdldHRlcikge1xuICAgICAgICAgICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBkaW0gdmFsdWUgZ2V0dGVyXG4gICAgICAgIGRpbVZhbHVlR2V0dGVyID0gZGltVmFsdWVHZXR0ZXIgfHwgZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhSXRlbSk7XG4gICAgICAgICAgICAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG4gICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlbFV0aWwuY29udmVyRGF0YVZhbHVlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlW2RpbUluZGV4XVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIHNpbmdsZSBudW1iZXIgb3Igc29tZXRoaW5nIGVsc2Ugbm90IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm9NYXBbZGltTmFtZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIC8vIE5PVElDRTogVHJ5IG5vdCB0byB3cml0ZSB0aGluZ3MgaW50byBkYXRhSXRlbVxuICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gZGF0YS5nZXRJdGVtKGkpO1xuICAgICAgICAgICAgLy8gRWFjaCBkYXRhIGl0ZW0gaXMgdmFsdWVcbiAgICAgICAgICAgIC8vIFsxLCAyXVxuICAgICAgICAgICAgLy8gMlxuICAgICAgICAgICAgLy8gQmFyIGNoYXJ0LCBsaW5lIGNoYXJ0IHdoaWNoIHVzZXMgY2F0ZWdvcnkgYXhpc1xuICAgICAgICAgICAgLy8gb25seSBnaXZlcyB0aGUgJ3knIHZhbHVlLiAneCcgdmFsdWUgaXMgdGhlIGluZGljZXMgb2YgY2F0ZW9ncnlcbiAgICAgICAgICAgIC8vIFVzZSBhIHRlbXBWYWx1ZSB0byBub3JtYWxpemUgdGhlIHZhbHVlIHRvIGJlIGEgKHgsIHkpIHZhbHVlXG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBkYXRhIGJ5IGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltZW5zaW9ucy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBkaW1lbnNpb25zW2tdO1xuICAgICAgICAgICAgICAgIHZhciBkaW1TdG9yYWdlID0gc3RvcmFnZVtkaW1dO1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgTlVMTCBpcyBlbXB0eSBvciB6ZXJvXG4gICAgICAgICAgICAgICAgZGltU3RvcmFnZVtpXSA9IGRpbVZhbHVlR2V0dGVyKGRhdGFJdGVtLCBkaW0sIGksIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgdGhlIG5hbWUgaW4gb3B0aW9uIGFuZCBjcmVhdGUgaWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0SXRlbShpKTtcbiAgICAgICAgICAgIGlmICghbmFtZUxpc3RbaV0gJiYgZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0ubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0W2ldID0gZGF0YUl0ZW0ubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZURpbUlkeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0W2ldID0gc3RvcmFnZVtkaW1lbnNpb25zW25hbWVEaW1JZHhdXVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVMaXN0W2ldIHx8ICcnO1xuICAgICAgICAgICAgLy8gVHJ5IHVzaW5nIHRoZSBpZCBpbiBvcHRpb25cbiAgICAgICAgICAgIHZhciBpZCA9IGRhdGFJdGVtICYmIGRhdGFJdGVtLmlkO1xuXG4gICAgICAgICAgICBpZiAoIWlkICYmIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgbmFtZSBhcyBpZCBhbmQgYWRkIGNvdW50ZXIgdG8gYXZvaWQgc2FtZSBuYW1lXG4gICAgICAgICAgICAgICAgbmFtZVJlcGVhdENvdW50W25hbWVdID0gbmFtZVJlcGVhdENvdW50W25hbWVdIHx8IDA7XG4gICAgICAgICAgICAgICAgaWQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lUmVwZWF0Q291bnRbbmFtZV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkICs9ICdfX2VjX18nICsgbmFtZVJlcGVhdENvdW50W25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lUmVwZWF0Q291bnRbbmFtZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkICYmIChpZExpc3RbaV0gPSBpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9uYW1lTGlzdCA9IG5hbWVMaXN0O1xuICAgICAgICB0aGlzLl9pZExpc3QgPSBpZExpc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGljZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUuIFJldHVybiBOYU4gaWYgaWR4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltIERpbSBtdXN0IGJlIGNvbmNyZXRlIG5hbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldCA9IGZ1bmN0aW9uIChkaW0sIGlkeCwgc3RhY2spIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gdGhpcy5pbmRpY2VzW2lkeF07XG5cbiAgICAgICAgLy8gSWYgdmFsdWUgbm90IGV4aXN0c1xuICAgICAgICBpZiAoZGF0YUluZGV4ID09IG51bGwgfHwgIXN0b3JhZ2VbZGltXSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0b3JhZ2VbZGltXVtkYXRhSW5kZXhdO1xuICAgICAgICAvLyBGSVhNRSBvcmRpbmFsIGRhdGEgdHlwZSBpcyBub3Qgc3RhY2thYmxlXG4gICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbkluZm8gPSB0aGlzLl9kaW1lbnNpb25JbmZvc1tkaW1dO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbkluZm8gJiYgZGltZW5zaW9uSW5mby5zdGFja2FibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uID0gdGhpcy5zdGFja2VkT247XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrZWRPbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbm8gc3RhY2tlZCBkYXRhIG9mIHN0YWNrZWQgb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRWYWx1ZSA9IHN0YWNrZWRPbi5nZXQoZGltLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyBwb3NpdGl2ZSBzdGFjaywgbmVnYXRpdmUgc3RhY2sgYW5kIGVtcHR5IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA+PSAwICYmIHN0YWNrZWRWYWx1ZSA+IDApICAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHZhbHVlIDw9IDAgJiYgc3RhY2tlZFZhbHVlIDwgMCkgLy8gTmVnYXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzdGFja2VkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uID0gc3RhY2tlZE9uLnN0YWNrZWRPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUgZm9yIG11bHRpIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdIElmIGlnbm9yZWQsIHVzaW5nIGFsbCBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaWR4LCBzdGFjaykge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgc3RhY2sgPSBpZHg7XG4gICAgICAgICAgICBpZHggPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgsIHN0YWNrKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZSBpcyBOYU4uIElubGN1ZGluZyAnLSdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaGFzVmFsdWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgICAgICB2YXIgZGltZW5zaW9uSW5mb3MgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpbWVuc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBPcmRpbmFsIHR5cGUgY2FuIGJlIHN0cmluZyBvciBudW1iZXJcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25zW2ldXS50eXBlICE9PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICAgICAmJiBpc05hTih0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXh0ZW50IG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldERhdGFFeHRlbnQgPSBmdW5jdGlvbiAoZGltLCBzdGFjaywgZmlsdGVyKSB7XG4gICAgICAgIGRpbSA9IHRoaXMuZ2V0RGltZW5zaW9uKGRpbSk7XG4gICAgICAgIHZhciBkaW1EYXRhID0gdGhpcy5fc3RvcmFnZVtkaW1dO1xuICAgICAgICB2YXIgZGltSW5mbyA9IHRoaXMuZ2V0RGltZW5zaW9uSW5mbyhkaW0pO1xuICAgICAgICBzdGFjayA9IChkaW1JbmZvICYmIGRpbUluZm8uc3RhY2thYmxlKSAmJiBzdGFjaztcbiAgICAgICAgdmFyIGRpbUV4dGVudCA9ICh0aGlzLl9leHRlbnQgfHwgKHRoaXMuX2V4dGVudCA9IHt9KSlbZGltICsgKCEhc3RhY2spXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoZGltRXh0ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGltRXh0ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciBkaW1JbmZvID0gdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltXTtcbiAgICAgICAgaWYgKGRpbURhdGEpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAvLyB2YXIgaXNPcmRpbmFsID0gZGltSW5mby50eXBlID09PSAnb3JkaW5hbCc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gaWYgKGlzT3JkaW5hbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHZhbHVlID0genJVdGlsLmluZGV4T2YoZGltRGF0YSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIodmFsdWUsIGRpbSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPCBtaW4gJiYgKG1pbiA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPiBtYXggJiYgKG1heCA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2V4dGVudFtkaW0gKyAhIXN0YWNrXSA9IFttaW4sIG1heF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3VtIG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldFN1bSA9IGZ1bmN0aW9uIChkaW0sIHN0YWNrKSB7XG4gICAgICAgIHZhciBkaW1EYXRhID0gdGhpcy5fc3RvcmFnZVtkaW1dO1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgaWYgKGRpbURhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIC8vIEZJWE1FIFByZWNpc2lvbiBvZiBmbG9hdCB2YWx1ZVxuICAgIGxpc3RQcm90by5pbmRleE9mID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgZGltRGF0YSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgaWYgKGRpbURhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhd0luZGV4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGltRGF0YVtyYXdJbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIG5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmluZGV4T2ZOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIHZhciBuYW1lTGlzdCA9IHRoaXMuX25hbWVMaXN0O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmF3SW5kZXggPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgaWYgKG5hbWVMaXN0W3Jhd0luZGV4XSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiByYXcgZGF0YSBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmFtZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaW5kZXhPZlJhd0luZGV4ID0gZnVuY3Rpb24gKHJhd0luZGV4KSB7XG4gICAgICAgIC8vIEluZGljZXMgYXJlIGFzY2VuZGluZ1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcblxuICAgICAgICAvLyBJZiByYXdJbmRleCA9PT0gZGF0YUluZGV4XG4gICAgICAgIHZhciByYXdEYXRhSW5kZXggPSBpbmRpY2VzW3Jhd0luZGV4XTtcbiAgICAgICAgaWYgKHJhd0RhdGFJbmRleCAhPSBudWxsICYmIHJhd0RhdGFJbmRleCA9PT0gcmF3SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaW5kaWNlcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IChsZWZ0ICsgcmlnaHQpIC8gMiB8IDA7XG4gICAgICAgICAgICBpZiAoaW5kaWNlc1ttaWRdIDwgcmF3SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGljZXNbbWlkXSA+IHJhd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCBvZiBuZWFyZXN0IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2sgSWYgZ2l2ZW4gdmFsdWUgaXMgYWZ0ZXIgc3RhY2tlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RGlzdGFuY2U9SW5maW5pdHldXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IENvbnNpZGVyZSBtdWx0aXBsZSBwb2ludHMgaGFzIHRoZSBzYW1lIHZhbHVlLlxuICAgICAqL1xuICAgIGxpc3RQcm90by5pbmRpY2VzT2ZOZWFyZXN0ID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUsIHN0YWNrLCBtYXhEaXN0YW5jZSkge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gICAgICAgIHZhciBkaW1EYXRhID0gc3RvcmFnZVtkaW1dO1xuICAgICAgICB2YXIgbmVhcmVzdEluZGljZXMgPSBbXTtcblxuICAgICAgICBpZiAoIWRpbURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhEaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgbWluRGlmZiA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gdmFsdWUgLSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZGlmZik7XG4gICAgICAgICAgICBpZiAoZGlmZiA8PSBtYXhEaXN0YW5jZSAmJiBkaXN0IDw9IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgdHdvIGRhdGEgYXJlIHNhbWUgb24geEF4aXMsIHdoaWNoIGhhcyBzZXF1ZW5jZSBkYXRhLlxuICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIG5lYXJlc3QgaW5kZXhcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL2VjaGFydHMvaXNzdWVzLzI4NjlcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgKGRpZmYgPj0gMCAmJiBtaW5EaWZmIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpZmYgPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0SW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWFyZXN0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0UmF3SW5kZXggPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciByYXdJZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgICAgICAgcmV0dXJuIHJhd0lkeCA9PSBudWxsID8gLTEgOiByYXdJZHg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSBpdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYXdEYXRhLmdldEl0ZW0odGhpcy5nZXRSYXdJbmRleChpZHgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXROYW1lID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZUxpc3RbdGhpcy5pbmRpY2VzW2lkeF1dIHx8ICcnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbm90RGVmYXVsdElkeD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldElkID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWRMaXN0W3RoaXMuaW5kaWNlc1tpZHhdXSB8fCAodGhpcy5nZXRSYXdJbmRleChpZHgpICsgJycpO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGRpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gW2RpbWVuc2lvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERhdGEgaXRlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBsaXN0LmVhY2goJ3gnLCBmdW5jdGlvbiAoeCwgaWR4KSB7fSk7XG4gICAgICogIGxpc3QuZWFjaChbJ3gnLCAneSddLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7fSk7XG4gICAgICogIGxpc3QuZWFjaChmdW5jdGlvbiAoaWR4KSB7fSlcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZWFjaCA9IGZ1bmN0aW9uIChkaW1zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgICAgICAgICBzdGFjayA9IGNiO1xuICAgICAgICAgICAgY2IgPSBkaW1zO1xuICAgICAgICAgICAgZGltcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltcyA9IHpyVXRpbC5tYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXMpO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgICAgICB2YXIgZGltU2l6ZSA9IGRpbXMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgICAgICAgc3dpdGNoIChkaW1TaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5nZXQoZGltc1swXSwgaSwgc3RhY2spLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbXNbMF0sIGksIHN0YWNrKSwgdGhpcy5nZXQoZGltc1sxXSwgaSwgc3RhY2spLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1TaXplOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdGhpcy5nZXQoZGltc1trXSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgY2IuYXBwbHkoY29udGV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERhdGEgZmlsdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gICAgICovXG4gICAgbGlzdFByb3RvLmZpbHRlclNlbGYgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHN0YWNrO1xuICAgICAgICAgICAgc3RhY2sgPSBjYjtcbiAgICAgICAgICAgIGNiID0gZGltZW5zaW9ucztcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKFxuICAgICAgICAgICAgbm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXNcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbmV3SW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICAgdmFyIGRpbVNpemUgPSBkaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZWVwO1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgICAgICAgaWYgKCFkaW1TaXplKSB7XG4gICAgICAgICAgICAgICAga2VlcCA9IGNiLmNhbGwoY29udGV4dCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaW1TaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2VlcCA9IGNiLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHRoaXMuZ2V0KGRpbWVuc2lvbnNbMF0sIGksIHN0YWNrKSwgaVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbVNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbWVuc2lvbnNba10sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVba10gPSBpO1xuICAgICAgICAgICAgICAgIGtlZXAgPSBjYi5hcHBseShjb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2VlcCkge1xuICAgICAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRpY2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ld0luZGljZXM7XG5cbiAgICAgICAgLy8gUmVzZXQgZGF0YSBleHRlbnRcbiAgICAgICAgdGhpcy5fZXh0ZW50ID0ge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERhdGEgbWFwcGluZyB0byBhIHBsYWluIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5tYXBBcnJheSA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgICAgICAgICBzdGFjayA9IGNiO1xuICAgICAgICAgICAgY2IgPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2IgJiYgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH0sIHN0YWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKG9yaWdpbmFsLCBleGNsdWRlRGltZW5zaW9ucykge1xuICAgICAgICB2YXIgYWxsRGltZW5zaW9ucyA9IG9yaWdpbmFsLmRpbWVuc2lvbnM7XG4gICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoXG4gICAgICAgICAgICB6clV0aWwubWFwKGFsbERpbWVuc2lvbnMsIG9yaWdpbmFsLmdldERpbWVuc2lvbkluZm8sIG9yaWdpbmFsKSxcbiAgICAgICAgICAgIG9yaWdpbmFsLmhvc3RNb2RlbFxuICAgICAgICApO1xuICAgICAgICAvLyBGSVhNRSBJZiBuZWVkcyBzdGFja2VkT24sIHZhbHVlIG1heSBhbHJlYWR5IGJlZW4gc3RhY2tlZFxuICAgICAgICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgb3JpZ2luYWwpO1xuXG4gICAgICAgIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZSA9IHt9O1xuICAgICAgICB2YXIgb3JpZ2luYWxTdG9yYWdlID0gb3JpZ2luYWwuX3N0b3JhZ2U7XG4gICAgICAgIC8vIEluaXQgc3RvcmFnZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbERpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW0gPSBhbGxEaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGRpbVN0b3JlID0gb3JpZ2luYWxTdG9yYWdlW2RpbV07XG4gICAgICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YoZXhjbHVkZURpbWVuc2lvbnMsIGRpbSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VbZGltXSA9IG5ldyBkaW1TdG9yZS5jb25zdHJ1Y3RvcihcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdG9yYWdlW2RpbV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERpcmVjdCByZWZlcmVuY2UgZm9yIG90aGVyIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2RpbV0gPSBvcmlnaW5hbFN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIG1hcHBpbmcgdG8gYSBuZXcgTGlzdCB3aXRoIGdpdmVuIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5tYXAgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKFxuICAgICAgICAgICAgbm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXNcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBkaW1lbnNpb25zKTtcbiAgICAgICAgLy8gRm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGFsbCBpbW11dGFibGUuXG4gICAgICAgIC8vIFNvIHdlIGNhbiByZWZlcmVuY2UgdG8gdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuXG4gICAgICAgIHZhciB0bXBSZXRWYWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgcmV0VmFsdWUgPSBjYiAmJiBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHJldFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBhIG51bWJlclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0VmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJldFZhbHVlWzBdID0gcmV0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldFZhbHVlID0gdG1wUmV0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1TdG9yZSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0lkeCA9IGluZGljZXNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpbVN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1TdG9yZVtyYXdJZHhdID0gcmV0VmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YWNrLCBjb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIG9uIGdpdmVuIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZVZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2FtcGxlSW5kZXggU2FtcGxlIGluZGV4IGZvciBuYW1lIGFuZCBpZFxuICAgICAqL1xuICAgIGxpc3RQcm90by5kb3duU2FtcGxlID0gZnVuY3Rpb24gKGRpbWVuc2lvbiwgcmF0ZSwgc2FtcGxlVmFsdWUsIHNhbXBsZUluZGV4KSB7XG4gICAgICAgIHZhciBsaXN0ID0gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKHRoaXMsIFtkaW1lbnNpb25dKTtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgdGFyZ2V0U3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2U7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgICAgICAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgZnJhbWVWYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIGZyYW1lSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgZnJhbWVTaXplID0gTWF0aC5mbG9vcigxIC8gcmF0ZSk7XG5cbiAgICAgICAgdmFyIGRpbVN0b3JlID0gdGFyZ2V0U3RvcmFnZVtkaW1lbnNpb25dO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAvLyBDb3B5IGRhdGEgZnJvbSBvcmlnaW5hbCBkYXRhXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmFnZVtkaW1lbnNpb25dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl1baV0gPSBzdG9yYWdlW2RpbWVuc2lvbl1baV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gZnJhbWVTaXplKSB7XG4gICAgICAgICAgICAvLyBMYXN0IGZyYW1lXG4gICAgICAgICAgICBpZiAoZnJhbWVTaXplID4gbGVuIC0gaSkge1xuICAgICAgICAgICAgICAgIGZyYW1lU2l6ZSA9IGxlbiAtIGk7XG4gICAgICAgICAgICAgICAgZnJhbWVWYWx1ZXMubGVuZ3RoID0gZnJhbWVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmcmFtZVNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBvcmlnaW5hbEluZGljZXNbaSArIGtdO1xuICAgICAgICAgICAgICAgIGZyYW1lVmFsdWVzW2tdID0gZGltU3RvcmVbaWR4XTtcbiAgICAgICAgICAgICAgICBmcmFtZUluZGljZXNba10gPSBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzYW1wbGVWYWx1ZShmcmFtZVZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gZnJhbWVJbmRpY2VzW3NhbXBsZUluZGV4KGZyYW1lVmFsdWVzLCB2YWx1ZSkgfHwgMF07XG4gICAgICAgICAgICAvLyBPbmx5IHdyaXRlIHZhbHVlIG9uIHRoZSBmaWx0ZXJlZCBkYXRhXG4gICAgICAgICAgICBkaW1TdG9yZVtpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbW9kZWwgb2Ygb25lIGRhdGEgaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKi9cbiAgICAvLyBGSVhNRSBNb2RlbCBwcm94eSA/XG4gICAgbGlzdFByb3RvLmdldEl0ZW1Nb2RlbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuICAgICAgICBpZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgICAgICAgcmV0dXJuIG5ldyBNb2RlbCh0aGlzLl9yYXdEYXRhLmdldEl0ZW0oaWR4KSwgaG9zdE1vZGVsLCBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLmVjTW9kZWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkYXRhIGRpZmZlclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBvdGhlckxpc3RcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0RhdGFEaWZmZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmRpZmYgPSBmdW5jdGlvbiAob3RoZXJMaXN0KSB7XG4gICAgICAgIHZhciBpZExpc3QgPSB0aGlzLl9pZExpc3Q7XG4gICAgICAgIHZhciBvdGhlcklkTGlzdCA9IG90aGVyTGlzdCAmJiBvdGhlckxpc3QuX2lkTGlzdDtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgLy8gVXNlIHByZWZpeCB0byBhdm9pZCBpbmRleCB0byBiZSB0aGUgc2FtZSBhcyBvdGhlcklkTGlzdFtpZHhdLFxuICAgICAgICAvLyB3aGljaCB3aWxsIGNhdXNlIHdlaXJkIHVkcGF0ZSBhbmltYXRpb24uXG4gICAgICAgIHZhciBwcmVmaXggPSAnZVxcMFxcMCc7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhRGlmZmVyKFxuICAgICAgICAgICAgb3RoZXJMaXN0ID8gb3RoZXJMaXN0LmluZGljZXMgOiBbXSxcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlcyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbCA9IG90aGVySWRMaXN0W2lkeF0pICE9IG51bGwgPyB2YWwgOiBwcmVmaXggKyBpZHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsID0gaWRMaXN0W2lkeF0pICE9IG51bGwgPyB2YWwgOiBwcmVmaXggKyBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdmlzdWFsIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmlzdWFsID0gdGhpcy5fdmlzdWFsO1xuICAgICAgICByZXR1cm4gdmlzdWFsICYmIHZpc3VhbFtrZXldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdmlzdWFsIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIHNldFZpc3VhbCgnY29sb3InLCBjb2xvcik7XG4gICAgICogIHNldFZpc3VhbCh7XG4gICAgICogICAgICAnY29sb3InOiBjb2xvclxuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWaXN1YWwobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzdWFsID0gdGhpcy5fdmlzdWFsIHx8IHt9O1xuICAgICAgICB0aGlzLl92aXN1YWxba2V5XSA9IHZhbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGxheW91dCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSBbdmFsXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRMYXlvdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldExheW91dChuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXlvdXRba2V5XSA9IHZhbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGxheW91dCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleS5cbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRMYXlvdXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRba2V5XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbUxheW91dHNbaWR4XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbbWVyZ2U9ZmFsc2VdXG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldEl0ZW1MYXlvdXQgPSBmdW5jdGlvbiAoaWR4LCBsYXlvdXQsIG1lcmdlKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF0gPSBtZXJnZVxuICAgICAgICAgICAgPyB6clV0aWwuZXh0ZW5kKHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF0gfHwge30sIGxheW91dClcbiAgICAgICAgICAgIDogbGF5b3V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgbGF5b3V0IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uY2xlYXJJdGVtTGF5b3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXRlbUxheW91dHMubGVuZ3RoID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHZpc3VhbCBwcm9wZXJ0eSBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIGlnbm9yZVBhcmVudCkge1xuICAgICAgICB2YXIgaXRlbVZpc3VhbCA9IHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF07XG4gICAgICAgIHZhciB2YWwgPSBpdGVtVmlzdWFsICYmIGl0ZW1WaXN1YWxba2V5XTtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmICFpZ25vcmVQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIFVzZSBnbG9iYWwgdmlzdWFsIHByb3BlcnR5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWaXN1YWwoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdmlzdWFsIHByb3BlcnR5IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgc2V0SXRlbVZpc3VhbCgwLCAnY29sb3InLCBjb2xvcik7XG4gICAgICogIHNldEl0ZW1WaXN1YWwoMCwge1xuICAgICAqICAgICAgJ2NvbG9yJzogY29sb3JcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XSB8fCB7fTtcbiAgICAgICAgdGhpcy5faXRlbVZpc3VhbHNbaWR4XSA9IGl0ZW1WaXN1YWw7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtVmlzdWFsW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdGVtVmlzdWFsW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgaXRlbVZpc3VhbHMgYW5kIGxpc3QgdmlzdWFsLlxuICAgICAqL1xuICAgIGxpc3RQcm90by5jbGVhckFsbFZpc3VhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmlzdWFsID0ge307XG4gICAgICAgIHRoaXMuX2l0ZW1WaXN1YWxzID0gW107XG4gICAgfTtcblxuICAgIHZhciBzZXRJdGVtRGF0YUFuZFNlcmllc0luZGV4ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnNlcmllc0luZGV4ID0gdGhpcy5zZXJpZXNJbmRleDtcbiAgICAgICAgY2hpbGQuZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7XG4gICAgICAgIGNoaWxkLmRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBncmFwaGljIGVsZW1lbnQgcmVsYXRpdmUgdG8gZGF0YS4gSXQgY2FuIGJlIHNldCBhcyBudWxsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2VsXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGlkeCwgZWwpIHtcbiAgICAgICAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgLy8gQWRkIGRhdGEgaW5kZXggYW5kIHNlcmllcyBpbmRleCBmb3IgaW5kZXhpbmcgdGhlIGRhdGEgYnkgZWxlbWVudFxuICAgICAgICAgICAgLy8gVXNlZnVsIGluIHRvb2x0aXBcbiAgICAgICAgICAgIGVsLmRhdGFJbmRleCA9IGlkeDtcbiAgICAgICAgICAgIGVsLmRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZTtcbiAgICAgICAgICAgIGVsLnNlcmllc0luZGV4ID0gaG9zdE1vZGVsICYmIGhvc3RNb2RlbC5zZXJpZXNJbmRleDtcbiAgICAgICAgICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgZWwudHJhdmVyc2Uoc2V0SXRlbURhdGFBbmRTZXJpZXNJbmRleCwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdID0gZWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAqL1xuICAgIGxpc3RQcm90by5lYWNoSXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICB6clV0aWwuZWFjaCh0aGlzLl9ncmFwaGljRWxzLCBmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgY2IgJiYgY2IuY2FsbChjb250ZXh0LCBlbCwgaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNoYWxsb3cgY2xvbmUgYSBuZXcgbGlzdCBleGNlcHQgdmlzdWFsIGFuZCBsYXlvdXQgcHJvcGVydGllcywgYW5kIGdyYXBoIGVsZW1lbnRzLlxuICAgICAqIE5ldyBsaXN0IG9ubHkgY2hhbmdlIHRoZSBpbmRpY2VzLlxuICAgICAqL1xuICAgIGxpc3RQcm90by5jbG9uZVNoYWxsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25JbmZvTGlzdCA9IHpyVXRpbC5tYXAodGhpcy5kaW1lbnNpb25zLCB0aGlzLmdldERpbWVuc2lvbkluZm8sIHRoaXMpO1xuICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbkluZm9MaXN0LCB0aGlzLmhvc3RNb2RlbCk7XG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgbGlzdC5fc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG5cbiAgICAgICAgdHJhbnNmZXJQcm9wZXJ0aWVzKGxpc3QsIHRoaXMpO1xuXG5cbiAgICAgICAgLy8gQ2xvbmUgd2lsbCBub3QgY2hhbmdlIHRoZSBkYXRhIGV4dGVudCBhbmQgaW5kaWNlc1xuICAgICAgICBsaXN0LmluZGljZXMgPSB0aGlzLmluZGljZXMuc2xpY2UoKTtcblxuICAgICAgICBpZiAodGhpcy5fZXh0ZW50KSB7XG4gICAgICAgICAgICBsaXN0Ll9leHRlbnQgPSB6clV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9leHRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyYXAgc29tZSBtZXRob2QgdG8gYWRkIG1vcmUgZmVhdHVyZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0RnVuY3Rpb25cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8ud3JhcE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmplY3RGdW5jdGlvbikge1xuICAgICAgICB2YXIgb3JpZ2luYWxNZXRob2QgPSB0aGlzW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3dyYXBwZWRNZXRob2RzID0gdGhpcy5fX3dyYXBwZWRNZXRob2RzIHx8IFtdO1xuICAgICAgICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMucHVzaChtZXRob2ROYW1lKTtcbiAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGluamVjdEZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtyZXNdLmNvbmNhdCh6clV0aWwuc2xpY2UoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBNZXRob2RzIHRoYXQgY3JlYXRlIGEgbmV3IGxpc3QgYmFzZWQgb24gdGhpcyBsaXN0IHNob3VsZCBiZSBsaXN0ZWQgaGVyZS5cbiAgICAvLyBOb3RpY2UgdGhhdCB0aG9zZSBtZXRob2Qgc2hvdWxkIGBSRVRVUk5gIHRoZSBuZXcgbGlzdC5cbiAgICBsaXN0UHJvdG8uVFJBTlNGRVJBQkxFX01FVEhPRFMgPSBbJ2Nsb25lU2hhbGxvdycsICdkb3duU2FtcGxlJywgJ21hcCddO1xuICAgIC8vIE1ldGhvZHMgdGhhdCBjaGFuZ2UgaW5kaWNlcyBvZiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuICAgIGxpc3RQcm90by5DSEFOR0FCTEVfTUVUSE9EUyA9IFsnZmlsdGVyU2VsZiddO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2RhdGEvTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucy5qcz8yNWE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLHNCQUFzQjtBQUNyQyxtQ0FBbUMsV0FBVztBQUM5QyxlQUFlLE9BQU8sdUNBQXVDO0FBQzdELGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSx1QkFBdUIsY0FBYztBQUNyQyxxREFBcUQsaUJBQWlCLG9CQUFvQjtBQUMxRjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBEQUEwRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21wbGV0ZSBkaW1lbnNpb25zIGJ5IGRhdGEgKGd1ZXNzIGRpbWVuc2lvbikuXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgaXNTdHJpbmcgPSB6clV0aWwuaXNTdHJpbmc7XG4gICAgdmFyIGRlZmF1bHRzID0genJVdGlsLmRlZmF1bHRzO1xuICAgIHZhciBub3JtYWxpemVUb0FycmF5ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXk7XG5cbiAgICB2YXIgT1RIRVJfRElNUyA9IHt0b29sdGlwOiAxLCBsYWJlbDogMSwgaXRlbU5hbWU6IDF9O1xuXG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgdGhlIGRpbWVuc2lvbnMgYXJyYXksIGJ5IHVzZXIgZGVmaW5lZCBgZGltZW5zaW9uYCBhbmQgYGVuY29kZWAsXG4gICAgICogYW5kIGd1ZXNzaW5nIGZyb20gdGhlIGRhdGEgc3RydWN0dXJlLlxuICAgICAqIElmIG5vICd2YWx1ZScgZGltZW5zaW9uIHNwZWNpZmllZCwgdGhlIGZpcnN0IG5vLW5hbWVkIGRpbWVuc2lvbiB3aWxsIGJlXG4gICAgICogbmFtZWQgYXMgJ3ZhbHVlJy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN5c0RpbXMgTmVjZXNzYXJ5IGRpbWVuc2lvbnMsIGxpa2UgWyd4JywgJ3knXSwgd2hpY2hcbiAgICAgKiAgICAgIHByb3ZpZGVzIG5vdCBvbmx5IGRpbSB0ZW1wbGF0ZSwgYnV0IGFsc28gZGVmYXVsdCBvcmRlci5cbiAgICAgKiAgICAgIGBuYW1lYCBvZiBlYWNoIGl0ZW0gcHJvdmlkZXMgZGVmYXVsdCBjb29yZCBuYW1lLlxuICAgICAqICAgICAgW3tkaW1zRGVmOiBbXX0sIC4uLl0gY2FuIGJlIHNwZWNpZmllZCB0byBnaXZlIG5hbWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgRGF0YSBsaXN0LiBbWzEsIDIsIDNdLCBbMiwgMywgNF1dLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxzdHJpbmc+fSBbb3B0LmRpbXNEZWZdIG9wdGlvbi5zZXJpZXMuZGltZW5zaW9ucyBVc2VyIGRlZmluZWQgZGltZW5zaW9uc1xuICAgICAqICAgICAgRm9yIGV4YW1wbGU6IFsnYXNkZicsIHtuYW1lLCB0eXBlfSwgLi4uXS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5lbmNvZGVEZWZdIG9wdGlvbi5zZXJpZXMuZW5jb2RlIHt4OiAyLCB5OiBbMywgMV0sIHRvb2x0aXA6IFsxLCAyXSwgbGFiZWw6IDN9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuZXh0cmFQcmVmaXhdIFByZWZpeCBvZiBuYW1lIHdoZW4gZmlsbGluZyB0aGUgbGVmdCBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmV4dHJhRnJvbVplcm9dIElmIHNwZWNpZmllZCwgZXh0cmEgZGltIG5hbWVzIHdpbGwgYmU6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgZXh0cmFQcmVmaXggKyAwLCBleHRyYVByZWZpeCArIGV4dHJhQmFzZUluZGV4ICsgMSAuLi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBJZiBub3Qgc3BlY2lmaWVkLCBleHRyYSBkaW0gbmFtZXMgd2lsbCBiZTpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBleHRyYVByZWZpeCwgZXh0cmFQcmVmaXggKyAwLCBleHRyYVByZWZpeCArIDEgLi4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZGltQ291bnRdIElmIG5vdCBzcGVjaWZpZWQsIGd1ZXNzIGJ5IHRoZSBmaXJzdCBkYXRhIGl0ZW0uXG4gICAgICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFt7XG4gICAgICogICAgICBuYW1lOiBzdHJpbmcgbWFuZGF0b3J5LFxuICAgICAqICAgICAgY29vcmREaW06IHN0cmluZyBtYW5kYXRvcnksXG4gICAgICogICAgICBjb29yZERpbUluZGV4OiBudW1iZXIgbWFuZGF0b3J5LFxuICAgICAqICAgICAgdHlwZTogc3RyaW5nIG9wdGlvbmFsLFxuICAgICAqICAgICAgdG9vbHRpcE5hbWU6IHN0cmluZyBvcHRpb25hbCxcbiAgICAgKiAgICAgIG90aGVyRGltczoge1xuICAgICAqICAgICAgICAgIHRvb2x0aXA6IG51bWJlciBvcHRpb25hbCxcbiAgICAgKiAgICAgICAgICBsYWJlbDogbnVtYmVyIG9wdGlvbmFsXG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgaXNFeHRyYUNvb3JkOiBib29sZWFuIHRydWUgb3IgdW5kZWZpbmVkLlxuICAgICAqICAgICAgb3RoZXIgcHJvcHMgLi4uXG4gICAgICogfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wbGV0ZURpbWVuc2lvbnMoc3lzRGltcywgZGF0YSwgb3B0KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHN5c0RpbXMgPSAoc3lzRGltcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIGRpbXNEZWYgPSAob3B0LmRpbXNEZWYgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIHZhciBlbmNvZGVEZWYgPSB6clV0aWwuY3JlYXRlSGFzaE1hcChvcHQuZW5jb2RlRGVmKTtcbiAgICAgICAgdmFyIGRhdGFEaW1OYW1lTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICAgICAgdmFyIGNvb3JkRGltTmFtZU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgICAgIC8vIHZhciB2YWx1ZUNhbmRpZGF0ZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHZhciBkaW1Db3VudCA9IG9wdC5kaW1Db3VudDtcbiAgICAgICAgaWYgKGRpbUNvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTAgPSByZXRyaWV2ZVZhbHVlKGRhdGFbMF0pO1xuICAgICAgICAgICAgZGltQ291bnQgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICB6clV0aWwuaXNBcnJheSh2YWx1ZTApICYmIHZhbHVlMC5sZW5ndGggfHwgMSxcbiAgICAgICAgICAgICAgICBzeXNEaW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkaW1zRGVmLmxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVhY2goc3lzRGltcywgZnVuY3Rpb24gKHN5c0RpbUl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgICAgICAgICAgICAgc3lzRGltSXRlbURpbXNEZWYgJiYgKGRpbUNvdW50ID0gTWF0aC5tYXgoZGltQ291bnQsIHN5c0RpbUl0ZW1EaW1zRGVmLmxlbmd0aCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSB1c2VyIGRlZmluZWQgZGltcyAoYG5hbWVgIGFuZCBgdHlwZWApIGFuZCBpbml0IHJlc3VsdC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGltRGVmSXRlbSA9IGlzU3RyaW5nKGRpbXNEZWZbaV0pID8ge25hbWU6IGRpbXNEZWZbaV19IDogKGRpbXNEZWZbaV0gfHwge30pO1xuICAgICAgICAgICAgdmFyIHVzZXJEaW1OYW1lID0gZGltRGVmSXRlbS5uYW1lO1xuICAgICAgICAgICAgdmFyIHJlc3VsdEl0ZW0gPSByZXN1bHRbaV0gPSB7b3RoZXJEaW1zOiB7fX07XG4gICAgICAgICAgICAvLyBOYW1lIHdpbGwgYmUgYXBwbGllZCBsYXRlciBmb3IgYXZvaWRpbmcgZHVwbGljYXRpb24uXG4gICAgICAgICAgICBpZiAodXNlckRpbU5hbWUgIT0gbnVsbCAmJiBkYXRhRGltTmFtZU1hcC5nZXQodXNlckRpbU5hbWUpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGlmIGBzZXJpZXMuZGltZW5zaW9uc2AgaXMgZGVmaW5lZCBpbiBvcHRpb24sIHRvb2x0aXBOYW1lXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBzZXQsIGFuZCBkaW1lbnNpb24gd2lsbCBiZSBkaXBsYXllZCB2ZXJ0aWNhbGx5IGluXG4gICAgICAgICAgICAgICAgLy8gdG9vbHRpcCBieSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0ubmFtZSA9IHJlc3VsdEl0ZW0udG9vbHRpcE5hbWUgPSB1c2VyRGltTmFtZTtcbiAgICAgICAgICAgICAgICBkYXRhRGltTmFtZU1hcC5zZXQodXNlckRpbU5hbWUsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGltRGVmSXRlbS50eXBlICE9IG51bGwgJiYgKHJlc3VsdEl0ZW0udHlwZSA9IGRpbURlZkl0ZW0udHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgYGNvb3JkRGltYCBhbmQgYGNvb3JkRGltSW5kZXhgIGJ5IGBlbmNvZGVEZWZgIGFuZCBub3JtYWxpemUgYGVuY29kZURlZmAuXG4gICAgICAgIGVuY29kZURlZi5lYWNoKGZ1bmN0aW9uIChkYXRhRGltcywgY29vcmREaW0pIHtcbiAgICAgICAgICAgIGRhdGFEaW1zID0gZW5jb2RlRGVmLnNldChjb29yZERpbSwgbm9ybWFsaXplVG9BcnJheShkYXRhRGltcykuc2xpY2UoKSk7XG4gICAgICAgICAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAocmVzdWx0RGltSWR4LCBjb29yZERpbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IHJlc3VsdERpbUlkeCBjYW4gYmUgZGltIG5hbWUgb3IgaW5kZXguXG4gICAgICAgICAgICAgICAgaXNTdHJpbmcocmVzdWx0RGltSWR4KSAmJiAocmVzdWx0RGltSWR4ID0gZGF0YURpbU5hbWVNYXAuZ2V0KHJlc3VsdERpbUlkeCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHREaW1JZHggIT0gbnVsbCAmJiByZXN1bHREaW1JZHggPCBkaW1Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhRGltc1tjb29yZERpbUluZGV4XSA9IHJlc3VsdERpbUlkeDtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlEaW0ocmVzdWx0W3Jlc3VsdERpbUlkeF0sIGNvb3JkRGltLCBjb29yZERpbUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGVtcGxldGVzIGFuZCBkZWZhdWx0IG9yZGVyIGZyb20gYHN5c0RpbXNgLlxuICAgICAgICB2YXIgYXZhaWxEaW1JZHggPSAwO1xuICAgICAgICBlYWNoKHN5c0RpbXMsIGZ1bmN0aW9uIChzeXNEaW1JdGVtLCBzeXNEaW1JbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkRGltO1xuICAgICAgICAgICAgdmFyIHN5c0RpbUl0ZW07XG4gICAgICAgICAgICB2YXIgc3lzRGltSXRlbURpbXNEZWY7XG4gICAgICAgICAgICB2YXIgc3lzRGltSXRlbU90aGVyRGltcztcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhzeXNEaW1JdGVtKSkge1xuICAgICAgICAgICAgICAgIGNvb3JkRGltID0gc3lzRGltSXRlbTtcbiAgICAgICAgICAgICAgICBzeXNEaW1JdGVtID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb29yZERpbSA9IHN5c0RpbUl0ZW0ubmFtZTtcbiAgICAgICAgICAgICAgICBzeXNEaW1JdGVtID0genJVdGlsLmNsb25lKHN5c0RpbUl0ZW0pO1xuICAgICAgICAgICAgICAgIC8vIGBjb29yZERpbUluZGV4YCBzaG91bGQgbm90IGJlIHNldCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICBzeXNEaW1JdGVtRGltc0RlZiA9IHN5c0RpbUl0ZW0uZGltc0RlZjtcbiAgICAgICAgICAgICAgICBzeXNEaW1JdGVtT3RoZXJEaW1zID0gc3lzRGltSXRlbS5vdGhlckRpbXM7XG4gICAgICAgICAgICAgICAgc3lzRGltSXRlbS5uYW1lID0gc3lzRGltSXRlbS5jb29yZERpbSA9IHN5c0RpbUl0ZW0uY29vcmREaW1JbmRleFxuICAgICAgICAgICAgICAgICAgICA9IHN5c0RpbUl0ZW0uZGltc0RlZiA9IHN5c0RpbUl0ZW0ub3RoZXJEaW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGFEaW1zID0gbm9ybWFsaXplVG9BcnJheShlbmNvZGVEZWYuZ2V0KGNvb3JkRGltKSk7XG4gICAgICAgICAgICAvLyBkaW1lbnNpb25zIHByb3ZpZGVzIGRlZmF1bHQgZGltIHNlcXVlbmNlcy5cbiAgICAgICAgICAgIGlmICghZGF0YURpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoc3lzRGltSXRlbURpbXNEZWYgJiYgc3lzRGltSXRlbURpbXNEZWYubGVuZ3RoIHx8IDEpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGF2YWlsRGltSWR4IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbYXZhaWxEaW1JZHhdLmNvb3JkRGltICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsRGltSWR4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZhaWxEaW1JZHggPCByZXN1bHQubGVuZ3RoICYmIGRhdGFEaW1zLnB1c2goYXZhaWxEaW1JZHgrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwbHkgdGVtcGxhdGVzLlxuICAgICAgICAgICAgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKHJlc3VsdERpbUlkeCwgY29vcmREaW1JbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRJdGVtID0gcmVzdWx0W3Jlc3VsdERpbUlkeF07XG4gICAgICAgICAgICAgICAgYXBwbHlEaW0oZGVmYXVsdHMocmVzdWx0SXRlbSwgc3lzRGltSXRlbSksIGNvb3JkRGltLCBjb29yZERpbUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SXRlbS5uYW1lID09IG51bGwgJiYgc3lzRGltSXRlbURpbXNEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SXRlbS5uYW1lID0gcmVzdWx0SXRlbS50b29sdGlwTmFtZSA9IHN5c0RpbUl0ZW1EaW1zRGVmW2Nvb3JkRGltSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeXNEaW1JdGVtT3RoZXJEaW1zICYmIGRlZmF1bHRzKHJlc3VsdEl0ZW0ub3RoZXJEaW1zLCBzeXNEaW1JdGVtT3RoZXJEaW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZpcnN0IGV4dHJhIGRpbSBpcyAndmFsdWUnLlxuICAgICAgICB2YXIgZXh0cmEgPSBvcHQuZXh0cmFQcmVmaXggfHwgJ3ZhbHVlJztcblxuICAgICAgICAvLyBTZXQgZGltIGBuYW1lYCBhbmQgb3RoZXIgYGNvb3JkRGltYCBhbmQgb3RoZXIgcHJvcHMuXG4gICAgICAgIGZvciAodmFyIHJlc3VsdERpbUlkeCA9IDA7IHJlc3VsdERpbUlkeCA8IGRpbUNvdW50OyByZXN1bHREaW1JZHgrKykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdEl0ZW0gPSByZXN1bHRbcmVzdWx0RGltSWR4XSA9IHJlc3VsdFtyZXN1bHREaW1JZHhdIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNvb3JkRGltID0gcmVzdWx0SXRlbS5jb29yZERpbTtcblxuICAgICAgICAgICAgY29vcmREaW0gPT0gbnVsbCAmJiAoXG4gICAgICAgICAgICAgICAgcmVzdWx0SXRlbS5jb29yZERpbSA9IGdlbk5hbWUoZXh0cmEsIGNvb3JkRGltTmFtZU1hcCwgb3B0LmV4dHJhRnJvbVplcm8pLFxuICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW1JbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgcmVzdWx0SXRlbS5pc0V4dHJhQ29vcmQgPSB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXN1bHRJdGVtLm5hbWUgPT0gbnVsbCAmJiAocmVzdWx0SXRlbS5uYW1lID0gZ2VuTmFtZShcbiAgICAgICAgICAgICAgICByZXN1bHRJdGVtLmNvb3JkRGltLFxuICAgICAgICAgICAgICAgIGRhdGFEaW1OYW1lTWFwXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgcmVzdWx0SXRlbS50eXBlID09IG51bGwgJiYgZ3Vlc3NPcmRpbmFsKGRhdGEsIHJlc3VsdERpbUlkeClcbiAgICAgICAgICAgICAgICAmJiAocmVzdWx0SXRlbS50eXBlID0gJ29yZGluYWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlEaW0ocmVzdWx0SXRlbSwgY29vcmREaW0sIGNvb3JkRGltSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChPVEhFUl9ESU1TW2Nvb3JkRGltXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0ub3RoZXJEaW1zW2Nvb3JkRGltXSA9IGNvb3JkRGltSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRJdGVtLmNvb3JkRGltID0gY29vcmREaW07XG4gICAgICAgICAgICAgICAgcmVzdWx0SXRlbS5jb29yZERpbUluZGV4ID0gY29vcmREaW1JbmRleDtcbiAgICAgICAgICAgICAgICBjb29yZERpbU5hbWVNYXAuc2V0KGNvb3JkRGltLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbk5hbWUobmFtZSwgbWFwLCBmcm9tWmVybykge1xuICAgICAgICAgICAgaWYgKGZyb21aZXJvIHx8IG1hcC5nZXQobmFtZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobWFwLmdldChuYW1lICsgaSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWUgKz0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBydWxlIHNob3VsZCBub3QgYmUgY29tcGxleCwgb3RoZXJ3aXNlIHVzZXIgbWlnaHQgbm90XG4gICAgLy8gYmUgYWJsZSB0byBrbm93biB3aGVyZSB0aGUgZGF0YSBpcyB3cm9uZy5cbiAgICB2YXIgZ3Vlc3NPcmRpbmFsID0gY29tcGxldGVEaW1lbnNpb25zLmd1ZXNzT3JkaW5hbCA9IGZ1bmN0aW9uIChkYXRhLCBkaW1JbmRleCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmV0cmlldmVWYWx1ZShkYXRhW2ldKTtcblxuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlW2RpbUluZGV4XTtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHVzYWdlIGNvbnZlbmllbmNlLCAnMScsICcyJyB3aWxsIGJlIHRyZWF0ZWQgYXMgXCJudW1iZXJcIi5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVZhbHVlKG8pIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KG8pID8gbyA6IHpyVXRpbC5pc09iamVjdChvKSA/IG8udmFsdWU6IG87XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb21wbGV0ZURpbWVuc2lvbnM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var classUtil = __webpack_require__(12);\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL2NvbG9yUGFsZXR0ZS5qcz80NzQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgY2xhc3NVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBzZXQgPSBjbGFzc1V0aWwuc2V0O1xuICAgIHZhciBnZXQgPSBjbGFzc1V0aWwuZ2V0O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNsZWFyQ29sb3JQYWxldHRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2NvbG9ySWR4JywgMCk7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2NvbG9yTmFtZU1hcCcsIHt9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGUgfHwgdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xvcklkeCA9IGdldChzY29wZSwgJ2NvbG9ySWR4JykgfHwgMDtcbiAgICAgICAgICAgIHZhciBjb2xvck5hbWVNYXAgPSBnZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnKSB8fCBzZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnLCB7fSk7XG4gICAgICAgICAgICAvLyBVc2UgYGhhc093blByb3BlcnR5YCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yTmFtZU1hcFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvclBhbGV0dGUgPSB0aGlzLmdldCgnY29sb3InLCB0cnVlKSB8fCBbXTtcbiAgICAgICAgICAgIGlmICghY29sb3JQYWxldHRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JQYWxldHRlW2NvbG9ySWR4XTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29sb3JOYW1lTWFwW25hbWVdID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQoc2NvcGUsICdjb2xvcklkeCcsIChjb2xvcklkeCArIDEpICUgY29sb3JQYWxldHRlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * For testable.\n */\n\n\n    var numberUtil = __webpack_require__(5);\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL2hlbHBlci5qcz82OGI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPLEVBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRm9yIHRlc3RhYmxlLlxuICovXG5cblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcblxuICAgIHZhciByb3VuZE51bWJlciA9IG51bWJlclV0aWwucm91bmQ7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBleHRlbnQgQm90aCBleHRlbnRbMF0gYW5kIGV4dGVudFsxXSBzaG91bGQgYmUgdmFsaWQgbnVtYmVyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaG91bGQgYmUgZXh0ZW50WzBdIDwgZXh0ZW50WzFdLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGxpdE51bWJlciBzcGxpdE51bWJlciBzaG91bGQgYmUgPj0gMS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbkludGVydmFsXVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ge2ludGVydmFsLCBpbnRlcnZhbFByZWNpc2lvbiwgbmljZVRpY2tFeHRlbnR9XG4gICAgICovXG4gICAgaGVscGVyLmludGVydmFsU2NhbGVOaWNlVGlja3MgPSBmdW5jdGlvbiAoZXh0ZW50LCBzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcblxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWwgPSBudW1iZXJVdGlsLm5pY2Uoc3BhbiAvIHNwbGl0TnVtYmVyLCB0cnVlKTtcbiAgICAgICAgaWYgKG1pbkludGVydmFsICE9IG51bGwgJiYgaW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWwgPSBtaW5JbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUb3cgbW9yZSBkaWdpdGFsIGZvciB0aWNrLlxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gcmVzdWx0LmludGVydmFsUHJlY2lzaW9uID0gaGVscGVyLmdldEludGVydmFsUHJlY2lzaW9uKGludGVydmFsKTtcbiAgICAgICAgLy8gTmljZWQgZXh0ZW50IGluc2lkZSBvcmlnaW5hbCBleHRlbnRcbiAgICAgICAgdmFyIG5pY2VUaWNrRXh0ZW50ID0gcmVzdWx0Lm5pY2VUaWNrRXh0ZW50ID0gW1xuICAgICAgICAgICAgcm91bmROdW1iZXIoTWF0aC5jZWlsKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsLCBwcmVjaXNpb24pLFxuICAgICAgICAgICAgcm91bmROdW1iZXIoTWF0aC5mbG9vcihleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uKVxuICAgICAgICBdO1xuXG4gICAgICAgIGhlbHBlci5maXhFeHRlbnQobmljZVRpY2tFeHRlbnQsIGV4dGVudCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBpbnRlcnZhbCBwcmVjaXNpb25cbiAgICAgKi9cbiAgICBoZWxwZXIuZ2V0SW50ZXJ2YWxQcmVjaXNpb24gPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gVG93IG1vcmUgZGlnaXRhbCBmb3IgdGljay5cbiAgICAgICAgcmV0dXJuIG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZShpbnRlcnZhbCkgKyAyO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGFtcChuaWNlVGlja0V4dGVudCwgaWR4LCBleHRlbnQpIHtcbiAgICAgICAgbmljZVRpY2tFeHRlbnRbaWR4XSA9IE1hdGgubWF4KE1hdGgubWluKG5pY2VUaWNrRXh0ZW50W2lkeF0sIGV4dGVudFsxXSksIGV4dGVudFswXSk7XG4gICAgfVxuXG4gICAgLy8gSW4gc29tZSBjYXNlcyAoZS5nLiwgc3BsaXROdW1iZXIgaXMgMSksIG5pY2VUaWNrRXh0ZW50IG1heSBiZSBvdXQgb2YgZXh0ZW50LlxuICAgIGhlbHBlci5maXhFeHRlbnQgPSBmdW5jdGlvbiAobmljZVRpY2tFeHRlbnQsIGV4dGVudCkge1xuICAgICAgICAhaXNGaW5pdGUobmljZVRpY2tFeHRlbnRbMF0pICYmIChuaWNlVGlja0V4dGVudFswXSA9IGV4dGVudFswXSk7XG4gICAgICAgICFpc0Zpbml0ZShuaWNlVGlja0V4dGVudFsxXSkgJiYgKG5pY2VUaWNrRXh0ZW50WzFdID0gZXh0ZW50WzFdKTtcbiAgICAgICAgY2xhbXAobmljZVRpY2tFeHRlbnQsIDAsIGV4dGVudCk7XG4gICAgICAgIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCAxLCBleHRlbnQpO1xuICAgICAgICBpZiAobmljZVRpY2tFeHRlbnRbMF0gPiBuaWNlVGlja0V4dGVudFsxXSkge1xuICAgICAgICAgICAgbmljZVRpY2tFeHRlbnRbMF0gPSBuaWNlVGlja0V4dGVudFsxXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBoZWxwZXIuaW50ZXJ2YWxTY2FsZUdldFRpY2tzID0gZnVuY3Rpb24gKGludGVydmFsLCBleHRlbnQsIG5pY2VUaWNrRXh0ZW50LCBpbnRlcnZhbFByZWNpc2lvbikge1xuICAgICAgICB2YXIgdGlja3MgPSBbXTtcblxuICAgICAgICAvLyBJZiBpbnRlcnZhbCBpcyAwLCByZXR1cm4gW107XG4gICAgICAgIGlmICghaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWNrcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTogdXNpbmcgZGF0YVpvb20gdG9vbGJveCwgem9vbSBhbmQgem9vbS5cbiAgICAgICAgdmFyIHNhZmVMaW1pdCA9IDEwMDAwO1xuXG4gICAgICAgIGlmIChleHRlbnRbMF0gPCBuaWNlVGlja0V4dGVudFswXSkge1xuICAgICAgICAgICAgdGlja3MucHVzaChleHRlbnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aWNrID0gbmljZVRpY2tFeHRlbnRbMF07XG5cbiAgICAgICAgd2hpbGUgKHRpY2sgPD0gbmljZVRpY2tFeHRlbnRbMV0pIHtcbiAgICAgICAgICAgIHRpY2tzLnB1c2godGljayk7XG4gICAgICAgICAgICAvLyBBdm9pZCByb3VuZGluZyBlcnJvclxuICAgICAgICAgICAgdGljayA9IHJvdW5kTnVtYmVyKHRpY2sgKyBpbnRlcnZhbCwgaW50ZXJ2YWxQcmVjaXNpb24pO1xuICAgICAgICAgICAgaWYgKHRpY2sgPT09IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgb3V0IG9mIHNhZmUgZmxvYXQgcG9pbnQsIGUuZy4sXG4gICAgICAgICAgICAgICAgLy8gLTM3MTExMjYuOTkwNzcwNyArIDJlLTEwID09PSAtMzcxMTEyNi45OTA3NzA3XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGlja3MubGVuZ3RoID4gc2FmZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTogdGhlIGxhc3QgaXRlbSBvZiB0aWNrcyBpcyBzbWFsbGVyXG4gICAgICAgIC8vIHRoYW4gbmljZVRpY2tFeHRlbnRbMV0gYW5kIG5pY2VUaWNrRXh0ZW50WzFdID09PSBleHRlbnRbMV0uXG4gICAgICAgIGlmIChleHRlbnRbMV0gPiAodGlja3MubGVuZ3RoID8gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0gOiBuaWNlVGlja0V4dGVudFsxXSkpIHtcbiAgICAgICAgICAgIHRpY2tzLnB1c2goZXh0ZW50WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aWNrcztcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBoZWxwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvc2NhbGUvaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 65 */
/***/ (function(module, exports) {

eval("\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanM/ZTgwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGxpYiA9IHt9O1xuXG4gICAgdmFyIE9SSUdJTl9NRVRIT0QgPSAnXFwwX190aHJvdHRsZU9yaWdpbk1ldGhvZCc7XG4gICAgdmFyIFJBVEUgPSAnXFwwX190aHJvdHRsZVJhdGUnO1xuICAgIHZhciBUSFJPVFRMRV9UWVBFID0gJ1xcMF9fdGhyb3R0bGVUeXBlJztcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0geyhGdW5jdGlvbil9IGZuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBVbml0OiBtcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJvdW5jZT1mYWxzZV1cbiAgICAgKiAgICAgICAgdHJ1ZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5YCwgb25seSB0aGUgbGFzdCBjYWxsIHdvcmtzLlxuICAgICAqICAgICAgICBmYWxzZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5LCBjYWxsIHdvcmtzIG9uIGZpeGVkIHJhdGUuXG4gICAgICogQHJldHVybiB7KEZ1bmN0aW9uKX0gdGhyb3R0bGVkIGZuLlxuICAgICAqL1xuICAgIGxpYi50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgZGVsYXksIGRlYm91bmNlKSB7XG5cbiAgICAgICAgdmFyIGN1cnJDYWxsO1xuICAgICAgICB2YXIgbGFzdENhbGwgPSAwO1xuICAgICAgICB2YXIgbGFzdEV4ZWMgPSAwO1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgdmFyIHNjb3BlO1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgdmFyIGRlYm91bmNlTmV4dENhbGw7XG5cbiAgICAgICAgZGVsYXkgPSBkZWxheSB8fCAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICBsYXN0RXhlYyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBmbi5hcHBseShzY29wZSwgYXJncyB8fCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjdXJyQ2FsbCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIHRoaXNEZWxheSA9IGRlYm91bmNlTmV4dENhbGwgfHwgZGVsYXk7XG4gICAgICAgICAgICB2YXIgdGhpc0RlYm91bmNlID0gZGVib3VuY2VOZXh0Q2FsbCB8fCBkZWJvdW5jZTtcbiAgICAgICAgICAgIGRlYm91bmNlTmV4dENhbGwgPSBudWxsO1xuICAgICAgICAgICAgZGlmZiA9IGN1cnJDYWxsIC0gKHRoaXNEZWJvdW5jZSA/IGxhc3RDYWxsIDogbGFzdEV4ZWMpIC0gdGhpc0RlbGF5O1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgICBpZiAodGhpc0RlYm91bmNlKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjLCAtZGlmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0Q2FsbCA9IGN1cnJDYWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciB0aHJvdHRsZS5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgY2IuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIGRlYm91bmNlIG9uY2UuXG4gICAgICAgICAqL1xuICAgICAgICBjYi5kZWJvdW5jZU5leHRDYWxsID0gZnVuY3Rpb24gKGRlYm91bmNlRGVsYXkpIHtcbiAgICAgICAgICAgIGRlYm91bmNlTmV4dENhbGwgPSBkZWJvdW5jZURlbGF5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjYjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRocm90dGxlIG1ldGhvZCBvciB1cGRhdGUgdGhyb3R0bGUgcmF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQ29tcG9uZW50Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gICAgICogICAgICAgICB0aGlzLFxuICAgICAqICAgICAgICAgJ19kaXNwYXRjaEFjdGlvbicsXG4gICAgICogICAgICAgICB0aGlzLm1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAgICAgKiAgICAgICAgICdmaXhSYXRlJ1xuICAgICAqICAgICApO1xuICAgICAqIH07XG4gICAgICogQ29tcG9uZW50Vmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XG4gICAgICogfTtcbiAgICAgKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZuQXR0clxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Rocm90dGxlVHlwZT0nZml4UmF0ZSddICdmaXhSYXRlJyBvciAnZGVib3VuY2UnXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBsaWIuY3JlYXRlT3JVcGRhdGUgPSBmdW5jdGlvbiAob2JqLCBmbkF0dHIsIHJhdGUsIHRocm90dGxlVHlwZSkge1xuICAgICAgICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcblxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luRm4gPSBmbltPUklHSU5fTUVUSE9EXSB8fCBmbjtcbiAgICAgICAgdmFyIGxhc3RUaHJvdHRsZVR5cGUgPSBmbltUSFJPVFRMRV9UWVBFXTtcbiAgICAgICAgdmFyIGxhc3RSYXRlID0gZm5bUkFURV07XG5cbiAgICAgICAgaWYgKGxhc3RSYXRlICE9PSByYXRlIHx8IGxhc3RUaHJvdHRsZVR5cGUgIT09IHRocm90dGxlVHlwZSkge1xuICAgICAgICAgICAgaWYgKHJhdGUgPT0gbnVsbCB8fCAhdGhyb3R0bGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChvYmpbZm5BdHRyXSA9IG9yaWdpbkZuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4gPSBvYmpbZm5BdHRyXSA9IGxpYi50aHJvdHRsZShcbiAgICAgICAgICAgICAgICBvcmlnaW5GbiwgcmF0ZSwgdGhyb3R0bGVUeXBlID09PSAnZGVib3VuY2UnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm5bT1JJR0lOX01FVEhPRF0gPSBvcmlnaW5GbjtcbiAgICAgICAgICAgIGZuW1RIUk9UVExFX1RZUEVdID0gdGhyb3R0bGVUeXBlO1xuICAgICAgICAgICAgZm5bUkFURV0gPSByYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aHJvdHRsZS4gRXhhbXBsZSBzZWUgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbkF0dHJcbiAgICAgKi9cbiAgICBsaWIuY2xlYXIgPSBmdW5jdGlvbiAob2JqLCBmbkF0dHIpIHtcbiAgICAgICAgdmFyIGZuID0gb2JqW2ZuQXR0cl07XG4gICAgICAgIGlmIChmbiAmJiBmbltPUklHSU5fTUVUSE9EXSkge1xuICAgICAgICAgICAgb2JqW2ZuQXR0cl0gPSBmbltPUklHSU5fTUVUSE9EXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3V0aWwvdGhyb3R0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var Group = __webpack_require__(27);\n    var componentUtil = __webpack_require__(37);\n    var clazzUtil = __webpack_require__(12);\n    var modelUtil = __webpack_require__(4);\n    var zrUtil = __webpack_require__(0);\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3ZpZXcvQ2hhcnQuanM/OGEzNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRCxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRCxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMseUJBQXlCOztBQUVyRSIsImZpbGUiOiI2Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwJyk7XG4gICAgdmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvbmVudCcpO1xuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBDaGFydCgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgndmlld0NoYXJ0Jyk7XG4gICAgfVxuXG4gICAgQ2hhcnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHR5cGU6ICdjaGFydCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgdGhlIGNoYXJ0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgY2hhcnRcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlnaGxpZ2h0IHNlcmllcyBvciBzcGVjaWZpZWQgZGF0YSBpdGVtXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdG9nZ2xlSGlnaGxpZ2h0KHNlcmllc01vZGVsLmdldERhdGEoKSwgcGF5bG9hZCwgJ2VtcGhhc2lzJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvd25wbGF5IHNlcmllcyBvciBzcGVjaWZpZWQgZGF0YSBpdGVtXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgZG93bnBsYXk6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnbm9ybWFsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzZWxmXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlIHNlbGZcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlldyBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICAgICAqIEBpbnRlcmZhY2VcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIGNvbnRhaW5Qb2ludDogZnVuY3Rpb24gKCkge31cblxuICAgIH07XG5cbiAgICB2YXIgY2hhcnRQcm90byA9IENoYXJ0LnByb3RvdHlwZTtcbiAgICBjaGFydFByb3RvLnVwZGF0ZVZpZXdcbiAgICAgICAgPSBjaGFydFByb3RvLnVwZGF0ZUxheW91dFxuICAgICAgICA9IGNoYXJ0UHJvdG8udXBkYXRlVmlzdWFsXG4gICAgICAgID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHN0YXRlIG9mIHNpbmdsZSBlbGVtZW50XG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWxTZXRTdGF0ZShlbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbC50cmlnZ2VyKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5jaGlsZENvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbFNldFN0YXRlKGVsLmNoaWxkQXQoaSksIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdGF0ZSAnbm9ybWFsJ3wnZW1waGFzaXMnXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9nZ2xlSGlnaGxpZ2h0KGRhdGEsIHBheWxvYWQsIHN0YXRlKSB7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICAgICAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShkYXRhSW5kZXgpLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgICAgICAgICAgIGVsU2V0U3RhdGUoZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJZHgpLCBzdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWxTZXRTdGF0ZShlbCwgc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmFibGUgQ2hhcnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDaGFydCwgWydkaXNwb3NlJ10pO1xuXG4gICAgLy8gQWRkIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ2hhcnQsIHtyZWdpc3RlcldoZW5FeHRlbmQ6IHRydWV9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvdmlldy9DaGFydC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var Group = __webpack_require__(27);\n    var componentUtil = __webpack_require__(37);\n    var clazzUtil = __webpack_require__(12);\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3ZpZXcvQ29tcG9uZW50LmpzPzA5OGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDOztBQUV4QyxtRUFBbUU7O0FBRW5FOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCx5QkFBeUI7O0FBRXpFIiwiZmlsZSI6IjY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcbiAgICB2YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY29tcG9uZW50Jyk7XG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcblxuICAgIHZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q29tcG9uZW50Jyk7XG4gICAgfTtcblxuICAgIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENvbXBvbmVudCxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7fSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuXG4gICAgfTtcblxuICAgIHZhciBjb21wb25lbnRQcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgY29tcG9uZW50UHJvdG8udXBkYXRlVmlld1xuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZUxheW91dFxuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZVZpc3VhbFxuICAgICAgICA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nO1xuICAgICAgICB9O1xuICAgIC8vIEVuYWJsZSBDb21wb25lbnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDb21wb25lbnQpO1xuXG4gICAgLy8gRW5hYmxlIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ29tcG9uZW50LCB7cmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module zrender/Element\n */\n\n\n    var guid = __webpack_require__(73);\n    var Eventful = __webpack_require__(21);\n    var Transformable = __webpack_require__(79);\n    var Animatable = __webpack_require__(216);\n    var zrUtil = __webpack_require__(0);\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL0VsZW1lbnQuanM/ZjdhNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IscUJBQXFCO0FBQ3JCO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvRWxlbWVudFxuICovXG5cblxuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKCcuL21peGluL1RyYW5zZm9ybWFibGUnKTtcbiAgICB2YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vQW5pbWF0YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuXG4gICAgICAgIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlLvluIPlhYPntKBJRFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xuICAgIH07XG5cbiAgICBFbGVtZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg57G75Z6LXG4gICAgICAgICAqIEVsZW1lbnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDlkI3lrZdcbiAgICAgICAgICogRWxlbWVudCBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICAgICAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX196cjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpZ25vcmU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgICAgICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICAgICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGNsaXBQYXRoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmlmdCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVs0XSArPSBkeDtcbiAgICAgICAgICAgIG1bNV0gKz0gZHk7XG5cbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICB0aGlzLl9fenIgPSB6cjtcbiAgICAgICAgICAgIC8vIOa3u+WKoOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIOenu+mZpOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = __webpack_require__(188);\n    var color = __webpack_require__(22);\n    var util = __webpack_require__(0);\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcz9kMWJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQywrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyw2QkFBNkI7QUFDN0Isb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xuXG5cbiAgICB2YXIgQ2xpcCA9IHJlcXVpcmUoJy4vQ2xpcCcpO1xuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4uL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc0FycmF5TGlrZSA9IHV0aWwuaXNBcnJheUxpa2U7XG5cbiAgICB2YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gbGVuICYmIHAwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV1bal0gPSBpbnRlcnBvbGF0ZU51bWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFycjAgaXMgc291cmNlIGFycmF5LCBhcnIxIGlzIHRhcmdldCBhcnJheS5cbiAgICAvLyBEbyBzb21lIHByZXByb2Nlc3MgdG8gYXZvaWQgZXJyb3IgaGFwcGVuZWQgd2hlbiBpbnRlcnBvbGF0aW5nIGZyb20gYXJyMCB0byBhcnIxXG4gICAgZnVuY3Rpb24gZmlsbEFycihhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGFycjBMZW4gPSBhcnIwLmxlbmd0aDtcbiAgICAgICAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIE5vdCB3b3JrIGZvciBUeXBlZEFycmF5XG4gICAgICAgICAgICB2YXIgaXNQcmV2aW91c0xhcmdlciA9IGFycjBMZW4gPiBhcnIxTGVuO1xuICAgICAgICAgICAgaWYgKGlzUHJldmlvdXNMYXJnZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJyMExlbjsgaSA8IGFycjFMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW0gPT09IDEgPyBhcnIxW2ldIDogYXJyYXlTbGljZS5jYWxsKGFycjFbaV0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsaW5nIE5hTiB2YWx1ZVxuICAgICAgICB2YXIgbGVuMiA9IGFycjBbMF0gJiYgYXJyMFswXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBhcnIwW2ldID0gYXJyMVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFycjBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgICAgICAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiAhPT0gYXJyMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycjBbaV1bal0gIT09IGFycjFbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMsIG91dCwgYXJyRGltXG4gICAgKSB7XG4gICAgICAgIHZhciBsZW4gPSBwMC5sZW5ndGg7XG4gICAgICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0M1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV1bal0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMFtpXVtqXSwgcDFbaV1bal0sIHAyW2ldW2pdLCBwM1tpXVtqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQsIHQyLCB0M1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIG51bWJlclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0M1xuICAgICAgICAgICAgICAgICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDJcbiAgICAgICAgICAgICAgICArIHYwICogdCArIHAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZVswXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChhcnJheVNsaWNlLmNhbGwodmFsdWVbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmdiYTJTdHJpbmcocmdiYSkge1xuICAgICAgICByZ2JhWzBdID0gTWF0aC5mbG9vcihyZ2JhWzBdKTtcbiAgICAgICAgcmdiYVsxXSA9IE1hdGguZmxvb3IocmdiYVsxXSk7XG4gICAgICAgIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pO1xuXG4gICAgICAgIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSB7XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICAgICAgICByZXR1cm4gaXNBcnJheUxpa2UobGFzdFZhbHVlICYmIGxhc3RWYWx1ZVswXSkgPyAyIDogMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAgKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgICAgICAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gICAgICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgICAgIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHdWVzcyBkYXRhIHR5cGVcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICAgICAgICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG4gICAgICAgIHZhciBhcnJEaW0gPSBpc1ZhbHVlQXJyYXkgPyBnZXRBcnJheURpbShrZXlmcmFtZXMpIDogMDtcblxuICAgICAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgICAgICAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuICAgICAgICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lO1xuICAgICAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlBlcmNlbnRzID0gW107XG4gICAgICAgIC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICBpZiAoISgoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkpXG4gICAgICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgICAgICAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAgICAgICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIHAwO1xuICAgICAgICB2YXIgcDE7XG4gICAgICAgIHZhciBwMjtcbiAgICAgICAgdmFyIHAzO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAgICAgICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgICAgICAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAoa2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV0pO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICAgICAgICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICAgICAgICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICAgICAgICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICAgICAgICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgICAgICAgICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICAgICAgICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgICAgICAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0b3IgPSBmdW5jdGlvbih0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2NsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZGVsYXkgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RvbmVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKHRpbWUgLyogbXMgKi8sIHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9wYXVzZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgY2xpcHNcbiAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gZWFzaW5nXG4gICAgICAgICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxhc3RDbGlwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICBjbGlwQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG4gICAgICAgICAgICBpZiAobGFzdENsaXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG4gICAgICAgICAgICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 70 */
/***/ (function(module, exports) {

eval("\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanM/OThlOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICgod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSlcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvaXNzdWVzLzE4OSNpc3N1ZWNvbW1lbnQtMjI0OTE5ODA5XG4gICAgICAgICAgICAgICAgfHwgKHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpKVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbiAgICAgICAgICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 71 */
/***/ (function(module, exports) {

eval("\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcz8yMjVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbm9ybWFsaXplUmFkaWFuOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICAgICAgYW5nbGUgJT0gUEkyO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29udGFpbi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 72 */
/***/ (function(module, exports) {

eval("// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvTFJVLmpzPzEzNmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgfTtcblxuICAgIHZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHt9IHZhbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5pbnNlcnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICAgICAgICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICBlbnRyeS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbisrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZW50cnkuXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyBoZWFkXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgdGFpbFxuICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xlbi0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgbGlzdFxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt9IHZhbFxuICAgICAqL1xuICAgIHZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTFJVIENhY2hlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gICAgICovXG4gICAgdmFyIExSVSA9IGZ1bmN0aW9uIChtYXhTaXplKSB7XG5cbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cbiAgICAgICAgdGhpcy5fbWFwID0ge307XG5cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG5cbiAgICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSAge30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBMUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIHZhciByZW1vdmVkID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaXN0LmxlbigpO1xuICAgICAgICAgICAgLy8gUmV1c2UgbGFzdCByZW1vdmVkIGVudHJ5XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5O1xuXG4gICAgICAgICAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgICAgICAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuXG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IGxlYXN0VXNlZEVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBsZWFzdFVzZWRFbnRyeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IEVudHJ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBMUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgICAgICAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZVxuICAgICAqL1xuICAgIExSVVByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExSVTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 73 */
/***/ (function(module, exports) {

eval("/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcz84MTg4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkU3RhcnQrKztcbiAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29yZS9ndWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n        var config = __webpack_require__(26);\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvbG9nLmpzPzRiMTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbG9nXG4gICAgICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuZGVidWdNb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKiBmb3IgZGVidWdcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1lcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgIG1lcyArICcgJyArIChuZXcgRGF0ZSgpIC0gMClcbiAgICAgICAgICAgICAgICArICc8YnIvPidcbiAgICAgICAgICAgICAgICArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MO1xuICAgICAgICB9O1xuICAgICAgICAqL1xuICAgIFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = __webpack_require__(40);\n    var BoundingRect = __webpack_require__(11);\n    var zrUtil = __webpack_require__(0);\n\n    var LRU = __webpack_require__(72);\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // 设置transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanM/NWYwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6Ijc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbWFnZSBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgWkltYWdlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuXG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTtcbiAgICAgICAgICAgIHZhciBpbWFnZTtcblxuICAgICAgICAgICAgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhIHVybCBzdHJpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRSBDYXNlIGNyZWF0ZSBtYW55IGltYWdlcyB3aXRoIHNyY1xuICAgICAgICAgICAgaWYgKCFpbWFnZSAmJiBzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0IGZyb20gZ2xvYmFsIGltYWdlIGNhY2hlXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KHNyYyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRJbWdPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV0uZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogW3RoaXNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQoc3JjLCBjYWNoZWRJbWdPYmopO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1hZ2UgaXMgbm90IGNvbXBsZXRlIGZpbmlzaCwgYWRkIHRvIHBlbmRpbmcgbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgICAgICAgICAgICAgIC8vIGlmIChpbWFnZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5Yqg6L295aSx6LSlXG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlaWdodCA9PSBudWxsICYmIHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOiuvue9rnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNXaWR0aCA9IHdpZHRoIC0gc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFpJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 76 */
/***/ (function(module, exports) {

eval("\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcz85N2IxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixXQUFXOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBQYXR0ZXJuID0gZnVuY3Rpb24gKGltYWdlLCByZXBlYXQpIHtcbiAgICAgICAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAgICAgICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge2ltYWdlOiAuLi59YCwgd2hlcmUgdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9O1xuXG4gICAgUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 77 */
/***/ (function(module, exports) {

eval("/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textPositionRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanM/MGRlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6Ijc3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9TdHlsZVxuICovXG5cblxuICAgIHZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxuICAgICAgICBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXVxuICAgIF07XG5cbiAgICAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuICAgIC8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG4gICAgdmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9wdHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwIDogb2JqLng7XG4gICAgICAgIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgICAgICAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICAgICAgICB2YXIgeTIgPSBvYmoueTIgPT0gbnVsbCA/IDAgOiBvYmoueTI7XG5cbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gICAgICAgIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICAgICAgICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICByID0gciAqIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG5cbiAgICBTdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgb3BhY2l0eTogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2g6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVXaWR0aDogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAgICAgICAqIFt4LCB5XVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBib3VuZGluZ1JlY3Qgb2YgYSBgZGlzcGxheWFibGVgLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFBvc2l0aW9uUmVjdDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogW3gsIHldXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRPZmZzZXQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QmFzZWxpbmU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dERpc3RhbmNlOiA1LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cmFuc2Zvcm0gdGV4dFxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFRyYW5zZm9ybTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRleHRUcmFuc2Zvcm0gaXMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Um90YXRpb246IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBibGVuZDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSkgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICAgICAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChvdmVyd3JpdGUgfHwgISB0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lXG4gICAgICAgICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICAgICAgICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgICAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgICAgICAgICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm92aWRlIGZvciBvdGhlcnNcbiAgICBTdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var smoothSpline = __webpack_require__(205);\n    var smoothBezier = __webpack_require__(204);\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanM/MzJmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoJy4vc21vb3RoU3BsaW5lJyk7XG4gICAgdmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoJy4vc21vb3RoQmV6aWVyJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgY2xvc2VQYXRoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcbiAgICAgICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gc21vb3RoQmV6aWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoY2xvc2VQYXRoID8gbGVuIDogbGVuIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoID09PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = __webpack_require__(20);\n    var vector = __webpack_require__(7);\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanM/MTQ0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI3OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5o+Q5L6b5Y+Y5o2i5omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcblxuICAgIHZhciBFUFNJTE9OID0gNWUtNTtcblxuICAgIGZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuICAgICAgICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5bmz56e7XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaXi+i9rFxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog57yp5pS+XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMSwgMV1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLm9yaWdpbiB8fCBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAgICAgKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblswXSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMV0gLSAxKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gICAgICAgIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgICAgICAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSBtIHx8IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbUlkZW50aXR5KG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5bqU55So54i26IqC54K55Y+Y5o2iXG4gICAgICAgIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4LmNvcHkobSwgcGFyZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbTtcblxuICAgICAgICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgbWF0cml4LmludmVydCh0aGlzLmludlRyYW5zZm9ybSwgbSk7XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRoaXMsIG0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gICAgICogQHBhcmFtIHtDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciAqIG1bMF0sIGRwciAqIG1bMV0sIGRwciAqIG1bMl0sIGRwciAqIG1bM10sIGRwciAqIG1bNF0sIGRwciAqIG1bNV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIH07XG5cbiAgICB2YXIgdG1wVHJhbnNmb3JtID0gW107XG5cbiAgICAvKipcbiAgICAgKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgICAgICAgdmFyIHN5ID0gbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgICAgICAgICBzeCA9IE1hdGguc3FydChzeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgICAgICAgICBzeSA9IE1hdGguc3FydChzeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bMF0gPCAwKSB7XG4gICAgICAgICAgICBzeCA9IC1zeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVszXSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gLXN5O1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgICAgICAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICBzY2FsZVsxXSA9IHN5O1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ2xvYmFsIHNjYWxlXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBNYXRoLnNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIGludlRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5vcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0LnBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW21dXG4gICAgICovXG4gICAgVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgICAgICAgbSA9IG0gfHwgW107XG4gICAgICAgIG1JZGVudGl0eShtKTtcblxuICAgICAgICB2YXIgb3JpZ2luID0gdGFyZ2V0Lm9yaWdpbjtcbiAgICAgICAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlIHx8IFsxLCAxXTtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRhcmdldC5wb3NpdGlvbiB8fCBbMCwgMF07XG5cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRvIG9yaWdpblxuICAgICAgICAgICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgICAgICAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgICAgICAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gKz0gb3JpZ2luWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgbVs0XSArPSBwb3NpdGlvblswXTtcbiAgICAgICAgbVs1XSArPSBwb3NpdGlvblsxXTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1hYmxlO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 80 */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(231),\n  /* template */\n  __webpack_require__(259),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.listItem.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.listItem.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-5d7b631c\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-5d7b631c\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0SXRlbS52dWU/NmYwOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjgxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy5saXN0SXRlbS52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTVkN2I2MzFjXFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Brcy5saXN0SXRlbS52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MubGlzdEl0ZW0udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MubGlzdEl0ZW0udnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTVkN2I2MzFjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNWQ3YjYzMWNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLmxpc3RJdGVtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(274)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanM/YzBiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjgyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24pIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(222),\n  /* template */\n  __webpack_require__(267),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\DataRender\\\\pks.histogram.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.histogram.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-d33d2420\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-d33d2420\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9EYXRhUmVuZGVyL3Brcy5oaXN0b2dyYW0udnVlPzdjYTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI4My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3MuaGlzdG9ncmFtLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZDMzZDI0MjBcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLmhpc3RvZ3JhbS52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcRGF0YVJlbmRlclxcXFxwa3MuaGlzdG9ncmFtLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gcGtzLmhpc3RvZ3JhbS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZDMzZDI0MjBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1kMzNkMjQyMFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvRGF0YVJlbmRlci9wa3MuaGlzdG9ncmFtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(223),\n  /* template */\n  __webpack_require__(256),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\Layout\\\\pks.header.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.header.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-327d6fb2\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-327d6fb2\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9MYXlvdXQvcGtzLmhlYWRlci52dWU/YjliZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6Ijg0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy5oZWFkZXIudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zMjdkNmZiMlxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3MuaGVhZGVyLnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIG51bGwsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRjpcXFxcMDAxLVNWTlxcXFzmkJzntKLkuJrliqHpg6hcXFxcMDLkuqflk4FcXFxcMDRQS1MxLjBcXFxc5byA5Y+R5bqTXFxcXDA057yW56CBXFxcXFBLUzEuMFxcXFwwMlBLUy5VSUNvbXBvbmVudHNcXFxcUEtTLlZ1ZVxcXFxTcmNcXFxcQ29tcG9uZW50c1xcXFxMYXlvdXRcXFxccGtzLmhlYWRlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5oZWFkZXIudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTMyN2Q2ZmIyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMzI3ZDZmYjJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL0xheW91dC9wa3MuaGVhZGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(224),\n  /* template */\n  __webpack_require__(270),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\Layout\\\\pks.menu.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.menu.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-eae78b0e\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-eae78b0e\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9MYXlvdXQvcGtzLm1lbnUudnVlPzdiMmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3MubWVudS52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWVhZTc4YjBlXFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Brcy5tZW51LnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIG51bGwsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRjpcXFxcMDAxLVNWTlxcXFzmkJzntKLkuJrliqHpg6hcXFxcMDLkuqflk4FcXFxcMDRQS1MxLjBcXFxc5byA5Y+R5bqTXFxcXDA057yW56CBXFxcXFBLUzEuMFxcXFwwMlBLUy5VSUNvbXBvbmVudHNcXFxcUEtTLlZ1ZVxcXFxTcmNcXFxcQ29tcG9uZW50c1xcXFxMYXlvdXRcXFxccGtzLm1lbnUudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MubWVudS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZWFlNzhiMGVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1lYWU3OGIwZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvTGF5b3V0L3Brcy5tZW51LnZ1ZVxuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(225),\n  /* template */\n  __webpack_require__(248),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.complexFiltration.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.complexFiltration.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-00866a0d\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-00866a0d\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5jb21wbGV4RmlsdHJhdGlvbi52dWU/NTM4NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy5jb21wbGV4RmlsdHJhdGlvbi52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTAwODY2YTBkXFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Brcy5jb21wbGV4RmlsdHJhdGlvbi52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MuY29tcGxleEZpbHRyYXRpb24udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MuY29tcGxleEZpbHRyYXRpb24udnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTAwODY2YTBkXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMDA4NjZhMGRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLmNvbXBsZXhGaWx0cmF0aW9uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(226),\n  /* template */\n  __webpack_require__(254),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.ctabs.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.ctabs.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-27c96d90\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-27c96d90\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5jdGFicy52dWU/NzA0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6Ijg3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy5jdGFicy52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTI3Yzk2ZDkwXFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Brcy5jdGFicy52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MuY3RhYnMudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MuY3RhYnMudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTI3Yzk2ZDkwXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMjdjOTZkOTBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLmN0YWJzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(227),\n  /* template */\n  __webpack_require__(250),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.filterlist.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.filterlist.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-116b44f7\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-116b44f7\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5maWx0ZXJsaXN0LnZ1ZT8yZWViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiODguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcGtzLmZpbHRlcmxpc3QudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0xMTZiNDRmN1xcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3MuZmlsdGVybGlzdC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MuZmlsdGVybGlzdC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5maWx0ZXJsaXN0LnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xMTZiNDRmN1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTExNmI0NGY3XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5maWx0ZXJsaXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(228),\n  /* template */\n  __webpack_require__(253),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.imglist.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.imglist.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-1768a850\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-1768a850\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5pbWdsaXN0LnZ1ZT80NGRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcGtzLmltZ2xpc3QudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0xNzY4YTg1MFxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3MuaW1nbGlzdC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MuaW1nbGlzdC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5pbWdsaXN0LnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xNzY4YTg1MFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTE3NjhhODUwXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5pbWdsaXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(229),\n  /* template */\n  __webpack_require__(261),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.imgviewer.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.imgviewer.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-8eba9d78\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-8eba9d78\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5pbWd2aWV3ZXIudnVlPzhhMDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI5MC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3MuaW1ndmlld2VyLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtOGViYTlkNzhcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLmltZ3ZpZXdlci52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MuaW1ndmlld2VyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gcGtzLmltZ3ZpZXdlci52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtOGViYTlkNzhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi04ZWJhOWQ3OFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MuaW1ndmlld2VyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(232),\n  /* template */\n  __webpack_require__(260),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.listm.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.listm.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-83d18084\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-83d18084\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0bS52dWU/ZTc1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjkxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy5saXN0bS52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTgzZDE4MDg0XFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Brcy5saXN0bS52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MubGlzdG0udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MubGlzdG0udnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTgzZDE4MDg0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtODNkMTgwODRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLmxpc3RtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(233),\n  /* template */\n  __webpack_require__(255),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.listtable.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.listtable.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-2962c3c2\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-2962c3c2\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0dGFibGUudnVlPzA5OTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3MubGlzdHRhYmxlLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMjk2MmMzYzJcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLmxpc3R0YWJsZS52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MubGlzdHRhYmxlLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gcGtzLmxpc3R0YWJsZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMjk2MmMzYzJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0yOTYyYzNjMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MubGlzdHRhYmxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(234),\n  /* template */\n  __webpack_require__(264),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.multipleTitle.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.multipleTitle.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-a5fc9252\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-a5fc9252\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5tdWx0aXBsZVRpdGxlLnZ1ZT8zZDRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcGtzLm11bHRpcGxlVGl0bGUudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1hNWZjOTI1MlxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3MubXVsdGlwbGVUaXRsZS52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MubXVsdGlwbGVUaXRsZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5tdWx0aXBsZVRpdGxlLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1hNWZjOTI1MlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWE1ZmM5MjUyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5tdWx0aXBsZVRpdGxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(235),\n  /* template */\n  __webpack_require__(258),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.nostructtable.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.nostructtable.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-57eb6567\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-57eb6567\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5ub3N0cnVjdHRhYmxlLnZ1ZT8zZThjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcGtzLm5vc3RydWN0dGFibGUudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01N2ViNjU2N1xcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3Mubm9zdHJ1Y3R0YWJsZS52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3Mubm9zdHJ1Y3R0YWJsZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5ub3N0cnVjdHRhYmxlLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01N2ViNjU2N1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTU3ZWI2NTY3XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5ub3N0cnVjdHRhYmxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nfunction injectStyle (ssrContext) {\n  if (disposed) return\n  __webpack_require__(272)\n}\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(236),\n  /* template */\n  __webpack_require__(257),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  \"data-v-3c0291f2\",\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.pager.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.pager.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-3c0291f2\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-3c0291f2\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYWdlci52dWU/OWYyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd047QUFDeE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI5NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2MwMjkxZjJcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vcGtzLnBhZ2VyLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcGtzLnBhZ2VyLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2MwMjkxZjJcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLnBhZ2VyLnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIGluamVjdFN0eWxlLFxuICAvKiBzY29wZUlkICovXG4gIFwiZGF0YS12LTNjMDI5MWYyXCIsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MucGFnZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MucGFnZXIudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTNjMDI5MWYyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtM2MwMjkxZjJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnBhZ2VyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(238),\n  /* template */\n  __webpack_require__(249),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.panel2.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.panel2.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-11527c0f\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-11527c0f\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbDIudnVlPzI3NDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI5Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3MucGFuZWwyLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTE1MjdjMGZcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLnBhbmVsMi52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3MucGFuZWwyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gcGtzLnBhbmVsMi52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMTE1MjdjMGZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0xMTUyN2MwZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MucGFuZWwyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(240),\n  /* template */\n  __webpack_require__(251),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.singleTitle.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.singleTitle.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-1363f15f\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-1363f15f\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zaW5nbGVUaXRsZS52dWU/Yzk3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0RBQXNELElBQUk7QUFDekksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6Ijk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy5zaW5nbGVUaXRsZS52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTEzNjNmMTVmXFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3Brcy5zaW5nbGVUaXRsZS52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3Muc2luZ2xlVGl0bGUudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3Muc2luZ2xlVGl0bGUudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTEzNjNmMTVmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMTM2M2YxNWZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnNpbmdsZVRpdGxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(241),\n  /* template */\n  __webpack_require__(268),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.singleimg.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.singleimg.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-dba11dac\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-dba11dac\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zaW5nbGVpbWcudnVlP2ViMmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3Muc2luZ2xlaW1nLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZGJhMTFkYWNcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLnNpbmdsZWltZy52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3Muc2luZ2xlaW1nLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gcGtzLnNpbmdsZWltZy52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZGJhMTFkYWNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1kYmExMWRhY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3Muc2luZ2xlaW1nLnZ1ZVxuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(242),\n  /* template */\n  __webpack_require__(263),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.sort.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.sort.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-a4f7bd82\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-a4f7bd82\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zb3J0LnZ1ZT85ZDExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcGtzLnNvcnQudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1hNGY3YmQ4MlxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3Muc29ydC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkY6XFxcXDAwMS1TVk5cXFxc5pCc57Si5Lia5Yqh6YOoXFxcXDAy5Lqn5ZOBXFxcXDA0UEtTMS4wXFxcXOW8gOWPkeW6k1xcXFwwNOe8lueggVxcXFxQS1MxLjBcXFxcMDJQS1MuVUlDb21wb25lbnRzXFxcXFBLUy5WdWVcXFxcU3JjXFxcXENvbXBvbmVudHNcXFxcU1pYVFxcXFxwa3Muc29ydC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5zb3J0LnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1hNGY3YmQ4MlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWE0ZjdiZDgyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zb3J0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(243),\n  /* template */\n  __webpack_require__(252),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\Src\\\\Components\\\\SZXT\\\\pks.tabs.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.tabs.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-15726f1f\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-15726f1f\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy50YWJzLnZ1ZT8yZWM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzREFBc0QsSUFBSTtBQUN6SSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3Brcy50YWJzLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTU3MjZmMWZcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcGtzLnRhYnMudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgbnVsbCxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJGOlxcXFwwMDEtU1ZOXFxcXOaQnOe0ouS4muWKoemDqFxcXFwwMuS6p+WTgVxcXFwwNFBLUzEuMFxcXFzlvIDlj5HlupNcXFxcMDTnvJbnoIFcXFxcUEtTMS4wXFxcXDAyUEtTLlVJQ29tcG9uZW50c1xcXFxQS1MuVnVlXFxcXFNyY1xcXFxDb21wb25lbnRzXFxcXFNaWFRcXFxccGtzLnRhYnMudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBwa3MudGFicy52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMTU3MjZmMWZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0xNTcyNmYxZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MudGFicy52dWVcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nfunction injectStyle (ssrContext) {\n  if (disposed) return\n  __webpack_require__(273)\n}\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(244),\n  /* template */\n  __webpack_require__(269),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\src\\\\Components\\\\DataRender\\\\pks.image.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] pks.image.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-e07f76f2\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-e07f76f2\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50cy9EYXRhUmVuZGVyL3Brcy5pbWFnZS52dWU/ZGIyZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeU47QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiIxMDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWUwN2Y3NmYyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9wa3MuaW1hZ2UudnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9wa3MuaW1hZ2UudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1lMDdmNzZmMlxcXCJ9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9wa3MuaW1hZ2UudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRjpcXFxcMDAxLVNWTlxcXFzmkJzntKLkuJrliqHpg6hcXFxcMDLkuqflk4FcXFxcMDRQS1MxLjBcXFxc5byA5Y+R5bqTXFxcXDA057yW56CBXFxcXFBLUzEuMFxcXFwwMlBLUy5VSUNvbXBvbmVudHNcXFxcUEtTLlZ1ZVxcXFxzcmNcXFxcQ29tcG9uZW50c1xcXFxEYXRhUmVuZGVyXFxcXHBrcy5pbWFnZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHBrcy5pbWFnZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZTA3Zjc2ZjJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1lMDdmNzZmMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0NvbXBvbmVudHMvRGF0YVJlbmRlci9wa3MuaW1hZ2UudnVlXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(245),\n  /* template */\n  __webpack_require__(265),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"F:\\\\001-SVN\\\\搜索业务部\\\\02产品\\\\04PKS1.0\\\\开发库\\\\04编码\\\\PKS1.0\\\\02PKS.UIComponents\\\\PKS.Vue\\\\src\\\\Components\\\\Samples\\\\demo.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] demo.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-c04a604c\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-c04a604c\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50cy9TYW1wbGVzL2RlbW8udnVlP2UxN2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiIxMDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vZGVtby52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWMwNGE2MDRjXFxcIn0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2RlbW8udnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgbnVsbCxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJGOlxcXFwwMDEtU1ZOXFxcXOaQnOe0ouS4muWKoemDqFxcXFwwMuS6p+WTgVxcXFwwNFBLUzEuMFxcXFzlvIDlj5HlupNcXFxcMDTnvJbnoIFcXFxcUEtTMS4wXFxcXDAyUEtTLlVJQ29tcG9uZW50c1xcXFxQS1MuVnVlXFxcXHNyY1xcXFxDb21wb25lbnRzXFxcXFNhbXBsZXNcXFxcZGVtby52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGRlbW8udnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWMwNGE2MDRjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtYzA0YTYwNGNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9Db21wb25lbnRzL1NhbXBsZXMvZGVtby52dWVcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export Url */\n/* unused harmony export Http */\n/* unused harmony export Resource */\n/*!\n * vue-resource v1.3.4\n * https://github.com/pagekit/vue-resource\n * Released under the MIT License.\n */\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nvar RESOLVED = 0;\nvar REJECTED = 1;\nvar PENDING  = 2;\n\nfunction Promise$1(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    var promise = this;\n\n    try {\n        executor(function (x) {\n            promise.resolve(x);\n        }, function (r) {\n            promise.reject(r);\n        });\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromise$1.reject = function (r) {\n    return new Promise$1(function (resolve, reject) {\n        reject(r);\n    });\n};\n\nPromise$1.resolve = function (x) {\n    return new Promise$1(function (resolve, reject) {\n        resolve(x);\n    });\n};\n\nPromise$1.all = function all(iterable) {\n    return new Promise$1(function (resolve, reject) {\n        var count = 0, result = [];\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$1.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromise$1.race = function race(iterable) {\n    return new Promise$1(function (resolve, reject) {\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$1.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nvar p$1 = Promise$1.prototype;\n\np$1.resolve = function resolve(x) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        var called = false;\n\n        try {\n            var then = x && x['then'];\n\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\n                then.call(x, function (x) {\n                    if (!called) {\n                        promise.resolve(x);\n                    }\n                    called = true;\n\n                }, function (r) {\n                    if (!called) {\n                        promise.reject(r);\n                    }\n                    called = true;\n                });\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np$1.reject = function reject(reason) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np$1.notify = function notify() {\n    var promise = this;\n\n    nextTick(function () {\n        if (promise.state !== PENDING) {\n            while (promise.deferred.length) {\n                var deferred = promise.deferred.shift(),\n                    onResolved = deferred[0],\n                    onRejected = deferred[1],\n                    resolve = deferred[2],\n                    reject = deferred[3];\n\n                try {\n                    if (promise.state === RESOLVED) {\n                        if (typeof onResolved === 'function') {\n                            resolve(onResolved.call(undefined, promise.value));\n                        } else {\n                            resolve(promise.value);\n                        }\n                    } else if (promise.state === REJECTED) {\n                        if (typeof onRejected === 'function') {\n                            resolve(onRejected.call(undefined, promise.value));\n                        } else {\n                            reject(promise.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np$1.then = function then(onResolved, onRejected) {\n    var promise = this;\n\n    return new Promise$1(function (resolve, reject) {\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n        promise.notify();\n    });\n};\n\np$1.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\n/**\n * Promise adapter.\n */\n\nif (typeof Promise === 'undefined') {\n    window.Promise = Promise$1;\n}\n\nfunction PromiseObj(executor, context) {\n\n    if (executor instanceof Promise) {\n        this.promise = executor;\n    } else {\n        this.promise = new Promise(executor.bind(context));\n    }\n\n    this.context = context;\n}\n\nPromiseObj.all = function (iterable, context) {\n    return new PromiseObj(Promise.all(iterable), context);\n};\n\nPromiseObj.resolve = function (value, context) {\n    return new PromiseObj(Promise.resolve(value), context);\n};\n\nPromiseObj.reject = function (reason, context) {\n    return new PromiseObj(Promise.reject(reason), context);\n};\n\nPromiseObj.race = function (iterable, context) {\n    return new PromiseObj(Promise.race(iterable), context);\n};\n\nvar p = PromiseObj.prototype;\n\np.bind = function (context) {\n    this.context = context;\n    return this;\n};\n\np.then = function (fulfilled, rejected) {\n\n    if (fulfilled && fulfilled.bind && this.context) {\n        fulfilled = fulfilled.bind(this.context);\n    }\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);\n};\n\np.catch = function (rejected) {\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new PromiseObj(this.promise.catch(rejected), this.context);\n};\n\np.finally = function (callback) {\n\n    return this.then(function (value) {\n            callback.call(this);\n            return value;\n        }, function (reason) {\n            callback.call(this);\n            return Promise.reject(reason);\n        }\n    );\n};\n\n/**\n * Utility functions.\n */\n\nvar ref = {};\nvar hasOwnProperty = ref.hasOwnProperty;\n\nvar ref$1 = [];\nvar slice = ref$1.slice;\nvar debug = false;\nvar ntick;\n\nvar inBrowser = typeof window !== 'undefined';\n\nvar Util = function (ref) {\n    var config = ref.config;\n    var nextTick = ref.nextTick;\n\n    ntick = nextTick;\n    debug = config.debug || !config.silent;\n};\n\nfunction warn(msg) {\n    if (typeof console !== 'undefined' && debug) {\n        console.warn('[VueResource warn]: ' + msg);\n    }\n}\n\nfunction error(msg) {\n    if (typeof console !== 'undefined') {\n        console.error(msg);\n    }\n}\n\nfunction nextTick(cb, ctx) {\n    return ntick(cb, ctx);\n}\n\nfunction trim(str) {\n    return str ? str.replace(/^\\s*|\\s*$/g, '') : '';\n}\n\nfunction trimEnd(str, chars) {\n\n    if (str && chars === undefined) {\n        return str.replace(/\\s+$/, '');\n    }\n\n    if (!str || !chars) {\n        return str;\n    }\n\n    return str.replace(new RegExp((\"[\" + chars + \"]+$\")), '');\n}\n\nfunction toLower(str) {\n    return str ? str.toLowerCase() : '';\n}\n\nfunction toUpper(str) {\n    return str ? str.toUpperCase() : '';\n}\n\nvar isArray = Array.isArray;\n\nfunction isString(val) {\n    return typeof val === 'string';\n}\n\n\n\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n}\n\nfunction isBlob(obj) {\n    return typeof Blob !== 'undefined' && obj instanceof Blob;\n}\n\nfunction isFormData(obj) {\n    return typeof FormData !== 'undefined' && obj instanceof FormData;\n}\n\nfunction when(value, fulfilled, rejected) {\n\n    var promise = PromiseObj.resolve(value);\n\n    if (arguments.length < 2) {\n        return promise;\n    }\n\n    return promise.then(fulfilled, rejected);\n}\n\nfunction options(fn, obj, opts) {\n\n    opts = opts || {};\n\n    if (isFunction(opts)) {\n        opts = opts.call(obj);\n    }\n\n    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});\n}\n\nfunction each(obj, iterator) {\n\n    var i, key;\n\n    if (isArray(obj)) {\n        for (i = 0; i < obj.length; i++) {\n            iterator.call(obj[i], obj[i], i);\n        }\n    } else if (isObject(obj)) {\n        for (key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                iterator.call(obj[key], obj[key], key);\n            }\n        }\n    }\n\n    return obj;\n}\n\nvar assign = Object.assign || _assign;\n\nfunction merge(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source, true);\n    });\n\n    return target;\n}\n\nfunction defaults(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n\n        for (var key in source) {\n            if (target[key] === undefined) {\n                target[key] = source[key];\n            }\n        }\n\n    });\n\n    return target;\n}\n\nfunction _assign(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source);\n    });\n\n    return target;\n}\n\nfunction _merge(target, source, deep) {\n    for (var key in source) {\n        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n                target[key] = {};\n            }\n            if (isArray(source[key]) && !isArray(target[key])) {\n                target[key] = [];\n            }\n            _merge(target[key], source[key], deep);\n        } else if (source[key] !== undefined) {\n            target[key] = source[key];\n        }\n    }\n}\n\n/**\n * Root Prefix Transform.\n */\n\nvar root = function (options$$1, next) {\n\n    var url = next(options$$1);\n\n    if (isString(options$$1.root) && !/^(https?:)?\\//.test(url)) {\n        url = trimEnd(options$$1.root, '/') + '/' + url;\n    }\n\n    return url;\n};\n\n/**\n * Query Parameter Transform.\n */\n\nvar query = function (options$$1, next) {\n\n    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);\n\n    each(options$$1.params, function (value, key) {\n        if (urlParams.indexOf(key) === -1) {\n            query[key] = value;\n        }\n    });\n\n    query = Url.params(query);\n\n    if (query) {\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n    }\n\n    return url;\n};\n\n/**\n * URL Template v2.0.6 (https://github.com/bramstein/url-template)\n */\n\nfunction expand(url, params, variables) {\n\n    var tmpl = parse(url), expanded = tmpl.expand(params);\n\n    if (variables) {\n        variables.push.apply(variables, tmpl.vars);\n    }\n\n    return expanded;\n}\n\nfunction parse(template) {\n\n    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];\n\n    return {\n        vars: variables,\n        expand: function expand(context) {\n            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n                if (expression) {\n\n                    var operator = null, values = [];\n\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\n                        operator = expression.charAt(0);\n                        expression = expression.substr(1);\n                    }\n\n                    expression.split(/,/g).forEach(function (variable) {\n                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n                        variables.push(tmp[1]);\n                    });\n\n                    if (operator && operator !== '+') {\n\n                        var separator = ',';\n\n                        if (operator === '?') {\n                            separator = '&';\n                        } else if (operator !== '#') {\n                            separator = operator;\n                        }\n\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\n                    } else {\n                        return values.join(',');\n                    }\n\n                } else {\n                    return encodeReserved(literal);\n                }\n            });\n        }\n    };\n}\n\nfunction getValues(context, operator, key, modifier) {\n\n    var value = context[key], result = [];\n\n    if (isDefined(value) && value !== '') {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n            value = value.toString();\n\n            if (modifier && modifier !== '*') {\n                value = value.substring(0, parseInt(modifier, 10));\n            }\n\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n        } else {\n            if (modifier === '*') {\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            result.push(encodeValue(operator, value[k], k));\n                        }\n                    });\n                }\n            } else {\n                var tmp = [];\n\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        tmp.push(encodeValue(operator, value));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            tmp.push(encodeURIComponent(k));\n                            tmp.push(encodeValue(operator, value[k].toString()));\n                        }\n                    });\n                }\n\n                if (isKeyOperator(operator)) {\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n                } else if (tmp.length !== 0) {\n                    result.push(tmp.join(','));\n                }\n            }\n        }\n    } else {\n        if (operator === ';') {\n            result.push(encodeURIComponent(key));\n        } else if (value === '' && (operator === '&' || operator === '?')) {\n            result.push(encodeURIComponent(key) + '=');\n        } else if (value === '') {\n            result.push('');\n        }\n    }\n\n    return result;\n}\n\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\n\nfunction isKeyOperator(operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n}\n\nfunction encodeValue(operator, value, key) {\n\n    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);\n\n    if (key) {\n        return encodeURIComponent(key) + '=' + value;\n    } else {\n        return value;\n    }\n}\n\nfunction encodeReserved(str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n        if (!/%[0-9A-Fa-f]/.test(part)) {\n            part = encodeURI(part);\n        }\n        return part;\n    }).join('');\n}\n\n/**\n * URL Template (RFC 6570) Transform.\n */\n\nvar template = function (options) {\n\n    var variables = [], url = expand(options.url, options.params, variables);\n\n    variables.forEach(function (key) {\n        delete options.params[key];\n    });\n\n    return url;\n};\n\n/**\n * Service for URL templating.\n */\n\nfunction Url(url, params) {\n\n    var self = this || {}, options$$1 = url, transform;\n\n    if (isString(url)) {\n        options$$1 = {url: url, params: params};\n    }\n\n    options$$1 = merge({}, Url.options, self.$options, options$$1);\n\n    Url.transforms.forEach(function (handler) {\n\n        if (isString(handler)) {\n            handler = Url.transform[handler];\n        }\n\n        if (isFunction(handler)) {\n            transform = factory(handler, transform, self.$vm);\n        }\n\n    });\n\n    return transform(options$$1);\n}\n\n/**\n * Url options.\n */\n\nUrl.options = {\n    url: '',\n    root: null,\n    params: {}\n};\n\n/**\n * Url transforms.\n */\n\nUrl.transform = {template: template, query: query, root: root};\nUrl.transforms = ['template', 'query', 'root'];\n\n/**\n * Encodes a Url parameter string.\n *\n * @param {Object} obj\n */\n\nUrl.params = function (obj) {\n\n    var params = [], escape = encodeURIComponent;\n\n    params.add = function (key, value) {\n\n        if (isFunction(value)) {\n            value = value();\n        }\n\n        if (value === null) {\n            value = '';\n        }\n\n        this.push(escape(key) + '=' + escape(value));\n    };\n\n    serialize(params, obj);\n\n    return params.join('&').replace(/%20/g, '+');\n};\n\n/**\n * Parse a URL and return its components.\n *\n * @param {String} url\n */\n\nUrl.parse = function (url) {\n\n    var el = document.createElement('a');\n\n    if (document.documentMode) {\n        el.href = url;\n        url = el.href;\n    }\n\n    el.href = url;\n\n    return {\n        href: el.href,\n        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n        port: el.port,\n        host: el.host,\n        hostname: el.hostname,\n        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n        search: el.search ? el.search.replace(/^\\?/, '') : '',\n        hash: el.hash ? el.hash.replace(/^#/, '') : ''\n    };\n};\n\nfunction factory(handler, next, vm) {\n    return function (options$$1) {\n        return handler.call(vm, options$$1, next);\n    };\n}\n\nfunction serialize(params, obj, scope) {\n\n    var array = isArray(obj), plain = isPlainObject(obj), hash;\n\n    each(obj, function (value, key) {\n\n        hash = isObject(value) || isArray(value);\n\n        if (scope) {\n            key = scope + '[' + (plain || hash ? key : '') + ']';\n        }\n\n        if (!scope && array) {\n            params.add(value.name, value.value);\n        } else if (hash) {\n            serialize(params, value, key);\n        } else {\n            params.add(key, value);\n        }\n    });\n}\n\n/**\n * XDomain client (Internet Explorer).\n */\n\nvar xdrClient = function (request) {\n    return new PromiseObj(function (resolve) {\n\n        var xdr = new XDomainRequest(), handler = function (ref) {\n            var type = ref.type;\n\n\n            var status = 0;\n\n            if (type === 'load') {\n                status = 200;\n            } else if (type === 'error') {\n                status = 500;\n            }\n\n            resolve(request.respondWith(xdr.responseText, {status: status}));\n        };\n\n        request.abort = function () { return xdr.abort(); };\n\n        xdr.open(request.method, request.getUrl());\n\n        if (request.timeout) {\n            xdr.timeout = request.timeout;\n        }\n\n        xdr.onload = handler;\n        xdr.onabort = handler;\n        xdr.onerror = handler;\n        xdr.ontimeout = handler;\n        xdr.onprogress = function () {};\n        xdr.send(request.getBody());\n    });\n};\n\n/**\n * CORS Interceptor.\n */\n\nvar SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();\n\nvar cors = function (request, next) {\n\n    if (inBrowser) {\n\n        var orgUrl = Url.parse(location.href);\n        var reqUrl = Url.parse(request.getUrl());\n\n        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {\n\n            request.crossOrigin = true;\n            request.emulateHTTP = false;\n\n            if (!SUPPORTS_CORS) {\n                request.client = xdrClient;\n            }\n        }\n    }\n\n    next();\n};\n\n/**\n * Form data Interceptor.\n */\n\nvar form = function (request, next) {\n\n    if (isFormData(request.body)) {\n\n        request.headers.delete('Content-Type');\n\n    } else if (isObject(request.body) && request.emulateJSON) {\n\n        request.body = Url.params(request.body);\n        request.headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    }\n\n    next();\n};\n\n/**\n * JSON Interceptor.\n */\n\nvar json = function (request, next) {\n\n    var type = request.headers.get('Content-Type') || '';\n\n    if (isObject(request.body) && type.indexOf('application/json') === 0) {\n        request.body = JSON.stringify(request.body);\n    }\n\n    next(function (response) {\n\n        return response.bodyText ? when(response.text(), function (text) {\n\n            type = response.headers.get('Content-Type') || '';\n\n            if (type.indexOf('application/json') === 0 || isJson(text)) {\n\n                try {\n                    response.body = JSON.parse(text);\n                } catch (e) {\n                    response.body = null;\n                }\n\n            } else {\n                response.body = text;\n            }\n\n            return response;\n\n        }) : response;\n\n    });\n};\n\nfunction isJson(str) {\n\n    var start = str.match(/^\\[|^\\{(?!\\{)/), end = {'[': /]$/, '{': /}$/};\n\n    return start && end[start[0]].test(str);\n}\n\n/**\n * JSONP client (Browser).\n */\n\nvar jsonpClient = function (request) {\n    return new PromiseObj(function (resolve) {\n\n        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;\n\n        handler = function (ref) {\n            var type = ref.type;\n\n\n            var status = 0;\n\n            if (type === 'load' && body !== null) {\n                status = 200;\n            } else if (type === 'error') {\n                status = 500;\n            }\n\n            if (status && window[callback]) {\n                delete window[callback];\n                document.body.removeChild(script);\n            }\n\n            resolve(request.respondWith(body, {status: status}));\n        };\n\n        window[callback] = function (result) {\n            body = JSON.stringify(result);\n        };\n\n        request.abort = function () {\n            handler({type: 'abort'});\n        };\n\n        request.params[name] = callback;\n\n        if (request.timeout) {\n            setTimeout(request.abort, request.timeout);\n        }\n\n        script = document.createElement('script');\n        script.src = request.getUrl();\n        script.type = 'text/javascript';\n        script.async = true;\n        script.onload = handler;\n        script.onerror = handler;\n\n        document.body.appendChild(script);\n    });\n};\n\n/**\n * JSONP Interceptor.\n */\n\nvar jsonp = function (request, next) {\n\n    if (request.method == 'JSONP') {\n        request.client = jsonpClient;\n    }\n\n    next();\n};\n\n/**\n * Before Interceptor.\n */\n\nvar before = function (request, next) {\n\n    if (isFunction(request.before)) {\n        request.before.call(this, request);\n    }\n\n    next();\n};\n\n/**\n * HTTP method override Interceptor.\n */\n\nvar method = function (request, next) {\n\n    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\n        request.headers.set('X-HTTP-Method-Override', request.method);\n        request.method = 'POST';\n    }\n\n    next();\n};\n\n/**\n * Header Interceptor.\n */\n\nvar header = function (request, next) {\n\n    var headers = assign({}, Http.headers.common,\n        !request.crossOrigin ? Http.headers.custom : {},\n        Http.headers[toLower(request.method)]\n    );\n\n    each(headers, function (value, name) {\n        if (!request.headers.has(name)) {\n            request.headers.set(name, value);\n        }\n    });\n\n    next();\n};\n\n/**\n * XMLHttp client (Browser).\n */\n\nvar xhrClient = function (request) {\n    return new PromiseObj(function (resolve) {\n\n        var xhr = new XMLHttpRequest(), handler = function (event) {\n\n            var response = request.respondWith(\n                'response' in xhr ? xhr.response : xhr.responseText, {\n                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\n                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)\n                }\n            );\n\n            each(trim(xhr.getAllResponseHeaders()).split('\\n'), function (row) {\n                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));\n            });\n\n            resolve(response);\n        };\n\n        request.abort = function () { return xhr.abort(); };\n\n        if (request.progress) {\n            if (request.method === 'GET') {\n                xhr.addEventListener('progress', request.progress);\n            } else if (/^(POST|PUT)$/i.test(request.method)) {\n                xhr.upload.addEventListener('progress', request.progress);\n            }\n        }\n\n        xhr.open(request.method, request.getUrl(), true);\n\n        if (request.timeout) {\n            xhr.timeout = request.timeout;\n        }\n\n        if (request.responseType && 'responseType' in xhr) {\n            xhr.responseType = request.responseType;\n        }\n\n        if (request.withCredentials || request.credentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (!request.crossOrigin) {\n            request.headers.set('X-Requested-With', 'XMLHttpRequest');\n        }\n\n        request.headers.forEach(function (value, name) {\n            xhr.setRequestHeader(name, value);\n        });\n\n        xhr.onload = handler;\n        xhr.onabort = handler;\n        xhr.onerror = handler;\n        xhr.ontimeout = handler;\n        xhr.send(request.getBody());\n    });\n};\n\n/**\n * Http client (Node).\n */\n\nvar nodeClient = function (request) {\n\n    var client = __webpack_require__(276);\n\n    return new PromiseObj(function (resolve) {\n\n        var url = request.getUrl();\n        var body = request.getBody();\n        var method = request.method;\n        var headers = {}, handler;\n\n        request.headers.forEach(function (value, name) {\n            headers[name] = value;\n        });\n\n        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {\n\n            var response = request.respondWith(resp.body, {\n                    status: resp.statusCode,\n                    statusText: trim(resp.statusMessage)\n                }\n            );\n\n            each(resp.headers, function (value, name) {\n                response.headers.set(name, value);\n            });\n\n            resolve(response);\n\n        }, function (error$$1) { return handler(error$$1.response); });\n    });\n};\n\n/**\n * Base client.\n */\n\nvar Client = function (context) {\n\n    var reqHandlers = [sendRequest], resHandlers = [], handler;\n\n    if (!isObject(context)) {\n        context = null;\n    }\n\n    function Client(request) {\n        return new PromiseObj(function (resolve, reject) {\n\n            function exec() {\n\n                handler = reqHandlers.pop();\n\n                if (isFunction(handler)) {\n                    handler.call(context, request, next);\n                } else {\n                    warn((\"Invalid interceptor of type \" + (typeof handler) + \", must be a function\"));\n                    next();\n                }\n            }\n\n            function next(response) {\n\n                if (isFunction(response)) {\n\n                    resHandlers.unshift(response);\n\n                } else if (isObject(response)) {\n\n                    resHandlers.forEach(function (handler) {\n                        response = when(response, function (response) {\n                            return handler.call(context, response) || response;\n                        }, reject);\n                    });\n\n                    when(response, resolve, reject);\n\n                    return;\n                }\n\n                exec();\n            }\n\n            exec();\n\n        }, context);\n    }\n\n    Client.use = function (handler) {\n        reqHandlers.push(handler);\n    };\n\n    return Client;\n};\n\nfunction sendRequest(request, resolve) {\n\n    var client = request.client || (inBrowser ? xhrClient : nodeClient);\n\n    resolve(client(request));\n}\n\n/**\n * HTTP Headers.\n */\n\nvar Headers = function Headers(headers) {\n    var this$1 = this;\n\n\n    this.map = {};\n\n    each(headers, function (value, name) { return this$1.append(name, value); });\n};\n\nHeaders.prototype.has = function has (name) {\n    return getName(this.map, name) !== null;\n};\n\nHeaders.prototype.get = function get (name) {\n\n    var list = this.map[getName(this.map, name)];\n\n    return list ? list.join() : null;\n};\n\nHeaders.prototype.getAll = function getAll (name) {\n    return this.map[getName(this.map, name)] || [];\n};\n\nHeaders.prototype.set = function set (name, value) {\n    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];\n};\n\nHeaders.prototype.append = function append (name, value){\n\n    var list = this.map[getName(this.map, name)];\n\n    if (list) {\n        list.push(trim(value));\n    } else {\n        this.set(name, value);\n    }\n};\n\nHeaders.prototype.delete = function delete$1 (name){\n    delete this.map[getName(this.map, name)];\n};\n\nHeaders.prototype.deleteAll = function deleteAll (){\n    this.map = {};\n};\n\nHeaders.prototype.forEach = function forEach (callback, thisArg) {\n        var this$1 = this;\n\n    each(this.map, function (list, name) {\n        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });\n    });\n};\n\nfunction getName(map, name) {\n    return Object.keys(map).reduce(function (prev, curr) {\n        return toLower(name) === toLower(curr) ? curr : prev;\n    }, null);\n}\n\nfunction normalizeName(name) {\n\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n        throw new TypeError('Invalid character in header field name');\n    }\n\n    return trim(name);\n}\n\n/**\n * HTTP Response.\n */\n\nvar Response = function Response(body, ref) {\n    var url = ref.url;\n    var headers = ref.headers;\n    var status = ref.status;\n    var statusText = ref.statusText;\n\n\n    this.url = url;\n    this.ok = status >= 200 && status < 300;\n    this.status = status || 0;\n    this.statusText = statusText || '';\n    this.headers = new Headers(headers);\n    this.body = body;\n\n    if (isString(body)) {\n\n        this.bodyText = body;\n\n    } else if (isBlob(body)) {\n\n        this.bodyBlob = body;\n\n        if (isBlobText(body)) {\n            this.bodyText = blobText(body);\n        }\n    }\n};\n\nResponse.prototype.blob = function blob () {\n    return when(this.bodyBlob);\n};\n\nResponse.prototype.text = function text () {\n    return when(this.bodyText);\n};\n\nResponse.prototype.json = function json () {\n    return when(this.text(), function (text) { return JSON.parse(text); });\n};\n\nObject.defineProperty(Response.prototype, 'data', {\n\n    get: function get() {\n        return this.body;\n    },\n\n    set: function set(body) {\n        this.body = body;\n    }\n\n});\n\nfunction blobText(body) {\n    return new PromiseObj(function (resolve) {\n\n        var reader = new FileReader();\n\n        reader.readAsText(body);\n        reader.onload = function () {\n            resolve(reader.result);\n        };\n\n    });\n}\n\nfunction isBlobText(body) {\n    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;\n}\n\n/**\n * HTTP Request.\n */\n\nvar Request = function Request(options$$1) {\n\n    this.body = null;\n    this.params = {};\n\n    assign(this, options$$1, {\n        method: toUpper(options$$1.method || 'GET')\n    });\n\n    if (!(this.headers instanceof Headers)) {\n        this.headers = new Headers(this.headers);\n    }\n};\n\nRequest.prototype.getUrl = function getUrl (){\n    return Url(this);\n};\n\nRequest.prototype.getBody = function getBody (){\n    return this.body;\n};\n\nRequest.prototype.respondWith = function respondWith (body, options$$1) {\n    return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));\n};\n\n/**\n * Service for sending network requests.\n */\n\nvar COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};\nvar JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};\n\nfunction Http(options$$1) {\n\n    var self = this || {}, client = Client(self.$vm);\n\n    defaults(options$$1 || {}, self.$options, Http.options);\n\n    Http.interceptors.forEach(function (handler) {\n\n        if (isString(handler)) {\n            handler = Http.interceptor[handler];\n        }\n\n        if (isFunction(handler)) {\n            client.use(handler);\n        }\n\n    });\n\n    return client(new Request(options$$1)).then(function (response) {\n\n        return response.ok ? response : PromiseObj.reject(response);\n\n    }, function (response) {\n\n        if (response instanceof Error) {\n            error(response);\n        }\n\n        return PromiseObj.reject(response);\n    });\n}\n\nHttp.options = {};\n\nHttp.headers = {\n    put: JSON_CONTENT_TYPE,\n    post: JSON_CONTENT_TYPE,\n    patch: JSON_CONTENT_TYPE,\n    delete: JSON_CONTENT_TYPE,\n    common: COMMON_HEADERS,\n    custom: {}\n};\n\nHttp.interceptor = {before: before, method: method, jsonp: jsonp, json: json, form: form, header: header, cors: cors};\nHttp.interceptors = ['before', 'method', 'jsonp', 'json', 'form', 'header', 'cors'];\n\n['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {\n\n    Http[method$$1] = function (url, options$$1) {\n        return this(assign(options$$1 || {}, {url: url, method: method$$1}));\n    };\n\n});\n\n['post', 'put', 'patch'].forEach(function (method$$1) {\n\n    Http[method$$1] = function (url, body, options$$1) {\n        return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body}));\n    };\n\n});\n\n/**\n * Service for interacting with RESTful services.\n */\n\nfunction Resource(url, params, actions, options$$1) {\n\n    var self = this || {}, resource = {};\n\n    actions = assign({},\n        Resource.actions,\n        actions\n    );\n\n    each(actions, function (action, name) {\n\n        action = merge({url: url, params: assign({}, params)}, options$$1, action);\n\n        resource[name] = function () {\n            return (self.$http || Http)(opts(action, arguments));\n        };\n    });\n\n    return resource;\n}\n\nfunction opts(action, args) {\n\n    var options$$1 = assign({}, action), params = {}, body;\n\n    switch (args.length) {\n\n        case 2:\n\n            params = args[0];\n            body = args[1];\n\n            break;\n\n        case 1:\n\n            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {\n                body = args[0];\n            } else {\n                params = args[0];\n            }\n\n            break;\n\n        case 0:\n\n            break;\n\n        default:\n\n            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';\n    }\n\n    options$$1.body = body;\n    options$$1.params = assign({}, options$$1.params, params);\n\n    return options$$1;\n}\n\nResource.actions = {\n\n    get: {method: 'GET'},\n    save: {method: 'POST'},\n    query: {method: 'GET'},\n    update: {method: 'PUT'},\n    remove: {method: 'DELETE'},\n    delete: {method: 'DELETE'}\n\n};\n\n/**\n * Install plugin.\n */\n\nfunction plugin(Vue) {\n\n    if (plugin.installed) {\n        return;\n    }\n\n    Util(Vue);\n\n    Vue.url = Url;\n    Vue.http = Http;\n    Vue.resource = Resource;\n    Vue.Promise = PromiseObj;\n\n    Object.defineProperties(Vue.prototype, {\n\n        $url: {\n            get: function get() {\n                return options(Vue.url, this, this.$options.url);\n            }\n        },\n\n        $http: {\n            get: function get() {\n                return options(Vue.http, this, this.$options.http);\n            }\n        },\n\n        $resource: {\n            get: function get() {\n                return Vue.resource.bind(this);\n            }\n        },\n\n        $promise: {\n            get: function get() {\n                var this$1 = this;\n\n                return function (executor) { return new Vue.Promise(executor, this$1); };\n            }\n        }\n\n    });\n}\n\nif (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(plugin);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (plugin);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5lczIwMTUuanM/ZmM5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix5QkFBeUIsUUFBUSxlQUFlO0FBQzFFOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLLEVBQUUsS0FBSyxNQUFNLEVBQUU7QUFDM0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUEseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLDJEQUEyRCxlQUFlO0FBQzFFOztBQUVBLHFDQUFxQyxvQkFBb0I7O0FBRXpEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsa0NBQWtDLEtBQUssWUFBWSxhQUFhLEtBQUs7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxlQUFlO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBLHFDQUFxQyxvQkFBb0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLFNBQVM7O0FBRVQscUJBQXFCLDZDQUE2Qzs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQSxTQUFTLHVCQUF1QixtQ0FBbUMsRUFBRTtBQUNyRSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLDBDQUEwQyxtQ0FBbUMsRUFBRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxvREFBb0QsRUFBRTtBQUMzRixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMseUJBQXlCLEVBQUU7QUFDekU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsR0FBRyxtQkFBbUI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qix5QkFBeUIsa0NBQWtDOztBQUUzRDs7QUFFQSx5QkFBeUI7O0FBRXpCLDZCQUE2Qjs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDLEdBQUcsNEJBQTRCO0FBQzFFOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSwyQ0FBMkMsR0FBRyx3Q0FBd0M7QUFDdEY7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCOztBQUV6Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QiwyQkFBMkIsVUFBVTs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLDhCQUE4QixzQkFBc0I7O0FBRXBEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxjQUFjO0FBQ3hCLFdBQVcsZUFBZTtBQUMxQixZQUFZLGNBQWM7QUFDMUIsYUFBYSxjQUFjO0FBQzNCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLDBDQUEwQztBQUN0RjtBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDUSIsImZpbGUiOiIxMDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHZ1ZS1yZXNvdXJjZSB2MS4zLjRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWdla2l0L3Z1ZS1yZXNvdXJjZVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUHJvbWlzZXMvQSsgcG9seWZpbGwgdjEuMS40IChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3Byb21pcylcbiAqL1xuXG52YXIgUkVTT0xWRUQgPSAwO1xudmFyIFJFSkVDVEVEID0gMTtcbnZhciBQRU5ESU5HICA9IDI7XG5cbmZ1bmN0aW9uIFByb21pc2UkMShleGVjdXRvcikge1xuXG4gICAgdGhpcy5zdGF0ZSA9IFBFTkRJTkc7XG4gICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRlZmVycmVkID0gW107XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlJDEucmVqZWN0ID0gZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChyKTtcbiAgICB9KTtcbn07XG5cblByb21pc2UkMS5yZXNvbHZlID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUoeCk7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDEuYWxsID0gZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY291bnQgPSAwLCByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoaXRlcmFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlcihpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFByb21pc2UkMS5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmVyKGkpLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDEucmFjZSA9IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFByb21pc2UkMS5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnZhciBwJDEgPSBQcm9taXNlJDEucHJvdG90eXBlO1xuXG5wJDEucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICAgIGlmICh4ID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIHNldHRsZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0aGVuID0geCAmJiB4Wyd0aGVuJ107XG5cbiAgICAgICAgICAgIGlmICh4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoZW4uY2FsbCh4LCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVTT0xWRUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB4O1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5yZWplY3QgPSBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSBzZXR0bGVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gcmVhc29uO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvbWlzZS5zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICAgICAgd2hpbGUgKHByb21pc2UuZGVmZXJyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcHJvbWlzZS5kZWZlcnJlZC5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICBvblJlc29sdmVkID0gZGVmZXJyZWRbMF0sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQgPSBkZWZlcnJlZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IGRlZmVycmVkWzJdLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QgPSBkZWZlcnJlZFszXTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBSRVNPTFZFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlc29sdmVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob25SZWplY3RlZC5jYWxsKHVuZGVmaW5lZCwgcHJvbWlzZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnAkMS50aGVuID0gZnVuY3Rpb24gdGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9taXNlLmRlZmVycmVkLnB1c2goW29uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH0pO1xufTtcblxucCQxLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFByb21pc2UgYWRhcHRlci5cbiAqL1xuXG5pZiAodHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbmZ1bmN0aW9uIFByb21pc2VPYmooZXhlY3V0b3IsIGNvbnRleHQpIHtcblxuICAgIGlmIChleGVjdXRvciBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gZXhlY3V0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZXhlY3V0b3IuYmluZChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUHJvbWlzZU9iai5hbGwgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooUHJvbWlzZS5hbGwoaXRlcmFibGUpLCBjb250ZXh0KTtcbn07XG5cblByb21pc2VPYmoucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihQcm9taXNlLnJlc29sdmUodmFsdWUpLCBjb250ZXh0KTtcbn07XG5cblByb21pc2VPYmoucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbiwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihQcm9taXNlLnJlamVjdChyZWFzb24pLCBjb250ZXh0KTtcbn07XG5cblByb21pc2VPYmoucmFjZSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihQcm9taXNlLnJhY2UoaXRlcmFibGUpLCBjb250ZXh0KTtcbn07XG5cbnZhciBwID0gUHJvbWlzZU9iai5wcm90b3R5cGU7XG5cbnAuYmluZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnAudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG5cbiAgICBpZiAoZnVsZmlsbGVkICYmIGZ1bGZpbGxlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICBmdWxmaWxsZWQgPSBmdWxmaWxsZWQuYmluZCh0aGlzLmNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChyZWplY3RlZCAmJiByZWplY3RlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICByZWplY3RlZCA9IHJlamVjdGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmoodGhpcy5wcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCksIHRoaXMuY29udGV4dCk7XG59O1xuXG5wLmNhdGNoID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG5cbiAgICBpZiAocmVqZWN0ZWQgJiYgcmVqZWN0ZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKHRoaXMucHJvbWlzZS5jYXRjaChyZWplY3RlZCksIHRoaXMuY29udGV4dCk7XG59O1xuXG5wLmZpbmFsbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICApO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgcmVmID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG5cbnZhciByZWYkMSA9IFtdO1xudmFyIHNsaWNlID0gcmVmJDEuc2xpY2U7XG52YXIgZGVidWcgPSBmYWxzZTtcbnZhciBudGljaztcblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgVXRpbCA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgY29uZmlnID0gcmVmLmNvbmZpZztcbiAgICB2YXIgbmV4dFRpY2sgPSByZWYubmV4dFRpY2s7XG5cbiAgICBudGljayA9IG5leHRUaWNrO1xuICAgIGRlYnVnID0gY29uZmlnLmRlYnVnIHx8ICFjb25maWcuc2lsZW50O1xufTtcblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW1Z1ZVJlc291cmNlIHdhcm5dOiAnICsgbXNnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soY2IsIGN0eCkge1xuICAgIHJldHVybiBudGljayhjYiwgY3R4KTtcbn1cblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKSA6ICcnO1xufVxuXG5mdW5jdGlvbiB0cmltRW5kKHN0ciwgY2hhcnMpIHtcblxuICAgIGlmIChzdHIgJiYgY2hhcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgIH1cblxuICAgIGlmICghc3RyIHx8ICFjaGFycykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKChcIltcIiArIGNoYXJzICsgXCJdKyRcIikpLCAnJyk7XG59XG5cbmZ1bmN0aW9uIHRvTG93ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ciA/IHN0ci50b0xvd2VyQ2FzZSgpIDogJyc7XG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ciA/IHN0ci50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBpc0Jsb2Iob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBCbG9iO1xufVxuXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKG9iaikge1xuICAgIHJldHVybiB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEZvcm1EYXRhO1xufVxuXG5mdW5jdGlvbiB3aGVuKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2VPYmoucmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuZnVuY3Rpb24gb3B0aW9ucyhmbiwgb2JqLCBvcHRzKSB7XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdHMpKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzLmNhbGwob2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2UoZm4uYmluZCh7JHZtOiBvYmosICRvcHRpb25zOiBvcHRzfSksIGZuLCB7JG9wdGlvbnM6IG9wdHN9KTtcbn1cblxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yKSB7XG5cbiAgICB2YXIgaSwga2V5O1xuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtpXSwgb2JqW2ldLCBpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwob2JqW2tleV0sIG9ialtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgX2Fzc2lnbjtcblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQpIHtcblxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQpIHtcblxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgX21lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSwgZGVlcCkge1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGRlZXAgJiYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pIHx8IGlzQXJyYXkoc291cmNlW2tleV0pKSkge1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmICFpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNBcnJheShzb3VyY2Vba2V5XSkgJiYgIWlzQXJyYXkodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9tZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIGRlZXApO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUm9vdCBQcmVmaXggVHJhbnNmb3JtLlxuICovXG5cbnZhciByb290ID0gZnVuY3Rpb24gKG9wdGlvbnMkJDEsIG5leHQpIHtcblxuICAgIHZhciB1cmwgPSBuZXh0KG9wdGlvbnMkJDEpO1xuXG4gICAgaWYgKGlzU3RyaW5nKG9wdGlvbnMkJDEucm9vdCkgJiYgIS9eKGh0dHBzPzopP1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9IHRyaW1FbmQob3B0aW9ucyQkMS5yb290LCAnLycpICsgJy8nICsgdXJsO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFF1ZXJ5IFBhcmFtZXRlciBUcmFuc2Zvcm0uXG4gKi9cblxudmFyIHF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMkJDEsIG5leHQpIHtcblxuICAgIHZhciB1cmxQYXJhbXMgPSBPYmplY3Qua2V5cyhVcmwub3B0aW9ucy5wYXJhbXMpLCBxdWVyeSA9IHt9LCB1cmwgPSBuZXh0KG9wdGlvbnMkJDEpO1xuXG4gICAgZWFjaChvcHRpb25zJCQxLnBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHVybFBhcmFtcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHF1ZXJ5ID0gVXJsLnBhcmFtcyhxdWVyeSk7XG5cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09IC0xID8gJz8nIDogJyYnKSArIHF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFVSTCBUZW1wbGF0ZSB2Mi4wLjYgKGh0dHBzOi8vZ2l0aHViLmNvbS9icmFtc3RlaW4vdXJsLXRlbXBsYXRlKVxuICovXG5cbmZ1bmN0aW9uIGV4cGFuZCh1cmwsIHBhcmFtcywgdmFyaWFibGVzKSB7XG5cbiAgICB2YXIgdG1wbCA9IHBhcnNlKHVybCksIGV4cGFuZGVkID0gdG1wbC5leHBhbmQocGFyYW1zKTtcblxuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyaWFibGVzLnB1c2guYXBwbHkodmFyaWFibGVzLCB0bXBsLnZhcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUpIHtcblxuICAgIHZhciBvcGVyYXRvcnMgPSBbJysnLCAnIycsICcuJywgJy8nLCAnOycsICc/JywgJyYnXSwgdmFyaWFibGVzID0gW107XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2YXJzOiB2YXJpYWJsZXMsXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW15cXHtcXH1dKylcXH18KFteXFx7XFx9XSspL2csIGZ1bmN0aW9uIChfLCBleHByZXNzaW9uLCBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBudWxsLCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoZXhwcmVzc2lvbi5jaGFyQXQoMCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBleHByZXNzaW9uLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uc3BsaXQoLywvZykuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSAvKFteOlxcKl0qKSg/OjooXFxkKyl8KFxcKikpPy8uZXhlYyh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwgdG1wWzFdLCB0bXBbMl0gfHwgdG1wWzNdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMucHVzaCh0bXBbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgJiYgb3BlcmF0b3IgIT09ICcrJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gJywnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9ICcmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5sZW5ndGggIT09IDAgPyBvcGVyYXRvciA6ICcnKSArIHZhbHVlcy5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG5cbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0W2tleV0sIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyICYmIG1vZGlmaWVyICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IG51bGwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10sIGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIHRtcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbignLCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc7Jykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyAmJiAob3BlcmF0b3IgPT09ICcmJyB8fCBvcGVyYXRvciA9PT0gJz8nKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgICByZXR1cm4gb3BlcmF0b3IgPT09ICc7JyB8fCBvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPyc7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwga2V5KSB7XG5cbiAgICB2YWx1ZSA9IChvcGVyYXRvciA9PT0gJysnIHx8IG9wZXJhdG9yID09PSAnIycpID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvKCVbMC05QS1GYS1mXXsyfSkvZykubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIGlmICghLyVbMC05QS1GYS1mXS8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgcGFydCA9IGVuY29kZVVSSShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydDtcbiAgICB9KS5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBVUkwgVGVtcGxhdGUgKFJGQyA2NTcwKSBUcmFuc2Zvcm0uXG4gKi9cblxudmFyIHRlbXBsYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIHZhciB2YXJpYWJsZXMgPSBbXSwgdXJsID0gZXhwYW5kKG9wdGlvbnMudXJsLCBvcHRpb25zLnBhcmFtcywgdmFyaWFibGVzKTtcblxuICAgIHZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zW2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBVUkwgdGVtcGxhdGluZy5cbiAqL1xuXG5mdW5jdGlvbiBVcmwodXJsLCBwYXJhbXMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCB7fSwgb3B0aW9ucyQkMSA9IHVybCwgdHJhbnNmb3JtO1xuXG4gICAgaWYgKGlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgb3B0aW9ucyQkMSA9IHt1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXN9O1xuICAgIH1cblxuICAgIG9wdGlvbnMkJDEgPSBtZXJnZSh7fSwgVXJsLm9wdGlvbnMsIHNlbGYuJG9wdGlvbnMsIG9wdGlvbnMkJDEpO1xuXG4gICAgVXJsLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuXG4gICAgICAgIGlmIChpc1N0cmluZyhoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlciA9IFVybC50cmFuc2Zvcm1baGFuZGxlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gZmFjdG9yeShoYW5kbGVyLCB0cmFuc2Zvcm0sIHNlbGYuJHZtKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtKG9wdGlvbnMkJDEpO1xufVxuXG4vKipcbiAqIFVybCBvcHRpb25zLlxuICovXG5cblVybC5vcHRpb25zID0ge1xuICAgIHVybDogJycsXG4gICAgcm9vdDogbnVsbCxcbiAgICBwYXJhbXM6IHt9XG59O1xuXG4vKipcbiAqIFVybCB0cmFuc2Zvcm1zLlxuICovXG5cblVybC50cmFuc2Zvcm0gPSB7dGVtcGxhdGU6IHRlbXBsYXRlLCBxdWVyeTogcXVlcnksIHJvb3Q6IHJvb3R9O1xuVXJsLnRyYW5zZm9ybXMgPSBbJ3RlbXBsYXRlJywgJ3F1ZXJ5JywgJ3Jvb3QnXTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVXJsIHBhcmFtZXRlciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cblVybC5wYXJhbXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICB2YXIgcGFyYW1zID0gW10sIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIHNlcmlhbGl6ZShwYXJhbXMsIG9iaik7XG5cbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBVUkwgYW5kIHJldHVybiBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKi9cblxuVXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xuXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgaWYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSkge1xuICAgICAgICBlbC5ocmVmID0gdXJsO1xuICAgICAgICB1cmwgPSBlbC5ocmVmO1xuICAgIH1cblxuICAgIGVsLmhyZWYgPSB1cmw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiBlbC5ocmVmLFxuICAgICAgICBwcm90b2NvbDogZWwucHJvdG9jb2wgPyBlbC5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBwb3J0OiBlbC5wb3J0LFxuICAgICAgICBob3N0OiBlbC5ob3N0LFxuICAgICAgICBob3N0bmFtZTogZWwuaG9zdG5hbWUsXG4gICAgICAgIHBhdGhuYW1lOiBlbC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IGVsLnBhdGhuYW1lIDogJy8nICsgZWwucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogZWwuc2VhcmNoID8gZWwuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogZWwuaGFzaCA/IGVsLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJ1xuICAgIH07XG59O1xuXG5mdW5jdGlvbiBmYWN0b3J5KGhhbmRsZXIsIG5leHQsIHZtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zJCQxKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodm0sIG9wdGlvbnMkJDEsIG5leHQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgc2NvcGUpIHtcblxuICAgIHZhciBhcnJheSA9IGlzQXJyYXkob2JqKSwgcGxhaW4gPSBpc1BsYWluT2JqZWN0KG9iaiksIGhhc2g7XG5cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblxuICAgICAgICBoYXNoID0gaXNPYmplY3QodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAga2V5ID0gc2NvcGUgKyAnWycgKyAocGxhaW4gfHwgaGFzaCA/IGtleSA6ICcnKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc2gpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIFhEb21haW4gY2xpZW50IChJbnRlcm5ldCBFeHBsb3JlcikuXG4gKi9cblxudmFyIHhkckNsaWVudCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpLCBoYW5kbGVyID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcblxuXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsb2FkJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDUwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbmRXaXRoKHhkci5yZXNwb25zZVRleHQsIHtzdGF0dXM6IHN0YXR1c30pKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LmFib3J0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geGRyLmFib3J0KCk7IH07XG5cbiAgICAgICAgeGRyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCkpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHhkci50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgeGRyLm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHhkci5vbmFib3J0ID0gaGFuZGxlcjtcbiAgICAgICAgeGRyLm9uZXJyb3IgPSBoYW5kbGVyO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gaGFuZGxlcjtcbiAgICAgICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDT1JTIEludGVyY2VwdG9yLlxuICovXG5cbnZhciBTVVBQT1JUU19DT1JTID0gaW5Ccm93c2VyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG52YXIgY29ycyA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAoaW5Ccm93c2VyKSB7XG5cbiAgICAgICAgdmFyIG9yZ1VybCA9IFVybC5wYXJzZShsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgdmFyIHJlcVVybCA9IFVybC5wYXJzZShyZXF1ZXN0LmdldFVybCgpKTtcblxuICAgICAgICBpZiAocmVxVXJsLnByb3RvY29sICE9PSBvcmdVcmwucHJvdG9jb2wgfHwgcmVxVXJsLmhvc3QgIT09IG9yZ1VybC5ob3N0KSB7XG5cbiAgICAgICAgICAgIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdC5lbXVsYXRlSFRUUCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIVNVUFBPUlRTX0NPUlMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudCA9IHhkckNsaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHQoKTtcbn07XG5cbi8qKlxuICogRm9ybSBkYXRhIEludGVyY2VwdG9yLlxuICovXG5cbnZhciBmb3JtID0gZnVuY3Rpb24gKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIGlmIChpc0Zvcm1EYXRhKHJlcXVlc3QuYm9keSkpIHtcblxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZGVsZXRlKCdDb250ZW50LVR5cGUnKTtcblxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocmVxdWVzdC5ib2R5KSAmJiByZXF1ZXN0LmVtdWxhdGVKU09OKSB7XG5cbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gVXJsLnBhcmFtcyhyZXF1ZXN0LmJvZHkpO1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xufTtcblxuLyoqXG4gKiBKU09OIEludGVyY2VwdG9yLlxuICovXG5cbnZhciBqc29uID0gZnVuY3Rpb24gKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIHZhciB0eXBlID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgfHwgJyc7XG5cbiAgICBpZiAoaXNPYmplY3QocmVxdWVzdC5ib2R5KSAmJiB0eXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMCkge1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpO1xuICAgIH1cblxuICAgIG5leHQoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHlUZXh0ID8gd2hlbihyZXNwb25zZS50ZXh0KCksIGZ1bmN0aW9uICh0ZXh0KSB7XG5cbiAgICAgICAgICAgIHR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgfHwgJyc7XG5cbiAgICAgICAgICAgIGlmICh0eXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMCB8fCBpc0pzb24odGV4dCkpIHtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICAgICAgfSkgOiByZXNwb25zZTtcblxuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gaXNKc29uKHN0cikge1xuXG4gICAgdmFyIHN0YXJ0ID0gc3RyLm1hdGNoKC9eXFxbfF5cXHsoPyFcXHspLyksIGVuZCA9IHsnWyc6IC9dJC8sICd7JzogL30kL307XG5cbiAgICByZXR1cm4gc3RhcnQgJiYgZW5kW3N0YXJ0WzBdXS50ZXN0KHN0cik7XG59XG5cbi8qKlxuICogSlNPTlAgY2xpZW50IChCcm93c2VyKS5cbiAqL1xuXG52YXIganNvbnBDbGllbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgIHZhciBuYW1lID0gcmVxdWVzdC5qc29ucCB8fCAnY2FsbGJhY2snLCBjYWxsYmFjayA9IHJlcXVlc3QuanNvbnBDYWxsYmFjayB8fCAnX2pzb25wJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKSwgYm9keSA9IG51bGwsIGhhbmRsZXIsIHNjcmlwdDtcblxuICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcblxuXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsb2FkJyAmJiBib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gNTAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdHVzICYmIHdpbmRvd1tjYWxsYmFja10pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25kV2l0aChib2R5LCB7c3RhdHVzOiBzdGF0dXN9KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93W2NhbGxiYWNrXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHt0eXBlOiAnYWJvcnQnfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5wYXJhbXNbbmFtZV0gPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAocmVxdWVzdC50aW1lb3V0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlcXVlc3QuYWJvcnQsIHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHJlcXVlc3QuZ2V0VXJsKCk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGhhbmRsZXI7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBKU09OUCBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIganNvbnAgPSBmdW5jdGlvbiAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09ICdKU09OUCcpIHtcbiAgICAgICAgcmVxdWVzdC5jbGllbnQgPSBqc29ucENsaWVudDtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIEJlZm9yZSBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIgYmVmb3JlID0gZnVuY3Rpb24gKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHJlcXVlc3QuYmVmb3JlKSkge1xuICAgICAgICByZXF1ZXN0LmJlZm9yZS5jYWxsKHRoaXMsIHJlcXVlc3QpO1xuICAgIH1cblxuICAgIG5leHQoKTtcbn07XG5cbi8qKlxuICogSFRUUCBtZXRob2Qgb3ZlcnJpZGUgSW50ZXJjZXB0b3IuXG4gKi9cblxudmFyIG1ldGhvZCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5lbXVsYXRlSFRUUCAmJiAvXihQVVR8UEFUQ0h8REVMRVRFKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgcmVxdWVzdC5tZXRob2QpO1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9ICdQT1NUJztcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIEhlYWRlciBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIgaGVhZGVyID0gZnVuY3Rpb24gKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIHZhciBoZWFkZXJzID0gYXNzaWduKHt9LCBIdHRwLmhlYWRlcnMuY29tbW9uLFxuICAgICAgICAhcmVxdWVzdC5jcm9zc09yaWdpbiA/IEh0dHAuaGVhZGVycy5jdXN0b20gOiB7fSxcbiAgICAgICAgSHR0cC5oZWFkZXJzW3RvTG93ZXIocmVxdWVzdC5tZXRob2QpXVxuICAgICk7XG5cbiAgICBlYWNoKGhlYWRlcnMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAoIXJlcXVlc3QuaGVhZGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIFhNTEh0dHAgY2xpZW50IChCcm93c2VyKS5cbiAqL1xuXG52YXIgeGhyQ2xpZW50ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25kV2l0aChcbiAgICAgICAgICAgICAgICAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cywgLy8gSUU5IHN0YXR1cyBidWdcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHRyaW0oeGhyLnN0YXR1c1RleHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZWFjaCh0cmltKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5hcHBlbmQocm93LnNsaWNlKDAsIHJvdy5pbmRleE9mKCc6JykpLCByb3cuc2xpY2Uocm93LmluZGV4T2YoJzonKSArIDEpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LmFib3J0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geGhyLmFib3J0KCk7IH07XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCByZXF1ZXN0LnByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oUE9TVHxQVVQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlcXVlc3QucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCksIHRydWUpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHhoci50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUeXBlICYmICdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzIHx8IHJlcXVlc3QuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeGhyLm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHhoci5vbmFib3J0ID0gaGFuZGxlcjtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBoYW5kbGVyO1xuICAgICAgICB4aHIub250aW1lb3V0ID0gaGFuZGxlcjtcbiAgICAgICAgeGhyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBIdHRwIGNsaWVudCAoTm9kZSkuXG4gKi9cblxudmFyIG5vZGVDbGllbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgdmFyIGNsaWVudCA9IHJlcXVpcmUoJ2dvdCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHVybCA9IHJlcXVlc3QuZ2V0VXJsKCk7XG4gICAgICAgIHZhciBib2R5ID0gcmVxdWVzdC5nZXRCb2R5KCk7XG4gICAgICAgIHZhciBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB7fSwgaGFuZGxlcjtcblxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xpZW50KHVybCwge2JvZHk6IGJvZHksIG1ldGhvZDogbWV0aG9kLCBoZWFkZXJzOiBoZWFkZXJzfSkudGhlbihoYW5kbGVyID0gZnVuY3Rpb24gKHJlc3ApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25kV2l0aChyZXNwLmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRyaW0ocmVzcC5zdGF0dXNNZXNzYWdlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGVhY2gocmVzcC5oZWFkZXJzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yJCQxKSB7IHJldHVybiBoYW5kbGVyKGVycm9yJCQxLnJlc3BvbnNlKTsgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEJhc2UgY2xpZW50LlxuICovXG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgdmFyIHJlcUhhbmRsZXJzID0gW3NlbmRSZXF1ZXN0XSwgcmVzSGFuZGxlcnMgPSBbXSwgaGFuZGxlcjtcblxuICAgIGlmICghaXNPYmplY3QoY29udGV4dCkpIHtcbiAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ2xpZW50KHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZXhlYygpIHtcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSByZXFIYW5kbGVycy5wb3AoKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChjb250ZXh0LCByZXF1ZXN0LCBuZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKChcIkludmFsaWQgaW50ZXJjZXB0b3Igb2YgdHlwZSBcIiArICh0eXBlb2YgaGFuZGxlcikgKyBcIiwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbmV4dChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmVzcG9uc2UpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzSGFuZGxlcnMudW5zaGlmdChyZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlc3BvbnNlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc0hhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gd2hlbihyZXNwb25zZSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChjb250ZXh0LCByZXNwb25zZSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB3aGVuKHJlc3BvbnNlLCByZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWMoKTtcblxuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBDbGllbnQudXNlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmVxSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENsaWVudDtcbn07XG5cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIHJlc29sdmUpIHtcblxuICAgIHZhciBjbGllbnQgPSByZXF1ZXN0LmNsaWVudCB8fCAoaW5Ccm93c2VyID8geGhyQ2xpZW50IDogbm9kZUNsaWVudCk7XG5cbiAgICByZXNvbHZlKGNsaWVudChyZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogSFRUUCBIZWFkZXJzLlxuICovXG5cbnZhciBIZWFkZXJzID0gZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblxuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBlYWNoKGhlYWRlcnMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkgeyByZXR1cm4gdGhpcyQxLmFwcGVuZChuYW1lLCB2YWx1ZSk7IH0pO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChuYW1lKSB7XG4gICAgcmV0dXJuIGdldE5hbWUodGhpcy5tYXAsIG5hbWUpICE9PSBudWxsO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChuYW1lKSB7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW2dldE5hbWUodGhpcy5tYXAsIG5hbWUpXTtcblxuICAgIHJldHVybiBsaXN0ID8gbGlzdC5qb2luKCkgOiBudWxsO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gZ2V0QWxsIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW2dldE5hbWUodGhpcy5tYXAsIG5hbWUpXSB8fCBbXTtcbn07XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKGdldE5hbWUodGhpcy5tYXAsIG5hbWUpIHx8IG5hbWUpXSA9IFt0cmltKHZhbHVlKV07XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG5hbWUsIHZhbHVlKXtcblxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbZ2V0TmFtZSh0aGlzLm1hcCwgbmFtZSldO1xuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgICAgbGlzdC5wdXNoKHRyaW0odmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuSGVhZGVycy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gZGVsZXRlJDEgKG5hbWUpe1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtnZXROYW1lKHRoaXMubWFwLCBuYW1lKV07XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbiBkZWxldGVBbGwgKCl7XG4gICAgdGhpcy5tYXAgPSB7fTtcbn07XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGVhY2godGhpcy5tYXAsIGZ1bmN0aW9uIChsaXN0LCBuYW1lKSB7XG4gICAgICAgIGVhY2gobGlzdCwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzJDEpOyB9KTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldE5hbWUobWFwLCBuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgIHJldHVybiB0b0xvd2VyKG5hbWUpID09PSB0b0xvd2VyKGN1cnIpID8gY3VyciA6IHByZXY7XG4gICAgfSwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuXG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyaW0obmFtZSk7XG59XG5cbi8qKlxuICogSFRUUCBSZXNwb25zZS5cbiAqL1xuXG52YXIgUmVzcG9uc2UgPSBmdW5jdGlvbiBSZXNwb25zZShib2R5LCByZWYpIHtcbiAgICB2YXIgdXJsID0gcmVmLnVybDtcbiAgICB2YXIgaGVhZGVycyA9IHJlZi5oZWFkZXJzO1xuICAgIHZhciBzdGF0dXMgPSByZWYuc3RhdHVzO1xuICAgIHZhciBzdGF0dXNUZXh0ID0gcmVmLnN0YXR1c1RleHQ7XG5cblxuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMub2sgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cyB8fCAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIGlmIChpc1N0cmluZyhib2R5KSkge1xuXG4gICAgICAgIHRoaXMuYm9keVRleHQgPSBib2R5O1xuXG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblxuICAgICAgICB0aGlzLmJvZHlCbG9iID0gYm9keTtcblxuICAgICAgICBpZiAoaXNCbG9iVGV4dChib2R5KSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5VGV4dCA9IGJsb2JUZXh0KGJvZHkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbiBibG9iICgpIHtcbiAgICByZXR1cm4gd2hlbih0aGlzLmJvZHlCbG9iKTtcbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gdGV4dCAoKSB7XG4gICAgcmV0dXJuIHdoZW4odGhpcy5ib2R5VGV4dCk7XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIGpzb24gKCkge1xuICAgIHJldHVybiB3aGVuKHRoaXMudGV4dCgpLCBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTsgfSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzcG9uc2UucHJvdG90eXBlLCAnZGF0YScsIHtcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5O1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChib2R5KSB7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuXG59KTtcblxuZnVuY3Rpb24gYmxvYlRleHQoYm9keSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGJvZHkpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpc0Jsb2JUZXh0KGJvZHkpIHtcbiAgICByZXR1cm4gYm9keS50eXBlLmluZGV4T2YoJ3RleHQnKSA9PT0gMCB8fCBib2R5LnR5cGUuaW5kZXhPZignanNvbicpICE9PSAtMTtcbn1cblxuLyoqXG4gKiBIVFRQIFJlcXVlc3QuXG4gKi9cblxudmFyIFJlcXVlc3QgPSBmdW5jdGlvbiBSZXF1ZXN0KG9wdGlvbnMkJDEpIHtcblxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgdGhpcy5wYXJhbXMgPSB7fTtcblxuICAgIGFzc2lnbih0aGlzLCBvcHRpb25zJCQxLCB7XG4gICAgICAgIG1ldGhvZDogdG9VcHBlcihvcHRpb25zJCQxLm1ldGhvZCB8fCAnR0VUJylcbiAgICB9KTtcblxuICAgIGlmICghKHRoaXMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgfVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gZ2V0VXJsICgpe1xuICAgIHJldHVybiBVcmwodGhpcyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRCb2R5ID0gZnVuY3Rpb24gZ2V0Qm9keSAoKXtcbiAgICByZXR1cm4gdGhpcy5ib2R5O1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZFdpdGggPSBmdW5jdGlvbiByZXNwb25kV2l0aCAoYm9keSwgb3B0aW9ucyQkMSkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgYXNzaWduKG9wdGlvbnMkJDEgfHwge30sIHt1cmw6IHRoaXMuZ2V0VXJsKCl9KSk7XG59O1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIHNlbmRpbmcgbmV0d29yayByZXF1ZXN0cy5cbiAqL1xuXG52YXIgQ09NTU9OX0hFQURFUlMgPSB7J0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonfTtcbnZhciBKU09OX0NPTlRFTlRfVFlQRSA9IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCd9O1xuXG5mdW5jdGlvbiBIdHRwKG9wdGlvbnMkJDEpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCB7fSwgY2xpZW50ID0gQ2xpZW50KHNlbGYuJHZtKTtcblxuICAgIGRlZmF1bHRzKG9wdGlvbnMkJDEgfHwge30sIHNlbGYuJG9wdGlvbnMsIEh0dHAub3B0aW9ucyk7XG5cbiAgICBIdHRwLmludGVyY2VwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gSHR0cC5pbnRlcmNlcHRvcltoYW5kbGVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICBjbGllbnQudXNlKGhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBjbGllbnQobmV3IFJlcXVlc3Qob3B0aW9ucyQkMSkpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gcmVzcG9uc2UgOiBQcm9taXNlT2JqLnJlamVjdChyZXNwb25zZSk7XG5cbiAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IocmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VPYmoucmVqZWN0KHJlc3BvbnNlKTtcbiAgICB9KTtcbn1cblxuSHR0cC5vcHRpb25zID0ge307XG5cbkh0dHAuaGVhZGVycyA9IHtcbiAgICBwdXQ6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIHBvc3Q6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIHBhdGNoOiBKU09OX0NPTlRFTlRfVFlQRSxcbiAgICBkZWxldGU6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIGNvbW1vbjogQ09NTU9OX0hFQURFUlMsXG4gICAgY3VzdG9tOiB7fVxufTtcblxuSHR0cC5pbnRlcmNlcHRvciA9IHtiZWZvcmU6IGJlZm9yZSwgbWV0aG9kOiBtZXRob2QsIGpzb25wOiBqc29ucCwganNvbjoganNvbiwgZm9ybTogZm9ybSwgaGVhZGVyOiBoZWFkZXIsIGNvcnM6IGNvcnN9O1xuSHR0cC5pbnRlcmNlcHRvcnMgPSBbJ2JlZm9yZScsICdtZXRob2QnLCAnanNvbnAnLCAnanNvbicsICdmb3JtJywgJ2hlYWRlcicsICdjb3JzJ107XG5cblsnZ2V0JywgJ2RlbGV0ZScsICdoZWFkJywgJ2pzb25wJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kJCQxKSB7XG5cbiAgICBIdHRwW21ldGhvZCQkMV0gPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zJCQxKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zJCQxIHx8IHt9LCB7dXJsOiB1cmwsIG1ldGhvZDogbWV0aG9kJCQxfSkpO1xuICAgIH07XG5cbn0pO1xuXG5bJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kJCQxKSB7XG5cbiAgICBIdHRwW21ldGhvZCQkMV0gPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zJCQxKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zJCQxIHx8IHt9LCB7dXJsOiB1cmwsIG1ldGhvZDogbWV0aG9kJCQxLCBib2R5OiBib2R5fSkpO1xuICAgIH07XG5cbn0pO1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIGludGVyYWN0aW5nIHdpdGggUkVTVGZ1bCBzZXJ2aWNlcy5cbiAqL1xuXG5mdW5jdGlvbiBSZXNvdXJjZSh1cmwsIHBhcmFtcywgYWN0aW9ucywgb3B0aW9ucyQkMSkge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LCByZXNvdXJjZSA9IHt9O1xuXG4gICAgYWN0aW9ucyA9IGFzc2lnbih7fSxcbiAgICAgICAgUmVzb3VyY2UuYWN0aW9ucyxcbiAgICAgICAgYWN0aW9uc1xuICAgICk7XG5cbiAgICBlYWNoKGFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24sIG5hbWUpIHtcblxuICAgICAgICBhY3Rpb24gPSBtZXJnZSh7dXJsOiB1cmwsIHBhcmFtczogYXNzaWduKHt9LCBwYXJhbXMpfSwgb3B0aW9ucyQkMSwgYWN0aW9uKTtcblxuICAgICAgICByZXNvdXJjZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2VsZi4kaHR0cCB8fCBIdHRwKShvcHRzKGFjdGlvbiwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIG9wdHMoYWN0aW9uLCBhcmdzKSB7XG5cbiAgICB2YXIgb3B0aW9ucyQkMSA9IGFzc2lnbih7fSwgYWN0aW9uKSwgcGFyYW1zID0ge30sIGJvZHk7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cbiAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgYm9keSA9IGFyZ3NbMV07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcblxuICAgICAgICAgICAgaWYgKC9eKFBPU1R8UFVUfFBBVENIKSQvaS50ZXN0KG9wdGlvbnMkJDEubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCB1cCB0byAyIGFyZ3VtZW50cyBbcGFyYW1zLCBib2R5XSwgZ290ICcgKyBhcmdzLmxlbmd0aCArICcgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICBvcHRpb25zJCQxLmJvZHkgPSBib2R5O1xuICAgIG9wdGlvbnMkJDEucGFyYW1zID0gYXNzaWduKHt9LCBvcHRpb25zJCQxLnBhcmFtcywgcGFyYW1zKTtcblxuICAgIHJldHVybiBvcHRpb25zJCQxO1xufVxuXG5SZXNvdXJjZS5hY3Rpb25zID0ge1xuXG4gICAgZ2V0OiB7bWV0aG9kOiAnR0VUJ30sXG4gICAgc2F2ZToge21ldGhvZDogJ1BPU1QnfSxcbiAgICBxdWVyeToge21ldGhvZDogJ0dFVCd9LFxuICAgIHVwZGF0ZToge21ldGhvZDogJ1BVVCd9LFxuICAgIHJlbW92ZToge21ldGhvZDogJ0RFTEVURSd9LFxuICAgIGRlbGV0ZToge21ldGhvZDogJ0RFTEVURSd9XG5cbn07XG5cbi8qKlxuICogSW5zdGFsbCBwbHVnaW4uXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luKFZ1ZSkge1xuXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFV0aWwoVnVlKTtcblxuICAgIFZ1ZS51cmwgPSBVcmw7XG4gICAgVnVlLmh0dHAgPSBIdHRwO1xuICAgIFZ1ZS5yZXNvdXJjZSA9IFJlc291cmNlO1xuICAgIFZ1ZS5Qcm9taXNlID0gUHJvbWlzZU9iajtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZ1ZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAkdXJsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyhWdWUudXJsLCB0aGlzLCB0aGlzLiRvcHRpb25zLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJGh0dHA6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zKFZ1ZS5odHRwLCB0aGlzLCB0aGlzLiRvcHRpb25zLmh0dHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRyZXNvdXJjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS5yZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRwcm9taXNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhlY3V0b3IpIHsgcmV0dXJuIG5ldyBWdWUuUHJvbWlzZShleGVjdXRvciwgdGhpcyQxKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZS51c2UocGx1Z2luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luO1xuZXhwb3J0IHsgVXJsLCBIdHRwLCBSZXNvdXJjZSB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5lczIwMTUuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL0V4dGVuc2lvbkFQSS5qcz85NzNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBIiwiZmlsZSI6IjEwNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGVjaGFydHNBUElMaXN0ID0gW1xuICAgICAgICAnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdnZXREZXZpY2VQaXhlbFJhdGlvJywgJ2Rpc3BhdGNoQWN0aW9uJywgJ2lzRGlzcG9zZWQnLFxuICAgICAgICAnb24nLCAnb2ZmJywgJ2dldERhdGFVUkwnLCAnZ2V0Q29ubmVjdGVkRGF0YVVSTCcsICdnZXRNb2RlbCcsICdnZXRPcHRpb24nLFxuICAgICAgICAnZ2V0Vmlld09mQ29tcG9uZW50TW9kZWwnLCAnZ2V0Vmlld09mU2VyaWVzTW9kZWwnXG4gICAgXTtcbiAgICAvLyBBbmQgYGdldENvb3JkaW5hdGVTeXN0ZW1zYCBhbmQgYGdldENvbXBvbmVudEJ5RWxlbWVudGAgd2lsbCBiZSBpbmplY3RlZCBpbiBlY2hhcnRzLmpzXG5cbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoY2hhcnRJbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaChlY2hhcnRzQVBJTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChjaGFydEluc3RhbmNlW25hbWVdLCBjaGFydEluc3RhbmNlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFeHRlbnNpb25BUEk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvRXh0ZW5zaW9uQVBJLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n\n    __webpack_require__(60);\n\n    __webpack_require__(106);\n    __webpack_require__(107);\n\n    var barLayoutGrid = __webpack_require__(164);\n    var echarts = __webpack_require__(1);\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    __webpack_require__(55);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2Jhci5qcz9kY2Q0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBIiwiZmlsZSI6IjEwNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgcmVxdWlyZSgnLi4vY29vcmQvY2FydGVzaWFuL0dyaWQnKTtcblxuICAgIHJlcXVpcmUoJy4vYmFyL0JhclNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vYmFyL0JhclZpZXcnKTtcblxuICAgIHZhciBiYXJMYXlvdXRHcmlkID0gcmVxdWlyZSgnLi4vbGF5b3V0L2JhckdyaWQnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQoenJVdGlsLmN1cnJ5KGJhckxheW91dEdyaWQsICdiYXInKSk7XG5cbiAgICAvLyBWaXN1YWwgY29kaW5nIGZvciBsZWdlbmRcbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnYmFyJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnLCAncm91bmRSZWN0Jyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbiAgICByZXF1aXJlKCcuLi9jb21wb25lbnQvZ3JpZFNpbXBsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2Jhci5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(108).extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJTZXJpZXMuanM/NGQ2MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSyIsImZpbGUiOiIxMDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9CYXNlQmFyU2VyaWVzJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLmJhcicsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcblxuICAgICAgICBicnVzaFNlbGVjdG9yOiAncmVjdCdcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var helper = __webpack_require__(110);\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(__webpack_require__(9).prototype, __webpack_require__(109));\n\n    var BarView = __webpack_require__(1).extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d'\n                || coordinateSystemType === 'polar'\n            ) {\n                this._render(seriesModel, ecModel, api);\n            }\n            else if (__DEV__) {\n                console.warn('Only cartesian2d and polar supported for bar.');\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _render: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var coord = seriesModel.coordinateSystem;\n            var baseAxis = coord.getBaseAxis();\n            var isHorizontalOrRadial;\n\n            if (coord.type === 'cartesian2d') {\n                isHorizontalOrRadial = baseAxis.isHorizontal();\n            }\n            else if (coord.type === 'polar') {\n                isHorizontalOrRadial = baseAxis.dim === 'angle';\n            }\n\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getLayout[coord.type](data, dataIndex, itemModel);\n                    var el = elementCreator[coord.type](\n                        data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel\n                    );\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, dataIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = elementCreator[coord.type](\n                            data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true\n                        );\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(\n                        el, data, newIndex, itemModel, layout,\n                        seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                    );\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    if (coord.type === 'cartesian2d') {\n                        el && removeRect(dataIndex, animationModel, el);\n                    }\n                    else {\n                        el && removeSector(dataIndex, animationModel, el);\n                    }\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        if (el.type === 'sector') {\n                            removeSector(el.dataIndex, ecModel, el);\n                        }\n                        else {\n                            removeRect(el.dataIndex, ecModel, el);\n                        }\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    var elementCreator = {\n\n        cartesian2d: function (\n            data, dataIndex, itemModel, layout, isHorizontal,\n            animationModel, isUpdate\n        ) {\n            var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var rectShape = rect.shape;\n                var animateProperty = isHorizontal ? 'height' : 'width';\n                var animateTarget = {};\n                rectShape[animateProperty] = 0;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return rect;\n        },\n\n        polar: function (\n            data, dataIndex, itemModel, layout, isRadial,\n            animationModel, isUpdate\n        ) {\n            var sector = new graphic.Sector({shape: zrUtil.extend({}, layout)});\n\n            // Animation\n            if (animationModel) {\n                var sectorShape = sector.shape;\n                var animateProperty = isRadial ? 'r' : 'endAngle';\n                var animateTarget = {};\n                sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n                animateTarget[animateProperty] = layout[animateProperty];\n                graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n                    shape: animateTarget\n                }, animationModel, dataIndex);\n            }\n\n            return sector;\n        }\n    };\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function removeSector(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                r: el.shape.r0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    var getLayout = {\n        cartesian2d: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            var fixedLineWidth = getLineWidth(itemModel, layout);\n\n            // fix layout with lineWidth\n            var signX = layout.width > 0 ? 1 : -1;\n            var signY = layout.height > 0 ? 1 : -1;\n            return {\n                x: layout.x + signX * fixedLineWidth / 2,\n                y: layout.y + signY * fixedLineWidth / 2,\n                width: layout.width - signX * fixedLineWidth,\n                height: layout.height - signY * fixedLineWidth\n            };\n        },\n\n        polar: function (data, dataIndex, itemModel) {\n            var layout = data.getItemLayout(dataIndex);\n            return {\n                cx: layout.cx,\n                cy: layout.cy,\n                r0: layout.r0,\n                r: layout.r,\n                startAngle: layout.startAngle,\n                endAngle: layout.endAngle\n            };\n        }\n    };\n\n    function updateStyle(\n        el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar\n    ) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        if (!isPolar) {\n            el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n        }\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && el.attr('cursor', cursorStyle);\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        if (!isPolar) {\n            helper.setLabel(\n                el.style, hoverStyle, itemModel, color,\n                seriesModel, dataIndex, labelPositionOutside\n            );\n        }\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJWaWV3LmpzP2YyZTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUIsVUFBVTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUIsVUFBVTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEwNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XG5cbiAgICB2YXIgQkFSX0JPUkRFUl9XSURUSF9RVUVSWSA9IFsnaXRlbVN0eWxlJywgJ25vcm1hbCcsICdiYXJCb3JkZXJXaWR0aCddO1xuXG4gICAgLy8gRklYTUVcbiAgICAvLyBKdXN0IGZvciBjb21wYXRpYmxlIHdpdGggZWMyLlxuICAgIHpyVXRpbC5leHRlbmQocmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKS5wcm90b3R5cGUsIHJlcXVpcmUoJy4vYmFySXRlbVN0eWxlJykpO1xuXG4gICAgdmFyIEJhclZpZXcgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ2hhcnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnYmFyJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcblxuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVTeXN0ZW1UeXBlID09PSAnY2FydGVzaWFuMmQnXG4gICAgICAgICAgICAgICAgfHwgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdwb2xhcidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ09ubHkgY2FydGVzaWFuMmQgYW5kIHBvbGFyIHN1cHBvcnRlZCBmb3IgYmFyLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiB6clV0aWwubm9vcCxcblxuICAgICAgICBfcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgICAgICB2YXIgY29vcmQgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmQuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWxPclJhZGlhbDtcblxuICAgICAgICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWxPclJhZGlhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29vcmQudHlwZSA9PT0gJ3BvbGFyJykge1xuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuZGltID09PSAnYW5nbGUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSA/IHNlcmllc01vZGVsIDogbnVsbDtcblxuICAgICAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGFuaW1hdGlvbk1vZGVsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLCBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBjb29yZC50eXBlID09PSAncG9sYXInXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzVmFsdWUobmV3SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtzaGFwZTogbGF5b3V0fSwgYW5pbWF0aW9uTW9kZWwsIG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZWxlbWVudENyZWF0b3JbY29vcmQudHlwZV0oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWxPclJhZGlhbCwgYW5pbWF0aW9uTW9kZWwsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SW5kZXgsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLCBkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGNvb3JkLnR5cGUgPT09ICdwb2xhcidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsICYmIHJlbW92ZVJlY3QoZGF0YUluZGV4LCBhbmltYXRpb25Nb2RlbCwgZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgJiYgcmVtb3ZlU2VjdG9yKGRhdGFJbmRleCwgYW5pbWF0aW9uTW9kZWwsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgaWYgKGVjTW9kZWwuZ2V0KCdhbmltYXRpb24nKSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ3NlY3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVTZWN0b3IoZWwuZGF0YUluZGV4LCBlY01vZGVsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSZWN0KGVsLmRhdGFJbmRleCwgZWNNb2RlbCwgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGVsZW1lbnRDcmVhdG9yID0ge1xuXG4gICAgICAgIGNhcnRlc2lhbjJkOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWwsXG4gICAgICAgICAgICBhbmltYXRpb25Nb2RlbCwgaXNVcGRhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe3NoYXBlOiB6clV0aWwuZXh0ZW5kKHt9LCBsYXlvdXQpfSk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RTaGFwZSA9IHJlY3Quc2hhcGU7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVQcm9wZXJ0eSA9IGlzSG9yaXpvbnRhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0ZVRhcmdldCA9IHt9O1xuICAgICAgICAgICAgICAgIHJlY3RTaGFwZVthbmltYXRlUHJvcGVydHldID0gMDtcbiAgICAgICAgICAgICAgICBhbmltYXRlVGFyZ2V0W2FuaW1hdGVQcm9wZXJ0eV0gPSBsYXlvdXRbYW5pbWF0ZVByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBncmFwaGljW2lzVXBkYXRlID8gJ3VwZGF0ZVByb3BzJyA6ICdpbml0UHJvcHMnXShyZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBhbmltYXRlVGFyZ2V0XG4gICAgICAgICAgICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvbGFyOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc1JhZGlhbCxcbiAgICAgICAgICAgIGFuaW1hdGlvbk1vZGVsLCBpc1VwZGF0ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBzZWN0b3IgPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe3NoYXBlOiB6clV0aWwuZXh0ZW5kKHt9LCBsYXlvdXQpfSk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY3RvclNoYXBlID0gc2VjdG9yLnNoYXBlO1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc1JhZGlhbCA/ICdyJyA6ICdlbmRBbmdsZSc7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVUYXJnZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBzZWN0b3JTaGFwZVthbmltYXRlUHJvcGVydHldID0gaXNSYWRpYWwgPyAwIDogbGF5b3V0LnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgZ3JhcGhpY1tpc1VwZGF0ZSA/ICd1cGRhdGVQcm9wcycgOiAnaW5pdFByb3BzJ10oc2VjdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBhbmltYXRlVGFyZ2V0XG4gICAgICAgICAgICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWN0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUmVjdChkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgIGVsLnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnQgJiYgZWwucGFyZW50LnJlbW92ZShlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNlY3RvcihkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgIGVsLnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICByOiBlbC5zaGFwZS5yMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnQgJiYgZWwucGFyZW50LnJlbW92ZShlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBnZXRMYXlvdXQgPSB7XG4gICAgICAgIGNhcnRlc2lhbjJkOiBmdW5jdGlvbiAoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBmaXhlZExpbmVXaWR0aCA9IGdldExpbmVXaWR0aChpdGVtTW9kZWwsIGxheW91dCk7XG5cbiAgICAgICAgICAgIC8vIGZpeCBsYXlvdXQgd2l0aCBsaW5lV2lkdGhcbiAgICAgICAgICAgIHZhciBzaWduWCA9IGxheW91dC53aWR0aCA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICB2YXIgc2lnblkgPSBsYXlvdXQuaGVpZ2h0ID4gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogbGF5b3V0LnggKyBzaWduWCAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5OiBsYXlvdXQueSArIHNpZ25ZICogZml4ZWRMaW5lV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGggLSBzaWduWCAqIGZpeGVkTGluZVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCAtIHNpZ25ZICogZml4ZWRMaW5lV2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9sYXI6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjeDogbGF5b3V0LmN4LFxuICAgICAgICAgICAgICAgIGN5OiBsYXlvdXQuY3ksXG4gICAgICAgICAgICAgICAgcjA6IGxheW91dC5yMCxcbiAgICAgICAgICAgICAgICByOiBsYXlvdXQucixcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBsYXlvdXQuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogbGF5b3V0LmVuZEFuZ2xlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKFxuICAgICAgICBlbCwgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbCwgaXNQb2xhclxuICAgICkge1xuICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnY29sb3InKTtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnb3BhY2l0eScpO1xuICAgICAgICB2YXIgaXRlbVN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5ub3JtYWwnKTtcbiAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEJhckl0ZW1TdHlsZSgpO1xuXG4gICAgICAgIGlmICghaXNQb2xhcikge1xuICAgICAgICAgICAgZWwuc2V0U2hhcGUoJ3InLCBpdGVtU3R5bGVNb2RlbC5nZXQoJ2JhckJvcmRlclJhZGl1cycpIHx8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtU3R5bGVNb2RlbC5nZXRCYXJJdGVtU3R5bGUoKVxuICAgICAgICApKTtcblxuICAgICAgICB2YXIgY3Vyc29yU3R5bGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gICAgICAgIGN1cnNvclN0eWxlICYmIGVsLmF0dHIoJ2N1cnNvcicsIGN1cnNvclN0eWxlKTtcblxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbk91dHNpZGUgPSBpc0hvcml6b250YWxcbiAgICAgICAgICAgID8gKGxheW91dC5oZWlnaHQgPiAwID8gJ2JvdHRvbScgOiAndG9wJylcbiAgICAgICAgICAgIDogKGxheW91dC53aWR0aCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnKTtcblxuICAgICAgICBpZiAoIWlzUG9sYXIpIHtcbiAgICAgICAgICAgIGhlbHBlci5zZXRMYWJlbChcbiAgICAgICAgICAgICAgICBlbC5zdHlsZSwgaG92ZXJTdHlsZSwgaXRlbU1vZGVsLCBjb2xvcixcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShlbCwgaG92ZXJTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSB3aWR0aCBvciBoZWlnaHQgYXJlIHRvbyBzbWFsbC5cbiAgICBmdW5jdGlvbiBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCByYXdMYXlvdXQpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGl0ZW1Nb2RlbC5nZXQoQkFSX0JPUkRFUl9XSURUSF9RVUVSWSkgfHwgMDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGxpbmVXaWR0aCwgTWF0aC5hYnMocmF3TGF5b3V0LndpZHRoKSwgTWF0aC5hYnMocmF3TGF5b3V0LmhlaWdodCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gQmFyVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var SeriesModel = __webpack_require__(35);\n    var createListFromArray = __webpack_require__(32);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 最小高度改为0\n            barMinHeight: 0,\n            // 最小角度为0，仅对极坐标系下的柱状图有效\n            barMinAngle: 0,\n            // cursor: null,\n\n            // barMaxWidth: null,\n            // 默认自适应\n            // barWidth: null,\n            // 柱间距离，默认为柱形宽度的30%，可设固定值\n            // barGap: '30%',\n            // 类目间柱形距离，默认为类目间距的20%，可设固定值\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: '各异'\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXNlQmFyU2VyaWVzLmpzP2FiNGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjEwOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG4gICAgdmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKCcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZXJpZXMuX19iYXNlX2Jhcl9fJyxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkob3B0aW9uLmRhdGEsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hcmtlclBvc2l0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmdldExheW91dCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBkYXRhLmdldExheW91dCgnc2l6ZScpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRJbmRleCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbiAgICAgICAgICAgICAgICBwdFtvZmZzZXRJbmRleF0gKz0gb2Zmc2V0ICsgc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgejogMiwgICAgICAgICAgICAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICAgICAgICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICAgICAgICAgIC8vIHN0YWNrOiBudWxsXG5cbiAgICAgICAgICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAgICAgICAgIC8vIHlBeGlzSW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIOacgOWwj+mrmOW6puaUueS4ujBcbiAgICAgICAgICAgIGJhck1pbkhlaWdodDogMCxcbiAgICAgICAgICAgIC8vIOacgOWwj+inkuW6puS4ujDvvIzku4Xlr7nmnoHlnZDmoIfns7vkuIvnmoTmn7Hnirblm77mnInmlYhcbiAgICAgICAgICAgIGJhck1pbkFuZ2xlOiAwLFxuICAgICAgICAgICAgLy8gY3Vyc29yOiBudWxsLFxuXG4gICAgICAgICAgICAvLyBiYXJNYXhXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIC8vIOm7mOiupOiHqumAguW6lFxuICAgICAgICAgICAgLy8gYmFyV2lkdGg6IG51bGwsXG4gICAgICAgICAgICAvLyDmn7Hpl7Tot53nprvvvIzpu5jorqTkuLrmn7HlvaLlrr3luqbnmoQzMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAgICAgICAgIC8vIGJhckdhcDogJzMwJScsXG4gICAgICAgICAgICAvLyDnsbvnm67pl7Tmn7HlvaLot53nprvvvIzpu5jorqTkuLrnsbvnm67pl7Tot53nmoQyMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAgICAgICAgIC8vIGJhckNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAgICAgICAgIC8vIGxhYmVsOiB7XG4gICAgICAgICAgICAvLyAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xvcjogJ+WQhOW8gidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0Jhc2VCYXJTZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n\n    var getBarItemStyle = __webpack_require__(24)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2Jhci9iYXJJdGVtU3R5bGUuanM/MzlkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuXG4gICAgdmFyIGdldEJhckl0ZW1TdHlsZSA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnc3Ryb2tlJywgJ2JvcmRlckNvbG9yJ10sXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLFxuICAgICAgICAgICAgLy8gQ29tcGF0aXRhYmxlIHdpdGggMlxuICAgICAgICAgICAgWydzdHJva2UnLCAnYmFyQm9yZGVyQ29sb3InXSxcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ2JhckJvcmRlcldpZHRoJ10sXG4gICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXVxuICAgICAgICBdXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0QmFySXRlbVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldEJhckl0ZW1TdHlsZS5jYWxsKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEJvcmRlckxpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgICAgICAgICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2Jhckl0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2Jhci9oZWxwZXIuanM/YTI3NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjExMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICBoZWxwZXIuc2V0TGFiZWwgPSBmdW5jdGlvbiAoXG4gICAgICAgIG5vcm1hbFN0eWxlLCBob3ZlclN0eWxlLCBpdGVtTW9kZWwsIGNvbG9yLCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICkge1xuICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gICAgICAgIHZhciBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLmVtcGhhc2lzJyk7XG5cbiAgICAgICAgaWYgKGxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgIHNldExhYmVsKFxuICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcixcbiAgICAgICAgICAgICAgICB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleCwgJ25vcm1hbCcpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3ZlckxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgIHNldExhYmVsKFxuICAgICAgICAgICAgICAgIGhvdmVyU3R5bGUsIGhvdmVyTGFiZWxNb2RlbCwgY29sb3IsXG4gICAgICAgICAgICAgICAgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXgsICdlbXBoYXNpcycpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvdmVyU3R5bGUudGV4dCA9ICcnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNldExhYmVsKHN0eWxlLCBtb2RlbCwgY29sb3IsIGxhYmVsVGV4dCwgbGFiZWxQb3NpdGlvbk91dHNpZGUpIHtcbiAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KHN0eWxlLCBtb2RlbCwgY29sb3IpO1xuICAgICAgICBzdHlsZS50ZXh0ID0gbGFiZWxUZXh0O1xuICAgICAgICBpZiAoc3R5bGUudGV4dFBvc2l0aW9uID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IGxhYmVsUG9zaXRpb25PdXRzaWRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBoZWxwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = __webpack_require__(2);\n    var Symbol = __webpack_require__(45);\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis'),\n            cursorStyle: seriesModel.get('cursor')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzP2U2ZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcbiAqL1xuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBTeW1ib2wgPSByZXF1aXJlKCcuL1N5bWJvbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfSBbc3ltYm9sQ3Rvcl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTeW1ib2xEcmF3KHN5bWJvbEN0b3IpIHtcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgdGhpcy5fc3ltYm9sQ3RvciA9IHN5bWJvbEN0b3IgfHwgU3ltYm9sO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2xEcmF3UHJvdG8gPSBTeW1ib2xEcmF3LnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBpZHgsIGlzSWdub3JlKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAvLyBJcyBhbiBvYmplY3RcbiAgICAgICAgLy8gaWYgKHBvaW50ICYmIHBvaW50Lmhhc093blByb3BlcnR5KCdwb2ludCcpKSB7XG4gICAgICAgIC8vICAgICBwb2ludCA9IHBvaW50LnBvaW50O1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBwb2ludCAmJiAhaXNOYU4ocG9pbnRbMF0pICYmICFpc05hTihwb2ludFsxXSkgJiYgIShpc0lnbm9yZSAmJiBpc0lnbm9yZShpZHgpKVxuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJykgIT09ICdub25lJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN5bWJvbHMgZHJhdyBieSBuZXcgZGF0YVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtpc0lnbm9yZV1cbiAgICAgKi9cbiAgICBzeW1ib2xEcmF3UHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpc0lnbm9yZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHZhciBTeW1ib2xDdG9yID0gdGhpcy5fc3ltYm9sQ3RvcjtcblxuICAgICAgICB2YXIgc2VyaWVzU2NvcGUgPSB7XG4gICAgICAgICAgICBpdGVtU3R5bGU6IHNlcmllc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJykuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSksXG4gICAgICAgICAgICBob3Zlckl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpLFxuICAgICAgICAgICAgc3ltYm9sUm90YXRlOiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpLFxuICAgICAgICAgICAgc3ltYm9sT2Zmc2V0OiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbE9mZnNldCcpLFxuICAgICAgICAgICAgaG92ZXJBbmltYXRpb246IHNlcmllc01vZGVsLmdldCgnaG92ZXJBbmltYXRpb24nKSxcblxuICAgICAgICAgICAgbGFiZWxNb2RlbDogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpLFxuICAgICAgICAgICAgaG92ZXJMYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKSxcbiAgICAgICAgICAgIGN1cnNvclN0eWxlOiBzZXJpZXNNb2RlbC5nZXQoJ2N1cnNvcicpXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sTmVlZHNEcmF3KGRhdGEsIG5ld0lkeCwgaXNJZ25vcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xFbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sTmVlZHNEcmF3KGRhdGEsIG5ld0lkeCwgaXNJZ25vcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzeW1ib2xFbCkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbEVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sRWwudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xFbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFja1xuICAgICAgICAgICAgICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICAgICAgICAgICAgZWwgJiYgZWwuZmFkZU91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgc3ltYm9sRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gTm90IHVzZSBhbmltYXRpb25cbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgICAgICAgICBlbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN5bWJvbERyYXdQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5mYWRlT3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xEcmF3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n\n    var helper = {};\n\n    helper.findLabelValueDim = function (data) {\n        var valueDim;\n        var labelDims = modelUtil.otherDimToDataDim(data, 'label');\n\n        if (labelDims.length) {\n            valueDim = labelDims[0];\n        }\n        else {\n            // Get last value dim\n            var dimensions = data.dimensions.slice();\n            var dataType;\n            while (dimensions.length && (\n                valueDim = dimensions.pop(),\n                dataType = data.getDimensionInfo(valueDim).type,\n                dataType === 'ordinal' || dataType === 'time'\n            )) {} // jshint ignore:line\n        }\n\n        return valueDim;\n    };\n\n    helper.setTextToStyle = function (\n        data, dataIndex, valueDim, elStyle, seriesModel, labelModel, color\n    ) {\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                data.get(valueDim, dataIndex)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9sYWJlbEhlbHBlci5qcz9mYTUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sXG4gKi9cblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIGhlbHBlci5maW5kTGFiZWxWYWx1ZURpbSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZURpbTtcbiAgICAgICAgdmFyIGxhYmVsRGltcyA9IG1vZGVsVXRpbC5vdGhlckRpbVRvRGF0YURpbShkYXRhLCAnbGFiZWwnKTtcblxuICAgICAgICBpZiAobGFiZWxEaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWVEaW0gPSBsYWJlbERpbXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBHZXQgbGFzdCB2YWx1ZSBkaW1cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gZGF0YS5kaW1lbnNpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgZGF0YVR5cGU7XG4gICAgICAgICAgICB3aGlsZSAoZGltZW5zaW9ucy5sZW5ndGggJiYgKFxuICAgICAgICAgICAgICAgIHZhbHVlRGltID0gZGltZW5zaW9ucy5wb3AoKSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyh2YWx1ZURpbSkudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA9PT0gJ29yZGluYWwnIHx8IGRhdGFUeXBlID09PSAndGltZSdcbiAgICAgICAgICAgICkpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlRGltO1xuICAgIH07XG5cbiAgICBoZWxwZXIuc2V0VGV4dFRvU3R5bGUgPSBmdW5jdGlvbiAoXG4gICAgICAgIGRhdGEsIGRhdGFJbmRleCwgdmFsdWVEaW0sIGVsU3R5bGUsIHNlcmllc01vZGVsLCBsYWJlbE1vZGVsLCBjb2xvclxuICAgICkge1xuICAgICAgICBpZiAodmFsdWVEaW0gIT0gbnVsbCAmJiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKSkge1xuICAgICAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KGVsU3R5bGUsIGxhYmVsTW9kZWwsIGNvbG9yKTtcbiAgICAgICAgICAgIGVsU3R5bGUudGV4dCA9IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXgsICdub3JtYWwnKSxcbiAgICAgICAgICAgICAgICBkYXRhLmdldCh2YWx1ZURpbSwgZGF0YUluZGV4KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsU3R5bGUudGV4dCA9ICcnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9sYWJlbEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n    var PRIORITY = echarts.PRIORITY;\n\n    __webpack_require__(114);\n    __webpack_require__(115);\n\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(182), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(165), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        __webpack_require__(177), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    __webpack_require__(55);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUuanM/NWJjMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjExMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciBQUklPUklUWSA9IGVjaGFydHMuUFJJT1JJVFk7XG5cbiAgICByZXF1aXJlKCcuL2xpbmUvTGluZVNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vbGluZS9MaW5lVmlldycpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL3Zpc3VhbC9zeW1ib2wnKSwgJ2xpbmUnLCAnY2lyY2xlJywgJ2xpbmUnXG4gICAgKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL2xheW91dC9wb2ludHMnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKFBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIHpyVXRpbC5jdXJyeShcbiAgICAgICAgcmVxdWlyZSgnLi4vcHJvY2Vzc29yL2RhdGFTYW1wbGUnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBJbiBjYXNlIGRldmVsb3BlciBmb3JnZXQgdG8gaW5jbHVkZSBncmlkIGNvbXBvbmVudFxuICAgIHJlcXVpcmUoJy4uL2NvbXBvbmVudC9ncmlkU2ltcGxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var createListFromArray = __webpack_require__(32);\n    var SeriesModel = __webpack_require__(35);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n            // cursor: null,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // 拐点图形类型\n            symbol: 'emptyCircle',\n            // 拐点图形大小\n            symbolSize: 4,\n            // 拐点图形旋转控制\n            symbolRotate: null,\n\n            // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n            showSymbol: true,\n            // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n            showAllSymbol: false,\n\n            // 是否连接断点\n            connectNulls: false,\n\n            // 数据过滤，'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qcz9iOTc4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgY3JlYXRlTGlzdEZyb21BcnJheSA9IHJlcXVpcmUoJy4uL2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5Jyk7XG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNlcmllc01vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5saW5lJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnZ3JpZCcsICdwb2xhciddLFxuXG4gICAgICAgIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IG9wdGlvbi5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgIGlmIChjb29yZFN5cyAhPT0gJ3BvbGFyJyAmJiBjb29yZFN5cyAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmUgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVN5c3RlbSBiZXNpZGVzIGNhcnRlc2lhbiBhbmQgcG9sYXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheShvcHRpb24uZGF0YSwgdGhpcywgZWNNb2RlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgejogMiwgICAgICAgICAgICAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICAgICAgICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcblxuICAgICAgICAgICAgaG92ZXJBbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAvLyBzdGFjazogbnVsbFxuICAgICAgICAgICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAgICAgICAgIC8vIHlBeGlzSW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIHBvbGFySW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIElmIGNsaXAgdGhlIG92ZXJmbG93IHZhbHVlXG4gICAgICAgICAgICBjbGlwT3ZlcmZsb3c6IHRydWUsXG4gICAgICAgICAgICAvLyBjdXJzb3I6IG51bGwsXG5cbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgIC8vICAgICBub3JtYWw6IHt9LFxuICAgICAgICAgICAgLy8gICAgIGVtcGhhc2lzOiB7fVxuICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhcmVhU3R5bGU6IHt9LFxuICAgICAgICAgICAgLy8gZmFsc2UsICdzdGFydCcsICdlbmQnLCAnbWlkZGxlJ1xuICAgICAgICAgICAgc3RlcDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIERpc2FibGVkIGlmIHN0ZXAgaXMgdHJ1ZVxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuICAgICAgICAgICAgLy8g5ouQ54K55Zu+5b2i57G75Z6LXG4gICAgICAgICAgICBzeW1ib2w6ICdlbXB0eUNpcmNsZScsXG4gICAgICAgICAgICAvLyDmi5Dngrnlm77lvaLlpKflsI9cbiAgICAgICAgICAgIHN5bWJvbFNpemU6IDQsXG4gICAgICAgICAgICAvLyDmi5Dngrnlm77lvaLml4vovazmjqfliLZcbiAgICAgICAgICAgIHN5bWJvbFJvdGF0ZTogbnVsbCxcblxuICAgICAgICAgICAgLy8g5piv5ZCm5pi+56S6IHN5bWJvbCwg5Y+q5pyJ5ZyoIHRvb2x0aXAgaG92ZXIg55qE5pe25YCZ5pi+56S6XG4gICAgICAgICAgICBzaG93U3ltYm9sOiB0cnVlLFxuICAgICAgICAgICAgLy8g5qCH5b+X5Zu+5b2i6buY6K6k5Y+q5pyJ5Li76L205pi+56S677yI6ZqP5Li76L205qCH562+6Ze06ZqU6ZqQ6JeP562W55Wl77yJXG4gICAgICAgICAgICBzaG93QWxsU3ltYm9sOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8g5piv5ZCm6L+e5o6l5pat54K5XG4gICAgICAgICAgICBjb25uZWN0TnVsbHM6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDmlbDmja7ov4fmu6TvvIwnYXZlcmFnZScsICdtYXgnLCAnbWluJywgJ3N1bSdcbiAgICAgICAgICAgIHNhbXBsaW5nOiAnbm9uZScsXG5cbiAgICAgICAgICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG5cbiAgICAgICAgICAgIC8vIERpc2FibGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgIHByb2dyZXNzaXZlOiAwLFxuICAgICAgICAgICAgaG92ZXJMYXllclRocmVzaG9sZDogSW5maW5pdHlcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// FIXME step not support polar\n\n\n    var zrUtil = __webpack_require__(0);\n    var SymbolDraw = __webpack_require__(111);\n    var Symbol = __webpack_require__(45);\n    var lineAnimationDiff = __webpack_require__(116);\n    var graphic = __webpack_require__(2);\n    var modelUtil = __webpack_require__(4);\n    var polyHelper = __webpack_require__(117);\n    var ChartView = __webpack_require__(66);\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        // If the area to be rendered is bigger than area defined by LinearGradient,\n        // the canvas spec prescribes that the color of the first stop and the last\n        // stop should be used. But if two stops are added at offset 0, in effect\n        // browsers use the color of the second stop to render area outside\n        // LinearGradient. So we can only infinitesimally extend area defined in\n        // LinearGradient to render `outerColors`.\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var axis = coordSys.getAxis(dimName);\n\n        // dataToCoor mapping may not be linear, but must be monotonic.\n        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n            return {\n                coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n                color: stop.color\n            };\n        });\n        var stopLen = colorStops.length;\n        var outerColors = visualMeta.outerColors.slice();\n\n        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n            colorStops.reverse();\n            outerColors.reverse();\n        }\n\n        var tinyExtent = 10; // Arbitrary value: 10px\n        var minCoord = colorStops[0].coord - tinyExtent;\n        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n        var coordSpan = maxCoord - minCoord;\n\n        if (coordSpan < 1e-3) {\n            return 'transparent';\n        }\n\n        zrUtil.each(colorStops, function (stop) {\n            stop.offset = (stop.coord - minCoord) / coordSpan;\n        });\n        colorStops.push({\n            offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n            color: outerColors[1] || 'transparent'\n        });\n        colorStops.unshift({ // notice colorStops.length have been changed.\n            offset: stopLen ? colorStops[0].offset : 0.5,\n            color: outerColors[0] || 'transparent'\n        });\n\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n        gradient[dimName] = minCoord;\n        gradient[dimName + '2'] = maxCoord;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    if (!pt) {\n                        // Null data\n                        return;\n                    }\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // FIXME\n                // can not downplay completely.\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanM/ODBhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0RUFBNEU7QUFDM0YsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQix1QkFBdUI7QUFDMUMsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gRklYTUUgc3RlcCBub3Qgc3VwcG9ydCBwb2xhclxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFN5bWJvbERyYXcgPSByZXF1aXJlKCcuLi9oZWxwZXIvU3ltYm9sRHJhdycpO1xuICAgIHZhciBTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXIvU3ltYm9sJyk7XG4gICAgdmFyIGxpbmVBbmltYXRpb25EaWZmID0gcmVxdWlyZSgnLi9saW5lQW5pbWF0aW9uRGlmZicpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4vcG9seScpO1xuICAgIHZhciBDaGFydFZpZXcgPSByZXF1aXJlKCcuLi8uLi92aWV3L0NoYXJ0Jyk7XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50c1NhbWUocG9pbnRzMSwgcG9pbnRzMikge1xuICAgICAgICBpZiAocG9pbnRzMS5sZW5ndGggIT09IHBvaW50czIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHMxW2ldO1xuICAgICAgICAgICAgdmFyIHAyID0gcG9pbnRzMltpXTtcbiAgICAgICAgICAgIGlmIChwMVswXSAhPT0gcDJbMF0gfHwgcDFbMV0gIT09IHAyWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNtb290aChzbW9vdGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiAoc21vb3RoKSA9PT0gJ251bWJlcicgPyBzbW9vdGggOiAoc21vb3RoID8gMC4zIDogMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc0V4dGVudFdpdGhHYXAoYXhpcykge1xuICAgICAgICB2YXIgZXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQoKTtcbiAgICAgICAgaWYgKGF4aXMub25CYW5kKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZXh0cmEgMXB4IHRvIGF2b2lkIGxpbmUgbWl0ZXIgaW4gY2xpcHBlZCBlZGdlXG4gICAgICAgICAgICB2YXIgaGFsZkJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCkgLyAyIC0gMTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBleHRlbnRbMV0gPiBleHRlbnRbMF0gPyAxIDogLTE7XG4gICAgICAgICAgICBleHRlbnRbMF0gKz0gZGlyICogaGFsZkJhbmRXaWR0aDtcbiAgICAgICAgICAgIGV4dGVudFsxXSAtPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2lnbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAwID8gMSA6IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRHxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9wb2xhci9Qb2xhcn0gY29vcmRTeXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gYmFzZUF4aXMub25aZXJvXG4gICAgICAgICAgICA/IDAgOiB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KClbMF07XG5cbiAgICAgICAgdmFyIHZhbHVlRGltID0gdmFsdWVBeGlzLmRpbTtcblxuICAgICAgICB2YXIgYmFzZURhdGFPZmZzZXQgPSB2YWx1ZURpbSA9PT0gJ3gnIHx8IHZhbHVlRGltID09PSAncmFkaXVzJyA/IDEgOiAwO1xuXG4gICAgICAgIHJldHVybiBkYXRhLm1hcEFycmF5KFt2YWx1ZURpbV0sIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrZWRPblNhbWVTaWduO1xuICAgICAgICAgICAgdmFyIHN0YWNrZWRPbiA9IGRhdGEuc3RhY2tlZE9uO1xuICAgICAgICAgICAgLy8gRmluZCBmaXJzdCBzdGFja2VkIHZhbHVlIHdpdGggc2FtZSBzaWduXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2tlZE9uICYmXG4gICAgICAgICAgICAgICAgc2lnbihzdGFja2VkT24uZ2V0KHZhbHVlRGltLCBpZHgpKSA9PT0gc2lnbih2YWwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzdGFja2VkT25TYW1lU2lnbiA9IHN0YWNrZWRPbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFja2VkRGF0YSA9IFtdO1xuICAgICAgICAgICAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoYmFzZUF4aXMuZGltLCBpZHgpO1xuICAgICAgICAgICAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHN0YWNrZWRPblNhbWVTaWduXG4gICAgICAgICAgICAgICAgPyBzdGFja2VkT25TYW1lU2lnbi5nZXQodmFsdWVEaW0sIGlkeCwgdHJ1ZSkgOiB2YWx1ZVN0YXJ0O1xuXG4gICAgICAgICAgICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHcmlkQ2xpcFNoYXBlKGNhcnRlc2lhbiwgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgeEV4dGVudCA9IGdldEF4aXNFeHRlbnRXaXRoR2FwKGNhcnRlc2lhbi5nZXRBeGlzKCd4JykpO1xuICAgICAgICB2YXIgeUV4dGVudCA9IGdldEF4aXNFeHRlbnRXaXRoR2FwKGNhcnRlc2lhbi5nZXRBeGlzKCd5JykpO1xuICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgdmFyIHggPSBNYXRoLm1pbih4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLm1pbih5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKTtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoeEV4dGVudFswXSwgeEV4dGVudFsxXSkgLSB4O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoeUV4dGVudFswXSwgeUV4dGVudFsxXSkgLSB5O1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gc2VyaWVzTW9kZWwuZ2V0KCdsaW5lU3R5bGUubm9ybWFsLndpZHRoJykgfHwgMjtcbiAgICAgICAgLy8gRXhwYW5kIGNsaXAgc2hhcGUgdG8gYXZvaWQgY2xpcHBpbmcgd2hlbiBsaW5lIHZhbHVlIGV4Y2VlZHMgYXhpc1xuICAgICAgICB2YXIgZXhwYW5kU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnY2xpcE92ZXJmbG93JykgPyBsaW5lV2lkdGggLyAyIDogTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHkgLT0gZXhwYW5kU2l6ZTtcbiAgICAgICAgICAgIGhlaWdodCArPSBleHBhbmRTaXplICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggLT0gZXhwYW5kU2l6ZTtcbiAgICAgICAgICAgIHdpZHRoICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgY2xpcFBhdGguc2hhcGVbaXNIb3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA9IDA7XG4gICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xpcFBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUG9sYXJDbGlwU2hhcGUocG9sYXIsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGFuZ2xlQXhpcyA9IHBvbGFyLmdldEFuZ2xlQXhpcygpO1xuICAgICAgICB2YXIgcmFkaXVzQXhpcyA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKTtcblxuICAgICAgICB2YXIgcmFkaXVzRXh0ZW50ID0gcmFkaXVzQXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgdmFyIGFuZ2xlRXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuXG4gICAgICAgIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAgIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIGN4OiBwb2xhci5jeCxcbiAgICAgICAgICAgICAgICBjeTogcG9sYXIuY3ksXG4gICAgICAgICAgICAgICAgcjA6IHJhZGl1c0V4dGVudFswXSxcbiAgICAgICAgICAgICAgICByOiByYWRpdXNFeHRlbnRbMV0sXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogLWFuZ2xlRXh0ZW50WzBdICogUkFESUFOLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiAtYW5nbGVFeHRlbnRbMV0gKiBSQURJQU4sXG4gICAgICAgICAgICAgICAgY2xvY2t3aXNlOiBhbmdsZUF4aXMuaW52ZXJzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjbGlwUGF0aC5zaGFwZS5lbmRBbmdsZSA9IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTjtcbiAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGlwUGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcidcbiAgICAgICAgICAgID8gY3JlYXRlUG9sYXJDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpXG4gICAgICAgICAgICA6IGNyZWF0ZUdyaWRDbGlwU2hhcGUoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwVHVybkF0KSB7XG4gICAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgIHZhciBiYXNlSW5kZXggPSBiYXNlQXhpcy5kaW0gPT09ICd4JyB8fCBiYXNlQXhpcy5kaW0gPT09ICdyYWRpdXMnID8gMCA6IDE7XG5cbiAgICAgICAgdmFyIHN0ZXBQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFB0ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIHN0ZXBQb2ludHMucHVzaChwdCk7XG5cbiAgICAgICAgICAgIHZhciBzdGVwUHQgPSBbXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RlcFR1cm5BdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gbmV4dFB0W2Jhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IHB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSAocHRbYmFzZUluZGV4XSArIG5leHRQdFtiYXNlSW5kZXhdKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGVwUHQyID0gW107XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gc3RlcFB0MltiYXNlSW5kZXhdID0gbWlkZGxlO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0MlsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHQyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBwdFtiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBuZXh0UHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGFzdCBwb2ludHNcbiAgICAgICAgcG9pbnRzW2ldICYmIHN0ZXBQb2ludHMucHVzaChwb2ludHNbaV0pO1xuICAgICAgICByZXR1cm4gc3RlcFBvaW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cykge1xuICAgICAgICB2YXIgdmlzdWFsTWV0YUxpc3QgPSBkYXRhLmdldFZpc3VhbCgndmlzdWFsTWV0YScpO1xuICAgICAgICBpZiAoIXZpc3VhbE1ldGFMaXN0IHx8ICF2aXN1YWxNZXRhTGlzdC5sZW5ndGggfHwgIWRhdGEuY291bnQoKSkge1xuICAgICAgICAgICAgLy8gV2hlbiBkYXRhLmNvdW50KCkgaXMgMCwgZ3JhZGllbnQgcmFuZ2UgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpc3VhbE1ldGE7XG4gICAgICAgIGZvciAodmFyIGkgPSB2aXN1YWxNZXRhTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLy8gQ2FuIG9ubHkgYmUgeCBvciB5XG4gICAgICAgICAgICBpZiAodmlzdWFsTWV0YUxpc3RbaV0uZGltZW5zaW9uIDwgMikge1xuICAgICAgICAgICAgICAgIHZpc3VhbE1ldGEgPSB2aXN1YWxNZXRhTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpc3VhbE1ldGEgfHwgY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Zpc3VhbCBtYXAgb24gbGluZSBzdHlsZSBvbmx5IHN1cHBvcnQgeCBvciB5IGRpbWVuc2lvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBhcmVhIHRvIGJlIHJlbmRlcmVkIGlzIGJpZ2dlciB0aGFuIGFyZWEgZGVmaW5lZCBieSBMaW5lYXJHcmFkaWVudCxcbiAgICAgICAgLy8gdGhlIGNhbnZhcyBzcGVjIHByZXNjcmliZXMgdGhhdCB0aGUgY29sb3Igb2YgdGhlIGZpcnN0IHN0b3AgYW5kIHRoZSBsYXN0XG4gICAgICAgIC8vIHN0b3Agc2hvdWxkIGJlIHVzZWQuIEJ1dCBpZiB0d28gc3RvcHMgYXJlIGFkZGVkIGF0IG9mZnNldCAwLCBpbiBlZmZlY3RcbiAgICAgICAgLy8gYnJvd3NlcnMgdXNlIHRoZSBjb2xvciBvZiB0aGUgc2Vjb25kIHN0b3AgdG8gcmVuZGVyIGFyZWEgb3V0c2lkZVxuICAgICAgICAvLyBMaW5lYXJHcmFkaWVudC4gU28gd2UgY2FuIG9ubHkgaW5maW5pdGVzaW1hbGx5IGV4dGVuZCBhcmVhIGRlZmluZWQgaW5cbiAgICAgICAgLy8gTGluZWFyR3JhZGllbnQgdG8gcmVuZGVyIGBvdXRlckNvbG9yc2AuXG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHZpc3VhbE1ldGEuZGltZW5zaW9uO1xuICAgICAgICB2YXIgZGltTmFtZSA9IGRhdGEuZGltZW5zaW9uc1tkaW1lbnNpb25dO1xuICAgICAgICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSk7XG5cbiAgICAgICAgLy8gZGF0YVRvQ29vciBtYXBwaW5nIG1heSBub3QgYmUgbGluZWFyLCBidXQgbXVzdCBiZSBtb25vdG9uaWMuXG4gICAgICAgIHZhciBjb2xvclN0b3BzID0genJVdGlsLm1hcCh2aXN1YWxNZXRhLnN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb29yZDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQoc3RvcC52YWx1ZSkpLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBzdG9wLmNvbG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0b3BMZW4gPSBjb2xvclN0b3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIG91dGVyQ29sb3JzID0gdmlzdWFsTWV0YS5vdXRlckNvbG9ycy5zbGljZSgpO1xuXG4gICAgICAgIGlmIChzdG9wTGVuICYmIGNvbG9yU3RvcHNbMF0uY29vcmQgPiBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5jb29yZCkge1xuICAgICAgICAgICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBvdXRlckNvbG9ycy5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlueUV4dGVudCA9IDEwOyAvLyBBcmJpdHJhcnkgdmFsdWU6IDEwcHhcbiAgICAgICAgdmFyIG1pbkNvb3JkID0gY29sb3JTdG9wc1swXS5jb29yZCAtIHRpbnlFeHRlbnQ7XG4gICAgICAgIHZhciBtYXhDb29yZCA9IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkICsgdGlueUV4dGVudDtcbiAgICAgICAgdmFyIGNvb3JkU3BhbiA9IG1heENvb3JkIC0gbWluQ29vcmQ7XG5cbiAgICAgICAgaWYgKGNvb3JkU3BhbiA8IDFlLTMpIHtcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNwYXJlbnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgenJVdGlsLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICAgIHN0b3Aub2Zmc2V0ID0gKHN0b3AuY29vcmQgLSBtaW5Db29yZCkgLyBjb29yZFNwYW47XG4gICAgICAgIH0pO1xuICAgICAgICBjb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0ub2Zmc2V0IDogMC41LFxuICAgICAgICAgICAgY29sb3I6IG91dGVyQ29sb3JzWzFdIHx8ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbG9yU3RvcHMudW5zaGlmdCh7IC8vIG5vdGljZSBjb2xvclN0b3BzLmxlbmd0aCBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgICAgIG9mZnNldDogc3RvcExlbiA/IGNvbG9yU3RvcHNbMF0ub2Zmc2V0IDogMC41LFxuICAgICAgICAgICAgY29sb3I6IG91dGVyQ29sb3JzWzBdIHx8ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8genJVdGlsLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24gKGNvbG9yU3RvcCkge1xuICAgICAgICAvLyAgICAgLy8gTWFrZSBzdXJlIGVhY2ggb2Zmc2V0IGhhcyByb3VuZGVkIHB4IHRvIGF2b2lkIG5vdCBzaGFycCBlZGdlXG4gICAgICAgIC8vICAgICBjb2xvclN0b3Aub2Zmc2V0ID0gKE1hdGgucm91bmQoY29sb3JTdG9wLm9mZnNldCAqIChlbmQgLSBzdGFydCkgKyBzdGFydCkgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCgwLCAwLCAwLCAwLCBjb2xvclN0b3BzLCB0cnVlKTtcbiAgICAgICAgZ3JhZGllbnRbZGltTmFtZV0gPSBtaW5Db29yZDtcbiAgICAgICAgZ3JhZGllbnRbZGltTmFtZSArICcyJ10gPSBtYXhDb29yZDtcblxuICAgICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDaGFydFZpZXcuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbGluZScsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmVHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHZhciBzeW1ib2xEcmF3ID0gbmV3IFN5bWJvbERyYXcoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApO1xuXG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xEcmF3ID0gc3ltYm9sRHJhdztcbiAgICAgICAgICAgIHRoaXMuX2xpbmVHcm91cCA9IGxpbmVHcm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5ub3JtYWwnKTtcbiAgICAgICAgICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUubm9ybWFsJyk7XG5cbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBkYXRhLm1hcEFycmF5KGRhdGEuZ2V0SXRlbUxheW91dCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBpc0Nvb3JkU3lzUG9sYXIgPSBjb29yZFN5cy50eXBlID09PSAncG9sYXInO1xuICAgICAgICAgICAgdmFyIHByZXZDb29yZFN5cyA9IHRoaXMuX2Nvb3JkU3lzO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXc7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcblxuICAgICAgICAgICAgdmFyIGxpbmVHcm91cCA9IHRoaXMuX2xpbmVHcm91cDtcblxuICAgICAgICAgICAgdmFyIGhhc0FuaW1hdGlvbiA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG5cbiAgICAgICAgICAgIHZhciBpc0FyZWFDaGFydCA9ICFhcmVhU3R5bGVNb2RlbC5pc0VtcHR5KCk7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gZ2V0U3RhY2tlZE9uUG9pbnRzKGNvb3JkU3lzLCBkYXRhKTtcblxuICAgICAgICAgICAgdmFyIHNob3dTeW1ib2wgPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dTeW1ib2wnKTtcblxuICAgICAgICAgICAgdmFyIGlzU3ltYm9sSWdub3JlID0gc2hvd1N5bWJvbCAmJiAhaXNDb29yZFN5c1BvbGFyICYmICFzZXJpZXNNb2RlbC5nZXQoJ3Nob3dBbGxTeW1ib2wnKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2dldFN5bWJvbElnbm9yZUZ1bmMoZGF0YSwgY29vcmRTeXMpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGVtcG9yYXJ5IHN5bWJvbHNcbiAgICAgICAgICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgIG9sZERhdGEgJiYgb2xkRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5fX3RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHN5bWJvbHMgaWYgc2hvd1N5bWJvbCBjaGFuZ2VkIHRvIGZhbHNlXG4gICAgICAgICAgICBpZiAoIXNob3dTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xEcmF3LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5hZGQobGluZUdyb3VwKTtcblxuICAgICAgICAgICAgLy8gRklYTUUgc3RlcCBub3Qgc3VwcG9ydCBwb2xhclxuICAgICAgICAgICAgdmFyIHN0ZXAgPSAhaXNDb29yZFN5c1BvbGFyICYmIHNlcmllc01vZGVsLmdldCgnc3RlcCcpO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5pbWF0aW9uIG9yIGNvb3JkaW5hdGUgc3lzdGVtIGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhKHBvbHlsaW5lICYmIHByZXZDb29yZFN5cy50eXBlID09PSBjb29yZFN5cy50eXBlICYmIHN0ZXAgPT09IHRoaXMuX3N0ZXApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzaG93U3ltYm9sICYmIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCBpc1N5bWJvbElnbm9yZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gdGhpcy5fbmV3UG9seWxpbmUocG9pbnRzLCBjb29yZFN5cywgaGFzQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcmVhQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsIHN0YWNrZWRPblBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzLCBoYXNBbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgdHJ1ZSwgc2VyaWVzTW9kZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0FyZWFDaGFydCAmJiAhcG9seWdvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsIHN0YWNrZWRPblBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzLCBoYXNBbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocG9seWdvbiAmJiAhaXNBcmVhQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXJlYVN0eWxlIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHRoaXMuX3BvbHlnb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjbGlwUGF0aFxuICAgICAgICAgICAgICAgIGxpbmVHcm91cC5zZXRDbGlwUGF0aChjcmVhdGVDbGlwU2hhcGUoY29vcmRTeXMsIGZhbHNlLCBzZXJpZXNNb2RlbCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSwgb3IgaXQgaXMgd3JvbmcgaW4gdGhlIGNhc2UgdHVybmluZyBvbiBsZWdlbmRcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHBvaW50cyBhcmUgbm90IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBzaG93U3ltYm9sICYmIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCBpc1N5bWJvbElnbm9yZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9wIHN5bWJvbCBhbmltYXRpb24gYW5kIHN5bmMgd2l0aCBsaW5lIHBvaW50c1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBlcmZvcm1hbmNlP1xuICAgICAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBkYXRhIHpvb20gdHJpZ2dlcnJlZCByZWZyZXNoaW5nIGZyZXF1ZW50bHlcbiAgICAgICAgICAgICAgICAvLyBEYXRhIG1heSBub3QgY2hhbmdlIGlmIGxpbmUgaGFzIGEgY2F0ZWdvcnkgYXhpcy4gU28gaXQgc2hvdWxkIGFuaW1hdGUgbm90aGluZ1xuICAgICAgICAgICAgICAgIGlmICghaXNQb2ludHNTYW1lKHRoaXMuX3N0YWNrZWRPblBvaW50cywgc3RhY2tlZE9uUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaXNQb2ludHNTYW1lKHRoaXMuX3BvaW50cywgcG9pbnRzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmltYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgYXBpLCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGRvIGl0IGluIHVwZGF0ZSB3aXRoIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24gJiYgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmlzdWFsQ29sb3IgPSBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cykgfHwgZGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG5cbiAgICAgICAgICAgIHBvbHlsaW5lLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAvLyBVc2UgY29sb3IgaW4gbGluZVN0eWxlIGZpcnN0XG4gICAgICAgICAgICAgICAgbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVKb2luOiAnYmV2ZWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aCcpO1xuICAgICAgICAgICAgc21vb3RoID0gZ2V0U21vb3RoKHNlcmllc01vZGVsLmdldCgnc21vb3RoJykpO1xuICAgICAgICAgICAgcG9seWxpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIHNtb290aDogc21vb3RoLFxuICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICAgICAgICAgICAgY29ubmVjdE51bGxzOiBzZXJpZXNNb2RlbC5nZXQoJ2Nvbm5lY3ROdWxscycpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRPblNtb290aCA9IDA7XG5cbiAgICAgICAgICAgICAgICBwb2x5Z29uLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAgICAgYXJlYVN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCksXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHZpc3VhbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC43LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUpvaW46ICdiZXZlbCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrZWRPbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uU2VyaWVzID0gc3RhY2tlZE9uLmhvc3RNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uU21vb3RoID0gZ2V0U21vb3RoKHN0YWNrZWRPblNlcmllcy5nZXQoJ3Ntb290aCcpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBzbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPblNtb290aDogc3RhY2tlZE9uU21vb3RoLFxuICAgICAgICAgICAgICAgICAgICBzbW9vdGhNb25vdG9uZTogc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGhNb25vdG9uZScpLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiBkYXRhIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMuX2Nvb3JkU3lzID0gY29vcmRTeXM7XG4gICAgICAgICAgICB0aGlzLl9zdGFja2VkT25Qb2ludHMgPSBzdGFja2VkT25Qb2ludHM7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgICAgICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGlmICghKGRhdGFJbmRleCBpbnN0YW5jZW9mIEFycmF5KSAmJiBkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgc3ltYm9sIGlmIGl0IGlzIG5vdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bGwgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woZGF0YSwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnBvc2l0aW9uID0gcHQ7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5zZXRaKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd6bGV2ZWwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneicpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5pZ25vcmUgPSBpc05hTihwdFswXSkgfHwgaXNOYU4ocHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuX190ZW1wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgc3ltYm9sKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHNjYWxlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuc3RvcFN5bWJvbEFuaW1hdGlvbih0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW1ib2wuaGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgd2hvbGUgc2VyaWVzXG4gICAgICAgICAgICAgICAgQ2hhcnRWaWV3LnByb3RvdHlwZS5oaWdobGlnaHQuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG93bnBsYXk6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAoZGF0YUluZGV4ICE9IG51bGwgJiYgZGF0YUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sLl9fdGVtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmRvd25wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIGNhbiBub3QgZG93bnBsYXkgY29tcGxldGVseS5cbiAgICAgICAgICAgICAgICAvLyBEb3ducGxheSB3aG9sZSBzZXJpZXNcbiAgICAgICAgICAgICAgICBDaGFydFZpZXcucHJvdG90eXBlLmRvd25wbGF5LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZXdQb2x5bGluZTogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5bGluZVxuICAgICAgICAgICAgaWYgKHBvbHlsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5bGluZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IHBvbHlIZWxwZXIuUG9seWxpbmUoe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5bGluZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lID0gcG9seWxpbmU7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2x5bGluZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gc3RhY2tlZE9uUG9pbnRzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbmV3UG9seWdvbjogZnVuY3Rpb24gKHBvaW50cywgc3RhY2tlZE9uUG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5Z29uXG4gICAgICAgICAgICBpZiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvbHlnb24gPSBuZXcgcG9seUhlbHBlci5Qb2x5Z29uKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xpbmVHcm91cC5hZGQocG9seWdvbik7XG5cbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24gPSBwb2x5Z29uO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2dldFN5bWJvbElnbm9yZUZ1bmM6IGZ1bmN0aW9uIChkYXRhLCBjb29yZFN5cykge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNvb3JkU3lzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF07XG4gICAgICAgICAgICAvLyBgZ2V0TGFiZWxJbnRlcnZhbGAgaXMgcHJvdmlkZWQgYnkgZWNoYXJ0cy9jb21wb25lbnQvYXhpc1xuICAgICAgICAgICAgaWYgKGNhdGVnb3J5QXhpcyAmJiBjYXRlZ29yeUF4aXMuaXNMYWJlbElnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLmJpbmQoY2F0ZWdvcnlBeGlzLmlzTGFiZWxJZ25vcmVkLCBjYXRlZ29yeUF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gRklYTUUgVHdvIHZhbHVlIGF4aXNcbiAgICAgICAgX3VwZGF0ZUFuaW1hdGlvbjogZnVuY3Rpb24gKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCkge1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBsaW5lQW5pbWF0aW9uRGlmZihcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLCBkYXRhLFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrZWRPblBvaW50cywgc3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3JkU3lzLCBjb29yZFN5c1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBkaWZmLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uQ3VycmVudCA9IGRpZmYuc3RhY2tlZE9uQ3VycmVudDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZGlmZi5uZXh0O1xuICAgICAgICAgICAgdmFyIHN0YWNrZWRPbk5leHQgPSBkaWZmLnN0YWNrZWRPbk5leHQ7XG4gICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuY3VycmVudCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPbkN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25DdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLm5leHQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICBzdGFja2VkT25OZXh0ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuc3RhY2tlZE9uTmV4dCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYGRpZmYuY3VycmVudGAgaXMgc3Vic2V0IG9mIGBjdXJyZW50YCAod2hpY2ggc2hvdWxkIGJlIGVuc3VyZWQgYnlcbiAgICAgICAgICAgIC8vIHR1cm5Qb2ludHNJbnRvU3RlcCksIHNvIHBvaW50cyBpbiBgX19wb2ludHNgIGNhbiBiZSB1cGRhdGVkIHdoZW5cbiAgICAgICAgICAgIC8vIHBvaW50cyBpbiBgY3VycmVudGAgYXJlIHVwZGF0ZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAgICAgICAgcG9seWxpbmUuc2hhcGUuX19wb2ludHMgPSBkaWZmLmN1cnJlbnQ7XG4gICAgICAgICAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBjdXJyZW50O1xuXG4gICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlsaW5lLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBuZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uQ3VycmVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBuZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25OZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVkRGF0YUluZm8gPSBbXTtcbiAgICAgICAgICAgIHZhciBkaWZmU3RhdHVzID0gZGlmZi5zdGF0dXM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlN0YXR1cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkaWZmU3RhdHVzW2ldLmNtZDtcbiAgICAgICAgICAgICAgICBpZiAoY21kID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRpZmZTdGF0dXNbaV0uaWR4MSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERhdGFJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdElkeDogaSAgICAvLyBJbmRleCBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9seWxpbmUuYW5pbWF0b3JzICYmIHBvbHlsaW5lLmFuaW1hdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb2x5bGluZS5hbmltYXRvcnNbMF0uZHVyaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVkRGF0YUluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHVwZGF0ZWREYXRhSW5mb1tpXS5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9seWxpbmUuc2hhcGUuX19wb2ludHNbdXBkYXRlZERhdGFJbmZvW2ldLnB0SWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGVtcG9yYXJ5IGNyZWF0ZWQgZWxlbWVudHMgd2hlbiBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgIG9sZERhdGEgJiYgb2xkRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5fX3RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lID1cbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24gPVxuICAgICAgICAgICAgdGhpcy5fY29vcmRTeXMgPVxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzID1cbiAgICAgICAgICAgIHRoaXMuX3N0YWNrZWRPblBvaW50cyA9XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 116 */
/***/ (function(module, exports) {

eval("\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUvbGluZUFuaW1hdGlvbkRpZmYuanM/M2IzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BELGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjExNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgLy8gdmFyIGFycmF5RGlmZiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvYXJyYXlEaWZmJyk7XG4gICAgLy8gJ3pyZW5kZXIvY29yZS9hcnJheURpZmYnIGhhcyBiZWVuIHVzZWQgYmVmb3JlLCBidXQgaXQgZGlkXG4gICAgLy8gbm90IGRvIHdlbGwgaW4gcGVyZm9ybWFuY2Ugd2hlbiByb2FtIHdpdGggZml4ZWQgZGF0YVpvb20gd2luZG93LlxuXG4gICAgZnVuY3Rpb24gc2lnbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAwID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50KGNvb3JkU3lzLCBkYXRhLCBpZHgpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gYmFzZUF4aXMub25aZXJvXG4gICAgICAgICAgICA/IDAgOiB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KClbMF07XG5cbiAgICAgICAgdmFyIHZhbHVlRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgICAgICAgdmFyIGJhc2VEYXRhT2Zmc2V0ID0gdmFsdWVEaW0gPT09ICd4JyB8fCB2YWx1ZURpbSA9PT0gJ3JhZGl1cycgPyAxIDogMDtcblxuICAgICAgICB2YXIgc3RhY2tlZE9uU2FtZVNpZ247XG4gICAgICAgIHZhciBzdGFja2VkT24gPSBkYXRhLnN0YWNrZWRPbjtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpO1xuICAgICAgICAvLyBGaW5kIGZpcnN0IHN0YWNrZWQgdmFsdWUgd2l0aCBzYW1lIHNpZ25cbiAgICAgICAgd2hpbGUgKHN0YWNrZWRPbiAmJlxuICAgICAgICAgICAgc2lnbihzdGFja2VkT24uZ2V0KHZhbHVlRGltLCBpZHgpKSA9PT0gc2lnbih2YWwpXG4gICAgICAgICkge1xuICAgICAgICAgICAgc3RhY2tlZE9uU2FtZVNpZ24gPSBzdGFja2VkT247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhY2tlZERhdGEgPSBbXTtcbiAgICAgICAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoYmFzZUF4aXMuZGltLCBpZHgpO1xuICAgICAgICBzdGFja2VkRGF0YVsxIC0gYmFzZURhdGFPZmZzZXRdID0gc3RhY2tlZE9uU2FtZVNpZ25cbiAgICAgICAgICAgID8gc3RhY2tlZE9uU2FtZVNpZ24uZ2V0KHZhbHVlRGltLCBpZHgsIHRydWUpIDogdmFsdWVTdGFydDtcblxuICAgICAgICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIGNvbnZlcnRUb0ludElkKG5ld0lkTGlzdCwgb2xkSWRMaXN0KSB7XG4gICAgLy8gICAgIC8vIEdlbmVyYXRlIGludCBpZCBpbnN0ZWFkIG9mIHN0cmluZyBpZC5cbiAgICAvLyAgICAgLy8gQ29tcGFyZSBzdHJpbmcgbWF5YmUgc2xvdyBpbiBzY29yZSBmdW5jdGlvbiBvZiBhcnJEaWZmXG5cbiAgICAvLyAgICAgLy8gQXNzdW1lIGlkIGluIGlkTGlzdCBhcmUgYWxsIHVuaXF1ZVxuICAgIC8vICAgICB2YXIgaWRJbmRpY2VzTWFwID0ge307XG4gICAgLy8gICAgIHZhciBpZHggPSAwO1xuICAgIC8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgaWRJbmRpY2VzTWFwW25ld0lkTGlzdFtpXV0gPSBpZHg7XG4gICAgLy8gICAgICAgICBuZXdJZExpc3RbaV0gPSBpZHgrKztcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZElkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICAgdmFyIG9sZElkID0gb2xkSWRMaXN0W2ldO1xuICAgIC8vICAgICAgICAgLy8gU2FtZSB3aXRoIG5ld0lkTGlzdFxuICAgIC8vICAgICAgICAgaWYgKGlkSW5kaWNlc01hcFtvbGRJZF0pIHtcbiAgICAvLyAgICAgICAgICAgICBvbGRJZExpc3RbaV0gPSBpZEluZGljZXNNYXBbb2xkSWRdO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgICAgZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgb2xkSWRMaXN0W2ldID0gaWR4Kys7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBkaWZmRGF0YShvbGREYXRhLCBuZXdEYXRhKSB7XG4gICAgICAgIHZhciBkaWZmUmVzdWx0ID0gW107XG5cbiAgICAgICAgbmV3RGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICBkaWZmUmVzdWx0LnB1c2goe2NtZDogJysnLCBpZHg6IGlkeH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgZGlmZlJlc3VsdC5wdXNoKHtjbWQ6ICc9JywgaWR4OiBvbGRJZHgsIGlkeDE6IG5ld0lkeH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIGRpZmZSZXN1bHQucHVzaCh7Y21kOiAnLScsIGlkeDogaWR4fSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICByZXR1cm4gZGlmZlJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChcbiAgICAgICAgb2xkRGF0YSwgbmV3RGF0YSxcbiAgICAgICAgb2xkU3RhY2tlZE9uUG9pbnRzLCBuZXdTdGFja2VkT25Qb2ludHMsXG4gICAgICAgIG9sZENvb3JkU3lzLCBuZXdDb29yZFN5c1xuICAgICkge1xuICAgICAgICB2YXIgZGlmZiA9IGRpZmZEYXRhKG9sZERhdGEsIG5ld0RhdGEpO1xuXG4gICAgICAgIC8vIHZhciBuZXdJZExpc3QgPSBuZXdEYXRhLm1hcEFycmF5KG5ld0RhdGEuZ2V0SWQpO1xuICAgICAgICAvLyB2YXIgb2xkSWRMaXN0ID0gb2xkRGF0YS5tYXBBcnJheShvbGREYXRhLmdldElkKTtcblxuICAgICAgICAvLyBjb252ZXJ0VG9JbnRJZChuZXdJZExpc3QsIG9sZElkTGlzdCk7XG5cbiAgICAgICAgLy8gLy8gRklYTUUgT25lIGRhdGEgP1xuICAgICAgICAvLyBkaWZmID0gYXJyYXlEaWZmKG9sZElkTGlzdCwgbmV3SWRMaXN0KTtcblxuICAgICAgICB2YXIgY3VyclBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgbmV4dFBvaW50cyA9IFtdO1xuICAgICAgICAvLyBQb2ludHMgZm9yIHN0YWNraW5nIGJhc2UgbGluZVxuICAgICAgICB2YXIgY3VyclN0YWNrZWRQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG5leHRTdGFja2VkUG9pbnRzID0gW107XG5cbiAgICAgICAgdmFyIHN0YXR1cyA9IFtdO1xuICAgICAgICB2YXIgc29ydGVkSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgcmF3SW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgZGltcyA9IG5ld0Nvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpZmZJdGVtID0gZGlmZltpXTtcbiAgICAgICAgICAgIHZhciBwb2ludEFkZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gRklYTUUsIGFuaW1hdGlvbiBpcyBub3Qgc28gcGVyZmVjdCB3aGVuIGRhdGFab29tIHdpbmRvdyBtb3ZlcyBmYXN0XG4gICAgICAgICAgICAvLyBXaGljaCBpcyBpbiBjYXNlIHJlbXZvaW5nIG9yIGFkZCBtb3JlIHRoYW4gb25lIGRhdGEgaW4gdGhlIHRhaWwgb3IgaGVhZFxuICAgICAgICAgICAgc3dpdGNoIChkaWZmSXRlbS5jbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQdCA9IG9sZERhdGEuZ2V0SXRlbUxheW91dChkaWZmSXRlbS5pZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFB0ID0gbmV3RGF0YS5nZXRJdGVtTGF5b3V0KGRpZmZJdGVtLmlkeDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBkYXRhIGlzIE5hTiwgdXNlIG5leHQgcG9pbnQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQdFswXSkgfHwgaXNOYU4oY3VycmVudFB0WzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFB0ID0gbmV4dFB0LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyclBvaW50cy5wdXNoKGN1cnJlbnRQdCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb2ludHMucHVzaChuZXh0UHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2RpZmZJdGVtLmlkeF0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tkaWZmSXRlbS5pZHgxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoZGlmZkl0ZW0uaWR4MSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGRpZmZJdGVtLmlkeDtcbiAgICAgICAgICAgICAgICAgICAgY3VyclBvaW50cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ29vcmRTeXMuZGF0YVRvUG9pbnQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGEuZ2V0KGRpbXNbMF0sIGlkeCwgdHJ1ZSksIG5ld0RhdGEuZ2V0KGRpbXNbMV0sIGlkeCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5ld0RhdGEuZ2V0SXRlbUxheW91dChpZHgpLnNsaWNlKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGFja2VkT25Qb2ludChvbGRDb29yZFN5cywgbmV3RGF0YSwgaWR4KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhY2tlZFBvaW50cy5wdXNoKG5ld1N0YWNrZWRPblBvaW50c1tpZHhdKTtcblxuICAgICAgICAgICAgICAgICAgICByYXdJbmRpY2VzLnB1c2gobmV3RGF0YS5nZXRSYXdJbmRleChpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBkaWZmSXRlbS5pZHg7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXdJbmRleCA9IG9sZERhdGEuZ2V0UmF3SW5kZXgoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGF0YSBpcyByZXBsYWNlZC4gSW4gdGhlIGNhc2Ugb2YgZHluYW1pYyBkYXRhIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEZJWE1FIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyUG9pbnRzLnB1c2gob2xkRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5ld0Nvb3JkU3lzLmRhdGFUb1BvaW50KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGREYXRhLmdldChkaW1zWzBdLCBpZHgsIHRydWUpLCBvbGREYXRhLmdldChkaW1zWzFdLCBpZHgsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGFja2VkT25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29vcmRTeXMsIG9sZERhdGEsIGlkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0luZGljZXMucHVzaChyYXdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgaW5kaWNlc1xuICAgICAgICAgICAgaWYgKHBvaW50QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaChkaWZmSXRlbSk7XG4gICAgICAgICAgICAgICAgc29ydGVkSW5kaWNlcy5wdXNoKHNvcnRlZEluZGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpZmYgcmVzdWx0IG1heSBiZSBjcm9zc2VkIGlmIGFsbCBpdGVtcyBhcmUgY2hhbmdlZFxuICAgICAgICAvLyBTb3J0IGJ5IGRhdGEgaW5kZXhcbiAgICAgICAgc29ydGVkSW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3SW5kaWNlc1thXSAtIHJhd0luZGljZXNbYl07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzb3J0ZWRDdXJyUG9pbnRzID0gW107XG4gICAgICAgIHZhciBzb3J0ZWROZXh0UG9pbnRzID0gW107XG5cbiAgICAgICAgdmFyIHNvcnRlZEN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gICAgICAgIHZhciBzb3J0ZWROZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBzb3J0ZWRTdGF0dXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc29ydGVkSW5kaWNlc1tpXTtcbiAgICAgICAgICAgIHNvcnRlZEN1cnJQb2ludHNbaV0gPSBjdXJyUG9pbnRzW2lkeF07XG4gICAgICAgICAgICBzb3J0ZWROZXh0UG9pbnRzW2ldID0gbmV4dFBvaW50c1tpZHhdO1xuXG4gICAgICAgICAgICBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50c1tpXSA9IGN1cnJTdGFja2VkUG9pbnRzW2lkeF07XG4gICAgICAgICAgICBzb3J0ZWROZXh0U3RhY2tlZFBvaW50c1tpXSA9IG5leHRTdGFja2VkUG9pbnRzW2lkeF07XG5cbiAgICAgICAgICAgIHNvcnRlZFN0YXR1c1tpXSA9IHN0YXR1c1tpZHhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQ6IHNvcnRlZEN1cnJQb2ludHMsXG4gICAgICAgICAgICBuZXh0OiBzb3J0ZWROZXh0UG9pbnRzLFxuXG4gICAgICAgICAgICBzdGFja2VkT25DdXJyZW50OiBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50cyxcbiAgICAgICAgICAgIHN0YWNrZWRPbk5leHQ6IHNvcnRlZE5leHRTdGFja2VkUG9pbnRzLFxuXG4gICAgICAgICAgICBzdGF0dXM6IHNvcnRlZFN0YXR1c1xuICAgICAgICB9O1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9saW5lQW5pbWF0aW9uRGlmZi5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

eval("// Poly path support NaN point\n\n\n    var Path = __webpack_require__(8);\n    var vec2 = __webpack_require__(7);\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qcz9lNzkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RCx1Q0FBdUMsa0JBQWtCO0FBQ3pELHVDQUF1QyxrQkFBa0I7QUFDekQsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QiLCJmaWxlIjoiMTE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gUG9seSBwYXRoIHN1cHBvcnQgTmFOIHBvaW50XG5cblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xuXG4gICAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgdmFyIHNjYWxlQW5kQWRkID0gdmVjMi5zY2FsZUFuZEFkZDtcbiAgICB2YXIgdjJDb3B5ID0gdmVjMi5jb3B5O1xuXG4gICAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgY3AwID0gW107XG4gICAgdmFyIGNwMSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gaXNQb2ludE51bGwocCkge1xuICAgICAgICByZXR1cm4gaXNOYU4ocFswXSkgfHwgaXNOYU4ocFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1NlZ21lbnQoXG4gICAgICAgIGN0eCwgcG9pbnRzLCBzdGFydCwgc2VnTGVuLCBhbGxMZW4sXG4gICAgICAgIGRpciwgc21vb3RoTWluLCBzbW9vdGhNYXgsIHNtb290aCwgc21vb3RoTW9ub3RvbmUsIGNvbm5lY3ROdWxsc1xuICAgICkge1xuICAgICAgICB2YXIgcHJldklkeCA9IDA7XG4gICAgICAgIHZhciBpZHggPSBzdGFydDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZWdMZW47IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gYWxsTGVuIHx8IGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1BvaW50TnVsbChwKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IGRpcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGN0eFtkaXIgPiAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgdjJDb3B5KGNwMCwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dElkeCA9IGlkeCArIGRpcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQID0gcG9pbnRzW25leHRJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQgcG9pbnQgbm90IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0UCAmJiBpc1BvaW50TnVsbChwb2ludHNbbmV4dElkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkeCArPSBkaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlAgPSBwb2ludHNbcHJldklkeF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRQIHx8IGlzUG9pbnROdWxsKG5leHRQKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjJDb3B5KGNwMSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuZXh0IGRhdGEgaXMgbnVsbCBpbiBub3QgY29ubmVjdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2ludE51bGwobmV4dFApICYmICFjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQLCBwcmV2UCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5QcmV2U2VnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbk5leHRTZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICd4JyB8fCBzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IHNtb290aE1vbm90b25lID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5QcmV2U2VnID0gTWF0aC5hYnMocFtkaW1dIC0gcHJldlBbZGltXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguYWJzKHBbZGltXSAtIG5leHRQW2RpbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuUHJldlNlZyA9IHZlYzIuZGlzdChwLCBwcmV2UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IHZlYzIuZGlzdChwLCBuZXh0UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSByYXRpbyBvZiBzZWcgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICByYXRpb05leHRTZWcgPSBsZW5OZXh0U2VnIC8gKGxlbk5leHRTZWcgKyBsZW5QcmV2U2VnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVBbmRBZGQoY3AxLCBwLCB2LCAtc21vb3RoICogKDEgLSByYXRpb05leHRTZWcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTbW9vdGggY29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMCwgY3AwLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMCwgY3AwLCBzbW9vdGhNaW4pO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMSwgY3AxLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMSwgY3AxLCBzbW9vdGhNaW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3AwWzBdLCBjcDBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcDFbMF0sIGNwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbMF0sIHBbMV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3AwIG9mIG5leHQgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBzY2FsZUFuZEFkZChjcDAsIHAsIHYsIHNtb290aCAqIHJhdGlvTmV4dFNlZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldklkeCA9IGlkeDtcbiAgICAgICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNtb290aENvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIHB0TWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgIHZhciBwdE1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGlmIChzbW9vdGhDb25zdHJhaW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHRbMF0gPCBwdE1pblswXSkgeyBwdE1pblswXSA9IHB0WzBdOyB9XG4gICAgICAgICAgICAgICAgaWYgKHB0WzFdIDwgcHRNaW5bMV0pIHsgcHRNaW5bMV0gPSBwdFsxXTsgfVxuICAgICAgICAgICAgICAgIGlmIChwdFswXSA+IHB0TWF4WzBdKSB7IHB0TWF4WzBdID0gcHRbMF07IH1cbiAgICAgICAgICAgICAgICBpZiAocHRbMV0gPiBwdE1heFsxXSkgeyBwdE1heFsxXSA9IHB0WzFdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogc21vb3RoQ29uc3RyYWludCA/IHB0TWluIDogcHRNYXgsXG4gICAgICAgICAgICBtYXg6IHNtb290aENvbnN0cmFpbnQgPyBwdE1heCA6IHB0TWluXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgUG9seWxpbmU6IFBhdGguZXh0ZW5kKHtcblxuICAgICAgICAgICAgdHlwZTogJ2VjLXBvbHlsaW5lJyxcblxuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoOiAwLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEJvdW5kaW5nQm94KHBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCByZXN1bHQubWluLCByZXN1bHQubWF4LCBzaGFwZS5zbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5zbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG5cbiAgICAgICAgUG9seWdvbjogUGF0aC5leHRlbmQoe1xuXG4gICAgICAgICAgICB0eXBlOiAnZWMtcG9seWdvbicsXG5cbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcblxuICAgICAgICAgICAgICAgIC8vIE9mZnNldCBiZXR3ZWVuIHN0YWNrZWQgYmFzZSBwb2ludHMgYW5kIHBvaW50c1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogW10sXG5cbiAgICAgICAgICAgICAgICBzbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzdGFja2VkT25TbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG5cbiAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gc2hhcGUuc3RhY2tlZE9uUG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNoYXBlLnNtb290aE1vbm90b25lO1xuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uQkJveCA9IGdldEJvdW5kaW5nQm94KHN0YWNrZWRPblBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCBiYm94Lm1pbiwgYmJveC5tYXgsIHNoYXBlLnNtb290aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHN0YWNrZWRPblBvaW50cywgaSArIGsgLSAxLCBrLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSwgc3RhY2tlZE9uQkJveC5taW4sIHN0YWNrZWRPbkJCb3gubWF4LCBzaGFwZS5zdGFja2VkT25TbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gayArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// TODO boundaryGap\n\n\n    __webpack_require__(59);\n\n    __webpack_require__(125);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzLmpzP2M4YzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7O0FBRUEiLCJmaWxlIjoiMTE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETyBib3VuZGFyeUdhcFxuXG5cbiAgICByZXF1aXJlKCcuLi9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsJyk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXcnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var echarts = __webpack_require__(1);\n    var axisPointerModelHelper = __webpack_require__(23);\n    var axisTrigger = __webpack_require__(124);\n    var zrUtil = __webpack_require__(0);\n\n    __webpack_require__(120);\n    __webpack_require__(121);\n\n    // CartesianAxisPointer is not supposed to be required here. But consider\n    // echarts.simple.js and online build tooltip, which only require gridSimple,\n    // CartesianAxisPointer should be able to required somewhere.\n    __webpack_require__(123);\n\n    echarts.registerPreprocessor(function (option) {\n        // Always has a global axisPointerModel for default setting.\n        if (option) {\n            (!option.axisPointer || option.axisPointer.length === 0)\n                && (option.axisPointer = {});\n\n            var link = option.axisPointer.link;\n            // Normalize to array to avoid object mergin. But if link\n            // is not set, remain null/undefined, otherwise it will\n            // override existent link setting.\n            if (link && !zrUtil.isArray(link)) {\n                option.axisPointer.link = [link];\n            }\n        }\n    });\n\n    // This process should proformed after coordinate systems created\n    // and series data processed. So put it on statistic processing stage.\n    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n        // allAxesInfo should be updated when setOption performed.\n        ecModel.getComponent('axisPointer').coordSysAxesInfo\n            = axisPointerModelHelper.collect(ecModel, api);\n    });\n\n    // Broadcast to all views.\n    echarts.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n    }, axisTrigger);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci5qcz9hMWFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjExOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi9lY2hhcnRzJyk7XG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKCcuL2F4aXNQb2ludGVyL21vZGVsSGVscGVyJyk7XG4gICAgdmFyIGF4aXNUcmlnZ2VyID0gcmVxdWlyZSgnLi9heGlzUG9pbnRlci9heGlzVHJpZ2dlcicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHJlcXVpcmUoJy4vYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJNb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJWaWV3Jyk7XG5cbiAgICAvLyBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcmVxdWlyZWQgaGVyZS4gQnV0IGNvbnNpZGVyXG4gICAgLy8gZWNoYXJ0cy5zaW1wbGUuanMgYW5kIG9ubGluZSBidWlsZCB0b29sdGlwLCB3aGljaCBvbmx5IHJlcXVpcmUgZ3JpZFNpbXBsZSxcbiAgICAvLyBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBzaG91bGQgYmUgYWJsZSB0byByZXF1aXJlZCBzb21ld2hlcmUuXG4gICAgcmVxdWlyZSgnLi9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlcicpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIC8vIEFsd2F5cyBoYXMgYSBnbG9iYWwgYXhpc1BvaW50ZXJNb2RlbCBmb3IgZGVmYXVsdCBzZXR0aW5nLlxuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAoIW9wdGlvbi5heGlzUG9pbnRlciB8fCBvcHRpb24uYXhpc1BvaW50ZXIubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICYmIChvcHRpb24uYXhpc1BvaW50ZXIgPSB7fSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rID0gb3B0aW9uLmF4aXNQb2ludGVyLmxpbms7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gYXJyYXkgdG8gYXZvaWQgb2JqZWN0IG1lcmdpbi4gQnV0IGlmIGxpbmtcbiAgICAgICAgICAgIC8vIGlzIG5vdCBzZXQsIHJlbWFpbiBudWxsL3VuZGVmaW5lZCwgb3RoZXJ3aXNlIGl0IHdpbGxcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIGV4aXN0ZW50IGxpbmsgc2V0dGluZy5cbiAgICAgICAgICAgIGlmIChsaW5rICYmICF6clV0aWwuaXNBcnJheShsaW5rKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5heGlzUG9pbnRlci5saW5rID0gW2xpbmtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGlzIHByb2Nlc3Mgc2hvdWxkIHByb2Zvcm1lZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbXMgY3JlYXRlZFxuICAgIC8vIGFuZCBzZXJpZXMgZGF0YSBwcm9jZXNzZWQuIFNvIHB1dCBpdCBvbiBzdGF0aXN0aWMgcHJvY2Vzc2luZyBzdGFnZS5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGVjaGFydHMuUFJJT1JJVFkuUFJPQ0VTU09SLlNUQVRJU1RJQywgZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAvLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuICAgICAgICAvLyBhbGxBeGVzSW5mbyBzaG91bGQgYmUgdXBkYXRlZCB3aGVuIHNldE9wdGlvbiBwZXJmb3JtZWQuXG4gICAgICAgIGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm9cbiAgICAgICAgICAgID0gYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5jb2xsZWN0KGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG5cbiAgICAvLyBCcm9hZGNhc3QgdG8gYWxsIHZpZXdzLlxuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICBldmVudDogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgdXBkYXRlOiAnOnVwZGF0ZUF4aXNQb2ludGVyJ1xuICAgIH0sIGF4aXNUcmlnZ2VyKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var echarts = __webpack_require__(1);\n\n    var AxisPointerModel = echarts.extendComponentModel({\n\n        type: 'axisPointer',\n\n        coordSysAxesInfo: null,\n\n        defaultOption: {\n            // 'auto' means that show when triggered by tooltip or handle.\n            show: 'auto',\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: null, // set default in AxisPonterView.js\n\n            zlevel: 0,\n            z: 50,\n\n            type: 'line',\n            // axispointer triggered by tootip determine snap automatically,\n            // see `modelHelper`.\n            snap: false,\n            triggerTooltip: true,\n\n            value: null,\n            status: null, // Init value depends on whether handle is used.\n\n            // [group0, group1, ...]\n            // Each group can be: {\n            //      mapper: function () {},\n            //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n            //      xAxisId: ...,\n            //      yAxisName: ...,\n            //      angleAxisIndex: ...\n            // }\n            // mapper: can be ignored.\n            //      input: {axisInfo, value}\n            //      output: {axisInfo, value}\n            link: [],\n\n            // Do not set 'auto' here, otherwise global animation: false\n            // will not effect at this axispointer.\n            animation: null,\n            animationDurationUpdate: 200,\n\n            lineStyle: {\n                color: '#aaa',\n                width: 1,\n                type: 'solid'\n            },\n\n            shadowStyle: {\n                color: 'rgba(150,150,150,0.3)'\n            },\n\n            label: {\n                show: true,\n                formatter: null, // string | Function\n                precision: 'auto', // Or a number like 0, 1, 2 ...\n                margin: 3,\n                textStyle: {\n                    color: '#fff'\n                },\n                padding: [5, 7, 5, 7],\n                backgroundColor: 'auto', // default: axis line color\n                borderColor: null,\n                borderWidth: 0,\n                shadowBlur: 3,\n                shadowColor: '#aaa'\n                // Considering applicability, common style should\n                // better not have shadowOffset.\n                // shadowOffsetX: 0,\n                // shadowOffsetY: 2\n            },\n\n            handle: {\n                show: false,\n                icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n                size: 45,\n                // handle margin is from symbol center to axis, which is stable when circular move.\n                margin: 50,\n                // color: '#1b8bbd'\n                // color: '#2f4554'\n                color: '#333',\n                shadowBlur: 3,\n                shadowColor: '#aaa',\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n\n                // For mobile performance\n                throttle: 40\n            }\n        }\n\n    });\n\n    module.exports = AxisPointerModel;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsLmpzPzNmMGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcblxuICAgIHZhciBBeGlzUG9pbnRlck1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ2F4aXNQb2ludGVyJyxcblxuICAgICAgICBjb29yZFN5c0F4ZXNJbmZvOiBudWxsLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIC8vICdhdXRvJyBtZWFucyB0aGF0IHNob3cgd2hlbiB0cmlnZ2VyZWQgYnkgdG9vbHRpcCBvciBoYW5kbGUuXG4gICAgICAgICAgICBzaG93OiAnYXV0bycsXG4gICAgICAgICAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICAgICAgICAgIHRyaWdnZXJPbjogbnVsbCwgLy8gc2V0IGRlZmF1bHQgaW4gQXhpc1BvbnRlclZpZXcuanNcblxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogNTAsXG5cbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgIC8vIGF4aXNwb2ludGVyIHRyaWdnZXJlZCBieSB0b290aXAgZGV0ZXJtaW5lIHNuYXAgYXV0b21hdGljYWxseSxcbiAgICAgICAgICAgIC8vIHNlZSBgbW9kZWxIZWxwZXJgLlxuICAgICAgICAgICAgc25hcDogZmFsc2UsXG4gICAgICAgICAgICB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSxcblxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsIC8vIEluaXQgdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIGhhbmRsZSBpcyB1c2VkLlxuXG4gICAgICAgICAgICAvLyBbZ3JvdXAwLCBncm91cDEsIC4uLl1cbiAgICAgICAgICAgIC8vIEVhY2ggZ3JvdXAgY2FuIGJlOiB7XG4gICAgICAgICAgICAvLyAgICAgIG1hcHBlcjogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICAvLyAgICAgIHNpbmdsZVRvb2x0aXA6ICdtdWx0aXBsZScsICAvLyAnbXVsdGlwbGUnIG9yICdzaW5nbGUnXG4gICAgICAgICAgICAvLyAgICAgIHhBeGlzSWQ6IC4uLixcbiAgICAgICAgICAgIC8vICAgICAgeUF4aXNOYW1lOiAuLi4sXG4gICAgICAgICAgICAvLyAgICAgIGFuZ2xlQXhpc0luZGV4OiAuLi5cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIG1hcHBlcjogY2FuIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAvLyAgICAgIGlucHV0OiB7YXhpc0luZm8sIHZhbHVlfVxuICAgICAgICAgICAgLy8gICAgICBvdXRwdXQ6IHtheGlzSW5mbywgdmFsdWV9XG4gICAgICAgICAgICBsaW5rOiBbXSxcblxuICAgICAgICAgICAgLy8gRG8gbm90IHNldCAnYXV0bycgaGVyZSwgb3RoZXJ3aXNlIGdsb2JhbCBhbmltYXRpb246IGZhbHNlXG4gICAgICAgICAgICAvLyB3aWxsIG5vdCBlZmZlY3QgYXQgdGhpcyBheGlzcG9pbnRlci5cbiAgICAgICAgICAgIGFuaW1hdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAyMDAsXG5cbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2FhYScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2hhZG93U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTUwLDE1MCwxNTAsMC4zKSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IG51bGwsIC8vIHN0cmluZyB8IEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAnYXV0bycsIC8vIE9yIGEgbnVtYmVyIGxpa2UgMCwgMSwgMiAuLi5cbiAgICAgICAgICAgICAgICBtYXJnaW46IDMsXG4gICAgICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFs1LCA3LCA1LCA3XSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdhdXRvJywgLy8gZGVmYXVsdDogYXhpcyBsaW5lIGNvbG9yXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogMyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogJyNhYWEnXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgYXBwbGljYWJpbGl0eSwgY29tbW9uIHN0eWxlIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJldHRlciBub3QgaGF2ZSBzaGFkb3dPZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICAvLyBzaGFkb3dPZmZzZXRZOiAyXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYW5kbGU6IHtcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpY29uOiAnTTEwLjcsMTEuOXYtMS4zSDkuM3YxLjNjLTQuOSwwLjMtOC44LDQuNC04LjgsOS40YzAsNSwzLjksOS4xLDguOCw5LjRoMS4zYzQuOS0wLjMsOC44LTQuNCw4LjgtOS40QzE5LjUsMTYuMywxNS42LDEyLjIsMTAuNywxMS45eiBNMTMuMywyNC40SDYuN3YtMS4yaDYuNnogTTEzLjMsMjJINi43di0xLjJoNi42eiBNMTMuMywxOS42SDYuN3YtMS4yaDYuNnonLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICBzaXplOiA0NSxcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgbWFyZ2luIGlzIGZyb20gc3ltYm9sIGNlbnRlciB0byBheGlzLCB3aGljaCBpcyBzdGFibGUgd2hlbiBjaXJjdWxhciBtb3ZlLlxuICAgICAgICAgICAgICAgIG1hcmdpbjogNTAsXG4gICAgICAgICAgICAgICAgLy8gY29sb3I6ICcjMWI4YmJkJ1xuICAgICAgICAgICAgICAgIC8vIGNvbG9yOiAnIzJmNDU1NCdcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgICAgICAgICAgICAgc2hhZG93Q29sb3I6ICcjYWFhJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IDIsXG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgbW9iaWxlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgdGhyb3R0bGU6IDQwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzUG9pbnRlck1vZGVsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var globalListener = __webpack_require__(47);\n\n    var AxisPonterView = __webpack_require__(1).extendComponentView({\n\n        type: 'axisPointer',\n\n        render: function (globalAxisPointerModel, ecModel, api) {\n            var globalTooltipModel = ecModel.getComponent('tooltip');\n            var triggerOn = globalAxisPointerModel.get('triggerOn')\n                || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n            // Register global listener in AxisPointerView to enable\n            // AxisPointerView to be independent to Tooltip.\n            globalListener.register(\n                'axisPointer',\n                api,\n                function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none'\n                        && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                    ) {\n                        dispatchAction({\n                            type: 'updateAxisPointer',\n                            currTrigger: currTrigger,\n                            x: e && e.offsetX,\n                            y: e && e.offsetY\n                        });\n                    }\n                }\n            );\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            globalListener.disopse(api.getZr(), 'axisPointer');\n            AxisPonterView.superApply(this._model, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            globalListener.unregister('axisPointer', api);\n            AxisPonterView.superApply(this._model, 'dispose', arguments);\n        }\n\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanM/NTRiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyIsImZpbGUiOiIxMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZ2xvYmFsTGlzdGVuZXInKTtcblxuICAgIHZhciBBeGlzUG9udGVyVmlldyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnYXhpc1BvaW50ZXInLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlck9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJPbicpXG4gICAgICAgICAgICAgICAgfHwgKGdsb2JhbFRvb2x0aXBNb2RlbCAmJiBnbG9iYWxUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCAnbW91c2Vtb3ZlfGNsaWNrJyk7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lciBpbiBBeGlzUG9pbnRlclZpZXcgdG8gZW5hYmxlXG4gICAgICAgICAgICAvLyBBeGlzUG9pbnRlclZpZXcgdG8gYmUgaW5kZXBlbmRlbnQgdG8gVG9vbHRpcC5cbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyKFxuICAgICAgICAgICAgICAgICdheGlzUG9pbnRlcicsXG4gICAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uICE9PSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCB0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVHJpZ2dlcjogY3VyclRyaWdnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZSAmJiBlLm9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZSAmJiBlLm9mZnNldFlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLmRpc29wc2UoYXBpLmdldFpyKCksICdheGlzUG9pbnRlcicpO1xuICAgICAgICAgICAgQXhpc1BvbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlcignYXhpc1BvaW50ZXInLCBhcGkpO1xuICAgICAgICAgICAgQXhpc1BvbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var clazzUtil = __webpack_require__(12);\n    var graphic = __webpack_require__(2);\n    var get = __webpack_require__(4).makeGetter();\n    var axisPointerModelHelper = __webpack_require__(23);\n    var eventTool = __webpack_require__(19);\n    var throttle = __webpack_require__(65);\n\n    var clone = zrUtil.clone;\n    var bind = zrUtil.bind;\n\n    /**\n     * Base axis pointer class in 2D.\n     * Implemenents {module:echarts/component/axis/IAxisPointer}.\n     */\n    function BaseAxisPointer () {\n    }\n\n    BaseAxisPointer.prototype = {\n\n        /**\n         * @private\n         */\n        _group: null,\n\n        /**\n         * @private\n         */\n        _lastGraphicKey: null,\n\n        /**\n         * @private\n         */\n        _handle: null,\n\n        /**\n         * @private\n         */\n        _dragging: false,\n\n        /**\n         * @private\n         */\n        _lastValue: null,\n\n        /**\n         * @private\n         */\n        _lastStatus: null,\n\n        /**\n         * @private\n         */\n        _payloadInfo: null,\n\n        /**\n         * In px, arbitrary value. Do not set too small,\n         * no animation is ok for most cases.\n         * @protected\n         */\n        animationThreshold: 15,\n\n        /**\n         * @implement\n         */\n        render: function (axisModel, axisPointerModel, api, forceRender) {\n            var value = axisPointerModel.get('value');\n            var status = axisPointerModel.get('status');\n\n            // Bind them to `this`, not in closure, otherwise they will not\n            // be replaced when user calling setOption in not merge mode.\n            this._axisModel = axisModel;\n            this._axisPointerModel = axisPointerModel;\n            this._api = api;\n\n            // Optimize: `render` will be called repeatly during mouse move.\n            // So it is power consuming if performing `render` each time,\n            // especially on mobile device.\n            if (!forceRender\n                && this._lastValue === value\n                && this._lastStatus === status\n            ) {\n                return;\n            }\n            this._lastValue = value;\n            this._lastStatus = status;\n\n            var group = this._group;\n            var handle = this._handle;\n\n            if (!status || status === 'hide') {\n                // Do not clear here, for animation better.\n                group && group.hide();\n                handle && handle.hide();\n                return;\n            }\n            group && group.show();\n            handle && handle.show();\n\n            // Otherwise status is 'show'\n            var elOption = {};\n            this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n            // Enable change axis pointer type.\n            var graphicKey = elOption.graphicKey;\n            if (graphicKey !== this._lastGraphicKey) {\n                this.clear(api);\n            }\n            this._lastGraphicKey = graphicKey;\n\n            var moveAnimation = this._moveAnimation =\n                this.determineAnimation(axisModel, axisPointerModel);\n\n            if (!group) {\n                group = this._group = new graphic.Group();\n                this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n                this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n                api.getZr().add(group);\n            }\n            else {\n                var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n                this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n                this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n            }\n\n            updateMandatoryProps(group, axisPointerModel, true);\n\n            this._renderHandle(value);\n        },\n\n        /**\n         * @implement\n         */\n        remove: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @implement\n         */\n        dispose: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @protected\n         */\n        determineAnimation: function (axisModel, axisPointerModel) {\n            var animation = axisPointerModel.get('animation');\n            var axis = axisModel.axis;\n            var isCategoryAxis = axis.type === 'category';\n            var useSnap = axisPointerModel.get('snap');\n\n            // Value axis without snap always do not snap.\n            if (!useSnap && !isCategoryAxis) {\n                return false;\n            }\n\n            if (animation === 'auto' || animation == null) {\n                var animationThreshold = this.animationThreshold;\n                if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                    return true;\n                }\n\n                // It is important to auto animation when snap used. Consider if there is\n                // a dataZoom, animation will be disabled when too many points exist, while\n                // it will be enabled for better visual effect when little points exist.\n                if (useSnap) {\n                    var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n                    var axisExtent = axis.getExtent();\n                    // Approximate band width\n                    return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n                }\n\n                return false;\n            }\n\n            return animation === true;\n        },\n\n        /**\n         * add {pointer, label, graphicKey} to elOption\n         * @protected\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            // Shoule be implemenented by sub-class.\n        },\n\n        /**\n         * @protected\n         */\n        createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n            var pointerOption = elOption.pointer;\n            if (pointerOption) {\n                var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](\n                    clone(elOption.pointer)\n                );\n                group.add(pointerEl);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n            if (elOption.label) {\n                var labelEl = get(group).labelEl = new graphic.Rect(\n                    clone(elOption.label)\n                );\n\n                group.add(labelEl);\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updatePointerEl: function (group, elOption, updateProps) {\n            var pointerEl = get(group).pointerEl;\n            if (pointerEl) {\n                pointerEl.setStyle(elOption.pointer.style);\n                updateProps(pointerEl, {shape: elOption.pointer.shape});\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n            var labelEl = get(group).labelEl;\n            if (labelEl) {\n                labelEl.setStyle(elOption.label.style);\n                updateProps(labelEl, {\n                    // Consider text length change in vertical axis, animation should\n                    // be used on shape, otherwise the effect will be weird.\n                    shape: elOption.label.shape,\n                    position: elOption.label.position\n                });\n\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _renderHandle: function (value) {\n            if (this._dragging || !this.updateHandleTransform) {\n                return;\n            }\n\n            var axisPointerModel = this._axisPointerModel;\n            var zr = this._api.getZr();\n            var handle = this._handle;\n            var handleModel = axisPointerModel.getModel('handle');\n\n            var status = axisPointerModel.get('status');\n            if (!handleModel.get('show') || !status || status === 'hide') {\n                handle && zr.remove(handle);\n                this._handle = null;\n                return;\n            }\n\n            var isInit;\n            if (!this._handle) {\n                isInit = true;\n                handle = this._handle = createIcon(handleModel, {\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        eventTool.stop(e.event);\n                    },\n                    onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n                    drift: bind(this._onHandleDragMove, this),\n                    ondragend: bind(this._onHandleDragEnd, this)\n                });\n                zr.add(handle);\n            }\n\n            updateMandatoryProps(handle, axisPointerModel, false);\n\n            // update style\n            var includeStyles = [\n                'color', 'borderColor', 'borderWidth', 'opacity',\n                'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n            ];\n            handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n            // update position\n            var handleSize = handleModel.get('size');\n            if (!zrUtil.isArray(handleSize)) {\n                handleSize = [handleSize, handleSize];\n            }\n            handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n            throttle.createOrUpdate(\n                this,\n                '_doDispatchAxisPointer',\n                handleModel.get('throttle') || 0,\n                'fixRate'\n            );\n\n            this._moveHandleToValue(value, isInit);\n        },\n\n        /**\n         * @private\n         */\n        _moveHandleToValue: function (value, isInit) {\n            updateProps(\n                this._axisPointerModel,\n                !isInit && this._moveAnimation,\n                this._handle,\n                getHandleTransProps(this.getHandleTransform(\n                    value, this._axisModel, this._axisPointerModel\n                ))\n            );\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragMove: function (dx, dy) {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            this._dragging = true;\n\n            // Persistent for throttle.\n            var trans = this.updateHandleTransform(\n                getHandleTransProps(handle),\n                [dx, dy],\n                this._axisModel,\n                this._axisPointerModel\n            );\n            this._payloadInfo = trans;\n\n            handle.stopAnimation();\n            handle.attr(getHandleTransProps(trans));\n            get(handle).lastProp = null;\n\n            this._doDispatchAxisPointer();\n        },\n\n        /**\n         * Throttled method.\n         * @private\n         */\n        _doDispatchAxisPointer: function () {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var payloadInfo = this._payloadInfo;\n            var axisModel = this._axisModel;\n            this._api.dispatchAction({\n                type: 'updateAxisPointer',\n                x: payloadInfo.cursorPoint[0],\n                y: payloadInfo.cursorPoint[1],\n                tooltipOption: payloadInfo.tooltipOption,\n                axesInfo: [{\n                    axisDim: axisModel.axis.dim,\n                    axisIndex: axisModel.componentIndex\n                }]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragEnd: function (moveAnimation) {\n            this._dragging = false;\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var value = this._axisPointerModel.get('value');\n            // Consider snap or categroy axis, handle may be not consistent with\n            // axisPointer. So move handle to align the exact value position when\n            // drag ended.\n            this._moveHandleToValue(value);\n\n            // For the effect: tooltip will be shown when finger holding on handle\n            // button, and will be hidden after finger left handle button.\n            this._api.dispatchAction({\n                type: 'hideTip'\n            });\n        },\n\n        /**\n         * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {number} value\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0}\n         */\n        getHandleTransform: null,\n\n        /**\n         * * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {Object} transform {position, rotation}\n         * @param {Array.<number>} delta [dx, dy]\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n         */\n        updateHandleTransform: null,\n\n        /**\n         * @private\n         */\n        clear: function (api) {\n            this._lastValue = null;\n            this._lastStatus = null;\n\n            var zr = api.getZr();\n            var group = this._group;\n            var handle = this._handle;\n            if (zr && group) {\n                this._lastGraphicKey = null;\n                group && zr.remove(group);\n                handle && zr.remove(handle);\n                this._group = null;\n                this._handle = null;\n                this._payloadInfo = null;\n            }\n        },\n\n        /**\n         * @protected\n         */\n        doClear: function () {\n            // Implemented by sub-class if necessary.\n        },\n\n        /**\n         * @protected\n         * @param {Array.<number>} xy\n         * @param {Array.<number>} wh\n         * @param {number} [xDimIndex=0] or 1\n         */\n        buildLabel: function (xy, wh, xDimIndex) {\n            xDimIndex = xDimIndex || 0;\n            return {\n                x: xy[xDimIndex],\n                y: xy[1 - xDimIndex],\n                width: wh[xDimIndex],\n                height: wh[1 - xDimIndex]\n            };\n        }\n    };\n\n    BaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\n    function updateProps(animationModel, moveAnimation, el, props) {\n        // Animation optimize.\n        if (!propsEqual(get(el).lastProp, props)) {\n            get(el).lastProp = props;\n            moveAnimation\n                ? graphic.updateProps(el, props, animationModel)\n                : (el.stopAnimation(), el.attr(props));\n        }\n    }\n\n    function propsEqual(lastProps, newProps) {\n        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n            var equals = true;\n            zrUtil.each(newProps, function (item, key) {\n                equals &= propsEqual(lastProps[key], item);\n            });\n            return !!equals;\n        }\n        else {\n            return lastProps === newProps;\n        }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n        return {\n            position: trans.position.slice(),\n            rotation: trans.rotation || 0\n        };\n    }\n\n    function createIcon(handleModel, handlers) {\n        var iconStr = handleModel.get('icon');\n        var style = {\n            x: -1, y: -1, width: 2, height: 2\n        };\n        var opt = zrUtil.extend({\n            style: {\n                strokeNoScale: true\n            },\n            rectHover: true,\n            cursor: 'move',\n            draggable: true\n        }, handlers);\n\n        return iconStr.indexOf('image://') === 0\n            ? (\n                style.image = iconStr.slice(8),\n                opt.style = style,\n                new graphic.Image(opt)\n            )\n            : graphic.makePath(\n                iconStr.replace('path://', ''),\n                opt,\n                style,\n                'center'\n            );\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n        var z = axisPointerModel.get('z');\n        var zlevel = axisPointerModel.get('zlevel');\n\n        group && group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n                el.silent = silent;\n            }\n        });\n    }\n\n    clazzUtil.enableClassExtend(BaseAxisPointer);\n\n    module.exports = BaseAxisPointer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanM/MGZiZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUEyQztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsMkJBQTJCO0FBQzlDLG9CQUFvQixPQUFPLEVBQUU7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTyxZQUFZO0FBQ3RDLG1CQUFtQixlQUFlO0FBQ2xDLG1CQUFtQiwyQkFBMkI7QUFDOUMsbUJBQW1CLDJCQUEyQjtBQUM5QyxvQkFBb0IsT0FBTyxFQUFFO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSIsImZpbGUiOiIxMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGdldCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKS5tYWtlR2V0dGVyKCk7XG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKCcuL21vZGVsSGVscGVyJyk7XG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgdGhyb3R0bGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL3Rocm90dGxlJyk7XG5cbiAgICB2YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG4gICAgdmFyIGJpbmQgPSB6clV0aWwuYmluZDtcblxuICAgIC8qKlxuICAgICAqIEJhc2UgYXhpcyBwb2ludGVyIGNsYXNzIGluIDJELlxuICAgICAqIEltcGxlbWVuZW50cyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2F4aXMvSUF4aXNQb2ludGVyfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCYXNlQXhpc1BvaW50ZXIgKCkge1xuICAgIH1cblxuICAgIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ3JvdXA6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbGFzdEdyYXBoaWNLZXk6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaGFuZGxlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2RyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9sYXN0VmFsdWU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbGFzdFN0YXR1czogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9wYXlsb2FkSW5mbzogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gcHgsIGFyYml0cmFyeSB2YWx1ZS4gRG8gbm90IHNldCB0b28gc21hbGwsXG4gICAgICAgICAqIG5vIGFuaW1hdGlvbiBpcyBvayBmb3IgbW9zdCBjYXNlcy5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uVGhyZXNob2xkOiAxNSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGltcGxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGZvcmNlUmVuZGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc3RhdHVzJyk7XG5cbiAgICAgICAgICAgIC8vIEJpbmQgdGhlbSB0byBgdGhpc2AsIG5vdCBpbiBjbG9zdXJlLCBvdGhlcndpc2UgdGhleSB3aWxsIG5vdFxuICAgICAgICAgICAgLy8gYmUgcmVwbGFjZWQgd2hlbiB1c2VyIGNhbGxpbmcgc2V0T3B0aW9uIGluIG5vdCBtZXJnZSBtb2RlLlxuICAgICAgICAgICAgdGhpcy5fYXhpc01vZGVsID0gYXhpc01vZGVsO1xuICAgICAgICAgICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgICAgIC8vIE9wdGltaXplOiBgcmVuZGVyYCB3aWxsIGJlIGNhbGxlZCByZXBlYXRseSBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAgICAgICAgIC8vIFNvIGl0IGlzIHBvd2VyIGNvbnN1bWluZyBpZiBwZXJmb3JtaW5nIGByZW5kZXJgIGVhY2ggdGltZSxcbiAgICAgICAgICAgIC8vIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZS5cbiAgICAgICAgICAgIGlmICghZm9yY2VSZW5kZXJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9sYXN0VmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fbGFzdFN0YXR1cyA9PT0gc3RhdHVzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTdGF0dXMgPSBzdGF0dXM7XG5cbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAnaGlkZScpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgY2xlYXIgaGVyZSwgZm9yIGFuaW1hdGlvbiBiZXR0ZXIuXG4gICAgICAgICAgICAgICAgZ3JvdXAgJiYgZ3JvdXAuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZSAmJiBoYW5kbGUuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwICYmIGdyb3VwLnNob3coKTtcbiAgICAgICAgICAgIGhhbmRsZSAmJiBoYW5kbGUuc2hvdygpO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc3RhdHVzIGlzICdzaG93J1xuICAgICAgICAgICAgdmFyIGVsT3B0aW9uID0ge307XG4gICAgICAgICAgICB0aGlzLm1ha2VFbE9wdGlvbihlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgLy8gRW5hYmxlIGNoYW5nZSBheGlzIHBvaW50ZXIgdHlwZS5cbiAgICAgICAgICAgIHZhciBncmFwaGljS2V5ID0gZWxPcHRpb24uZ3JhcGhpY0tleTtcbiAgICAgICAgICAgIGlmIChncmFwaGljS2V5ICE9PSB0aGlzLl9sYXN0R3JhcGhpY0tleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhc3RHcmFwaGljS2V5ID0gZ3JhcGhpY0tleTtcblxuICAgICAgICAgICAgdmFyIG1vdmVBbmltYXRpb24gPSB0aGlzLl9tb3ZlQW5pbWF0aW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmRldGVybWluZUFuaW1hdGlvbihheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLl9ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICAgICAgYXBpLmdldFpyKCkuYWRkKGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZVByb3BzID0genJVdGlsLmN1cnJ5KHVwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsLCBtb3ZlQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvaW50ZXJFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckhhbmRsZSh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbXBsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcihhcGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW1wbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoYXBpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKGFwaSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVybWluZUFuaW1hdGlvbjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICB2YXIgdXNlU25hcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzbmFwJyk7XG5cbiAgICAgICAgICAgIC8vIFZhbHVlIGF4aXMgd2l0aG91dCBzbmFwIGFsd2F5cyBkbyBub3Qgc25hcC5cbiAgICAgICAgICAgIGlmICghdXNlU25hcCAmJiAhaXNDYXRlZ29yeUF4aXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRpb24gPT09ICdhdXRvJyB8fCBhbmltYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25UaHJlc2hvbGQgPSB0aGlzLmFuaW1hdGlvblRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYXRlZ29yeUF4aXMgJiYgYXhpcy5nZXRCYW5kV2lkdGgoKSA+IGFuaW1hdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYXV0byBhbmltYXRpb24gd2hlbiBzbmFwIHVzZWQuIENvbnNpZGVyIGlmIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgLy8gYSBkYXRhWm9vbSwgYW5pbWF0aW9uIHdpbGwgYmUgZGlzYWJsZWQgd2hlbiB0b28gbWFueSBwb2ludHMgZXhpc3QsIHdoaWxlXG4gICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSBlbmFibGVkIGZvciBiZXR0ZXIgdmlzdWFsIGVmZmVjdCB3aGVuIGxpdHRsZSBwb2ludHMgZXhpc3QuXG4gICAgICAgICAgICAgICAgaWYgKHVzZVNuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0RhdGFDb3VudCA9IGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZ2V0QXhpc0luZm8oYXhpc01vZGVsKS5zZXJpZXNEYXRhQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgYmFuZCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXhpc0V4dGVudFswXSAtIGF4aXNFeHRlbnRbMV0pIC8gc2VyaWVzRGF0YUNvdW50ID4gYW5pbWF0aW9uVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbiA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgLy8gU2hvdWxlIGJlIGltcGxlbWVuZW50ZWQgYnkgc3ViLWNsYXNzLlxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVQb2ludGVyRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJPcHRpb24gPSBlbE9wdGlvbi5wb2ludGVyO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlckVsID0gZ2V0KGdyb3VwKS5wb2ludGVyRWwgPSBuZXcgZ3JhcGhpY1twb2ludGVyT3B0aW9uLnR5cGVdKFxuICAgICAgICAgICAgICAgICAgICBjbG9uZShlbE9wdGlvbi5wb2ludGVyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBvaW50ZXJFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUxhYmVsRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGVsT3B0aW9uLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsRWwgPSBnZXQoZ3JvdXApLmxhYmVsRWwgPSBuZXcgZ3JhcGhpYy5SZWN0KFxuICAgICAgICAgICAgICAgICAgICBjbG9uZShlbE9wdGlvbi5sYWJlbClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGxhYmVsRWwpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBnZXQoZ3JvdXApLnBvaW50ZXJFbDtcbiAgICAgICAgICAgIGlmIChwb2ludGVyRWwpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyRWwuc2V0U3R5bGUoZWxPcHRpb24ucG9pbnRlci5zdHlsZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHMocG9pbnRlckVsLCB7c2hhcGU6IGVsT3B0aW9uLnBvaW50ZXIuc2hhcGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTGFiZWxFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbEVsID0gZ2V0KGdyb3VwKS5sYWJlbEVsO1xuICAgICAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbEVsLnNldFN0eWxlKGVsT3B0aW9uLmxhYmVsLnN0eWxlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wcyhsYWJlbEVsLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRleHQgbGVuZ3RoIGNoYW5nZSBpbiB2ZXJ0aWNhbCBheGlzLCBhbmltYXRpb24gc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIHVzZWQgb24gc2hhcGUsIG90aGVyd2lzZSB0aGUgZWZmZWN0IHdpbGwgYmUgd2VpcmQuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBlbE9wdGlvbi5sYWJlbC5zaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGVsT3B0aW9uLmxhYmVsLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcgfHwgIXRoaXMudXBkYXRlSGFuZGxlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IHRoaXMuX2F4aXNQb2ludGVyTW9kZWw7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9hcGkuZ2V0WnIoKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICB2YXIgaGFuZGxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdoYW5kbGUnKTtcblxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlTW9kZWwuZ2V0KCdzaG93JykgfHwgIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZSAmJiB6ci5yZW1vdmUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzSW5pdDtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgaXNJbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSB0aGlzLl9oYW5kbGUgPSBjcmVhdGVJY29uKGhhbmRsZU1vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm90IG1vYmlsZSBkZXZpY2VtLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbm1vdXNlZG93bjogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdNb3ZlLCB0aGlzLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnTW92ZSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdFbmQsIHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgenIuYWRkKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZU1hbmRhdG9yeVByb3BzKGhhbmRsZSwgYXhpc1BvaW50ZXJNb2RlbCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgc3R5bGVcbiAgICAgICAgICAgIHZhciBpbmNsdWRlU3R5bGVzID0gW1xuICAgICAgICAgICAgICAgICdjb2xvcicsICdib3JkZXJDb2xvcicsICdib3JkZXJXaWR0aCcsICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaGFuZGxlLnNldFN0eWxlKGhhbmRsZU1vZGVsLmdldEl0ZW1TdHlsZShudWxsLCBpbmNsdWRlU3R5bGVzKSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGhhbmRsZVNpemUgPSBoYW5kbGVNb2RlbC5nZXQoJ3NpemUnKTtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoaGFuZGxlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVTaXplID0gW2hhbmRsZVNpemUsIGhhbmRsZVNpemVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlLmF0dHIoJ3NjYWxlJywgW2hhbmRsZVNpemVbMF0gLyAyLCBoYW5kbGVTaXplWzFdIC8gMl0pO1xuXG4gICAgICAgICAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICdfZG9EaXNwYXRjaEF4aXNQb2ludGVyJyxcbiAgICAgICAgICAgICAgICBoYW5kbGVNb2RlbC5nZXQoJ3Rocm90dGxlJykgfHwgMCxcbiAgICAgICAgICAgICAgICAnZml4UmF0ZSdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX21vdmVIYW5kbGVUb1ZhbHVlKHZhbHVlLCBpc0luaXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX21vdmVIYW5kbGVUb1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGlzSW5pdCkge1xuICAgICAgICAgICAgdXBkYXRlUHJvcHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCxcbiAgICAgICAgICAgICAgICAhaXNJbml0ICYmIHRoaXMuX21vdmVBbmltYXRpb24sXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLFxuICAgICAgICAgICAgICAgIGdldEhhbmRsZVRyYW5zUHJvcHModGhpcy5nZXRIYW5kbGVUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9vbkhhbmRsZURyYWdNb3ZlOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gUGVyc2lzdGVudCBmb3IgdGhyb3R0bGUuXG4gICAgICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICBnZXRIYW5kbGVUcmFuc1Byb3BzKGhhbmRsZSksXG4gICAgICAgICAgICAgICAgW2R4LCBkeV0sXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc01vZGVsLFxuICAgICAgICAgICAgICAgIHRoaXMuX2F4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9wYXlsb2FkSW5mbyA9IHRyYW5zO1xuXG4gICAgICAgICAgICBoYW5kbGUuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgaGFuZGxlLmF0dHIoZ2V0SGFuZGxlVHJhbnNQcm9wcyh0cmFucykpO1xuICAgICAgICAgICAgZ2V0KGhhbmRsZSkubGFzdFByb3AgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9kb0Rpc3BhdGNoQXhpc1BvaW50ZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3R0bGVkIG1ldGhvZC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9kb0Rpc3BhdGNoQXhpc1BvaW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBheWxvYWRJbmZvID0gdGhpcy5fcGF5bG9hZEluZm87XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5fYXhpc01vZGVsO1xuICAgICAgICAgICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgICAgIHg6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzBdLFxuICAgICAgICAgICAgICAgIHk6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzFdLFxuICAgICAgICAgICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWRJbmZvLnRvb2x0aXBPcHRpb24sXG4gICAgICAgICAgICAgICAgYXhlc0luZm86IFt7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNEaW06IGF4aXNNb2RlbC5heGlzLmRpbSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4OiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfb25IYW5kbGVEcmFnRW5kOiBmdW5jdGlvbiAobW92ZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBzbmFwIG9yIGNhdGVncm95IGF4aXMsIGhhbmRsZSBtYXkgYmUgbm90IGNvbnNpc3RlbnQgd2l0aFxuICAgICAgICAgICAgLy8gYXhpc1BvaW50ZXIuIFNvIG1vdmUgaGFuZGxlIHRvIGFsaWduIHRoZSBleGFjdCB2YWx1ZSBwb3NpdGlvbiB3aGVuXG4gICAgICAgICAgICAvLyBkcmFnIGVuZGVkLlxuICAgICAgICAgICAgdGhpcy5fbW92ZUhhbmRsZVRvVmFsdWUodmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBGb3IgdGhlIGVmZmVjdDogdG9vbHRpcCB3aWxsIGJlIHNob3duIHdoZW4gZmluZ2VyIGhvbGRpbmcgb24gaGFuZGxlXG4gICAgICAgICAgICAvLyBidXR0b24sIGFuZCB3aWxsIGJlIGhpZGRlbiBhZnRlciBmaW5nZXIgbGVmdCBoYW5kbGUgYnV0dG9uLlxuICAgICAgICAgICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGlkZVRpcCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MgaWYgc3VwcG9ydCBgaGFuZGxlYC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB7cG9zaXRpb246IFt4LCB5XSwgcm90YXRpb246IDB9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIYW5kbGVUcmFuc2Zvcm06IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICogU2hvdWxkIGJlIGltcGxlbWVuZW50ZWQgYnkgc3ViLWNsYXNzIGlmIHN1cHBvcnQgYGhhbmRsZWAuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB7cG9zaXRpb24sIHJvdGF0aW9ufVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkZWx0YSBbZHgsIGR5XVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb3NpdGlvbjogW3gsIHldLCByb3RhdGlvbjogMCwgY3Vyc29yUG9pbnQ6IFt4LCB5XX1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUhhbmRsZVRyYW5zZm9ybTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoYXBpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFN0YXR1cyA9IG51bGw7XG5cbiAgICAgICAgICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXA7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgICAgICAgICAgaWYgKHpyICYmIGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEdyYXBoaWNLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGdyb3VwICYmIHpyLnJlbW92ZShncm91cCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlICYmIHpyLnJlbW92ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BheWxvYWRJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZG9DbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB4eVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB3aFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3hEaW1JbmRleD0wXSBvciAxXG4gICAgICAgICAqL1xuICAgICAgICBidWlsZExhYmVsOiBmdW5jdGlvbiAoeHksIHdoLCB4RGltSW5kZXgpIHtcbiAgICAgICAgICAgIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgICAgICAgICAgICAgIHk6IHh5WzEgLSB4RGltSW5kZXhdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgICAgICAgICAgICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2VBeGlzUG9pbnRlcjtcblxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUHJvcHMoYW5pbWF0aW9uTW9kZWwsIG1vdmVBbmltYXRpb24sIGVsLCBwcm9wcykge1xuICAgICAgICAvLyBBbmltYXRpb24gb3B0aW1pemUuXG4gICAgICAgIGlmICghcHJvcHNFcXVhbChnZXQoZWwpLmxhc3RQcm9wLCBwcm9wcykpIHtcbiAgICAgICAgICAgIGdldChlbCkubGFzdFByb3AgPSBwcm9wcztcbiAgICAgICAgICAgIG1vdmVBbmltYXRpb25cbiAgICAgICAgICAgICAgICA/IGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHByb3BzLCBhbmltYXRpb25Nb2RlbClcbiAgICAgICAgICAgICAgICA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3BzRXF1YWwobGFzdFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGxhc3RQcm9wcykgJiYgenJVdGlsLmlzT2JqZWN0KG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgdmFyIGVxdWFscyA9IHRydWU7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChuZXdQcm9wcywgZnVuY3Rpb24gKGl0ZW0sIGtleSkge1xuICAgICAgICAgICAgICAgIGVxdWFscyAmPSBwcm9wc0VxdWFsKGxhc3RQcm9wc1trZXldLCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICEhZXF1YWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RQcm9wcyA9PT0gbmV3UHJvcHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgbGFiZWxFbFtheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwuc2hvdycpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEhhbmRsZVRyYW5zUHJvcHModHJhbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0cmFucy5wb3NpdGlvbi5zbGljZSgpLFxuICAgICAgICAgICAgcm90YXRpb246IHRyYW5zLnJvdGF0aW9uIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJY29uKGhhbmRsZU1vZGVsLCBoYW5kbGVycykge1xuICAgICAgICB2YXIgaWNvblN0ciA9IGhhbmRsZU1vZGVsLmdldCgnaWNvbicpO1xuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICB4OiAtMSwgeTogLTEsIHdpZHRoOiAyLCBoZWlnaHQ6IDJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdCA9IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjdEhvdmVyOiB0cnVlLFxuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcbiAgICAgICAgfSwgaGFuZGxlcnMpO1xuXG4gICAgICAgIHJldHVybiBpY29uU3RyLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDBcbiAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgIHN0eWxlLmltYWdlID0gaWNvblN0ci5zbGljZSg4KSxcbiAgICAgICAgICAgICAgICBvcHQuc3R5bGUgPSBzdHlsZSxcbiAgICAgICAgICAgICAgICBuZXcgZ3JhcGhpYy5JbWFnZShvcHQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA6IGdyYXBoaWMubWFrZVBhdGgoXG4gICAgICAgICAgICAgICAgaWNvblN0ci5yZXBsYWNlKCdwYXRoOi8vJywgJycpLFxuICAgICAgICAgICAgICAgIG9wdCxcbiAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICAnY2VudGVyJ1xuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgc2lsZW50KSB7XG4gICAgICAgIHZhciB6ID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3onKTtcbiAgICAgICAgdmFyIHpsZXZlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd6bGV2ZWwnKTtcblxuICAgICAgICBncm91cCAmJiBncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgeiAhPSBudWxsICYmIChlbC56ID0geik7XG4gICAgICAgICAgICAgICAgemxldmVsICE9IG51bGwgJiYgKGVsLnpsZXZlbCA9IHpsZXZlbCk7XG4gICAgICAgICAgICAgICAgZWwuc2lsZW50ID0gc2lsZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQmFzZUF4aXNQb2ludGVyKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQmFzZUF4aXNQb2ludGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var graphic = __webpack_require__(2);\n    var BaseAxisPointer = __webpack_require__(122);\n    var viewHelper = __webpack_require__(48);\n    var cartesianAxisHelper = __webpack_require__(51);\n    var AxisView = __webpack_require__(50);\n\n    var CartesianAxisPointer = BaseAxisPointer.extend({\n\n        /**\n         * @override\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisPointerType = axisPointerModel.get('type');\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n            if (axisPointerType && axisPointerType !== 'none') {\n                var elStyle = viewHelper.buildElStyle(axisPointerModel);\n                var pointerOption = pointerShapeBuilder[axisPointerType](\n                    axis, pixelValue, otherExtent, elStyle\n                );\n                pointerOption.style = elStyle;\n                elOption.graphicKey = pointerOption.type;\n                elOption.pointer = pointerOption;\n            }\n\n            var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n            viewHelper.buildCartesianSingleLabelElOption(\n                value, elOption, layoutInfo, axisModel, axisPointerModel, api\n            );\n        },\n\n        /**\n         * @override\n         */\n        getHandleTransform: function (value, axisModel, axisPointerModel) {\n            var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n                labelInside: false\n            });\n            layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n            return {\n                position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n                rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n            };\n        },\n\n        /**\n         * @override\n         */\n        updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisExtent = axis.getGlobalExtent(true);\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n            var currPosition = transform.position;\n            currPosition[dimIndex] += delta[dimIndex];\n            currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n            currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n            var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n            var cursorPoint = [cursorOtherValue, cursorOtherValue];\n            cursorPoint[dimIndex] = currPosition[dimIndex];\n\n            // Make tooltip do not overlap axisPointer and in the middle of the grid.\n            var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n            return {\n                position: currPosition,\n                rotation: transform.rotation,\n                cursorPoint: cursorPoint,\n                tooltipOption: tooltipOptions[dimIndex]\n            };\n        }\n\n    });\n\n    function getCartesian(grid, axis) {\n        var opt = {};\n        opt[axis.dim + 'AxisIndex'] = axis.index;\n        return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n\n        line: function (axis, pixelValue, otherExtent, elStyle) {\n            var targetShape = viewHelper.makeLineShape(\n                [pixelValue, otherExtent[0]],\n                [pixelValue, otherExtent[1]],\n                getAxisDimIndex(axis)\n            );\n            graphic.subPixelOptimizeLine({\n                shape: targetShape,\n                style: elStyle\n            });\n            return {\n                type: 'Line',\n                shape: targetShape\n            };\n        },\n\n        shadow: function (axis, pixelValue, otherExtent, elStyle) {\n            var bandWidth = axis.getBandWidth();\n            var span = otherExtent[1] - otherExtent[0];\n            return {\n                type: 'Rect',\n                shape: viewHelper.makeRectShape(\n                    [pixelValue - bandWidth / 2, otherExtent[0]],\n                    [bandWidth, span],\n                    getAxisDimIndex(axis)\n                )\n            };\n        }\n    };\n\n    function getAxisDimIndex(axis) {\n        return axis.dim === 'x' ? 0 : 1;\n    }\n\n    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n    module.exports = CartesianAxisPointer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qcz9kYTdhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHdCQUF3QixHQUFHLGdCQUFnQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjEyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgQmFzZUF4aXNQb2ludGVyID0gcmVxdWlyZSgnLi9CYXNlQXhpc1BvaW50ZXInKTtcbiAgICB2YXIgdmlld0hlbHBlciA9IHJlcXVpcmUoJy4vdmlld0hlbHBlcicpO1xuICAgIHZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZSgnLi4vYXhpcy9jYXJ0ZXNpYW5BeGlzSGVscGVyJyk7XG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi4vYXhpcy9BeGlzVmlldycpO1xuXG4gICAgdmFyIENhcnRlc2lhbkF4aXNQb2ludGVyID0gQmFzZUF4aXNQb2ludGVyLmV4dGVuZCh7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gYXhpcy5ncmlkO1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIHBpeGVsVmFsdWUgPSBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSwgdHJ1ZSkpO1xuXG4gICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJUeXBlICYmIGF4aXNQb2ludGVyVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsU3R5bGUgPSB2aWV3SGVscGVyLmJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlck9wdGlvbiA9IHBvaW50ZXJTaGFwZUJ1aWxkZXJbYXhpc1BvaW50ZXJUeXBlXShcbiAgICAgICAgICAgICAgICAgICAgYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJPcHRpb24uc3R5bGUgPSBlbFN0eWxlO1xuICAgICAgICAgICAgICAgIGVsT3B0aW9uLmdyYXBoaWNLZXkgPSBwb2ludGVyT3B0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgZWxPcHRpb24ucG9pbnRlciA9IHBvaW50ZXJPcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRJbmZvID0gY2FydGVzaWFuQXhpc0hlbHBlci5sYXlvdXQoZ3JpZC5tb2RlbCwgYXhpc01vZGVsKTtcbiAgICAgICAgICAgIHZpZXdIZWxwZXIuYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uKFxuICAgICAgICAgICAgICAgIHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGFuZGxlVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dEluZm8gPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsLCBheGlzTW9kZWwsIHtcbiAgICAgICAgICAgICAgICBsYWJlbEluc2lkZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5sYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdoYW5kbGUubWFyZ2luJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB2aWV3SGVscGVyLmdldFRyYW5zZm9ybWVkUG9zaXRpb24oYXhpc01vZGVsLmF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbGF5b3V0SW5mby5yb3RhdGlvbiArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIDwgMCA/IE1hdGguUEkgOiAwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVIYW5kbGVUcmFuc2Zvcm06IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGRlbHRhLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IGF4aXMuZ3JpZDtcbiAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGRpbUluZGV4ID0gYXhpcy5kaW0gPT09ICd4JyA/IDAgOiAxO1xuXG4gICAgICAgICAgICB2YXIgY3VyclBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgY3VyclBvc2l0aW9uW2RpbUluZGV4XSArPSBkZWx0YVtkaW1JbmRleF07XG4gICAgICAgICAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5taW4oYXhpc0V4dGVudFsxXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgICAgICAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3JPdGhlclZhbHVlID0gKG90aGVyRXh0ZW50WzFdICsgb3RoZXJFeHRlbnRbMF0pIC8gMjtcbiAgICAgICAgICAgIHZhciBjdXJzb3JQb2ludCA9IFtjdXJzb3JPdGhlclZhbHVlLCBjdXJzb3JPdGhlclZhbHVlXTtcbiAgICAgICAgICAgIGN1cnNvclBvaW50W2RpbUluZGV4XSA9IGN1cnJQb3NpdGlvbltkaW1JbmRleF07XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdG9vbHRpcCBkbyBub3Qgb3ZlcmxhcCBheGlzUG9pbnRlciBhbmQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0aW9ucyA9IFt7dmVydGljYWxBbGlnbjogJ21pZGRsZSd9LCB7YWxpZ246ICdjZW50ZXInfV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGN1cnJQb3NpdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogdHJhbnNmb3JtLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIGN1cnNvclBvaW50OiBjdXJzb3JQb2ludCxcbiAgICAgICAgICAgICAgICB0b29sdGlwT3B0aW9uOiB0b29sdGlwT3B0aW9uc1tkaW1JbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpIHtcbiAgICAgICAgdmFyIG9wdCA9IHt9O1xuICAgICAgICBvcHRbYXhpcy5kaW0gKyAnQXhpc0luZGV4J10gPSBheGlzLmluZGV4O1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRDYXJ0ZXNpYW4ob3B0KTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRlclNoYXBlQnVpbGRlciA9IHtcblxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHZpZXdIZWxwZXIubWFrZUxpbmVTaGFwZShcbiAgICAgICAgICAgICAgICBbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMF1dLFxuICAgICAgICAgICAgICAgIFtwaXhlbFZhbHVlLCBvdGhlckV4dGVudFsxXV0sXG4gICAgICAgICAgICAgICAgZ2V0QXhpc0RpbUluZGV4KGF4aXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaGFkb3c6IGZ1bmN0aW9uIChheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCwgZWxTdHlsZSkge1xuICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSZWN0JyxcbiAgICAgICAgICAgICAgICBzaGFwZTogdmlld0hlbHBlci5tYWtlUmVjdFNoYXBlKFxuICAgICAgICAgICAgICAgICAgICBbcGl4ZWxWYWx1ZSAtIGJhbmRXaWR0aCAvIDIsIG90aGVyRXh0ZW50WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgW2JhbmRXaWR0aCwgc3Bhbl0sXG4gICAgICAgICAgICAgICAgICAgIGdldEF4aXNEaW1JbmRleChheGlzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc0RpbUluZGV4KGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbiAgICB9XG5cbiAgICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MoJ0NhcnRlc2lhbkF4aXNQb2ludGVyJywgQ2FydGVzaWFuQXhpc1BvaW50ZXIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW5BeGlzUG9pbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQ2FydGVzaWFuQXhpc1BvaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n    var modelHelper = __webpack_require__(23);\n    var findPointFromSeries = __webpack_require__(46);\n\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n    var get = modelUtil.makeGetter();\n\n    /**\n     * Basic logic: check all axis, if they do not demand show/highlight,\n     * then hide/downplay them.\n     *\n     * @param {Object} coordSysAxesInfo\n     * @param {Object} payload\n     * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n     * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n     * @param {Object} [payload.dataIndex] finder, restrict target axes.\n     * @param {Object} [payload.axesInfo] finder, restrict target axes.\n     *        [{\n     *          axisDim: 'x'|'y'|'angle'|...,\n     *          axisIndex: ...,\n     *          value: ...\n     *        }, ...]\n     * @param {Function} [payload.dispatchAction]\n     * @param {Object} [payload.tooltipOption]\n     * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n     *        which can be specified in dispatchAction\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     * @return {Object} content of event obj for echarts.connect.\n     */\n    function axisTrigger(payload, ecModel, api) {\n        var currTrigger = payload.currTrigger;\n        var point = [payload.x, payload.y];\n        var finder = payload;\n        var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        if (illegalPoint(point)) {\n            // Used in the default behavior of `connection`: use the sample seriesIndex\n            // and dataIndex. And also used in the tooltipView trigger.\n            point = findPointFromSeries({\n                seriesIndex: finder.seriesIndex,\n                // Do not use dataIndexInside from other ec instance.\n                // FIXME: auto detect it?\n                dataIndex: finder.dataIndex\n            }, ecModel).point;\n        }\n        var isIllegalPoint = illegalPoint(point);\n\n        // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n        // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n        // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n        // and dataIndex.\n        var inputAxesInfo = finder.axesInfo;\n\n        var axesInfo = coordSysAxesInfo.axesInfo;\n        var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n        var outputFinder = {};\n\n        var showValueMap = {};\n        var dataByCoordSys = {list: [], map: {}};\n        var updaters = {\n            showPointer: curry(showPointer, showValueMap),\n            showTooltip: curry(showTooltip, dataByCoordSys)\n        };\n\n        // Process for triggered axes.\n        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n            // If a point given, it must be contained by the coordinate system.\n            var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n\n            each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n                var axis = axisInfo.axis;\n                var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n                // If no inputAxesInfo, no axis is restricted.\n                if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n                    var val = inputAxisInfo && inputAxisInfo.value;\n                    if (val == null && !isIllegalPoint) {\n                        val = axis.pointToData(point);\n                    }\n                    val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n                }\n            });\n        });\n\n        // Process for linked axes.\n        var linkTriggers = {};\n        each(axesInfo, function (tarAxisInfo, tarKey) {\n            var linkGroup = tarAxisInfo.linkGroup;\n\n            // If axis has been triggered in the previous stage, it should not be triggered by link.\n            if (linkGroup && !showValueMap[tarKey]) {\n                each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                    var srcValItem = showValueMap[srcKey];\n                    // If srcValItem exist, source axis is triggered, so link to target axis.\n                    if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                        var val = srcValItem.value;\n                        linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                            val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                        )));\n                        linkTriggers[tarAxisInfo.key] = val;\n                    }\n                });\n            }\n        });\n        each(linkTriggers, function (val, tarKey) {\n            processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n        });\n\n        updateModelActually(showValueMap, axesInfo, outputFinder);\n        dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n        dispatchHighDownActually(axesInfo, dispatchAction, api);\n\n        return outputFinder;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n        var axis = axisInfo.axis;\n\n        if (axis.scale.isBlank() || !axis.containData(newValue)) {\n            return;\n        }\n\n        if (!axisInfo.involveSeries) {\n            updaters.showPointer(axisInfo, newValue);\n            return;\n        }\n\n        // Heavy calculation. So put it after axis.containData checking.\n        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n        var payloadBatch = payloadInfo.payloadBatch;\n        var snapToValue = payloadInfo.snapToValue;\n\n        // Fill content of event obj for echarts.connect.\n        // By defualt use the first involved series data as a sample to connect.\n        if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n            zrUtil.extend(outputFinder, payloadBatch[0]);\n        }\n\n        // If no linkSource input, this process is for collecting link\n        // target, where snap should not be accepted.\n        if (!dontSnap && axisInfo.snap) {\n            if (axis.containData(snapToValue) && snapToValue != null) {\n                newValue = snapToValue;\n            }\n        }\n\n        updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);\n        // Tooltip should always be snapToValue, otherwise there will be\n        // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n        var axis = axisInfo.axis;\n        var dim = axis.dim;\n        var snapToValue = value;\n        var payloadBatch = [];\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n\n        each(axisInfo.seriesModels, function (series, idx) {\n            var dataDim = series.coordDimToDataDim(dim);\n            var seriesNestestValue;\n            var dataIndices;\n\n            if (series.getAxisTooltipData) {\n                var result = series.getAxisTooltipData(dataDim, value, axis);\n                dataIndices = result.dataIndices;\n                seriesNestestValue = result.nestestValue;\n            }\n            else {\n                dataIndices = series.getData().indicesOfNearest(\n                    dataDim[0],\n                    value,\n                    // Add a threshold to avoid find the wrong dataIndex\n                    // when data length is not same.\n                    false, axis.type === 'category' ? 0.5 : null\n                );\n                if (!dataIndices.length) {\n                    return;\n                }\n                seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n            }\n\n            if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n                return;\n            }\n\n            var diff = value - seriesNestestValue;\n            var dist = Math.abs(diff);\n            // Consider category case\n            if (dist <= minDist) {\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    snapToValue = seriesNestestValue;\n                    payloadBatch.length = 0;\n                }\n                each(dataIndices, function (dataIndex) {\n                    payloadBatch.push({\n                        seriesIndex: series.seriesIndex,\n                        dataIndexInside: dataIndex,\n                        dataIndex: series.getData().getRawIndex(dataIndex)\n                    });\n                });\n            }\n        });\n\n        return {\n            payloadBatch: payloadBatch,\n            snapToValue: snapToValue\n        };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n        showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n        var payloadBatch = payloadInfo.payloadBatch;\n        var axis = axisInfo.axis;\n        var axisModel = axis.model;\n        var axisPointerModel = axisInfo.axisPointerModel;\n\n        // If no data, do not create anything in dataByCoordSys,\n        // whose length will be used to judge whether dispatch action.\n        if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n            return;\n        }\n\n        var coordSysModel = axisInfo.coordSys.model;\n        var coordSysKey = modelHelper.makeKey(coordSysModel);\n        var coordSysItem = dataByCoordSys.map[coordSysKey];\n        if (!coordSysItem) {\n            coordSysItem = dataByCoordSys.map[coordSysKey] = {\n                coordSysId: coordSysModel.id,\n                coordSysIndex: coordSysModel.componentIndex,\n                coordSysType: coordSysModel.type,\n                coordSysMainType: coordSysModel.mainType,\n                dataByAxis: []\n            };\n            dataByCoordSys.list.push(coordSysItem);\n        }\n\n        coordSysItem.dataByAxis.push({\n            axisDim: axis.dim,\n            axisIndex: axisModel.componentIndex,\n            axisType: axisModel.type,\n            axisId: axisModel.id,\n            value: value,\n            // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n            // depends that all models have been updated. So it should not be performed\n            // here. Considering axisPointerModel used here is volatile, which is hard\n            // to be retrieve in TooltipView, we prepare parameters here.\n            valueLabelOpt: {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            },\n            seriesDataIndices: payloadBatch.slice()\n        });\n    }\n\n    function updateModelActually(showValueMap, axesInfo, outputFinder) {\n        var outputAxesInfo = outputFinder.axesInfo = [];\n        // Basic logic: If no 'show' required, 'hide' this axisPointer.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            var valItem = showValueMap[key];\n\n            if (valItem) {\n                !axisInfo.useHandle && (option.status = 'show');\n                option.value = valItem.value;\n                // For label formatter param and highlight.\n                option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n            }\n            // When always show (e.g., handle used), remain\n            // original value and status.\n            else {\n                // If hide, value still need to be set, consider\n                // click legend to toggle axis blank.\n                !axisInfo.useHandle && (option.status = 'hide');\n            }\n\n            // If status is 'hide', should be no info in payload.\n            option.status === 'show' && outputAxesInfo.push({\n                axisDim: axisInfo.axis.dim,\n                axisIndex: axisInfo.axis.model.componentIndex,\n                value: option.value\n            });\n        });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n        // Basic logic: If no showTip required, hideTip will be dispatched.\n        if (illegalPoint(point) || !dataByCoordSys.list.length) {\n            dispatchAction({type: 'hideTip'});\n            return;\n        }\n\n        // In most case only one axis (or event one series is used). It is\n        // convinient to fetch payload.seriesIndex and payload.dataIndex\n        // dirtectly. So put the first seriesIndex and dataIndex of the first\n        // axis on the payload.\n        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n        dispatchAction({\n            type: 'showTip',\n            escapeConnect: true,\n            x: point[0],\n            y: point[1],\n            tooltipOption: payload.tooltipOption,\n            position: payload.position,\n            dataIndexInside: sampleItem.dataIndexInside,\n            dataIndex: sampleItem.dataIndex,\n            seriesIndex: sampleItem.seriesIndex,\n            dataByCoordSys: dataByCoordSys.list\n        });\n    }\n\n    function dispatchHighDownActually(axesInfo, dispatchAction, api) {\n        // FIXME\n        // highlight status modification shoule be a stage of main process?\n        // (Consider confilct (e.g., legend and axisPointer) and setOption)\n\n        var zr = api.getZr();\n        var highDownKey = 'axisPointerLastHighlights';\n        var lastHighlights = get(zr)[highDownKey] || {};\n        var newHighlights = get(zr)[highDownKey] = {};\n\n        // Update highlight/downplay status according to axisPointer model.\n        // Build hash map and remove duplicate incidentally.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n                var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n                newHighlights[key] = batchItem;\n            });\n        });\n\n        // Diff.\n        var toHighlight = [];\n        var toDownplay = [];\n        zrUtil.each(lastHighlights, function (batchItem, key) {\n            !newHighlights[key] && toDownplay.push(batchItem);\n        });\n        zrUtil.each(newHighlights, function (batchItem, key) {\n            !lastHighlights[key] && toHighlight.push(batchItem);\n        });\n\n        toDownplay.length && api.dispatchAction({\n            type: 'downplay', escapeConnect: true, batch: toDownplay\n        });\n        toHighlight.length && api.dispatchAction({\n            type: 'highlight', escapeConnect: true, batch: toHighlight\n        });\n    }\n\n    function findInputAxisInfo(inputAxesInfo, axisInfo) {\n        for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n            var inputAxisInfo = inputAxesInfo[i];\n            if (axisInfo.axis.dim === inputAxisInfo.axisDim\n                && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex\n            ) {\n                return inputAxisInfo;\n            }\n        }\n    }\n\n    function makeMapperParam(axisInfo) {\n        var axisModel = axisInfo.axis.model;\n        var item = {};\n        var dim = item.axisDim = axisInfo.axis.dim;\n        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n        item.axisName = item[dim + 'AxisName'] = axisModel.name;\n        item.axisId = item[dim + 'AxisId'] = axisModel.id;\n        return item;\n    }\n\n    function illegalPoint(point) {\n        return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    module.exports = axisTrigger;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9heGlzVHJpZ2dlci5qcz9iMzcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLCtCQUErQjtBQUM5QztBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsNEJBQTRCO0FBQzNDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSx3RUFBd0UsMEJBQTBCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIG1vZGVsSGVscGVyID0gcmVxdWlyZSgnLi9tb2RlbEhlbHBlcicpO1xuICAgIHZhciBmaW5kUG9pbnRGcm9tU2VyaWVzID0gcmVxdWlyZSgnLi9maW5kUG9pbnRGcm9tU2VyaWVzJyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbiAgICB2YXIgZ2V0ID0gbW9kZWxVdGlsLm1ha2VHZXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEJhc2ljIGxvZ2ljOiBjaGVjayBhbGwgYXhpcywgaWYgdGhleSBkbyBub3QgZGVtYW5kIHNob3cvaGlnaGxpZ2h0LFxuICAgICAqIHRoZW4gaGlkZS9kb3ducGxheSB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvb3JkU3lzQXhlc0luZm9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC5jdXJyVHJpZ2dlcl0gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ2xlYXZlJ1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtwYXlsb2FkLnhdIHggYW5kIHksIHdoaWNoIGFyZSBtYW5kYXRvcnksIHNwZWNpZnkgYSBwb2ludCB0b1xuICAgICAqICAgICAgICAgICAgICB0cmlnZ2VyIGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtwYXlsb2FkLnldIHggYW5kIHksIHdoaWNoIGFyZSBtYW5kYXRvcnksIHNwZWNpZnkgYSBwb2ludCB0b1xuICAgICAqICAgICAgICAgICAgICB0cmlnZ2VyIGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGF5bG9hZC5zZXJpZXNJbmRleF0gZmluZGVyLCBvcHRpb25hbCwgcmVzdHJpY3QgdGFyZ2V0IGF4ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXlsb2FkLmRhdGFJbmRleF0gZmluZGVyLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWQuYXhlc0luZm9dIGZpbmRlciwgcmVzdHJpY3QgdGFyZ2V0IGF4ZXMuXG4gICAgICogICAgICAgIFt7XG4gICAgICogICAgICAgICAgYXhpc0RpbTogJ3gnfCd5J3wnYW5nbGUnfC4uLixcbiAgICAgKiAgICAgICAgICBheGlzSW5kZXg6IC4uLixcbiAgICAgKiAgICAgICAgICB2YWx1ZTogLi4uXG4gICAgICogICAgICAgIH0sIC4uLl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGF5bG9hZC5kaXNwYXRjaEFjdGlvbl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWQudG9vbHRpcE9wdGlvbl1cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheS48bnVtYmVyPnxGdW5jdGlvbn0gW3BheWxvYWQucG9zaXRpb25dIFRvb2x0aXAgcG9zaXRpb24sXG4gICAgICogICAgICAgIHdoaWNoIGNhbiBiZSBzcGVjaWZpZWQgaW4gZGlzcGF0Y2hBY3Rpb25cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNvbnRlbnQgb2YgZXZlbnQgb2JqIGZvciBlY2hhcnRzLmNvbm5lY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXhpc1RyaWdnZXIocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBjdXJyVHJpZ2dlciA9IHBheWxvYWQuY3VyclRyaWdnZXI7XG4gICAgICAgIHZhciBwb2ludCA9IFtwYXlsb2FkLngsIHBheWxvYWQueV07XG4gICAgICAgIHZhciBmaW5kZXIgPSBwYXlsb2FkO1xuICAgICAgICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBwYXlsb2FkLmRpc3BhdGNoQWN0aW9uIHx8IHpyVXRpbC5iaW5kKGFwaS5kaXNwYXRjaEFjdGlvbiwgYXBpKTtcbiAgICAgICAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvO1xuXG4gICAgICAgIGlmIChpbGxlZ2FsUG9pbnQocG9pbnQpKSB7XG4gICAgICAgICAgICAvLyBVc2VkIGluIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGBjb25uZWN0aW9uYDogdXNlIHRoZSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgICAgICAgICAgIC8vIGFuZCBkYXRhSW5kZXguIEFuZCBhbHNvIHVzZWQgaW4gdGhlIHRvb2x0aXBWaWV3IHRyaWdnZXIuXG4gICAgICAgICAgICBwb2ludCA9IGZpbmRQb2ludEZyb21TZXJpZXMoe1xuICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBmaW5kZXIuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBkYXRhSW5kZXhJbnNpZGUgZnJvbSBvdGhlciBlYyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogYXV0byBkZXRlY3QgaXQ/XG4gICAgICAgICAgICAgICAgZGF0YUluZGV4OiBmaW5kZXIuZGF0YUluZGV4XG4gICAgICAgICAgICB9LCBlY01vZGVsKS5wb2ludDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNJbGxlZ2FsUG9pbnQgPSBpbGxlZ2FsUG9pbnQocG9pbnQpO1xuXG4gICAgICAgIC8vIEF4aXMgYW5kIHZhbHVlIGNhbiBiZSBzcGVjaWZpZWQgd2hlbiBjYWxsaW5nIGRpc3BhdGNoQWN0aW9uKHt0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInfSkuXG4gICAgICAgIC8vIE5vdGljZTogSW4gdGhpcyBjYXNlLCBpdCBpcyBkaWZmaWN1bHQgdG8gZ2V0IHRoZSBgcG9pbnRgICh3aGljaCBpcyBuZWNlc3NhcnkgdG8gc2hvd1xuICAgICAgICAvLyB0b29sdGlwLCBzbyBpZiBwb2ludCBpcyBub3QgZ2l2ZW4sIHdlIGp1c3QgdXNlIHRoZSBwb2ludCBmb3VuZCBieSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgICAgICAgLy8gYW5kIGRhdGFJbmRleC5cbiAgICAgICAgdmFyIGlucHV0QXhlc0luZm8gPSBmaW5kZXIuYXhlc0luZm87XG5cbiAgICAgICAgdmFyIGF4ZXNJbmZvID0gY29vcmRTeXNBeGVzSW5mby5heGVzSW5mbztcbiAgICAgICAgdmFyIHNob3VsZEhpZGUgPSBjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCBpbGxlZ2FsUG9pbnQocG9pbnQpO1xuICAgICAgICB2YXIgb3V0cHV0RmluZGVyID0ge307XG5cbiAgICAgICAgdmFyIHNob3dWYWx1ZU1hcCA9IHt9O1xuICAgICAgICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSB7bGlzdDogW10sIG1hcDoge319O1xuICAgICAgICB2YXIgdXBkYXRlcnMgPSB7XG4gICAgICAgICAgICBzaG93UG9pbnRlcjogY3Vycnkoc2hvd1BvaW50ZXIsIHNob3dWYWx1ZU1hcCksXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogY3Vycnkoc2hvd1Rvb2x0aXAsIGRhdGFCeUNvb3JkU3lzKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZm9yIHRyaWdnZXJlZCBheGVzLlxuICAgICAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNNYXAsIGZ1bmN0aW9uIChjb29yZFN5cywgY29vcmRTeXNLZXkpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcG9pbnQgZ2l2ZW4sIGl0IG11c3QgYmUgY29udGFpbmVkIGJ5IHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICAgIHZhciBjb29yZFN5c0NvbnRhaW5zUG9pbnQgPSBpc0lsbGVnYWxQb2ludCB8fCBjb29yZFN5cy5jb250YWluUG9pbnQocG9pbnQpO1xuXG4gICAgICAgICAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dEF4aXNJbmZvID0gZmluZElucHV0QXhpc0luZm8oaW5wdXRBeGVzSW5mbywgYXhpc0luZm8pO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGlucHV0QXhlc0luZm8sIG5vIGF4aXMgaXMgcmVzdHJpY3RlZC5cbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEhpZGUgJiYgY29vcmRTeXNDb250YWluc1BvaW50ICYmICghaW5wdXRBeGVzSW5mbyB8fCBpbnB1dEF4aXNJbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW5wdXRBeGlzSW5mbyAmJiBpbnB1dEF4aXNJbmZvLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgIWlzSWxsZWdhbFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBheGlzLnBvaW50VG9EYXRhKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWwgIT0gbnVsbCAmJiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCB2YWwsIHVwZGF0ZXJzLCBmYWxzZSwgb3V0cHV0RmluZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBmb3IgbGlua2VkIGF4ZXMuXG4gICAgICAgIHZhciBsaW5rVHJpZ2dlcnMgPSB7fTtcbiAgICAgICAgZWFjaChheGVzSW5mbywgZnVuY3Rpb24gKHRhckF4aXNJbmZvLCB0YXJLZXkpIHtcbiAgICAgICAgICAgIHZhciBsaW5rR3JvdXAgPSB0YXJBeGlzSW5mby5saW5rR3JvdXA7XG5cbiAgICAgICAgICAgIC8vIElmIGF4aXMgaGFzIGJlZW4gdHJpZ2dlcmVkIGluIHRoZSBwcmV2aW91cyBzdGFnZSwgaXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgYnkgbGluay5cbiAgICAgICAgICAgIGlmIChsaW5rR3JvdXAgJiYgIXNob3dWYWx1ZU1hcFt0YXJLZXldKSB7XG4gICAgICAgICAgICAgICAgZWFjaChsaW5rR3JvdXAuYXhlc0luZm8sIGZ1bmN0aW9uIChzcmNBeGlzSW5mbywgc3JjS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmNWYWxJdGVtID0gc2hvd1ZhbHVlTWFwW3NyY0tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNyY1ZhbEl0ZW0gZXhpc3QsIHNvdXJjZSBheGlzIGlzIHRyaWdnZXJlZCwgc28gbGluayB0byB0YXJnZXQgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY0F4aXNJbmZvICE9PSB0YXJBeGlzSW5mbyAmJiBzcmNWYWxJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3JjVmFsSXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtHcm91cC5tYXBwZXIgJiYgKHZhbCA9IHRhckF4aXNJbmZvLmF4aXMuc2NhbGUucGFyc2UobGlua0dyb3VwLm1hcHBlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwsIG1ha2VNYXBwZXJQYXJhbShzcmNBeGlzSW5mbyksIG1ha2VNYXBwZXJQYXJhbSh0YXJBeGlzSW5mbylcbiAgICAgICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtUcmlnZ2Vyc1t0YXJBeGlzSW5mby5rZXldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKGxpbmtUcmlnZ2VycywgZnVuY3Rpb24gKHZhbCwgdGFyS2V5KSB7XG4gICAgICAgICAgICBwcm9jZXNzT25BeGlzKGF4ZXNJbmZvW3RhcktleV0sIHZhbCwgdXBkYXRlcnMsIHRydWUsIG91dHB1dEZpbmRlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVwZGF0ZU1vZGVsQWN0dWFsbHkoc2hvd1ZhbHVlTWFwLCBheGVzSW5mbywgb3V0cHV0RmluZGVyKTtcbiAgICAgICAgZGlzcGF0Y2hUb29sdGlwQWN0dWFsbHkoZGF0YUJ5Q29vcmRTeXMsIHBvaW50LCBwYXlsb2FkLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgIGRpc3BhdGNoSGlnaERvd25BY3R1YWxseShheGVzSW5mbywgZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dEZpbmRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCBuZXdWYWx1ZSwgdXBkYXRlcnMsIGRvbnRTbmFwLCBvdXRwdXRGaW5kZXIpIHtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuXG4gICAgICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSB8fCAhYXhpcy5jb250YWluRGF0YShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXhpc0luZm8uaW52b2x2ZVNlcmllcykge1xuICAgICAgICAgICAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlYXZ5IGNhbGN1bGF0aW9uLiBTbyBwdXQgaXQgYWZ0ZXIgYXhpcy5jb250YWluRGF0YSBjaGVja2luZy5cbiAgICAgICAgdmFyIHBheWxvYWRJbmZvID0gYnVpbGRQYXlsb2Fkc0J5U2VyaWVzKG5ld1ZhbHVlLCBheGlzSW5mbyk7XG4gICAgICAgIHZhciBwYXlsb2FkQmF0Y2ggPSBwYXlsb2FkSW5mby5wYXlsb2FkQmF0Y2g7XG4gICAgICAgIHZhciBzbmFwVG9WYWx1ZSA9IHBheWxvYWRJbmZvLnNuYXBUb1ZhbHVlO1xuXG4gICAgICAgIC8vIEZpbGwgY29udGVudCBvZiBldmVudCBvYmogZm9yIGVjaGFydHMuY29ubmVjdC5cbiAgICAgICAgLy8gQnkgZGVmdWFsdCB1c2UgdGhlIGZpcnN0IGludm9sdmVkIHNlcmllcyBkYXRhIGFzIGEgc2FtcGxlIHRvIGNvbm5lY3QuXG4gICAgICAgIGlmIChwYXlsb2FkQmF0Y2hbMF0gJiYgb3V0cHV0RmluZGVyLnNlcmllc0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHpyVXRpbC5leHRlbmQob3V0cHV0RmluZGVyLCBwYXlsb2FkQmF0Y2hbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gbGlua1NvdXJjZSBpbnB1dCwgdGhpcyBwcm9jZXNzIGlzIGZvciBjb2xsZWN0aW5nIGxpbmtcbiAgICAgICAgLy8gdGFyZ2V0LCB3aGVyZSBzbmFwIHNob3VsZCBub3QgYmUgYWNjZXB0ZWQuXG4gICAgICAgIGlmICghZG9udFNuYXAgJiYgYXhpc0luZm8uc25hcCkge1xuICAgICAgICAgICAgaWYgKGF4aXMuY29udGFpbkRhdGEoc25hcFRvVmFsdWUpICYmIHNuYXBUb1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHNuYXBUb1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlLCBwYXlsb2FkQmF0Y2gsIG91dHB1dEZpbmRlcik7XG4gICAgICAgIC8vIFRvb2x0aXAgc2hvdWxkIGFsd2F5cyBiZSBzbmFwVG9WYWx1ZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmVcbiAgICAgICAgLy8gaW5jb3JyZWN0IFwiYXhpcyB2YWx1ZSB+IHNlcmllcyB2YWx1ZVwiIG1hcHBpbmcgZGlzcGxheWVkIGluIHRvb2x0aXAuXG4gICAgICAgIHVwZGF0ZXJzLnNob3dUb29sdGlwKGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgc25hcFRvVmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZHNCeVNlcmllcyh2YWx1ZSwgYXhpc0luZm8pIHtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICAgICAgICB2YXIgZGltID0gYXhpcy5kaW07XG4gICAgICAgIHZhciBzbmFwVG9WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB2YXIgcGF5bG9hZEJhdGNoID0gW107XG4gICAgICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIG1pbkRpZmYgPSAtMTtcblxuICAgICAgICBlYWNoKGF4aXNJbmZvLnNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllcywgaWR4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YURpbSA9IHNlcmllcy5jb29yZERpbVRvRGF0YURpbShkaW0pO1xuICAgICAgICAgICAgdmFyIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kaWNlcztcblxuICAgICAgICAgICAgaWYgKHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YShkYXRhRGltLCB2YWx1ZSwgYXhpcyk7XG4gICAgICAgICAgICAgICAgZGF0YUluZGljZXMgPSByZXN1bHQuZGF0YUluZGljZXM7XG4gICAgICAgICAgICAgICAgc2VyaWVzTmVzdGVzdFZhbHVlID0gcmVzdWx0Lm5lc3Rlc3RWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFJbmRpY2VzID0gc2VyaWVzLmdldERhdGEoKS5pbmRpY2VzT2ZOZWFyZXN0KFxuICAgICAgICAgICAgICAgICAgICBkYXRhRGltWzBdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgdGhyZXNob2xkIHRvIGF2b2lkIGZpbmQgdGhlIHdyb25nIGRhdGFJbmRleFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGRhdGEgbGVuZ3RoIGlzIG5vdCBzYW1lLlxuICAgICAgICAgICAgICAgICAgICBmYWxzZSwgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gMC41IDogbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSBzZXJpZXMuZ2V0RGF0YSgpLmdldChkYXRhRGltWzBdLCBkYXRhSW5kaWNlc1swXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXNOZXN0ZXN0VmFsdWUgPT0gbnVsbCB8fCAhaXNGaW5pdGUoc2VyaWVzTmVzdGVzdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZGlmZik7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBjYXRlZ29yeSBjYXNlXG4gICAgICAgICAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0IHx8IChkaWZmID49IDAgJiYgbWluRGlmZiA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgc25hcFRvVmFsdWUgPSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRCYXRjaC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlYWNoKGRhdGFJbmRpY2VzLCBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRCYXRjaC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXMuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXhJbnNpZGU6IGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleDogc2VyaWVzLmdldERhdGEoKS5nZXRSYXdJbmRleChkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2gsXG4gICAgICAgICAgICBzbmFwVG9WYWx1ZTogc25hcFRvVmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93UG9pbnRlcihzaG93VmFsdWVNYXAsIGF4aXNJbmZvLCB2YWx1ZSwgcGF5bG9hZEJhdGNoKSB7XG4gICAgICAgIHNob3dWYWx1ZU1hcFtheGlzSW5mby5rZXldID0ge3ZhbHVlOiB2YWx1ZSwgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2h9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGRhdGFCeUNvb3JkU3lzLCBheGlzSW5mbywgcGF5bG9hZEluZm8sIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXlsb2FkQmF0Y2ggPSBwYXlsb2FkSW5mby5wYXlsb2FkQmF0Y2g7XG4gICAgICAgIHZhciBheGlzID0gYXhpc0luZm8uYXhpcztcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcblxuICAgICAgICAvLyBJZiBubyBkYXRhLCBkbyBub3QgY3JlYXRlIGFueXRoaW5nIGluIGRhdGFCeUNvb3JkU3lzLFxuICAgICAgICAvLyB3aG9zZSBsZW5ndGggd2lsbCBiZSB1c2VkIHRvIGp1ZGdlIHdoZXRoZXIgZGlzcGF0Y2ggYWN0aW9uLlxuICAgICAgICBpZiAoIWF4aXNJbmZvLnRyaWdnZXJUb29sdGlwIHx8ICFwYXlsb2FkQmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGF4aXNJbmZvLmNvb3JkU3lzLm1vZGVsO1xuICAgICAgICB2YXIgY29vcmRTeXNLZXkgPSBtb2RlbEhlbHBlci5tYWtlS2V5KGNvb3JkU3lzTW9kZWwpO1xuICAgICAgICB2YXIgY29vcmRTeXNJdGVtID0gZGF0YUJ5Q29vcmRTeXMubWFwW2Nvb3JkU3lzS2V5XTtcbiAgICAgICAgaWYgKCFjb29yZFN5c0l0ZW0pIHtcbiAgICAgICAgICAgIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV0gPSB7XG4gICAgICAgICAgICAgICAgY29vcmRTeXNJZDogY29vcmRTeXNNb2RlbC5pZCxcbiAgICAgICAgICAgICAgICBjb29yZFN5c0luZGV4OiBjb29yZFN5c01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgICAgICAgICAgIGNvb3JkU3lzVHlwZTogY29vcmRTeXNNb2RlbC50eXBlLFxuICAgICAgICAgICAgICAgIGNvb3JkU3lzTWFpblR5cGU6IGNvb3JkU3lzTW9kZWwubWFpblR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YUJ5QXhpczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhQnlDb29yZFN5cy5saXN0LnB1c2goY29vcmRTeXNJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb3JkU3lzSXRlbS5kYXRhQnlBeGlzLnB1c2goe1xuICAgICAgICAgICAgYXhpc0RpbTogYXhpcy5kaW0sXG4gICAgICAgICAgICBheGlzSW5kZXg6IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICAgIGF4aXNUeXBlOiBheGlzTW9kZWwudHlwZSxcbiAgICAgICAgICAgIGF4aXNJZDogYXhpc01vZGVsLmlkLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLy8gQ2F1c3Rpb246IHZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbCBpcyBhY3R1YWxseSBvbiBcInZpZXcgc3RhZ2VcIiwgd2hpY2hcbiAgICAgICAgICAgIC8vIGRlcGVuZHMgdGhhdCBhbGwgbW9kZWxzIGhhdmUgYmVlbiB1cGRhdGVkLiBTbyBpdCBzaG91bGQgbm90IGJlIHBlcmZvcm1lZFxuICAgICAgICAgICAgLy8gaGVyZS4gQ29uc2lkZXJpbmcgYXhpc1BvaW50ZXJNb2RlbCB1c2VkIGhlcmUgaXMgdm9sYXRpbGUsIHdoaWNoIGlzIGhhcmRcbiAgICAgICAgICAgIC8vIHRvIGJlIHJldHJpZXZlIGluIFRvb2x0aXBWaWV3LCB3ZSBwcmVwYXJlIHBhcmFtZXRlcnMgaGVyZS5cbiAgICAgICAgICAgIHZhbHVlTGFiZWxPcHQ6IHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5wcmVjaXNpb24nKSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5mb3JtYXR0ZXInKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmllc0RhdGFJbmRpY2VzOiBwYXlsb2FkQmF0Y2guc2xpY2UoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNb2RlbEFjdHVhbGx5KHNob3dWYWx1ZU1hcCwgYXhlc0luZm8sIG91dHB1dEZpbmRlcikge1xuICAgICAgICB2YXIgb3V0cHV0QXhlc0luZm8gPSBvdXRwdXRGaW5kZXIuYXhlc0luZm8gPSBbXTtcbiAgICAgICAgLy8gQmFzaWMgbG9naWM6IElmIG5vICdzaG93JyByZXF1aXJlZCwgJ2hpZGUnIHRoaXMgYXhpc1BvaW50ZXIuXG4gICAgICAgIGVhY2goYXhlc0luZm8sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbC5vcHRpb247XG4gICAgICAgICAgICB2YXIgdmFsSXRlbSA9IHNob3dWYWx1ZU1hcFtrZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsSXRlbSkge1xuICAgICAgICAgICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnc2hvdycpO1xuICAgICAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbEl0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGxhYmVsIGZvcm1hdHRlciBwYXJhbSBhbmQgaGlnaGxpZ2h0LlxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZXJpZXNEYXRhSW5kaWNlcyA9ICh2YWxJdGVtLnBheWxvYWRCYXRjaCB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gYWx3YXlzIHNob3cgKGUuZy4sIGhhbmRsZSB1c2VkKSwgcmVtYWluXG4gICAgICAgICAgICAvLyBvcmlnaW5hbCB2YWx1ZSBhbmQgc3RhdHVzLlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaGlkZSwgdmFsdWUgc3RpbGwgbmVlZCB0byBiZSBzZXQsIGNvbnNpZGVyXG4gICAgICAgICAgICAgICAgLy8gY2xpY2sgbGVnZW5kIHRvIHRvZ2dsZSBheGlzIGJsYW5rLlxuICAgICAgICAgICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnaGlkZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBzdGF0dXMgaXMgJ2hpZGUnLCBzaG91bGQgYmUgbm8gaW5mbyBpbiBwYXlsb2FkLlxuICAgICAgICAgICAgb3B0aW9uLnN0YXR1cyA9PT0gJ3Nob3cnICYmIG91dHB1dEF4ZXNJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgIGF4aXNEaW06IGF4aXNJbmZvLmF4aXMuZGltLFxuICAgICAgICAgICAgICAgIGF4aXNJbmRleDogYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hUb29sdGlwQWN0dWFsbHkoZGF0YUJ5Q29vcmRTeXMsIHBvaW50LCBwYXlsb2FkLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAvLyBCYXNpYyBsb2dpYzogSWYgbm8gc2hvd1RpcCByZXF1aXJlZCwgaGlkZVRpcCB3aWxsIGJlIGRpc3BhdGNoZWQuXG4gICAgICAgIGlmIChpbGxlZ2FsUG9pbnQocG9pbnQpIHx8ICFkYXRhQnlDb29yZFN5cy5saXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICdoaWRlVGlwJ30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gbW9zdCBjYXNlIG9ubHkgb25lIGF4aXMgKG9yIGV2ZW50IG9uZSBzZXJpZXMgaXMgdXNlZCkuIEl0IGlzXG4gICAgICAgIC8vIGNvbnZpbmllbnQgdG8gZmV0Y2ggcGF5bG9hZC5zZXJpZXNJbmRleCBhbmQgcGF5bG9hZC5kYXRhSW5kZXhcbiAgICAgICAgLy8gZGlydGVjdGx5LiBTbyBwdXQgdGhlIGZpcnN0IHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICAgIC8vIGF4aXMgb24gdGhlIHBheWxvYWQuXG4gICAgICAgIHZhciBzYW1wbGVJdGVtID0gKChkYXRhQnlDb29yZFN5cy5saXN0WzBdLmRhdGFCeUF4aXNbMF0gfHwge30pLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdKVswXSB8fCB7fTtcblxuICAgICAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICBlc2NhcGVDb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgeDogcG9pbnRbMF0sXG4gICAgICAgICAgICB5OiBwb2ludFsxXSxcbiAgICAgICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWQudG9vbHRpcE9wdGlvbixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICAgICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICAgICAgICAgIGRhdGFJbmRleDogc2FtcGxlSXRlbS5kYXRhSW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogc2FtcGxlSXRlbS5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoSGlnaERvd25BY3R1YWxseShheGVzSW5mbywgZGlzcGF0Y2hBY3Rpb24sIGFwaSkge1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBoaWdobGlnaHQgc3RhdHVzIG1vZGlmaWNhdGlvbiBzaG91bGUgYmUgYSBzdGFnZSBvZiBtYWluIHByb2Nlc3M/XG4gICAgICAgIC8vIChDb25zaWRlciBjb25maWxjdCAoZS5nLiwgbGVnZW5kIGFuZCBheGlzUG9pbnRlcikgYW5kIHNldE9wdGlvbilcblxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICAgICAgdmFyIGhpZ2hEb3duS2V5ID0gJ2F4aXNQb2ludGVyTGFzdEhpZ2hsaWdodHMnO1xuICAgICAgICB2YXIgbGFzdEhpZ2hsaWdodHMgPSBnZXQoenIpW2hpZ2hEb3duS2V5XSB8fCB7fTtcbiAgICAgICAgdmFyIG5ld0hpZ2hsaWdodHMgPSBnZXQoenIpW2hpZ2hEb3duS2V5XSA9IHt9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSBoaWdobGlnaHQvZG93bnBsYXkgc3RhdHVzIGFjY29yZGluZyB0byBheGlzUG9pbnRlciBtb2RlbC5cbiAgICAgICAgLy8gQnVpbGQgaGFzaCBtYXAgYW5kIHJlbW92ZSBkdXBsaWNhdGUgaW5jaWRlbnRhbGx5LlxuICAgICAgICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgICAgICAgICAgb3B0aW9uLnN0YXR1cyA9PT0gJ3Nob3cnICYmIGVhY2gob3B0aW9uLnNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGJhdGNoSXRlbS5zZXJpZXNJbmRleCArICcgfCAnICsgYmF0Y2hJdGVtLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICBuZXdIaWdobGlnaHRzW2tleV0gPSBiYXRjaEl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGlmZi5cbiAgICAgICAgdmFyIHRvSGlnaGxpZ2h0ID0gW107XG4gICAgICAgIHZhciB0b0Rvd25wbGF5ID0gW107XG4gICAgICAgIHpyVXRpbC5lYWNoKGxhc3RIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICFuZXdIaWdobGlnaHRzW2tleV0gJiYgdG9Eb3ducGxheS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICB6clV0aWwuZWFjaChuZXdIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICFsYXN0SGlnaGxpZ2h0c1trZXldICYmIHRvSGlnaGxpZ2h0LnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG9Eb3ducGxheS5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdkb3ducGxheScsIGVzY2FwZUNvbm5lY3Q6IHRydWUsIGJhdGNoOiB0b0Rvd25wbGF5XG4gICAgICAgIH0pO1xuICAgICAgICB0b0hpZ2hsaWdodC5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdoaWdobGlnaHQnLCBlc2NhcGVDb25uZWN0OiB0cnVlLCBiYXRjaDogdG9IaWdobGlnaHRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZElucHV0QXhpc0luZm8oaW5wdXRBeGVzSW5mbywgYXhpc0luZm8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoaW5wdXRBeGVzSW5mbyB8fCBbXSkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dEF4aXNJbmZvID0gaW5wdXRBeGVzSW5mb1tpXTtcbiAgICAgICAgICAgIGlmIChheGlzSW5mby5heGlzLmRpbSA9PT0gaW5wdXRBeGlzSW5mby5heGlzRGltXG4gICAgICAgICAgICAgICAgJiYgYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCA9PT0gaW5wdXRBeGlzSW5mby5heGlzSW5kZXhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dEF4aXNJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZU1hcHBlclBhcmFtKGF4aXNJbmZvKSB7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBheGlzSW5mby5heGlzLm1vZGVsO1xuICAgICAgICB2YXIgaXRlbSA9IHt9O1xuICAgICAgICB2YXIgZGltID0gaXRlbS5heGlzRGltID0gYXhpc0luZm8uYXhpcy5kaW07XG4gICAgICAgIGl0ZW0uYXhpc0luZGV4ID0gaXRlbVtkaW0gKyAnQXhpc0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgICAgIGl0ZW0uYXhpc05hbWUgPSBpdGVtW2RpbSArICdBeGlzTmFtZSddID0gYXhpc01vZGVsLm5hbWU7XG4gICAgICAgIGl0ZW0uYXhpc0lkID0gaXRlbVtkaW0gKyAnQXhpc0lkJ10gPSBheGlzTW9kZWwuaWQ7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlsbGVnYWxQb2ludChwb2ludCkge1xuICAgICAgICByZXR1cm4gIXBvaW50IHx8IHBvaW50WzBdID09IG51bGwgfHwgaXNOYU4ocG9pbnRbMF0pIHx8IHBvaW50WzFdID09IG51bGwgfHwgaXNOYU4ocG9pbnRbMV0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYXhpc1RyaWdnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var AxisBuilder = __webpack_require__(49);\n    var AxisView = __webpack_require__(50);\n    var cartesianAxisHelper = __webpack_require__(51);\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var CartesianAxisView = AxisView.extend({\n\n        type: 'cartesianAxis',\n\n        axisPointerClass: 'CartesianAxisPointer',\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n            CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    CartesianAxisView.extend({\n        type: 'xAxis'\n    });\n    CartesianAxisView.extend({\n        type: 'yAxis'\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0NhcnRlc2lhbkF4aXNWaWV3LmpzPzc5MGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQix5Q0FBeUM7QUFDNUQsbUJBQW1CLHlDQUF5QztBQUM1RCxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RCxtQkFBbUIseUNBQXlDO0FBQzVELG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgQXhpc0J1aWxkZXIgPSByZXF1aXJlKCcuL0F4aXNCdWlsZGVyJyk7XG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi9BeGlzVmlldycpO1xuICAgIHZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZSgnLi9jYXJ0ZXNpYW5BeGlzSGVscGVyJyk7XG4gICAgdmFyIGlmSWdub3JlT25UaWNrID0gQXhpc0J1aWxkZXIuaWZJZ25vcmVPblRpY2s7XG4gICAgdmFyIGdldEludGVydmFsID0gQXhpc0J1aWxkZXIuZ2V0SW50ZXJ2YWw7XG5cbiAgICB2YXIgYXhpc0J1aWxkZXJBdHRycyA9IFtcbiAgICAgICAgJ2F4aXNMaW5lJywgJ2F4aXNMYWJlbCcsICdheGlzVGljaycsICdheGlzTmFtZSdcbiAgICBdO1xuICAgIHZhciBzZWxmQnVpbGRlckF0dHJzID0gW1xuICAgICAgICAnc3BsaXRBcmVhJywgJ3NwbGl0TGluZSdcbiAgICBdO1xuXG4gICAgLy8gZnVuY3Rpb24gZ2V0QWxpZ25XaXRoTGFiZWwobW9kZWwsIGF4aXNNb2RlbCkge1xuICAgIC8vICAgICB2YXIgYWxpZ25XaXRoTGFiZWwgPSBtb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4gICAgLy8gICAgIGlmIChhbGlnbldpdGhMYWJlbCA9PT0gJ2F1dG8nKSB7XG4gICAgLy8gICAgICAgICBhbGlnbldpdGhMYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLmFsaWduV2l0aExhYmVsJyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIGFsaWduV2l0aExhYmVsO1xuICAgIC8vIH1cblxuICAgIHZhciBDYXJ0ZXNpYW5BeGlzVmlldyA9IEF4aXNWaWV3LmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbkF4aXMnLFxuXG4gICAgICAgIGF4aXNQb2ludGVyQ2xhc3M6ICdDYXJ0ZXNpYW5BeGlzUG9pbnRlcicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICAgICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZE1vZGVsID0gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgICAgICAgICAgdmFyIGxheW91dCA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGdyaWRNb2RlbCwgYXhpc01vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgbGF5b3V0KTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2goYXhpc0J1aWxkZXJBdHRycywgYXhpc0J1aWxkZXIuYWRkLCBheGlzQnVpbGRlcik7XG5cbiAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNlbGZCdWlsZGVyQXR0cnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXQobmFtZSArICcuc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgbmFtZV0oYXhpc01vZGVsLCBncmlkTW9kZWwsIGxheW91dC5sYWJlbEludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgZ3JhcGhpYy5ncm91cFRyYW5zaXRpb24ob2xkQXhpc0dyb3VwLCB0aGlzLl9heGlzR3JvdXAsIGF4aXNNb2RlbCk7XG5cbiAgICAgICAgICAgIENhcnRlc2lhbkF4aXNWaWV3LnN1cGVyQ2FsbCh0aGlzLCAncmVuZGVyJywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NwbGl0TGluZTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzcGxpdExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgbGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVJbnRlcnZhbCA9IGdldEludGVydmFsKHNwbGl0TGluZU1vZGVsLCBsYWJlbEludGVydmFsKTtcblxuICAgICAgICAgICAgbGluZUNvbG9ycyA9IHpyVXRpbC5pc0FycmF5KGxpbmVDb2xvcnMpID8gbGluZUNvbG9ycyA6IFtsaW5lQ29sb3JzXTtcblxuICAgICAgICAgICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKFxuICAgICAgICAgICAgICAgIC8vIHNwbGl0TGluZU1vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcblxuICAgICAgICAgICAgdmFyIHAxID0gW107XG4gICAgICAgICAgICB2YXIgcDIgPSBbXTtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIC8vIEJhdGNoaW5nIHRoZSBsaW5lcyBpZiBjb2xvciBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGUgPSBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaSwgbGluZUludGVydmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzW2ldKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAxWzFdID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgcDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAyWzFdID0gZ3JpZFJlY3QueSArIGdyaWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAxWzBdID0gZ3JpZFJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgcDFbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAyWzBdID0gZ3JpZFJlY3QueCArIGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBwMlsxXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IChsaW5lQ291bnQrKykgJSBsaW5lQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGlzR3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAgICAgICAgICAgICAgIGFuaWQ6ICdsaW5lXycgKyB0aWNrc1tpXSxcblxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTE6IHAxWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IHAyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5lQ29sb3JzW2NvbG9ySW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0sIGxpbmVTdHlsZSksXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfEZ1bmN0aW9ufSBsYWJlbEludGVydmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc3BsaXRBcmVhOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBncmlkTW9kZWwsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICAgICAgICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNwbGl0QXJlYU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdzcGxpdEFyZWEnKTtcbiAgICAgICAgICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNwbGl0QXJlYU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuXG4gICAgICAgICAgICB2YXIgZ3JpZFJlY3QgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG5cbiAgICAgICAgICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoXG4gICAgICAgICAgICAgICAgLy8gc3BsaXRBcmVhTW9kZWwuZ2V0KCdhbGlnbldpdGhMYWJlbCcpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgICAgICB2YXIgcHJldlggPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbMF0pO1xuICAgICAgICAgICAgdmFyIHByZXZZID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdKTtcblxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICAgICAgdmFyIGFyZWFJbnRlcnZhbCA9IGdldEludGVydmFsKHNwbGl0QXJlYU1vZGVsLCBsYWJlbEludGVydmFsKTtcblxuICAgICAgICAgICAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgICAgICAgICAgYXJlYUNvbG9ycyA9IHpyVXRpbC5pc0FycmF5KGFyZWFDb2xvcnMpID8gYXJlYUNvbG9ycyA6IFthcmVhQ29sb3JzXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpLCBhcmVhSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHByZXZYO1xuICAgICAgICAgICAgICAgICAgICB5ID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aWNrQ29vcmQgLSB4O1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gZ3JpZFJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHByZXZZO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aWNrQ29vcmQgLSB5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gKGNvdW50KyspICUgYXJlYUNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgYW5pZDogJ2FyZWFfJyArIHRpY2tzW2ldLFxuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogYXJlYUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBwcmV2WCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIENhcnRlc2lhbkF4aXNWaWV3LmV4dGVuZCh7XG4gICAgICAgIHR5cGU6ICd4QXhpcydcbiAgICB9KTtcbiAgICBDYXJ0ZXNpYW5BeGlzVmlldy5leHRlbmQoe1xuICAgICAgICB0eXBlOiAneUF4aXMnXG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9DYXJ0ZXNpYW5BeGlzVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * DataZoom component entry\n */\n\n\n    __webpack_require__(132);\n\n    __webpack_require__(52);\n    __webpack_require__(53);\n\n    __webpack_require__(128);\n    __webpack_require__(129);\n\n    __webpack_require__(131);\n    __webpack_require__(130);\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbVNlbGVjdC5qcz8wYjcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRhWm9vbSBjb21wb25lbnQgZW50cnlcbiAqL1xuXG5cbiAgICByZXF1aXJlKCcuL2RhdGFab29tL3R5cGVEZWZhdWx0ZXInKTtcblxuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vRGF0YVpvb21Nb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vRGF0YVpvb21WaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuL2RhdGFab29tL1NlbGVjdFpvb21Nb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vU2VsZWN0Wm9vbVZpZXcnKTtcblxuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vZGF0YVpvb21Qcm9jZXNzb3InKTtcbiAgICByZXF1aXJlKCcuL2RhdGFab29tL2RhdGFab29tQWN0aW9uJyk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb21TZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Axis operator\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var numberUtil = __webpack_require__(5);\n    var helper = __webpack_require__(33);\n    var each = zrUtil.each;\n    var asc = numberUtil.asc;\n\n    /**\n     * Operate single axis.\n     * One axis can only operated by one axis operator.\n     * Different dataZoomModels may be defined to operate the same axis.\n     * (i.e. 'inside' data zoom and 'slider' data zoom components)\n     * So dataZoomModels share one axisProxy in that case.\n     *\n     * @class\n     */\n    var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._dimName = dimName;\n\n        /**\n         * @private\n         */\n        this._axisIndex = axisIndex;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._valueWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._percentWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._dataExtent;\n\n        /**\n         * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n         * @private\n         * @type {Object}\n         */\n        this._minMaxSpan;\n\n        /**\n         * @readOnly\n         * @type {module: echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @private\n         * @type {module: echarts/component/dataZoom/DataZoomModel}\n         */\n        this._dataZoomModel = dataZoomModel;\n    };\n\n    AxisProxy.prototype = {\n\n        constructor: AxisProxy,\n\n        /**\n         * Whether the axisProxy is hosted by dataZoomModel.\n         *\n         * @public\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         * @return {boolean}\n         */\n        hostedBy: function (dataZoomModel) {\n            return this._dataZoomModel === dataZoomModel;\n        },\n\n        /**\n         * @return {Array.<number>} Value can only be NaN or finite value.\n         */\n        getDataValueWindow: function () {\n            return this._valueWindow.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataPercentWindow: function () {\n            return this._percentWindow.slice();\n        },\n\n        /**\n         * @public\n         * @param {number} axisIndex\n         * @return {Array} seriesModels\n         */\n        getTargetSeriesModels: function () {\n            var seriesModels = [];\n            var ecModel = this.ecModel;\n\n            ecModel.eachSeries(function (seriesModel) {\n                if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n                    var dimName = this._dimName;\n                    var axisModel = ecModel.queryComponents({\n                        mainType: dimName + 'Axis',\n                        index: seriesModel.get(dimName + 'AxisIndex'),\n                        id: seriesModel.get(dimName + 'AxisId')\n                    })[0];\n                    if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n                        seriesModels.push(seriesModel);\n                    }\n                }\n            }, this);\n\n            return seriesModels;\n        },\n\n        getAxisModel: function () {\n            return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n        },\n\n        getOtherAxisModel: function () {\n            var axisDim = this._dimName;\n            var ecModel = this.ecModel;\n            var axisModel = this.getAxisModel();\n            var isCartesian = axisDim === 'x' || axisDim === 'y';\n            var otherAxisDim;\n            var coordSysIndexName;\n            if (isCartesian) {\n                coordSysIndexName = 'gridIndex';\n                otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n            }\n            else {\n                coordSysIndexName = 'polarIndex';\n                otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n            }\n            var foundOtherAxisModel;\n            ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n                if ((otherAxisModel.get(coordSysIndexName) || 0)\n                    === (axisModel.get(coordSysIndexName) || 0)\n                ) {\n                    foundOtherAxisModel = otherAxisModel;\n                }\n            });\n            return foundOtherAxisModel;\n        },\n\n        getMinMaxSpan: function () {\n            return zrUtil.clone(this._minMaxSpan);\n        },\n\n        /**\n         * Only calculate by given range and this._dataExtent, do not change anything.\n         *\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         */\n        calculateDataWindow: function (opt) {\n            var dataExtent = this._dataExtent;\n            var axisModel = this.getAxisModel();\n            var scale = axisModel.axis.scale;\n            var rangePropMode = this._dataZoomModel.getRangePropMode();\n            var percentExtent = [0, 100];\n            var percentWindow = [\n                opt.start,\n                opt.end\n            ];\n            var valueWindow = [];\n\n            each(['startValue', 'endValue'], function (prop) {\n                valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n            });\n\n            // Normalize bound.\n            each([0, 1], function (idx) {\n                var boundValue = valueWindow[idx];\n                var boundPercent = percentWindow[idx];\n\n                // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n                // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n                // for cases that a dataZoom component controls multiple axes with different\n                // unit or extent, and the latter one is suitable for accurate zoom by pixel\n                // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n                // but it is awkward that `percentProp` can not be obtained from `valueProp`\n                // accurately (because all of values that are overflow the `dataExtent` will\n                // be calculated to percent '100%'). So we have to use\n                // `dataZoom.getRangePropMode()` to mark which prop is used.\n                // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n                // it remains its original value.\n\n                if (rangePropMode[idx] === 'percent') {\n                    if (boundPercent == null) {\n                        boundPercent = percentExtent[idx];\n                    }\n                    // Use scale.parse to math round for category or time axis.\n                    boundValue = scale.parse(numberUtil.linearMap(\n                        boundPercent, percentExtent, dataExtent, true\n                    ));\n                }\n                else {\n                    // Calculating `percent` from `value` may be not accurate, because\n                    // This calculation can not be inversed, because all of values that\n                    // are overflow the `dataExtent` will be calculated to percent '100%'\n                    boundPercent = numberUtil.linearMap(\n                        boundValue, dataExtent, percentExtent, true\n                    );\n                }\n\n                // valueWindow[idx] = round(boundValue);\n                // percentWindow[idx] = round(boundPercent);\n                valueWindow[idx] = boundValue;\n                percentWindow[idx] = boundPercent;\n            });\n\n            return {\n                valueWindow: asc(valueWindow),\n                percentWindow: asc(percentWindow)\n            };\n        },\n\n        /**\n         * Notice: reset should not be called before series.restoreData() called,\n         * so it is recommanded to be called in \"process stage\" but not \"model init\n         * stage\".\n         *\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        reset: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            // Culculate data window and data extent, and record them.\n            this._dataExtent = calculateDataExtent(\n                this, this._dimName, this.getTargetSeriesModels()\n            );\n\n            var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n\n            this._valueWindow = dataWindow.valueWindow;\n            this._percentWindow = dataWindow.percentWindow;\n\n            setMinMaxSpan(this);\n\n            // Update axis setting then.\n            setAxisModel(this);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        restore: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            this._valueWindow = this._percentWindow = null;\n            setAxisModel(this, true);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        filterData: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            var axisDim = this._dimName;\n            var seriesModels = this.getTargetSeriesModels();\n            var filterMode = dataZoomModel.get('filterMode');\n            var valueWindow = this._valueWindow;\n\n            if (filterMode === 'none') {\n                return;\n            }\n\n            // FIXME\n            // Toolbox may has dataZoom injected. And if there are stacked bar chart\n            // with NaN data, NaN will be filtered and stack will be wrong.\n            // So we need to force the mode to be set empty.\n            // In fect, it is not a big deal that do not support filterMode-'filter'\n            // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n            // selection\" some day, which might need \"adapt to data extent on the\n            // otherAxis\", which is disabled by filterMode-'empty'.\n            var otherAxisModel = this.getOtherAxisModel();\n            if (dataZoomModel.get('$fromToolbox')\n                && otherAxisModel\n                && otherAxisModel.get('type') === 'category'\n            ) {\n                filterMode = 'empty';\n            }\n\n            // Process series data\n            each(seriesModels, function (seriesModel) {\n                var seriesData = seriesModel.getData();\n                var dataDims = seriesModel.coordDimToDataDim(axisDim);\n\n                if (filterMode === 'weakFilter') {\n                    seriesData && seriesData.filterSelf(function (dataIndex) {\n                        var leftOut;\n                        var rightOut;\n                        var hasValue;\n                        for (var i = 0; i < dataDims.length; i++) {\n                            var value = seriesData.get(dataDims[i], dataIndex);\n                            var thisHasValue = !isNaN(value);\n                            var thisLeftOut = value < valueWindow[0];\n                            var thisRightOut = value > valueWindow[1];\n                            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n                                return true;\n                            }\n                            thisHasValue && (hasValue = true);\n                            thisLeftOut && (leftOut = true);\n                            thisRightOut && (rightOut = true);\n                        }\n                        // If both left out and right out, do not filter.\n                        return hasValue && leftOut && rightOut;\n                    });\n                }\n                else {\n                    seriesData && each(dataDims, function (dim) {\n                        if (filterMode === 'empty') {\n                            seriesModel.setData(\n                                seriesData.map(dim, function (value) {\n                                    return !isInWindow(value) ? NaN : value;\n                                })\n                            );\n                        }\n                        else {\n                            seriesData.filterSelf(dim, isInWindow);\n                        }\n                    });\n                }\n            });\n\n            function isInWindow(value) {\n                return value >= valueWindow[0] && value <= valueWindow[1];\n            }\n        }\n    };\n\n    function calculateDataExtent(axisProxy, axisDim, seriesModels) {\n        var dataExtent = [Infinity, -Infinity];\n\n        each(seriesModels, function (seriesModel) {\n            var seriesData = seriesModel.getData();\n            if (seriesData) {\n                each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    var seriesExtent = seriesData.getDataExtent(dim);\n                    seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n                    seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n                });\n            }\n        });\n\n        if (dataExtent[1] < dataExtent[0]) {\n            dataExtent = [NaN, NaN];\n        }\n\n        // It is important to get \"consistent\" extent when more then one axes is\n        // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n        // when zooming. But it is difficult to know what is \"consistent\", considering\n        // axes have different type or even different meanings (For example, two\n        // time axes are used to compare data of the same date in different years).\n        // So basically dataZoom just obtains extent by series.data (in category axis\n        // extent can be obtained from axis.data).\n        // Nevertheless, user can set min/max/scale on axes to make extent of axes\n        // consistent.\n        fixExtentByAxis(axisProxy, dataExtent);\n\n        return dataExtent;\n    }\n\n    function fixExtentByAxis(axisProxy, dataExtent) {\n        var axisModel = axisProxy.getAxisModel();\n        var min = axisModel.getMin(true);\n\n        // For category axis, if min/max/scale are not set, extent is determined\n        // by axis.data by default.\n        var isCategoryAxis = axisModel.get('type') === 'category';\n        var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n        if (min != null && min !== 'dataMin') {\n            dataExtent[0] = min;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n        }\n\n        var max = axisModel.getMax(true);\n        if (max != null && max !== 'dataMax') {\n            dataExtent[1] = max;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n        }\n\n        if (!axisModel.get('scale', true)) {\n            dataExtent[0] > 0 && (dataExtent[0] = 0);\n            dataExtent[1] < 0 && (dataExtent[1] = 0);\n        }\n\n        // For value axis, if min/max/scale are not set, we just use the extent obtained\n        // by series data, which may be a little different from the extent calculated by\n        // `axisHelper.getScaleExtent`. But the different just affects the experience a\n        // little when zooming. So it will not be fixed until some users require it strongly.\n\n        return dataExtent;\n    }\n\n    function setAxisModel(axisProxy, isRestore) {\n        var axisModel = axisProxy.getAxisModel();\n\n        var percentWindow = axisProxy._percentWindow;\n        var valueWindow = axisProxy._valueWindow;\n\n        if (!percentWindow) {\n            return;\n        }\n\n        // [0, 500]: arbitrary value, guess axis extent.\n        var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n        // isRestore or isFull\n        var useOrigin = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n\n        axisModel.setRange(\n            useOrigin ? null : +valueWindow[0].toFixed(precision),\n            useOrigin ? null : +valueWindow[1].toFixed(precision)\n        );\n    }\n\n    function setMinMaxSpan(axisProxy) {\n        var minMaxSpan = axisProxy._minMaxSpan = {};\n        var dataZoomModel = axisProxy._dataZoomModel;\n\n        each(['min', 'max'], function (minMax) {\n            minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span');\n\n            // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n            var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n            if (valueSpan != null) {\n                minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n\n                valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n                if (valueSpan != null) {\n                    minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(\n                        valueSpan, axisProxy._dataExtent, [0, 100], true\n                    );\n                }\n            }\n        });\n    }\n\n    module.exports = AxisProxy;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHkuanM/MjNlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFpRDtBQUNwRSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWlEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixpREFBaUQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixpREFBaUQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUJBQXFCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSIsImZpbGUiOiIxMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEF4aXMgb3BlcmF0b3JcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBoZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0ZSBzaW5nbGUgYXhpcy5cbiAgICAgKiBPbmUgYXhpcyBjYW4gb25seSBvcGVyYXRlZCBieSBvbmUgYXhpcyBvcGVyYXRvci5cbiAgICAgKiBEaWZmZXJlbnQgZGF0YVpvb21Nb2RlbHMgbWF5IGJlIGRlZmluZWQgdG8gb3BlcmF0ZSB0aGUgc2FtZSBheGlzLlxuICAgICAqIChpLmUuICdpbnNpZGUnIGRhdGEgem9vbSBhbmQgJ3NsaWRlcicgZGF0YSB6b29tIGNvbXBvbmVudHMpXG4gICAgICogU28gZGF0YVpvb21Nb2RlbHMgc2hhcmUgb25lIGF4aXNQcm94eSBpbiB0aGF0IGNhc2UuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKi9cbiAgICB2YXIgQXhpc1Byb3h5ID0gZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGltTmFtZSA9IGRpbU5hbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9heGlzSW5kZXggPSBheGlzSW5kZXg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZhbHVlV2luZG93O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wZXJjZW50V2luZG93O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kYXRhRXh0ZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB7bWluU3BhbiwgbWF4U3BhbiwgbWluVmFsdWVTcGFuLCBtYXhWYWx1ZVNwYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9taW5NYXhTcGFuO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge21vZHVsZTogZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG4gICAgfTtcblxuICAgIEF4aXNQcm94eS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEF4aXNQcm94eSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYXhpc1Byb3h5IGlzIGhvc3RlZCBieSBkYXRhWm9vbU1vZGVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBob3N0ZWRCeTogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhWm9vbU1vZGVsID09PSBkYXRhWm9vbU1vZGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVmFsdWUgY2FuIG9ubHkgYmUgTmFOIG9yIGZpbml0ZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldERhdGFWYWx1ZVdpbmRvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlV2luZG93LnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0YVBlcmNlbnRXaW5kb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZXJjZW50V2luZG93LnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gc2VyaWVzTW9kZWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUYXJnZXRTZXJpZXNNb2RlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuXG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlbHBlci5pc0Nvb3JkU3VwcG9ydGVkKHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltTmFtZSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogZGltTmFtZSArICdBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSWQnKVxuICAgICAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F4aXNJbmRleCA9PT0gKGF4aXNNb2RlbCAmJiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbHMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlcmllc01vZGVscztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KHRoaXMuX2RpbU5hbWUgKyAnQXhpcycsIHRoaXMuX2F4aXNJbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0T3RoZXJBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzRGltID0gdGhpcy5fZGltTmFtZTtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7XG4gICAgICAgICAgICB2YXIgaXNDYXJ0ZXNpYW4gPSBheGlzRGltID09PSAneCcgfHwgYXhpc0RpbSA9PT0gJ3knO1xuICAgICAgICAgICAgdmFyIG90aGVyQXhpc0RpbTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5c0luZGV4TmFtZTtcbiAgICAgICAgICAgIGlmIChpc0NhcnRlc2lhbikge1xuICAgICAgICAgICAgICAgIGNvb3JkU3lzSW5kZXhOYW1lID0gJ2dyaWRJbmRleCc7XG4gICAgICAgICAgICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29vcmRTeXNJbmRleE5hbWUgPSAncG9sYXJJbmRleCc7XG4gICAgICAgICAgICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ2FuZ2xlJyA/ICdyYWRpdXMnIDogJ2FuZ2xlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3VuZE90aGVyQXhpc01vZGVsO1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KG90aGVyQXhpc0RpbSArICdBeGlzJywgZnVuY3Rpb24gKG90aGVyQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvdGhlckF4aXNNb2RlbC5nZXQoY29vcmRTeXNJbmRleE5hbWUpIHx8IDApXG4gICAgICAgICAgICAgICAgICAgID09PSAoYXhpc01vZGVsLmdldChjb29yZFN5c0luZGV4TmFtZSkgfHwgMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRPdGhlckF4aXNNb2RlbCA9IG90aGVyQXhpc01vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kT3RoZXJBeGlzTW9kZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWluTWF4U3BhbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5jbG9uZSh0aGlzLl9taW5NYXhTcGFuKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBjYWxjdWxhdGUgYnkgZ2l2ZW4gcmFuZ2UgYW5kIHRoaXMuX2RhdGFFeHRlbnQsIGRvIG5vdCBjaGFuZ2UgYW55dGhpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kVmFsdWVdXG4gICAgICAgICAqL1xuICAgICAgICBjYWxjdWxhdGVEYXRhV2luZG93OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuX2RhdGFFeHRlbnQ7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGF4aXNNb2RlbC5heGlzLnNjYWxlO1xuICAgICAgICAgICAgdmFyIHJhbmdlUHJvcE1vZGUgPSB0aGlzLl9kYXRhWm9vbU1vZGVsLmdldFJhbmdlUHJvcE1vZGUoKTtcbiAgICAgICAgICAgIHZhciBwZXJjZW50RXh0ZW50ID0gWzAsIDEwMF07XG4gICAgICAgICAgICB2YXIgcGVyY2VudFdpbmRvdyA9IFtcbiAgICAgICAgICAgICAgICBvcHQuc3RhcnQsXG4gICAgICAgICAgICAgICAgb3B0LmVuZFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZVdpbmRvdyA9IFtdO1xuXG4gICAgICAgICAgICBlYWNoKFsnc3RhcnRWYWx1ZScsICdlbmRWYWx1ZSddLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhbHVlV2luZG93LnB1c2gob3B0W3Byb3BdICE9IG51bGwgPyBzY2FsZS5wYXJzZShvcHRbcHJvcF0pIDogbnVsbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGJvdW5kLlxuICAgICAgICAgICAgZWFjaChbMCwgMV0sIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRWYWx1ZSA9IHZhbHVlV2luZG93W2lkeF07XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kUGVyY2VudCA9IHBlcmNlbnRXaW5kb3dbaWR4XTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdGljZTogZGF0YVpvb20gaXMgYmFzZWQgZWl0aGVyIG9uIGBwZXJjZW50UHJvcGAgKCdzdGFydCcsICdlbmQnKSBvclxuICAgICAgICAgICAgICAgIC8vIG9uIGB2YWx1ZVByb3BgICgnc3RhcnRWYWx1ZScsICdlbmRWYWx1ZScpLiBUaGUgZm9ybWVyIG9uZSBpcyBzdWl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIGZvciBjYXNlcyB0aGF0IGEgZGF0YVpvb20gY29tcG9uZW50IGNvbnRyb2xzIG11bHRpcGxlIGF4ZXMgd2l0aCBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAvLyB1bml0IG9yIGV4dGVudCwgYW5kIHRoZSBsYXR0ZXIgb25lIGlzIHN1aXRhYmxlIGZvciBhY2N1cmF0ZSB6b29tIGJ5IHBpeGVsXG4gICAgICAgICAgICAgICAgLy8gKGUuZy4sIGluIGRhdGFab29tU2VsZWN0KS4gYHZhbHVlUHJvcGAgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSBgcGVyY2VudFByb3BgLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCBpcyBhd2t3YXJkIHRoYXQgYHBlcmNlbnRQcm9wYCBjYW4gbm90IGJlIG9idGFpbmVkIGZyb20gYHZhbHVlUHJvcGBcbiAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5IChiZWNhdXNlIGFsbCBvZiB2YWx1ZXMgdGhhdCBhcmUgb3ZlcmZsb3cgdGhlIGBkYXRhRXh0ZW50YCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJykuIFNvIHdlIGhhdmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgLy8gYGRhdGFab29tLmdldFJhbmdlUHJvcE1vZGUoKWAgdG8gbWFyayB3aGljaCBwcm9wIGlzIHVzZWQuXG4gICAgICAgICAgICAgICAgLy8gYHJhbmdlUHJvcE1vZGVgIGlzIHVwZGF0ZWQgb25seSB3aGVuIHNldE9wdGlvbiBvciBkaXNwYXRjaEFjdGlvbiwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgLy8gaXQgcmVtYWlucyBpdHMgb3JpZ2luYWwgdmFsdWUuXG5cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQcm9wTW9kZVtpZHhdID09PSAncGVyY2VudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kUGVyY2VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBlcmNlbnQgPSBwZXJjZW50RXh0ZW50W2lkeF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHNjYWxlLnBhcnNlIHRvIG1hdGggcm91bmQgZm9yIGNhdGVnb3J5IG9yIHRpbWUgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgYm91bmRWYWx1ZSA9IHNjYWxlLnBhcnNlKG51bWJlclV0aWwubGluZWFyTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQZXJjZW50LCBwZXJjZW50RXh0ZW50LCBkYXRhRXh0ZW50LCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRpbmcgYHBlcmNlbnRgIGZyb20gYHZhbHVlYCBtYXkgYmUgbm90IGFjY3VyYXRlLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FsY3VsYXRpb24gY2FuIG5vdCBiZSBpbnZlcnNlZCwgYmVjYXVzZSBhbGwgb2YgdmFsdWVzIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIG92ZXJmbG93IHRoZSBgZGF0YUV4dGVudGAgd2lsbCBiZSBjYWxjdWxhdGVkIHRvIHBlcmNlbnQgJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUGVyY2VudCA9IG51bWJlclV0aWwubGluZWFyTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRWYWx1ZSwgZGF0YUV4dGVudCwgcGVyY2VudEV4dGVudCwgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlV2luZG93W2lkeF0gPSByb3VuZChib3VuZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBwZXJjZW50V2luZG93W2lkeF0gPSByb3VuZChib3VuZFBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIHZhbHVlV2luZG93W2lkeF0gPSBib3VuZFZhbHVlO1xuICAgICAgICAgICAgICAgIHBlcmNlbnRXaW5kb3dbaWR4XSA9IGJvdW5kUGVyY2VudDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlV2luZG93OiBhc2ModmFsdWVXaW5kb3cpLFxuICAgICAgICAgICAgICAgIHBlcmNlbnRXaW5kb3c6IGFzYyhwZXJjZW50V2luZG93KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm90aWNlOiByZXNldCBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgc2VyaWVzLnJlc3RvcmVEYXRhKCkgY2FsbGVkLFxuICAgICAgICAgKiBzbyBpdCBpcyByZWNvbW1hbmRlZCB0byBiZSBjYWxsZWQgaW4gXCJwcm9jZXNzIHN0YWdlXCIgYnV0IG5vdCBcIm1vZGVsIGluaXRcbiAgICAgICAgICogc3RhZ2VcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEN1bGN1bGF0ZSBkYXRhIHdpbmRvdyBhbmQgZGF0YSBleHRlbnQsIGFuZCByZWNvcmQgdGhlbS5cbiAgICAgICAgICAgIHRoaXMuX2RhdGFFeHRlbnQgPSBjYWxjdWxhdGVEYXRhRXh0ZW50KFxuICAgICAgICAgICAgICAgIHRoaXMsIHRoaXMuX2RpbU5hbWUsIHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhV2luZG93ID0gdGhpcy5jYWxjdWxhdGVEYXRhV2luZG93KGRhdGFab29tTW9kZWwub3B0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5fdmFsdWVXaW5kb3cgPSBkYXRhV2luZG93LnZhbHVlV2luZG93O1xuICAgICAgICAgICAgdGhpcy5fcGVyY2VudFdpbmRvdyA9IGRhdGFXaW5kb3cucGVyY2VudFdpbmRvdztcblxuICAgICAgICAgICAgc2V0TWluTWF4U3Bhbih0aGlzKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGF4aXMgc2V0dGluZyB0aGVuLlxuICAgICAgICAgICAgc2V0QXhpc01vZGVsKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVdpbmRvdyA9IHRoaXMuX3BlcmNlbnRXaW5kb3cgPSBudWxsO1xuICAgICAgICAgICAgc2V0QXhpc01vZGVsKHRoaXMsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyRGF0YTogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhpc0RpbSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgICAgICAgICB2YXIgc2VyaWVzTW9kZWxzID0gdGhpcy5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJNb2RlID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2ZpbHRlck1vZGUnKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZVdpbmRvdyA9IHRoaXMuX3ZhbHVlV2luZG93O1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gVG9vbGJveCBtYXkgaGFzIGRhdGFab29tIGluamVjdGVkLiBBbmQgaWYgdGhlcmUgYXJlIHN0YWNrZWQgYmFyIGNoYXJ0XG4gICAgICAgICAgICAvLyB3aXRoIE5hTiBkYXRhLCBOYU4gd2lsbCBiZSBmaWx0ZXJlZCBhbmQgc3RhY2sgd2lsbCBiZSB3cm9uZy5cbiAgICAgICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gZm9yY2UgdGhlIG1vZGUgdG8gYmUgc2V0IGVtcHR5LlxuICAgICAgICAgICAgLy8gSW4gZmVjdCwgaXQgaXMgbm90IGEgYmlnIGRlYWwgdGhhdCBkbyBub3Qgc3VwcG9ydCBmaWx0ZXJNb2RlLSdmaWx0ZXInXG4gICAgICAgICAgICAvLyB3aGVuIHVzaW5nIHRvb2xib3gjZGF0YVpvb20sIHV0aWxsIHRvb2x0aXAjZGF0YVpvb20gc3VwcG9ydCBcInNpbmdsZSBheGlzXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb25cIiBzb21lIGRheSwgd2hpY2ggbWlnaHQgbmVlZCBcImFkYXB0IHRvIGRhdGEgZXh0ZW50IG9uIHRoZVxuICAgICAgICAgICAgLy8gb3RoZXJBeGlzXCIsIHdoaWNoIGlzIGRpc2FibGVkIGJ5IGZpbHRlck1vZGUtJ2VtcHR5Jy5cbiAgICAgICAgICAgIHZhciBvdGhlckF4aXNNb2RlbCA9IHRoaXMuZ2V0T3RoZXJBeGlzTW9kZWwoKTtcbiAgICAgICAgICAgIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnJGZyb21Ub29sYm94JylcbiAgICAgICAgICAgICAgICAmJiBvdGhlckF4aXNNb2RlbFxuICAgICAgICAgICAgICAgICYmIG90aGVyQXhpc01vZGVsLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJNb2RlID0gJ2VtcHR5JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBzZXJpZXMgZGF0YVxuICAgICAgICAgICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhRGltcyA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGF4aXNEaW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlck1vZGUgPT09ICd3ZWFrRmlsdGVyJykge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhICYmIHNlcmllc0RhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdE91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodE91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YURpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzZXJpZXNEYXRhLmdldChkYXRhRGltc1tpXSwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0hhc1ZhbHVlID0gIWlzTmFOKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0xlZnRPdXQgPSB2YWx1ZSA8IHZhbHVlV2luZG93WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzUmlnaHRPdXQgPSB2YWx1ZSA+IHZhbHVlV2luZG93WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzSGFzVmFsdWUgJiYgIXRoaXNMZWZ0T3V0ICYmICF0aGlzUmlnaHRPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNIYXNWYWx1ZSAmJiAoaGFzVmFsdWUgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzTGVmdE91dCAmJiAobGVmdE91dCA9IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSaWdodE91dCAmJiAocmlnaHRPdXQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGJvdGggbGVmdCBvdXQgYW5kIHJpZ2h0IG91dCwgZG8gbm90IGZpbHRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNWYWx1ZSAmJiBsZWZ0T3V0ICYmIHJpZ2h0T3V0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0RhdGEgJiYgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlck1vZGUgPT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5zZXREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLm1hcChkaW0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc0luV2luZG93KHZhbHVlKSA/IE5hTiA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLmZpbHRlclNlbGYoZGltLCBpc0luV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gdmFsdWVXaW5kb3dbMF0gJiYgdmFsdWUgPD0gdmFsdWVXaW5kb3dbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlRGF0YUV4dGVudChheGlzUHJveHksIGF4aXNEaW0sIHNlcmllc01vZGVscykge1xuICAgICAgICB2YXIgZGF0YUV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcblxuICAgICAgICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIGlmIChzZXJpZXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzRGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRXh0ZW50ID0gc2VyaWVzRGF0YS5nZXREYXRhRXh0ZW50KGRpbSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0V4dGVudFswXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFFeHRlbnRbMF0gPSBzZXJpZXNFeHRlbnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNFeHRlbnRbMV0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gc2VyaWVzRXh0ZW50WzFdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRhdGFFeHRlbnRbMV0gPCBkYXRhRXh0ZW50WzBdKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50ID0gW05hTiwgTmFOXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBnZXQgXCJjb25zaXN0ZW50XCIgZXh0ZW50IHdoZW4gbW9yZSB0aGVuIG9uZSBheGVzIGlzXG4gICAgICAgIC8vIGNvbnRyb2xsZWQgYnkgYSBgZGF0YVpvb21gLCBvdGhlcndpc2UgdGhvc2UgYXhlcyB3aWxsIG5vdCBiZSBzeW5jaHJvbml6ZWRcbiAgICAgICAgLy8gd2hlbiB6b29taW5nLiBCdXQgaXQgaXMgZGlmZmljdWx0IHRvIGtub3cgd2hhdCBpcyBcImNvbnNpc3RlbnRcIiwgY29uc2lkZXJpbmdcbiAgICAgICAgLy8gYXhlcyBoYXZlIGRpZmZlcmVudCB0eXBlIG9yIGV2ZW4gZGlmZmVyZW50IG1lYW5pbmdzIChGb3IgZXhhbXBsZSwgdHdvXG4gICAgICAgIC8vIHRpbWUgYXhlcyBhcmUgdXNlZCB0byBjb21wYXJlIGRhdGEgb2YgdGhlIHNhbWUgZGF0ZSBpbiBkaWZmZXJlbnQgeWVhcnMpLlxuICAgICAgICAvLyBTbyBiYXNpY2FsbHkgZGF0YVpvb20ganVzdCBvYnRhaW5zIGV4dGVudCBieSBzZXJpZXMuZGF0YSAoaW4gY2F0ZWdvcnkgYXhpc1xuICAgICAgICAvLyBleHRlbnQgY2FuIGJlIG9idGFpbmVkIGZyb20gYXhpcy5kYXRhKS5cbiAgICAgICAgLy8gTmV2ZXJ0aGVsZXNzLCB1c2VyIGNhbiBzZXQgbWluL21heC9zY2FsZSBvbiBheGVzIHRvIG1ha2UgZXh0ZW50IG9mIGF4ZXNcbiAgICAgICAgLy8gY29uc2lzdGVudC5cbiAgICAgICAgZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGFFeHRlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCkge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICAgICAgICB2YXIgbWluID0gYXhpc01vZGVsLmdldE1pbih0cnVlKTtcblxuICAgICAgICAvLyBGb3IgY2F0ZWdvcnkgYXhpcywgaWYgbWluL21heC9zY2FsZSBhcmUgbm90IHNldCwgZXh0ZW50IGlzIGRldGVybWluZWRcbiAgICAgICAgLy8gYnkgYXhpcy5kYXRhIGJ5IGRlZmF1bHQuXG4gICAgICAgIHZhciBpc0NhdGVnb3J5QXhpcyA9IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgICAgdmFyIGF4aXNEYXRhTGVuID0gaXNDYXRlZ29yeUF4aXMgJiYgKGF4aXNNb2RlbC5nZXQoJ2RhdGEnKSB8fCBbXSkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChtaW4gIT0gbnVsbCAmJiBtaW4gIT09ICdkYXRhTWluJykge1xuICAgICAgICAgICAgZGF0YUV4dGVudFswXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NhdGVnb3J5QXhpcykge1xuICAgICAgICAgICAgZGF0YUV4dGVudFswXSA9IGF4aXNEYXRhTGVuID4gMCA/IDAgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4ID0gYXhpc01vZGVsLmdldE1heCh0cnVlKTtcbiAgICAgICAgaWYgKG1heCAhPSBudWxsICYmIG1heCAhPT0gJ2RhdGFNYXgnKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50WzFdID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50WzFdID0gYXhpc0RhdGFMZW4gPiAwID8gYXhpc0RhdGFMZW4gLSAxIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdzY2FsZScsIHRydWUpKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50WzBdID4gMCAmJiAoZGF0YUV4dGVudFswXSA9IDApO1xuICAgICAgICAgICAgZGF0YUV4dGVudFsxXSA8IDAgJiYgKGRhdGFFeHRlbnRbMV0gPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciB2YWx1ZSBheGlzLCBpZiBtaW4vbWF4L3NjYWxlIGFyZSBub3Qgc2V0LCB3ZSBqdXN0IHVzZSB0aGUgZXh0ZW50IG9idGFpbmVkXG4gICAgICAgIC8vIGJ5IHNlcmllcyBkYXRhLCB3aGljaCBtYXkgYmUgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIGV4dGVudCBjYWxjdWxhdGVkIGJ5XG4gICAgICAgIC8vIGBheGlzSGVscGVyLmdldFNjYWxlRXh0ZW50YC4gQnV0IHRoZSBkaWZmZXJlbnQganVzdCBhZmZlY3RzIHRoZSBleHBlcmllbmNlIGFcbiAgICAgICAgLy8gbGl0dGxlIHdoZW4gem9vbWluZy4gU28gaXQgd2lsbCBub3QgYmUgZml4ZWQgdW50aWwgc29tZSB1c2VycyByZXF1aXJlIGl0IHN0cm9uZ2x5LlxuXG4gICAgICAgIHJldHVybiBkYXRhRXh0ZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEF4aXNNb2RlbChheGlzUHJveHksIGlzUmVzdG9yZSkge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuXG4gICAgICAgIHZhciBwZXJjZW50V2luZG93ID0gYXhpc1Byb3h5Ll9wZXJjZW50V2luZG93O1xuICAgICAgICB2YXIgdmFsdWVXaW5kb3cgPSBheGlzUHJveHkuX3ZhbHVlV2luZG93O1xuXG4gICAgICAgIGlmICghcGVyY2VudFdpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWzAsIDUwMF06IGFyYml0cmFyeSB2YWx1ZSwgZ3Vlc3MgYXhpcyBleHRlbnQuXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKHZhbHVlV2luZG93LCBbMCwgNTAwXSk7XG4gICAgICAgIC8vIGlzUmVzdG9yZSBvciBpc0Z1bGxcbiAgICAgICAgdmFyIHVzZU9yaWdpbiA9IGlzUmVzdG9yZSB8fCAocGVyY2VudFdpbmRvd1swXSA9PT0gMCAmJiBwZXJjZW50V2luZG93WzFdID09PSAxMDApO1xuXG4gICAgICAgIGF4aXNNb2RlbC5zZXRSYW5nZShcbiAgICAgICAgICAgIHVzZU9yaWdpbiA/IG51bGwgOiArdmFsdWVXaW5kb3dbMF0udG9GaXhlZChwcmVjaXNpb24pLFxuICAgICAgICAgICAgdXNlT3JpZ2luID8gbnVsbCA6ICt2YWx1ZVdpbmRvd1sxXS50b0ZpeGVkKHByZWNpc2lvbilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRNaW5NYXhTcGFuKGF4aXNQcm94eSkge1xuICAgICAgICB2YXIgbWluTWF4U3BhbiA9IGF4aXNQcm94eS5fbWluTWF4U3BhbiA9IHt9O1xuICAgICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGF4aXNQcm94eS5fZGF0YVpvb21Nb2RlbDtcblxuICAgICAgICBlYWNoKFsnbWluJywgJ21heCddLCBmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgICAgICAgICBtaW5NYXhTcGFuW21pbk1heCArICdTcGFuJ10gPSBkYXRhWm9vbU1vZGVsLmdldChtaW5NYXggKyAnU3BhbicpO1xuXG4gICAgICAgICAgICAvLyBtaW5WYWx1ZVNwYW4gYW5kIG1heFZhbHVlU3BhbiBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gbWluU3BhbiBhbmQgbWF4U3BhblxuICAgICAgICAgICAgdmFyIHZhbHVlU3BhbiA9IGRhdGFab29tTW9kZWwuZ2V0KG1pbk1heCArICdWYWx1ZVNwYW4nKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVNwYW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1ZhbHVlU3BhbiddID0gdmFsdWVTcGFuO1xuXG4gICAgICAgICAgICAgICAgdmFsdWVTcGFuID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXMuc2NhbGUucGFyc2UodmFsdWVTcGFuKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVTcGFuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluTWF4U3BhblttaW5NYXggKyAnU3BhbiddID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwYW4sIGF4aXNQcm94eS5fZGF0YUV4dGVudCwgWzAsIDEwMF0sIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gQXhpc1Byb3h5O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0F4aXNQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom model\n */\n\n\n    var DataZoomModel = __webpack_require__(52);\n\n    module.exports = DataZoomModel.extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWwuanM/M2ZjOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLEtBQUsiLCJmaWxlIjoiMTI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBEYXRhIHpvb20gbW9kZWxcbiAqL1xuXG5cbiAgICB2YXIgRGF0YVpvb21Nb2RlbCA9IHJlcXVpcmUoJy4vRGF0YVpvb21Nb2RlbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhWm9vbU1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2RhdGFab29tLnNlbGVjdCdcblxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NlbGVjdFpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(53).extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tVmlldy5qcz9hY2E2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSyIsImZpbGUiOiIxMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9EYXRhWm9vbVZpZXcnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdkYXRhWm9vbS5zZWxlY3QnXG5cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom action\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var helper = __webpack_require__(33);\n    var echarts = __webpack_require__(1);\n\n\n    echarts.registerAction('dataZoom', function (payload, ecModel) {\n\n        var linkedNodesFinder = helper.createLinkedNodesFinder(\n            zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n            helper.eachAxisDim,\n            function (model, dimNames) {\n                return model.get(dimNames.axisIndex);\n            }\n        );\n\n        var effectedModels = [];\n\n        ecModel.eachComponent(\n            {mainType: 'dataZoom', query: payload},\n            function (model, index) {\n                effectedModels.push.apply(\n                    effectedModels, linkedNodesFinder(model).nodes\n                );\n            }\n        );\n\n        zrUtil.each(effectedModels, function (dataZoomModel, index) {\n            dataZoomModel.setRawRange({\n                start: payload.start,\n                end: payload.end,\n                startValue: payload.startValue,\n                endValue: payload.endValue\n            });\n        });\n\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbi5qcz9lNWU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVCxLQUFLIiwiZmlsZSI6IjEzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgRGF0YSB6b29tIGFjdGlvblxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcblxuXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignZGF0YVpvb20nLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuXG4gICAgICAgIHZhciBsaW5rZWROb2Rlc0ZpbmRlciA9IGhlbHBlci5jcmVhdGVMaW5rZWROb2Rlc0ZpbmRlcihcbiAgICAgICAgICAgIHpyVXRpbC5iaW5kKGVjTW9kZWwuZWFjaENvbXBvbmVudCwgZWNNb2RlbCwgJ2RhdGFab29tJyksXG4gICAgICAgICAgICBoZWxwZXIuZWFjaEF4aXNEaW0sXG4gICAgICAgICAgICBmdW5jdGlvbiAobW9kZWwsIGRpbU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBlZmZlY3RlZE1vZGVscyA9IFtdO1xuXG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudChcbiAgICAgICAgICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHBheWxvYWR9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGVmZmVjdGVkTW9kZWxzLnB1c2guYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdGVkTW9kZWxzLCBsaW5rZWROb2Rlc0ZpbmRlcihtb2RlbCkubm9kZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKGVmZmVjdGVkTW9kZWxzLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXlsb2FkLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogcGF5bG9hZC5lbmQsXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogcGF5bG9hZC5zdGFydFZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZFZhbHVlOiBwYXlsb2FkLmVuZFZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom processor\n */\n\n\n    var echarts = __webpack_require__(1);\n\n    echarts.registerProcessor(function (ecModel, api) {\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // We calculate window and reset axis here but not in model\n            // init stage and not after action dispatch handler, because\n            // reset should be called after seriesData.restoreData.\n            dataZoomModel.eachTargetAxis(resetSingleAxis);\n\n            // Caution: data zoom filtering is order sensitive when using\n            // percent range and no min/max/scale set on axis.\n            // For example, we have dataZoom definition:\n            // [\n            //      {xAxisIndex: 0, start: 30, end: 70},\n            //      {yAxisIndex: 0, start: 20, end: 80}\n            // ]\n            // In this case, [20, 80] of y-dataZoom should be based on data\n            // that have filtered by x-dataZoom using range of [30, 70],\n            // but should not be based on full raw data. Thus sliding\n            // x-dataZoom will change both ranges of xAxis and yAxis,\n            // while sliding y-dataZoom will only change the range of yAxis.\n            // So we should filter x-axis after reset x-axis immediately,\n            // and then reset y-axis and filter y-axis.\n            dataZoomModel.eachTargetAxis(filterSingleAxis);\n        });\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // Fullfill all of the range props so that user\n            // is able to get them from chart.getOption().\n            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n            var percentRange = axisProxy.getDataPercentWindow();\n            var valueRange = axisProxy.getDataValueWindow();\n\n            dataZoomModel.setRawRange({\n                start: percentRange[0],\n                end: percentRange[1],\n                startValue: valueRange[0],\n                endValue: valueRange[1]\n            }, true);\n        });\n    });\n\n    function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n    }\n\n    function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n    }\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qcz9kODFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQ0FBa0M7QUFDdkQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIERhdGEgem9vbSBwcm9jZXNzb3JcbiAqL1xuXG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IoZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuXG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgLy8gV2UgY2FsY3VsYXRlIHdpbmRvdyBhbmQgcmVzZXQgYXhpcyBoZXJlIGJ1dCBub3QgaW4gbW9kZWxcbiAgICAgICAgICAgIC8vIGluaXQgc3RhZ2UgYW5kIG5vdCBhZnRlciBhY3Rpb24gZGlzcGF0Y2ggaGFuZGxlciwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gcmVzZXQgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBzZXJpZXNEYXRhLnJlc3RvcmVEYXRhLlxuICAgICAgICAgICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhyZXNldFNpbmdsZUF4aXMpO1xuXG4gICAgICAgICAgICAvLyBDYXV0aW9uOiBkYXRhIHpvb20gZmlsdGVyaW5nIGlzIG9yZGVyIHNlbnNpdGl2ZSB3aGVuIHVzaW5nXG4gICAgICAgICAgICAvLyBwZXJjZW50IHJhbmdlIGFuZCBubyBtaW4vbWF4L3NjYWxlIHNldCBvbiBheGlzLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHdlIGhhdmUgZGF0YVpvb20gZGVmaW5pdGlvbjpcbiAgICAgICAgICAgIC8vIFtcbiAgICAgICAgICAgIC8vICAgICAge3hBeGlzSW5kZXg6IDAsIHN0YXJ0OiAzMCwgZW5kOiA3MH0sXG4gICAgICAgICAgICAvLyAgICAgIHt5QXhpc0luZGV4OiAwLCBzdGFydDogMjAsIGVuZDogODB9XG4gICAgICAgICAgICAvLyBdXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIFsyMCwgODBdIG9mIHktZGF0YVpvb20gc2hvdWxkIGJlIGJhc2VkIG9uIGRhdGFcbiAgICAgICAgICAgIC8vIHRoYXQgaGF2ZSBmaWx0ZXJlZCBieSB4LWRhdGFab29tIHVzaW5nIHJhbmdlIG9mIFszMCwgNzBdLFxuICAgICAgICAgICAgLy8gYnV0IHNob3VsZCBub3QgYmUgYmFzZWQgb24gZnVsbCByYXcgZGF0YS4gVGh1cyBzbGlkaW5nXG4gICAgICAgICAgICAvLyB4LWRhdGFab29tIHdpbGwgY2hhbmdlIGJvdGggcmFuZ2VzIG9mIHhBeGlzIGFuZCB5QXhpcyxcbiAgICAgICAgICAgIC8vIHdoaWxlIHNsaWRpbmcgeS1kYXRhWm9vbSB3aWxsIG9ubHkgY2hhbmdlIHRoZSByYW5nZSBvZiB5QXhpcy5cbiAgICAgICAgICAgIC8vIFNvIHdlIHNob3VsZCBmaWx0ZXIgeC1heGlzIGFmdGVyIHJlc2V0IHgtYXhpcyBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgIC8vIGFuZCB0aGVuIHJlc2V0IHktYXhpcyBhbmQgZmlsdGVyIHktYXhpcy5cbiAgICAgICAgICAgIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMoZmlsdGVyU2luZ2xlQXhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgLy8gRnVsbGZpbGwgYWxsIG9mIHRoZSByYW5nZSBwcm9wcyBzbyB0aGF0IHVzZXJcbiAgICAgICAgICAgIC8vIGlzIGFibGUgdG8gZ2V0IHRoZW0gZnJvbSBjaGFydC5nZXRPcHRpb24oKS5cbiAgICAgICAgICAgIHZhciBheGlzUHJveHkgPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnRSYW5nZSA9IGF4aXNQcm94eS5nZXREYXRhUGVyY2VudFdpbmRvdygpO1xuICAgICAgICAgICAgdmFyIHZhbHVlUmFuZ2UgPSBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG5cbiAgICAgICAgICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBwZXJjZW50UmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgZW5kOiBwZXJjZW50UmFuZ2VbMV0sXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdmFsdWVSYW5nZVswXSxcbiAgICAgICAgICAgICAgICBlbmRWYWx1ZTogdmFsdWVSYW5nZVsxXVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRTaW5nbGVBeGlzKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoZGltTmFtZXMubmFtZSwgYXhpc0luZGV4KS5yZXNldChkYXRhWm9vbU1vZGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJTaW5nbGVBeGlzKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoZGltTmFtZXMubmFtZSwgYXhpc0luZGV4KS5maWx0ZXJEYXRhKGRhdGFab29tTW9kZWwpO1xuICAgIH1cblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(13).registerSubTypeDefaulter('dataZoom', function (option) {\n        // Default 'slider' when no type specified.\n        return 'slider';\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS90eXBlRGVmYXVsdGVyLmpzPzQyMjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjEzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgcmVxdWlyZSgnLi4vLi4vbW9kZWwvQ29tcG9uZW50JykucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyKCdkYXRhWm9vbScsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy8gRGVmYXVsdCAnc2xpZGVyJyB3aGVuIG5vIHR5cGUgc3BlY2lmaWVkLlxuICAgICAgICByZXR1cm4gJ3NsaWRlcic7XG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vdHlwZURlZmF1bHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Box selection tool.\n *\n * @module echarts/component/helper/BrushController\n */\n\n\n\n    var Eventful = __webpack_require__(21);\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var interactionMutex = __webpack_require__(137);\n    var DataDiffer = __webpack_require__(34);\n\n    var curry = zrUtil.curry;\n    var each = zrUtil.each;\n    var map = zrUtil.map;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathPow = Math.pow;\n\n    var COVER_Z = 10000;\n    var UNSELECT_THRESHOLD = 6;\n    var MIN_RESIZE_LINE_WIDTH = 6;\n    var MUTEX_RESOURCE_KEY = 'globalPan';\n\n    var DIRECTION_MAP = {\n        w: [0, 0],\n        e: [0, 1],\n        n: [1, 0],\n        s: [1, 1]\n    };\n    var CURSOR_MAP = {\n        w: 'ew',\n        e: 'ew',\n        n: 'ns',\n        s: 'ns',\n        ne: 'nesw',\n        sw: 'nesw',\n        nw: 'nwse',\n        se: 'nwse'\n    };\n    var DEFAULT_BRUSH_OPT = {\n        brushStyle: {\n            lineWidth: 2,\n            stroke: 'rgba(0,0,0,0.3)',\n            fill: 'rgba(0,0,0,0.1)'\n        },\n        transformable: true,\n        brushMode: 'single',\n        removeOnClick: false\n    };\n\n    var baseUID = 0;\n\n    /**\n     * @alias module:echarts/component/helper/BrushController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     * @event module:echarts/component/helper/BrushController#brush\n     *        params:\n     *            areas: Array.<Array>, coord relates to container group,\n     *                                    If no container specified, to global.\n     *            opt {\n     *                isEnd: boolean,\n     *                removeOnClick: boolean\n     *            }\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     */\n    function BrushController(zr) {\n\n        if (__DEV__) {\n            zrUtil.assert(zr);\n        }\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:zrender/zrender~ZRender}\n         * @private\n         */\n        this._zr = zr;\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *     'line', 'rect', 'polygon' or false\n         *     If passing false/null/undefined, disable brush.\n         *     If passing 'auto', determined by panel.defaultBrushType\n         * @private\n         * @type {string}\n         */\n        this._brushType;\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *\n         * @private\n         * @type {Object}\n         */\n        this._brushOption;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._panels;\n\n        /**\n         * @private\n         * @type {Array.<nubmer>}\n         */\n        this._track = [];\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._dragging;\n\n        /**\n         * @private\n         * @type {Array}\n         */\n        this._covers = [];\n\n        /**\n         * @private\n         * @type {moudule:zrender/container/Group}\n         */\n        this._creatingCover;\n\n        /**\n         * `true` means global panel\n         * @private\n         * @type {module:zrender/container/Group|boolean}\n         */\n        this._creatingPanel;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._enableGlobalPan;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        if (__DEV__) {\n            this._mounted;\n        }\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._uid = 'brushController_' + baseUID++;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._handlers = {};\n        each(mouseHandlers, function (handler, eventName) {\n            this._handlers[eventName] = zrUtil.bind(handler, this);\n        }, this);\n    }\n\n    BrushController.prototype = {\n\n        constructor: BrushController,\n\n        /**\n         * If set to null/undefined/false, select disabled.\n         * @param {Object} brushOption\n         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n         *                          If passing false/null/undefined, disable brush.\n         *                          If passing 'auto', determined by panel.defaultBrushType.\n         *                              ('auto' can not be used in global panel)\n         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n         * @param {boolean} [brushOption.transformable=true]\n         * @param {boolean} [brushOption.removeOnClick=false]\n         * @param {Object} [brushOption.brushStyle]\n         * @param {number} [brushOption.brushStyle.width]\n         * @param {number} [brushOption.brushStyle.lineWidth]\n         * @param {string} [brushOption.brushStyle.stroke]\n         * @param {string} [brushOption.brushStyle.fill]\n         * @param {number} [brushOption.z]\n         */\n        enableBrush: function (brushOption) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            this._brushType && doDisableBrush(this);\n            brushOption.brushType && doEnableBrush(this, brushOption);\n\n            return this;\n        },\n\n        /**\n         * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n         *        Each items: {\n         *            panelId, // mandatory.\n         *            clipPath, // mandatory. function.\n         *            isTargetByCursor, // mandatory. function.\n         *            defaultBrushType, // optional, only used when brushType is 'auto'.\n         *            getLinearBrushOtherExtent, // optional. function.\n         *        }\n         */\n        setPanels: function (panelOpts) {\n            if (panelOpts && panelOpts.length) {\n                var panels = this._panels = {};\n                zrUtil.each(panelOpts, function (panelOpts) {\n                    panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n                });\n            }\n            else {\n                this._panels = null;\n            }\n            return this;\n        },\n\n        /**\n         * @param {Object} [opt]\n         * @return {boolean} [opt.enableGlobalPan=false]\n         */\n        mount: function (opt) {\n            opt = opt || {};\n\n            if (__DEV__) {\n                this._mounted = true; // should be at first.\n            }\n\n            this._enableGlobalPan = opt.enableGlobalPan;\n\n            var thisGroup = this.group;\n            this._zr.add(thisGroup);\n\n            thisGroup.attr({\n                position: opt.position || [0, 0],\n                rotation: opt.rotation || 0,\n                scale: opt.scale || [1, 1]\n            });\n            this._transform = thisGroup.getLocalTransform();\n\n            return this;\n        },\n\n        eachCover: function (cb, context) {\n            each(this._covers, cb, context);\n        },\n\n        /**\n         * Update covers.\n         * @param {Array.<Object>} brushOptionList Like:\n         *        [\n         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n         *            ...\n         *        ]\n         *        `brushType` is required in each cover info. (can not be 'auto')\n         *        `id` is not mandatory.\n         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n         *        If brushOptionList is null/undefined, all covers removed.\n         */\n        updateCovers: function (brushOptionList) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n                return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n            });\n\n            var tmpIdPrefix = '\\0-brush-index-';\n            var oldCovers = this._covers;\n            var newCovers = this._covers = [];\n            var controller = this;\n            var creatingCover = this._creatingCover;\n\n            (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))\n                .add(addOrUpdate)\n                .update(addOrUpdate)\n                .remove(remove)\n                .execute();\n\n            return this;\n\n            function getKey(brushOption, index) {\n                return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)\n                    + '-' + brushOption.brushType;\n            }\n\n            function oldGetKey(cover, index) {\n                return getKey(cover.__brushOption, index);\n            }\n\n            function addOrUpdate(newIndex, oldIndex) {\n                var newBrushOption = brushOptionList[newIndex];\n                // Consider setOption in event listener of brushSelect,\n                // where updating cover when creating should be forbiden.\n                if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n                    newCovers[newIndex] = oldCovers[oldIndex];\n                }\n                else {\n                    var cover = newCovers[newIndex] = oldIndex != null\n                        ? (\n                            oldCovers[oldIndex].__brushOption = newBrushOption,\n                            oldCovers[oldIndex]\n                        )\n                        : endCreating(controller, createCover(controller, newBrushOption));\n                    updateCoverAfterCreation(controller, cover);\n                }\n            }\n\n            function remove(oldIndex) {\n                if (oldCovers[oldIndex] !== creatingCover) {\n                    controller.group.remove(oldCovers[oldIndex]);\n                }\n            }\n        },\n\n        unmount: function () {\n            if (__DEV__) {\n                if (!this._mounted) {\n                    return;\n                }\n            }\n\n            this.enableBrush(false);\n\n            // container may 'removeAll' outside.\n            clearCovers(this);\n            this._zr.remove(this.group);\n\n            if (__DEV__) {\n                this._mounted = false; // should be at last.\n            }\n\n            return this;\n        },\n\n        dispose: function () {\n            this.unmount();\n            this.off();\n        }\n    };\n\n    zrUtil.mixin(BrushController, Eventful);\n\n    function doEnableBrush(controller, brushOption) {\n        var zr = controller._zr;\n\n        // Consider roam, which takes globalPan too.\n        if (!controller._enableGlobalPan) {\n            interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n        }\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.on(eventName, handler);\n        });\n\n        controller._brushType = brushOption.brushType;\n        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    }\n\n    function doDisableBrush(controller) {\n        var zr = controller._zr;\n\n        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.off(eventName, handler);\n        });\n\n        controller._brushType = controller._brushOption = null;\n    }\n\n    function createCover(controller, brushOption) {\n        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n        cover.__brushOption = brushOption;\n        updateZ(cover, brushOption);\n        controller.group.add(cover);\n        return cover;\n    }\n\n    function endCreating(controller, creatingCover) {\n        var coverRenderer = getCoverRenderer(creatingCover);\n        if (coverRenderer.endCreating) {\n            coverRenderer.endCreating(controller, creatingCover);\n            updateZ(creatingCover, creatingCover.__brushOption);\n        }\n        return creatingCover;\n    }\n\n    function updateCoverShape(controller, cover) {\n        var brushOption = cover.__brushOption;\n        getCoverRenderer(cover).updateCoverShape(\n            controller, cover, brushOption.range, brushOption\n        );\n    }\n\n    function updateZ(cover, brushOption) {\n        var z = brushOption.z;\n        z == null && (z = COVER_Z);\n        cover.traverse(function (el) {\n            el.z = z;\n            el.z2 = z; // Consider in given container.\n        });\n    }\n\n    function updateCoverAfterCreation(controller, cover) {\n        getCoverRenderer(cover).updateCommon(controller, cover);\n        updateCoverShape(controller, cover);\n    }\n\n    function getCoverRenderer(cover) {\n        return coverRenderers[cover.__brushOption.brushType];\n    }\n\n    // return target panel or `true` (means global panel)\n    function getPanelByPoint(controller, e, localCursorPoint) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panel;\n        var transform = controller._transform;\n        each(panels, function (pn) {\n            pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n        });\n        return panel;\n    }\n\n    // Return a panel or true\n    function getPanelByCover(controller, cover) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panelId = cover.__brushOption.panelId;\n        // User may give cover without coord sys info,\n        // which is then treated as global panel.\n        return panelId != null ? panels[panelId] : true;\n    }\n\n    function clearCovers(controller) {\n        var covers = controller._covers;\n        var originalLength = covers.length;\n        each(covers, function (cover) {\n            controller.group.remove(cover);\n        }, controller);\n        covers.length = 0;\n\n        return !!originalLength;\n    }\n\n    function trigger(controller, opt) {\n        var areas = map(controller._covers, function (cover) {\n            var brushOption = cover.__brushOption;\n            var range = zrUtil.clone(brushOption.range);\n            return {\n                brushType: brushOption.brushType,\n                panelId: brushOption.panelId,\n                range: range\n            };\n        });\n\n        controller.trigger('brush', areas, {\n            isEnd: !!opt.isEnd,\n            removeOnClick: !!opt.removeOnClick\n        });\n    }\n\n    function shouldShowCover(controller) {\n        var track = controller._track;\n\n        if (!track.length) {\n            return false;\n        }\n\n        var p2 = track[track.length - 1];\n        var p1 = track[0];\n        var dx = p2[0] - p1[0];\n        var dy = p2[1] - p1[1];\n        var dist = mathPow(dx * dx + dy * dy, 0.5);\n\n        return dist > UNSELECT_THRESHOLD;\n    }\n\n    function getTrackEnds(track) {\n        var tail = track.length - 1;\n        tail < 0 && (tail = 0);\n        return [track[0], track[tail]];\n    }\n\n    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n        var cover = new graphic.Group();\n\n        cover.add(new graphic.Rect({\n            name: 'main',\n            style: makeStyle(brushOption),\n            silent: true,\n            draggable: true,\n            cursor: 'move',\n            drift: curry(doDrift, controller, cover, 'nswe'),\n            ondragend: curry(trigger, controller, {isEnd: true})\n        }));\n\n        each(\n            edgeNames,\n            function (name) {\n                cover.add(new graphic.Rect({\n                    name: name,\n                    style: {opacity: 0},\n                    draggable: true,\n                    silent: true,\n                    invisible: true,\n                    drift: curry(doDrift, controller, cover, name),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            }\n        );\n\n        return cover;\n    }\n\n    function updateBaseRect(controller, cover, localRange, brushOption) {\n        var lineWidth = brushOption.brushStyle.lineWidth || 0;\n        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n        var x = localRange[0][0];\n        var y = localRange[1][0];\n        var xa = x - lineWidth / 2;\n        var ya = y - lineWidth / 2;\n        var x2 = localRange[0][1];\n        var y2 = localRange[1][1];\n        var x2a = x2 - handleSize + lineWidth / 2;\n        var y2a = y2 - handleSize + lineWidth / 2;\n        var width = x2 - x;\n        var height = y2 - y;\n        var widtha = width + lineWidth;\n        var heighta = height + lineWidth;\n\n        updateRectShape(controller, cover, 'main', x, y, width, height);\n\n        if (brushOption.transformable) {\n            updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n            updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n\n            updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n            updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n        }\n    }\n\n    function updateCommon(controller, cover) {\n        var brushOption = cover.__brushOption;\n        var transformable = brushOption.transformable;\n\n        var mainEl = cover.childAt(0);\n        mainEl.useStyle(makeStyle(brushOption));\n        mainEl.attr({\n            silent: !transformable,\n            cursor: transformable ? 'move' : 'default'\n        });\n\n        each(\n            ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],\n            function (name) {\n                var el = cover.childOfName(name);\n                var globalDir = getGlobalDirection(controller, name);\n\n                el && el.attr({\n                    silent: !transformable,\n                    invisible: !transformable,\n                    cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n                });\n            }\n        );\n    }\n\n    function updateRectShape(controller, cover, name, x, y, w, h) {\n        var el = cover.childOfName(name);\n        el && el.setShape(pointsToRect(\n            clipByPanel(controller, cover, [[x, y], [x + w, y + h]])\n        ));\n    }\n\n    function makeStyle(brushOption) {\n        return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);\n    }\n\n    function formatRectRange(x, y, x2, y2) {\n        var min = [mathMin(x, x2), mathMin(y, y2)];\n        var max = [mathMax(x, x2), mathMax(y, y2)];\n\n        return [\n            [min[0], max[0]], // x range\n            [min[1], max[1]] // y range\n        ];\n    }\n\n    function getTransform(controller) {\n        return graphic.getTransform(controller.group);\n    }\n\n    function getGlobalDirection(controller, localDirection) {\n        if (localDirection.length > 1) {\n            localDirection = localDirection.split('');\n            var globalDir = [\n                getGlobalDirection(controller, localDirection[0]),\n                getGlobalDirection(controller, localDirection[1])\n            ];\n            (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n            return globalDir.join('');\n        }\n        else {\n            var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'};\n            var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};\n            var globalDir = graphic.transformDirection(\n                map[localDirection], getTransform(controller)\n            );\n            return inverseMap[globalDir];\n        }\n    }\n\n    function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n        var brushOption = cover.__brushOption;\n        var rectRange = toRectRange(brushOption.range);\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(name.split(''), function (namePart) {\n            var ind = DIRECTION_MAP[namePart];\n            rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n        });\n\n        brushOption.range = fromRectRange(formatRectRange(\n            rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]\n        ));\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function driftPolygon(controller, cover, dx, dy, e) {\n        var range = cover.__brushOption.range;\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(range, function (point) {\n            point[0] += localDelta[0];\n            point[1] += localDelta[1];\n        });\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function toLocalDelta(controller, dx, dy) {\n        var thisGroup = controller.group;\n        var localD = thisGroup.transformCoordToLocal(dx, dy);\n        var localZero = thisGroup.transformCoordToLocal(0, 0);\n\n        return [localD[0] - localZero[0], localD[1] - localZero[1]];\n    }\n\n    function clipByPanel(controller, cover, data) {\n        var panel = getPanelByCover(controller, cover);\n\n        return (panel && panel !== true)\n            ? panel.clipPath(data, controller._transform)\n            : zrUtil.clone(data);\n    }\n\n    function pointsToRect(points) {\n        var xmin = mathMin(points[0][0], points[1][0]);\n        var ymin = mathMin(points[0][1], points[1][1]);\n        var xmax = mathMax(points[0][0], points[1][0]);\n        var ymax = mathMax(points[0][1], points[1][1]);\n\n        return {\n            x: xmin,\n            y: ymin,\n            width: xmax - xmin,\n            height: ymax - ymin\n        };\n    }\n\n    function resetCursor(controller, e, localCursorPoint) {\n        // Check active\n        if (!controller._brushType) {\n            return;\n        }\n\n        var zr = controller._zr;\n        var covers = controller._covers;\n        var currPanel = getPanelByPoint(controller, e, localCursorPoint);\n\n        // Check whether in covers.\n        if (!controller._dragging) {\n            for (var i = 0; i < covers.length; i++) {\n                var brushOption = covers[i].__brushOption;\n                if (currPanel\n                    && (currPanel === true || brushOption.panelId === currPanel.panelId)\n                    && coverRenderers[brushOption.brushType].contain(\n                        covers[i], localCursorPoint[0], localCursorPoint[1]\n                    )\n                ) {\n                    // Use cursor style set on cover.\n                    return;\n                }\n            }\n        }\n\n        currPanel && zr.setCursorStyle('crosshair');\n    }\n\n    function preventDefault(e) {\n        var rawE = e.event;\n        rawE.preventDefault && rawE.preventDefault();\n    }\n\n    function mainShapeContain(cover, x, y) {\n        return cover.childOfName('main').contain(x, y);\n    }\n\n    function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n        var creatingCover = controller._creatingCover;\n        var panel = controller._creatingPanel;\n        var thisBrushOption = controller._brushOption;\n        var eventParams;\n\n        controller._track.push(localCursorPoint.slice());\n\n        if (shouldShowCover(controller) || creatingCover) {\n\n            if (panel && !creatingCover) {\n                thisBrushOption.brushMode === 'single' && clearCovers(controller);\n                var brushOption = zrUtil.clone(thisBrushOption);\n                brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n                brushOption.panelId = panel === true ? null : panel.panelId;\n                creatingCover = controller._creatingCover = createCover(controller, brushOption);\n                controller._covers.push(creatingCover);\n            }\n\n            if (creatingCover) {\n                var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n                var coverBrushOption = creatingCover.__brushOption;\n\n                coverBrushOption.range = coverRenderer.getCreatingRange(\n                    clipByPanel(controller, creatingCover, controller._track)\n                );\n\n                if (isEnd) {\n                    endCreating(controller, creatingCover);\n                    coverRenderer.updateCommon(controller, creatingCover);\n                }\n\n                updateCoverShape(controller, creatingCover);\n\n                eventParams = {isEnd: isEnd};\n            }\n        }\n        else if (\n            isEnd\n            && thisBrushOption.brushMode === 'single'\n            && thisBrushOption.removeOnClick\n        ) {\n            // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n            // But a single click do not clear covers, because user may have casual\n            // clicks (for example, click on other component and do not expect covers\n            // disappear).\n            // Only some cover removed, trigger action, but not every click trigger action.\n            if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n                eventParams = {isEnd: isEnd, removeOnClick: true};\n            }\n        }\n\n        return eventParams;\n    }\n\n    function determineBrushType(brushType, panel) {\n        if (brushType === 'auto') {\n            if (__DEV__) {\n                zrUtil.assert(\n                    panel && panel.defaultBrushType,\n                    'MUST have defaultBrushType when brushType is \"atuo\"'\n                );\n            }\n            return panel.defaultBrushType;\n        }\n        return brushType;\n    }\n\n    var mouseHandlers = {\n\n        mousedown: function (e) {\n            if (this._dragging) {\n                // In case some browser do not support globalOut,\n                // and release mose out side the browser.\n                handleDragEnd.call(this, e);\n            }\n            else if (!e.target || !e.target.draggable) {\n\n                preventDefault(e);\n\n                var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n                this._creatingCover = null;\n                var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n                if (panel) {\n                    this._dragging = true;\n                    this._track = [localCursorPoint.slice()];\n                }\n            }\n        },\n\n        mousemove: function (e) {\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n            resetCursor(this, e, localCursorPoint);\n\n            if (this._dragging) {\n\n                preventDefault(e);\n\n                var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n\n                eventParams && trigger(this, eventParams);\n            }\n        },\n\n        mouseup: handleDragEnd //,\n\n        // FIXME\n        // in tooltip, globalout should not be triggered.\n        // globalout: handleDragEnd\n    };\n\n    function handleDragEnd(e) {\n        if (this._dragging) {\n\n            preventDefault(e);\n\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n            var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n\n            this._dragging = false;\n            this._track = [];\n            this._creatingCover = null;\n\n            // trigger event shoule be at final, after procedure will be nested.\n            eventParams && trigger(this, eventParams);\n        }\n    }\n\n    /**\n     * key: brushType\n     * @type {Object}\n     */\n    var coverRenderers = {\n\n        lineX: getLineRenderer(0),\n\n        lineY: getLineRenderer(1),\n\n        rect: {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            return range;\n                        },\n                        function (range) {\n                            return range;\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                updateBaseRect(controller, cover, localRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        },\n\n        polygon: {\n            createCover: function (controller, brushOption) {\n                var cover = new graphic.Group();\n\n                // Do not use graphic.Polygon because graphic.Polyline do not close the\n                // border of the shape when drawing, which is a better experience for user.\n                cover.add(new graphic.Polyline({\n                    name: 'main',\n                    style: makeStyle(brushOption),\n                    silent: true\n                }));\n\n                return cover;\n            },\n            getCreatingRange: function (localTrack) {\n                return localTrack;\n            },\n            endCreating: function (controller, cover) {\n                cover.remove(cover.childAt(0));\n                // Use graphic.Polygon close the shape.\n                cover.add(new graphic.Polygon({\n                    name: 'main',\n                    draggable: true,\n                    drift: curry(driftPolygon, controller, cover),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                cover.childAt(0).setShape({\n                    points: clipByPanel(controller, cover, localRange)\n                });\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        }\n    };\n\n    function getLineRenderer(xyIndex) {\n        return {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            var rectRange = [range, [0, 100]];\n                            xyIndex && rectRange.reverse();\n                            return rectRange;\n                        },\n                        function (rectRange) {\n                            return rectRange[xyIndex];\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    [['w', 'e'], ['n', 's']][xyIndex]\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n                var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n\n                return [min, max];\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                var otherExtent;\n                // If brushWidth not specified, fit the panel.\n                var panel = getPanelByCover(controller, cover);\n                if (panel !== true && panel.getLinearBrushOtherExtent) {\n                    otherExtent = panel.getLinearBrushOtherExtent(\n                        xyIndex, controller._transform\n                    );\n                }\n                else {\n                    var zr = controller._zr;\n                    otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n                }\n                var rectRange = [localRange, otherExtent];\n                xyIndex && rectRange.reverse();\n\n                updateBaseRect(controller, cover, rectRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        };\n    }\n\n    module.exports = BrushController;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyLmpzPzBhMzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQSx1QkFBdUIsd0VBQXdFO0FBQy9GLHVCQUF1Qix5REFBeUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDZCQUE2QixhQUFhO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkUsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQm94IHNlbGVjdGlvbiB0b29sLlxuICpcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlclxuICovXG5cblxuXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgaW50ZXJhY3Rpb25NdXRleCA9IHJlcXVpcmUoJy4vaW50ZXJhY3Rpb25NdXRleCcpO1xuICAgIHZhciBEYXRhRGlmZmVyID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9EYXRhRGlmZmVyJyk7XG5cbiAgICB2YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgbWFwID0genJVdGlsLm1hcDtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcblxuICAgIHZhciBDT1ZFUl9aID0gMTAwMDA7XG4gICAgdmFyIFVOU0VMRUNUX1RIUkVTSE9MRCA9IDY7XG4gICAgdmFyIE1JTl9SRVNJWkVfTElORV9XSURUSCA9IDY7XG4gICAgdmFyIE1VVEVYX1JFU09VUkNFX0tFWSA9ICdnbG9iYWxQYW4nO1xuXG4gICAgdmFyIERJUkVDVElPTl9NQVAgPSB7XG4gICAgICAgIHc6IFswLCAwXSxcbiAgICAgICAgZTogWzAsIDFdLFxuICAgICAgICBuOiBbMSwgMF0sXG4gICAgICAgIHM6IFsxLCAxXVxuICAgIH07XG4gICAgdmFyIENVUlNPUl9NQVAgPSB7XG4gICAgICAgIHc6ICdldycsXG4gICAgICAgIGU6ICdldycsXG4gICAgICAgIG46ICducycsXG4gICAgICAgIHM6ICducycsXG4gICAgICAgIG5lOiAnbmVzdycsXG4gICAgICAgIHN3OiAnbmVzdycsXG4gICAgICAgIG53OiAnbndzZScsXG4gICAgICAgIHNlOiAnbndzZSdcbiAgICB9O1xuICAgIHZhciBERUZBVUxUX0JSVVNIX09QVCA9IHtcbiAgICAgICAgYnJ1c2hTdHlsZToge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwLjMpJyxcbiAgICAgICAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDAuMSknXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybWFibGU6IHRydWUsXG4gICAgICAgIGJydXNoTW9kZTogJ3NpbmdsZScsXG4gICAgICAgIHJlbW92ZU9uQ2xpY2s6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhciBiYXNlVUlEID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtaXhpbiB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gICAgICogQGV2ZW50IG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyI2JydXNoXG4gICAgICogICAgICAgIHBhcmFtczpcbiAgICAgKiAgICAgICAgICAgIGFyZWFzOiBBcnJheS48QXJyYXk+LCBjb29yZCByZWxhdGVzIHRvIGNvbnRhaW5lciBncm91cCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vIGNvbnRhaW5lciBzcGVjaWZpZWQsIHRvIGdsb2JhbC5cbiAgICAgKiAgICAgICAgICAgIG9wdCB7XG4gICAgICogICAgICAgICAgICAgICAgaXNFbmQ6IGJvb2xlYW4sXG4gICAgICogICAgICAgICAgICAgICAgcmVtb3ZlT25DbGljazogYm9vbGVhblxuICAgICAqICAgICAgICAgICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci96cmVuZGVyflpSZW5kZXJ9IHpyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQnJ1c2hDb250cm9sbGVyKHpyKSB7XG5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoenIpO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL3pyZW5kZXJ+WlJlbmRlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3pyID0genI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZm9yIGRyYXdpbmcgKGFmdGVyIGVuYWJsZWRCcnVzaCkuXG4gICAgICAgICAqICAgICAnbGluZScsICdyZWN0JywgJ3BvbHlnb24nIG9yIGZhbHNlXG4gICAgICAgICAqICAgICBJZiBwYXNzaW5nIGZhbHNlL251bGwvdW5kZWZpbmVkLCBkaXNhYmxlIGJydXNoLlxuICAgICAgICAgKiAgICAgSWYgcGFzc2luZyAnYXV0bycsIGRldGVybWluZWQgYnkgcGFuZWwuZGVmYXVsdEJydXNoVHlwZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYnJ1c2hUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGZvciBkcmF3aW5nIChhZnRlciBlbmFibGVkQnJ1c2gpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYnJ1c2hPcHRpb247XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wYW5lbHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVibWVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYWNrID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZHJhZ2dpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvdmVycyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW91ZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NyZWF0aW5nQ292ZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0cnVlYCBtZWFucyBnbG9iYWwgcGFuZWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cHxib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3JlYXRpbmdQYW5lbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbmFibGVHbG9iYWxQYW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIHRoaXMuX21vdW50ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VpZCA9ICdicnVzaENvbnRyb2xsZXJfJyArIGJhc2VVSUQrKztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICAgIGVhY2gobW91c2VIYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IHpyVXRpbC5iaW5kKGhhbmRsZXIsIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBCcnVzaENvbnRyb2xsZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBCcnVzaENvbnRyb2xsZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byBudWxsL3VuZGVmaW5lZC9mYWxzZSwgc2VsZWN0IGRpc2FibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYnJ1c2hPcHRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gYnJ1c2hPcHRpb24uYnJ1c2hUeXBlICdsaW5lJywgJ3JlY3QnLCAncG9seWdvbicgb3IgZmFsc2VcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIElmIHBhc3NpbmcgZmFsc2UvbnVsbC91bmRlZmluZWQsIGRpc2FibGUgYnJ1c2guXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBwYXNzaW5nICdhdXRvJywgZGV0ZXJtaW5lZCBieSBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnYXV0bycgY2FuIG5vdCBiZSB1c2VkIGluIGdsb2JhbCBwYW5lbClcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaE1vZGU9J3NpbmdsZSddICdzaW5nbGUnIG9yICdtdWx0aXBsZSdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbYnJ1c2hPcHRpb24udHJhbnNmb3JtYWJsZT10cnVlXVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFticnVzaE9wdGlvbi5yZW1vdmVPbkNsaWNrPWZhbHNlXVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JydXNoT3B0aW9uLmJydXNoU3R5bGVdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZS53aWR0aF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLmxpbmVXaWR0aF1cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLnN0cm9rZV1cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLmZpbGxdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYnJ1c2hPcHRpb24uel1cbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZUJydXNoOiBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmFzc2VydCh0aGlzLl9tb3VudGVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fYnJ1c2hUeXBlICYmIGRvRGlzYWJsZUJydXNoKHRoaXMpO1xuICAgICAgICAgICAgYnJ1c2hPcHRpb24uYnJ1c2hUeXBlICYmIGRvRW5hYmxlQnJ1c2godGhpcywgYnJ1c2hPcHRpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gcGFuZWxPcHRzIElmIG5vdCBwYXNzLCBpdCBpcyBnbG9iYWwgYnJ1c2guXG4gICAgICAgICAqICAgICAgICBFYWNoIGl0ZW1zOiB7XG4gICAgICAgICAqICAgICAgICAgICAgcGFuZWxJZCwgLy8gbWFuZGF0b3J5LlxuICAgICAgICAgKiAgICAgICAgICAgIGNsaXBQYXRoLCAvLyBtYW5kYXRvcnkuIGZ1bmN0aW9uLlxuICAgICAgICAgKiAgICAgICAgICAgIGlzVGFyZ2V0QnlDdXJzb3IsIC8vIG1hbmRhdG9yeS4gZnVuY3Rpb24uXG4gICAgICAgICAqICAgICAgICAgICAgZGVmYXVsdEJydXNoVHlwZSwgLy8gb3B0aW9uYWwsIG9ubHkgdXNlZCB3aGVuIGJydXNoVHlwZSBpcyAnYXV0bycuXG4gICAgICAgICAqICAgICAgICAgICAgZ2V0TGluZWFyQnJ1c2hPdGhlckV4dGVudCwgLy8gb3B0aW9uYWwuIGZ1bmN0aW9uLlxuICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGFuZWxzOiBmdW5jdGlvbiAocGFuZWxPcHRzKSB7XG4gICAgICAgICAgICBpZiAocGFuZWxPcHRzICYmIHBhbmVsT3B0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZWxzID0gdGhpcy5fcGFuZWxzID0ge307XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gocGFuZWxPcHRzLCBmdW5jdGlvbiAocGFuZWxPcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsc1twYW5lbE9wdHMucGFuZWxJZF0gPSB6clV0aWwuY2xvbmUocGFuZWxPcHRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhbmVscyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFtvcHQuZW5hYmxlR2xvYmFsUGFuPWZhbHNlXVxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VudGVkID0gdHJ1ZTsgLy8gc2hvdWxkIGJlIGF0IGZpcnN0LlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVHbG9iYWxQYW4gPSBvcHQuZW5hYmxlR2xvYmFsUGFuO1xuXG4gICAgICAgICAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzR3JvdXApO1xuXG4gICAgICAgICAgICB0aGlzR3JvdXAuYXR0cih7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG9wdC5wb3NpdGlvbiB8fCBbMCwgMF0sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IG9wdC5yb3RhdGlvbiB8fCAwLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBvcHQuc2NhbGUgfHwgWzEsIDFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRoaXNHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBlYWNoQ292ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZWFjaCh0aGlzLl9jb3ZlcnMsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGNvdmVycy5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYnJ1c2hPcHRpb25MaXN0IExpa2U6XG4gICAgICAgICAqICAgICAgICBbXG4gICAgICAgICAqICAgICAgICAgICAge2lkOiAneHgnLCBicnVzaFR5cGU6ICdsaW5lJywgcmFuZ2U6IFsyMywgNDRdLCBicnVzaFN0eWxlLCB0cmFuc2Zvcm1hYmxlfSxcbiAgICAgICAgICogICAgICAgICAgICB7aWQ6ICd5eScsIGJydXNoVHlwZTogJ3JlY3QnLCByYW5nZTogW1syMywgNDRdLCBbMjMsIDU0XV19LFxuICAgICAgICAgKiAgICAgICAgICAgIC4uLlxuICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgKiAgICAgICAgYGJydXNoVHlwZWAgaXMgcmVxdWlyZWQgaW4gZWFjaCBjb3ZlciBpbmZvLiAoY2FuIG5vdCBiZSAnYXV0bycpXG4gICAgICAgICAqICAgICAgICBgaWRgIGlzIG5vdCBtYW5kYXRvcnkuXG4gICAgICAgICAqICAgICAgICBgYnJ1c2hTdHlsZWAsIGB0cmFuc2Zvcm1hYmxlYCBpcyBub3QgbWFuZGF0b3J5LCB1c2UgREVGQVVMVF9CUlVTSF9PUFQgYnkgZGVmYXVsdC5cbiAgICAgICAgICogICAgICAgIElmIGJydXNoT3B0aW9uTGlzdCBpcyBudWxsL3VuZGVmaW5lZCwgYWxsIGNvdmVycyByZW1vdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlQ292ZXJzOiBmdW5jdGlvbiAoYnJ1c2hPcHRpb25MaXN0KSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQodGhpcy5fbW91bnRlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJydXNoT3B0aW9uTGlzdCA9IHpyVXRpbC5tYXAoYnJ1c2hPcHRpb25MaXN0LCBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShERUZBVUxUX0JSVVNIX09QVCksIGJydXNoT3B0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdG1wSWRQcmVmaXggPSAnXFwwLWJydXNoLWluZGV4LSc7XG4gICAgICAgICAgICB2YXIgb2xkQ292ZXJzID0gdGhpcy5fY292ZXJzO1xuICAgICAgICAgICAgdmFyIG5ld0NvdmVycyA9IHRoaXMuX2NvdmVycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNyZWF0aW5nQ292ZXIgPSB0aGlzLl9jcmVhdGluZ0NvdmVyO1xuXG4gICAgICAgICAgICAobmV3IERhdGFEaWZmZXIob2xkQ292ZXJzLCBicnVzaE9wdGlvbkxpc3QsIG9sZEdldEtleSwgZ2V0S2V5KSlcbiAgICAgICAgICAgICAgICAuYWRkKGFkZE9yVXBkYXRlKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoYWRkT3JVcGRhdGUpXG4gICAgICAgICAgICAgICAgLnJlbW92ZShyZW1vdmUpXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEtleShicnVzaE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGJydXNoT3B0aW9uLmlkICE9IG51bGwgPyBicnVzaE9wdGlvbi5pZCA6IHRtcElkUHJlZml4ICsgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICsgJy0nICsgYnJ1c2hPcHRpb24uYnJ1c2hUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbGRHZXRLZXkoY292ZXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEtleShjb3Zlci5fX2JydXNoT3B0aW9uLCBpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE9yVXBkYXRlKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdCcnVzaE9wdGlvbiA9IGJydXNoT3B0aW9uTGlzdFtuZXdJbmRleF07XG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgc2V0T3B0aW9uIGluIGV2ZW50IGxpc3RlbmVyIG9mIGJydXNoU2VsZWN0LFxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIHVwZGF0aW5nIGNvdmVyIHdoZW4gY3JlYXRpbmcgc2hvdWxkIGJlIGZvcmJpZGVuLlxuICAgICAgICAgICAgICAgIGlmIChvbGRJbmRleCAhPSBudWxsICYmIG9sZENvdmVyc1tvbGRJbmRleF0gPT09IGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q292ZXJzW25ld0luZGV4XSA9IG9sZENvdmVyc1tvbGRJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY292ZXIgPSBuZXdDb3ZlcnNbbmV3SW5kZXhdID0gb2xkSW5kZXggIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ292ZXJzW29sZEluZGV4XS5fX2JydXNoT3B0aW9uID0gbmV3QnJ1c2hPcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ292ZXJzW29sZEluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlbmRDcmVhdGluZyhjb250cm9sbGVyLCBjcmVhdGVDb3Zlcihjb250cm9sbGVyLCBuZXdCcnVzaE9wdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKG9sZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZENvdmVyc1tvbGRJbmRleF0gIT09IGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5ncm91cC5yZW1vdmUob2xkQ292ZXJzW29sZEluZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQnJ1c2goZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBjb250YWluZXIgbWF5ICdyZW1vdmVBbGwnIG91dHNpZGUuXG4gICAgICAgICAgICBjbGVhckNvdmVycyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmdyb3VwKTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VudGVkID0gZmFsc2U7IC8vIHNob3VsZCBiZSBhdCBsYXN0LlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVubW91bnQoKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLm1peGluKEJydXNoQ29udHJvbGxlciwgRXZlbnRmdWwpO1xuXG4gICAgZnVuY3Rpb24gZG9FbmFibGVCcnVzaChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgICB2YXIgenIgPSBjb250cm9sbGVyLl96cjtcblxuICAgICAgICAvLyBDb25zaWRlciByb2FtLCB3aGljaCB0YWtlcyBnbG9iYWxQYW4gdG9vLlxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX2VuYWJsZUdsb2JhbFBhbikge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25NdXRleC50YWtlKHpyLCBNVVRFWF9SRVNPVVJDRV9LRVksIGNvbnRyb2xsZXIuX3VpZCk7XG4gICAgICAgIH1cblxuICAgICAgICBlYWNoKGNvbnRyb2xsZXIuX2hhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB6ci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb250cm9sbGVyLl9icnVzaFR5cGUgPSBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gICAgICAgIGNvbnRyb2xsZXIuX2JydXNoT3B0aW9uID0genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShERUZBVUxUX0JSVVNIX09QVCksIGJydXNoT3B0aW9uLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb0Rpc2FibGVCcnVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIHZhciB6ciA9IGNvbnRyb2xsZXIuX3pyO1xuXG4gICAgICAgIGludGVyYWN0aW9uTXV0ZXgucmVsZWFzZSh6ciwgTVVURVhfUkVTT1VSQ0VfS0VZLCBjb250cm9sbGVyLl91aWQpO1xuXG4gICAgICAgIGVhY2goY29udHJvbGxlci5faGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHpyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb250cm9sbGVyLl9icnVzaFR5cGUgPSBjb250cm9sbGVyLl9icnVzaE9wdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ292ZXIoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgdmFyIGNvdmVyID0gY292ZXJSZW5kZXJlcnNbYnJ1c2hPcHRpb24uYnJ1c2hUeXBlXS5jcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbik7XG4gICAgICAgIGNvdmVyLl9fYnJ1c2hPcHRpb24gPSBicnVzaE9wdGlvbjtcbiAgICAgICAgdXBkYXRlWihjb3ZlciwgYnJ1c2hPcHRpb24pO1xuICAgICAgICBjb250cm9sbGVyLmdyb3VwLmFkZChjb3Zlcik7XG4gICAgICAgIHJldHVybiBjb3ZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRDcmVhdGluZyhjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKSB7XG4gICAgICAgIHZhciBjb3ZlclJlbmRlcmVyID0gZ2V0Q292ZXJSZW5kZXJlcihjcmVhdGluZ0NvdmVyKTtcbiAgICAgICAgaWYgKGNvdmVyUmVuZGVyZXIuZW5kQ3JlYXRpbmcpIHtcbiAgICAgICAgICAgIGNvdmVyUmVuZGVyZXIuZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcik7XG4gICAgICAgICAgICB1cGRhdGVaKGNyZWF0aW5nQ292ZXIsIGNyZWF0aW5nQ292ZXIuX19icnVzaE9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0aW5nQ292ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJTaGFwZShjb250cm9sbGVyLCBjb3Zlcikge1xuICAgICAgICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICAgICAgICBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKS51cGRhdGVDb3ZlclNoYXBlKFxuICAgICAgICAgICAgY29udHJvbGxlciwgY292ZXIsIGJydXNoT3B0aW9uLnJhbmdlLCBicnVzaE9wdGlvblxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVooY292ZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICAgIHZhciB6ID0gYnJ1c2hPcHRpb24uejtcbiAgICAgICAgeiA9PSBudWxsICYmICh6ID0gQ09WRVJfWik7XG4gICAgICAgIGNvdmVyLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwueiA9IHo7XG4gICAgICAgICAgICBlbC56MiA9IHo7IC8vIENvbnNpZGVyIGluIGdpdmVuIGNvbnRhaW5lci5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gICAgICAgIGdldENvdmVyUmVuZGVyZXIoY292ZXIpLnVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgICAgIHVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY292ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvdmVyUmVuZGVyZXIoY292ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvdmVyUmVuZGVyZXJzW2NvdmVyLl9fYnJ1c2hPcHRpb24uYnJ1c2hUeXBlXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdGFyZ2V0IHBhbmVsIG9yIGB0cnVlYCAobWVhbnMgZ2xvYmFsIHBhbmVsKVxuICAgIGZ1bmN0aW9uIGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KSB7XG4gICAgICAgIHZhciBwYW5lbHMgPSBjb250cm9sbGVyLl9wYW5lbHM7XG4gICAgICAgIGlmICghcGFuZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gR2xvYmFsIHBhbmVsXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhbmVsO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gY29udHJvbGxlci5fdHJhbnNmb3JtO1xuICAgICAgICBlYWNoKHBhbmVscywgZnVuY3Rpb24gKHBuKSB7XG4gICAgICAgICAgICBwbi5pc1RhcmdldEJ5Q3Vyc29yKGUsIGxvY2FsQ3Vyc29yUG9pbnQsIHRyYW5zZm9ybSkgJiYgKHBhbmVsID0gcG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhbmVsO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIHBhbmVsIG9yIHRydWVcbiAgICBmdW5jdGlvbiBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpIHtcbiAgICAgICAgdmFyIHBhbmVscyA9IGNvbnRyb2xsZXIuX3BhbmVscztcbiAgICAgICAgaWYgKCFwYW5lbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBHbG9iYWwgcGFuZWxcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFuZWxJZCA9IGNvdmVyLl9fYnJ1c2hPcHRpb24ucGFuZWxJZDtcbiAgICAgICAgLy8gVXNlciBtYXkgZ2l2ZSBjb3ZlciB3aXRob3V0IGNvb3JkIHN5cyBpbmZvLFxuICAgICAgICAvLyB3aGljaCBpcyB0aGVuIHRyZWF0ZWQgYXMgZ2xvYmFsIHBhbmVsLlxuICAgICAgICByZXR1cm4gcGFuZWxJZCAhPSBudWxsID8gcGFuZWxzW3BhbmVsSWRdIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckNvdmVycyhjb250cm9sbGVyKSB7XG4gICAgICAgIHZhciBjb3ZlcnMgPSBjb250cm9sbGVyLl9jb3ZlcnM7XG4gICAgICAgIHZhciBvcmlnaW5hbExlbmd0aCA9IGNvdmVycy5sZW5ndGg7XG4gICAgICAgIGVhY2goY292ZXJzLCBmdW5jdGlvbiAoY292ZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZ3JvdXAucmVtb3ZlKGNvdmVyKTtcbiAgICAgICAgfSwgY29udHJvbGxlcik7XG4gICAgICAgIGNvdmVycy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiAhIW9yaWdpbmFsTGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXIoY29udHJvbGxlciwgb3B0KSB7XG4gICAgICAgIHZhciBhcmVhcyA9IG1hcChjb250cm9sbGVyLl9jb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgICAgICAgICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXIuX19icnVzaE9wdGlvbjtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHpyVXRpbC5jbG9uZShicnVzaE9wdGlvbi5yYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJydXNoVHlwZTogYnJ1c2hPcHRpb24uYnJ1c2hUeXBlLFxuICAgICAgICAgICAgICAgIHBhbmVsSWQ6IGJydXNoT3B0aW9uLnBhbmVsSWQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb250cm9sbGVyLnRyaWdnZXIoJ2JydXNoJywgYXJlYXMsIHtcbiAgICAgICAgICAgIGlzRW5kOiAhIW9wdC5pc0VuZCxcbiAgICAgICAgICAgIHJlbW92ZU9uQ2xpY2s6ICEhb3B0LnJlbW92ZU9uQ2xpY2tcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkU2hvd0NvdmVyKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gY29udHJvbGxlci5fdHJhY2s7XG5cbiAgICAgICAgaWYgKCF0cmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwMiA9IHRyYWNrW3RyYWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcDEgPSB0cmFja1swXTtcbiAgICAgICAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcbiAgICAgICAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcbiAgICAgICAgdmFyIGRpc3QgPSBtYXRoUG93KGR4ICogZHggKyBkeSAqIGR5LCAwLjUpO1xuXG4gICAgICAgIHJldHVybiBkaXN0ID4gVU5TRUxFQ1RfVEhSRVNIT0xEO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRyYWNrRW5kcyh0cmFjaykge1xuICAgICAgICB2YXIgdGFpbCA9IHRyYWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIHRhaWwgPCAwICYmICh0YWlsID0gMCk7XG4gICAgICAgIHJldHVybiBbdHJhY2tbMF0sIHRyYWNrW3RhaWxdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlUmVjdENvdmVyKGRvRHJpZnQsIGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uLCBlZGdlTmFtZXMpIHtcbiAgICAgICAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgICBzdHlsZTogbWFrZVN0eWxlKGJydXNoT3B0aW9uKSxcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnLFxuICAgICAgICAgICAgZHJpZnQ6IGN1cnJ5KGRvRHJpZnQsIGNvbnRyb2xsZXIsIGNvdmVyLCAnbnN3ZScpLFxuICAgICAgICAgICAgb25kcmFnZW5kOiBjdXJyeSh0cmlnZ2VyLCBjb250cm9sbGVyLCB7aXNFbmQ6IHRydWV9KVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgZWFjaChcbiAgICAgICAgICAgIGVkZ2VOYW1lcyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgY292ZXIuYWRkKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkcmlmdDogY3VycnkoZG9EcmlmdCwgY29udHJvbGxlciwgY292ZXIsIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBvbmRyYWdlbmQ6IGN1cnJ5KHRyaWdnZXIsIGNvbnRyb2xsZXIsIHtpc0VuZDogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjb3ZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGJydXNoT3B0aW9uLmJydXNoU3R5bGUubGluZVdpZHRoIHx8IDA7XG4gICAgICAgIHZhciBoYW5kbGVTaXplID0gbWF0aE1heChsaW5lV2lkdGgsIE1JTl9SRVNJWkVfTElORV9XSURUSCk7XG4gICAgICAgIHZhciB4ID0gbG9jYWxSYW5nZVswXVswXTtcbiAgICAgICAgdmFyIHkgPSBsb2NhbFJhbmdlWzFdWzBdO1xuICAgICAgICB2YXIgeGEgPSB4IC0gbGluZVdpZHRoIC8gMjtcbiAgICAgICAgdmFyIHlhID0geSAtIGxpbmVXaWR0aCAvIDI7XG4gICAgICAgIHZhciB4MiA9IGxvY2FsUmFuZ2VbMF1bMV07XG4gICAgICAgIHZhciB5MiA9IGxvY2FsUmFuZ2VbMV1bMV07XG4gICAgICAgIHZhciB4MmEgPSB4MiAtIGhhbmRsZVNpemUgKyBsaW5lV2lkdGggLyAyO1xuICAgICAgICB2YXIgeTJhID0geTIgLSBoYW5kbGVTaXplICsgbGluZVdpZHRoIC8gMjtcbiAgICAgICAgdmFyIHdpZHRoID0geDIgLSB4O1xuICAgICAgICB2YXIgaGVpZ2h0ID0geTIgLSB5O1xuICAgICAgICB2YXIgd2lkdGhhID0gd2lkdGggKyBsaW5lV2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRhID0gaGVpZ2h0ICsgbGluZVdpZHRoO1xuXG4gICAgICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ21haW4nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBpZiAoYnJ1c2hPcHRpb24udHJhbnNmb3JtYWJsZSkge1xuICAgICAgICAgICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAndycsIHhhLCB5YSwgaGFuZGxlU2l6ZSwgaGVpZ2h0YSk7XG4gICAgICAgICAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdlJywgeDJhLCB5YSwgaGFuZGxlU2l6ZSwgaGVpZ2h0YSk7XG4gICAgICAgICAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICduJywgeGEsIHlhLCB3aWR0aGEsIGhhbmRsZVNpemUpO1xuICAgICAgICAgICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAncycsIHhhLCB5MmEsIHdpZHRoYSwgaGFuZGxlU2l6ZSk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ253JywgeGEsIHlhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICAgICAgICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ25lJywgeDJhLCB5YSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgICAgICAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzdycsIHhhLCB5MmEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICAgICAgICAgICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnc2UnLCB4MmEsIHkyYSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb21tb24oY29udHJvbGxlciwgY292ZXIpIHtcbiAgICAgICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXIuX19icnVzaE9wdGlvbjtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWFibGUgPSBicnVzaE9wdGlvbi50cmFuc2Zvcm1hYmxlO1xuXG4gICAgICAgIHZhciBtYWluRWwgPSBjb3Zlci5jaGlsZEF0KDApO1xuICAgICAgICBtYWluRWwudXNlU3R5bGUobWFrZVN0eWxlKGJydXNoT3B0aW9uKSk7XG4gICAgICAgIG1haW5FbC5hdHRyKHtcbiAgICAgICAgICAgIHNpbGVudDogIXRyYW5zZm9ybWFibGUsXG4gICAgICAgICAgICBjdXJzb3I6IHRyYW5zZm9ybWFibGUgPyAnbW92ZScgOiAnZGVmYXVsdCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWFjaChcbiAgICAgICAgICAgIFsndycsICdlJywgJ24nLCAncycsICdzZScsICdzdycsICduZScsICdudyddLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBjb3Zlci5jaGlsZE9mTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsRGlyID0gZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIG5hbWUpO1xuXG4gICAgICAgICAgICAgICAgZWwgJiYgZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogIXRyYW5zZm9ybWFibGUsXG4gICAgICAgICAgICAgICAgICAgIGludmlzaWJsZTogIXRyYW5zZm9ybWFibGUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogdHJhbnNmb3JtYWJsZSA/IENVUlNPUl9NQVBbZ2xvYmFsRGlyXSArICctcmVzaXplJyA6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsIG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgICAgICAgdmFyIGVsID0gY292ZXIuY2hpbGRPZk5hbWUobmFtZSk7XG4gICAgICAgIGVsICYmIGVsLnNldFNoYXBlKHBvaW50c1RvUmVjdChcbiAgICAgICAgICAgIGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBbW3gsIHldLCBbeCArIHcsIHkgKyBoXV0pXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VTdHlsZShicnVzaE9wdGlvbikge1xuICAgICAgICByZXR1cm4genJVdGlsLmRlZmF1bHRzKHtzdHJva2VOb1NjYWxlOiB0cnVlfSwgYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UmVjdFJhbmdlKHgsIHksIHgyLCB5Mikge1xuICAgICAgICB2YXIgbWluID0gW21hdGhNaW4oeCwgeDIpLCBtYXRoTWluKHksIHkyKV07XG4gICAgICAgIHZhciBtYXggPSBbbWF0aE1heCh4LCB4MiksIG1hdGhNYXgoeSwgeTIpXTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW21pblswXSwgbWF4WzBdXSwgLy8geCByYW5nZVxuICAgICAgICAgICAgW21pblsxXSwgbWF4WzFdXSAvLyB5IHJhbmdlXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGNvbnRyb2xsZXIuZ3JvdXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEdsb2JhbERpcmVjdGlvbihjb250cm9sbGVyLCBsb2NhbERpcmVjdGlvbikge1xuICAgICAgICBpZiAobG9jYWxEaXJlY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9jYWxEaXJlY3Rpb24gPSBsb2NhbERpcmVjdGlvbi5zcGxpdCgnJyk7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsRGlyID0gW1xuICAgICAgICAgICAgICAgIGdldEdsb2JhbERpcmVjdGlvbihjb250cm9sbGVyLCBsb2NhbERpcmVjdGlvblswXSksXG4gICAgICAgICAgICAgICAgZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uWzFdKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIChnbG9iYWxEaXJbMF0gPT09ICdlJyB8fCBnbG9iYWxEaXJbMF0gPT09ICd3JykgJiYgZ2xvYmFsRGlyLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxEaXIuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWFwID0ge3c6ICdsZWZ0JywgZTogJ3JpZ2h0JywgbjogJ3RvcCcsIHM6ICdib3R0b20nfTtcbiAgICAgICAgICAgIHZhciBpbnZlcnNlTWFwID0ge2xlZnQ6ICd3JywgcmlnaHQ6ICdlJywgdG9wOiAnbicsIGJvdHRvbTogJ3MnfTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxEaXIgPSBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbihcbiAgICAgICAgICAgICAgICBtYXBbbG9jYWxEaXJlY3Rpb25dLCBnZXRUcmFuc2Zvcm0oY29udHJvbGxlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gaW52ZXJzZU1hcFtnbG9iYWxEaXJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJpZnRSZWN0KHRvUmVjdFJhbmdlLCBmcm9tUmVjdFJhbmdlLCBjb250cm9sbGVyLCBjb3ZlciwgbmFtZSwgZHgsIGR5LCBlKSB7XG4gICAgICAgIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gICAgICAgIHZhciByZWN0UmFuZ2UgPSB0b1JlY3RSYW5nZShicnVzaE9wdGlvbi5yYW5nZSk7XG4gICAgICAgIHZhciBsb2NhbERlbHRhID0gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSk7XG5cbiAgICAgICAgZWFjaChuYW1lLnNwbGl0KCcnKSwgZnVuY3Rpb24gKG5hbWVQYXJ0KSB7XG4gICAgICAgICAgICB2YXIgaW5kID0gRElSRUNUSU9OX01BUFtuYW1lUGFydF07XG4gICAgICAgICAgICByZWN0UmFuZ2VbaW5kWzBdXVtpbmRbMV1dICs9IGxvY2FsRGVsdGFbaW5kWzBdXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnJ1c2hPcHRpb24ucmFuZ2UgPSBmcm9tUmVjdFJhbmdlKGZvcm1hdFJlY3RSYW5nZShcbiAgICAgICAgICAgIHJlY3RSYW5nZVswXVswXSwgcmVjdFJhbmdlWzFdWzBdLCByZWN0UmFuZ2VbMF1bMV0sIHJlY3RSYW5nZVsxXVsxXVxuICAgICAgICApKTtcblxuICAgICAgICB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpO1xuICAgICAgICB0cmlnZ2VyKGNvbnRyb2xsZXIsIHtpc0VuZDogZmFsc2V9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmlmdFBvbHlnb24oY29udHJvbGxlciwgY292ZXIsIGR4LCBkeSwgZSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBjb3Zlci5fX2JydXNoT3B0aW9uLnJhbmdlO1xuICAgICAgICB2YXIgbG9jYWxEZWx0YSA9IHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpO1xuXG4gICAgICAgIGVhY2gocmFuZ2UsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgcG9pbnRbMF0gKz0gbG9jYWxEZWx0YVswXTtcbiAgICAgICAgICAgIHBvaW50WzFdICs9IGxvY2FsRGVsdGFbMV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgICAgIHRyaWdnZXIoY29udHJvbGxlciwge2lzRW5kOiBmYWxzZX0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpIHtcbiAgICAgICAgdmFyIHRoaXNHcm91cCA9IGNvbnRyb2xsZXIuZ3JvdXA7XG4gICAgICAgIHZhciBsb2NhbEQgPSB0aGlzR3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGR4LCBkeSk7XG4gICAgICAgIHZhciBsb2NhbFplcm8gPSB0aGlzR3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKDAsIDApO1xuXG4gICAgICAgIHJldHVybiBbbG9jYWxEWzBdIC0gbG9jYWxaZXJvWzBdLCBsb2NhbERbMV0gLSBsb2NhbFplcm9bMV1dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBkYXRhKSB7XG4gICAgICAgIHZhciBwYW5lbCA9IGdldFBhbmVsQnlDb3Zlcihjb250cm9sbGVyLCBjb3Zlcik7XG5cbiAgICAgICAgcmV0dXJuIChwYW5lbCAmJiBwYW5lbCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgID8gcGFuZWwuY2xpcFBhdGgoZGF0YSwgY29udHJvbGxlci5fdHJhbnNmb3JtKVxuICAgICAgICAgICAgOiB6clV0aWwuY2xvbmUoZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRzVG9SZWN0KHBvaW50cykge1xuICAgICAgICB2YXIgeG1pbiA9IG1hdGhNaW4ocG9pbnRzWzBdWzBdLCBwb2ludHNbMV1bMF0pO1xuICAgICAgICB2YXIgeW1pbiA9IG1hdGhNaW4ocG9pbnRzWzBdWzFdLCBwb2ludHNbMV1bMV0pO1xuICAgICAgICB2YXIgeG1heCA9IG1hdGhNYXgocG9pbnRzWzBdWzBdLCBwb2ludHNbMV1bMF0pO1xuICAgICAgICB2YXIgeW1heCA9IG1hdGhNYXgocG9pbnRzWzBdWzFdLCBwb2ludHNbMV1bMV0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4bWluLFxuICAgICAgICAgICAgeTogeW1pbixcbiAgICAgICAgICAgIHdpZHRoOiB4bWF4IC0geG1pbixcbiAgICAgICAgICAgIGhlaWdodDogeW1heCAtIHltaW5cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldEN1cnNvcihjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KSB7XG4gICAgICAgIC8vIENoZWNrIGFjdGl2ZVxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX2JydXNoVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gICAgICAgIHZhciBjb3ZlcnMgPSBjb250cm9sbGVyLl9jb3ZlcnM7XG4gICAgICAgIHZhciBjdXJyUGFuZWwgPSBnZXRQYW5lbEJ5UG9pbnQoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBpbiBjb3ZlcnMuXG4gICAgICAgIGlmICghY29udHJvbGxlci5fZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXJzW2ldLl9fYnJ1c2hPcHRpb247XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJQYW5lbFxuICAgICAgICAgICAgICAgICAgICAmJiAoY3VyclBhbmVsID09PSB0cnVlIHx8IGJydXNoT3B0aW9uLnBhbmVsSWQgPT09IGN1cnJQYW5lbC5wYW5lbElkKVxuICAgICAgICAgICAgICAgICAgICAmJiBjb3ZlclJlbmRlcmVyc1ticnVzaE9wdGlvbi5icnVzaFR5cGVdLmNvbnRhaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcnNbaV0sIGxvY2FsQ3Vyc29yUG9pbnRbMF0sIGxvY2FsQ3Vyc29yUG9pbnRbMV1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY3Vyc29yIHN0eWxlIHNldCBvbiBjb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJQYW5lbCAmJiB6ci5zZXRDdXJzb3JTdHlsZSgnY3Jvc3NoYWlyJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICAgICAgICB2YXIgcmF3RSA9IGUuZXZlbnQ7XG4gICAgICAgIHJhd0UucHJldmVudERlZmF1bHQgJiYgcmF3RS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1haW5TaGFwZUNvbnRhaW4oY292ZXIsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGNvdmVyLmNoaWxkT2ZOYW1lKCdtYWluJykuY29udGFpbih4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb3ZlckJ5TW91c2UoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCwgaXNFbmQpIHtcbiAgICAgICAgdmFyIGNyZWF0aW5nQ292ZXIgPSBjb250cm9sbGVyLl9jcmVhdGluZ0NvdmVyO1xuICAgICAgICB2YXIgcGFuZWwgPSBjb250cm9sbGVyLl9jcmVhdGluZ1BhbmVsO1xuICAgICAgICB2YXIgdGhpc0JydXNoT3B0aW9uID0gY29udHJvbGxlci5fYnJ1c2hPcHRpb247XG4gICAgICAgIHZhciBldmVudFBhcmFtcztcblxuICAgICAgICBjb250cm9sbGVyLl90cmFjay5wdXNoKGxvY2FsQ3Vyc29yUG9pbnQuc2xpY2UoKSk7XG5cbiAgICAgICAgaWYgKHNob3VsZFNob3dDb3Zlcihjb250cm9sbGVyKSB8fCBjcmVhdGluZ0NvdmVyKSB7XG5cbiAgICAgICAgICAgIGlmIChwYW5lbCAmJiAhY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXNCcnVzaE9wdGlvbi5icnVzaE1vZGUgPT09ICdzaW5nbGUnICYmIGNsZWFyQ292ZXJzKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIHZhciBicnVzaE9wdGlvbiA9IHpyVXRpbC5jbG9uZSh0aGlzQnJ1c2hPcHRpb24pO1xuICAgICAgICAgICAgICAgIGJydXNoT3B0aW9uLmJydXNoVHlwZSA9IGRldGVybWluZUJydXNoVHlwZShicnVzaE9wdGlvbi5icnVzaFR5cGUsIHBhbmVsKTtcbiAgICAgICAgICAgICAgICBicnVzaE9wdGlvbi5wYW5lbElkID0gcGFuZWwgPT09IHRydWUgPyBudWxsIDogcGFuZWwucGFuZWxJZDtcbiAgICAgICAgICAgICAgICBjcmVhdGluZ0NvdmVyID0gY29udHJvbGxlci5fY3JlYXRpbmdDb3ZlciA9IGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLl9jb3ZlcnMucHVzaChjcmVhdGluZ0NvdmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY292ZXJSZW5kZXJlciA9IGNvdmVyUmVuZGVyZXJzW2RldGVybWluZUJydXNoVHlwZShjb250cm9sbGVyLl9icnVzaFR5cGUsIHBhbmVsKV07XG4gICAgICAgICAgICAgICAgdmFyIGNvdmVyQnJ1c2hPcHRpb24gPSBjcmVhdGluZ0NvdmVyLl9fYnJ1c2hPcHRpb247XG5cbiAgICAgICAgICAgICAgICBjb3ZlckJydXNoT3B0aW9uLnJhbmdlID0gY292ZXJSZW5kZXJlci5nZXRDcmVhdGluZ1JhbmdlKFxuICAgICAgICAgICAgICAgICAgICBjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyLCBjb250cm9sbGVyLl90cmFjaylcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb3ZlclJlbmRlcmVyLnVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMgPSB7aXNFbmQ6IGlzRW5kfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIGlzRW5kXG4gICAgICAgICAgICAmJiB0aGlzQnJ1c2hPcHRpb24uYnJ1c2hNb2RlID09PSAnc2luZ2xlJ1xuICAgICAgICAgICAgJiYgdGhpc0JydXNoT3B0aW9uLnJlbW92ZU9uQ2xpY2tcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBIZWxwIHVzZXIgdG8gcmVtb3ZlIGNvdmVycyBlYXNpbHksIG9ubHkgYnkgYSB0aW55IGRyYWcsIGluICdzaW5nbGUnIG1vZGUuXG4gICAgICAgICAgICAvLyBCdXQgYSBzaW5nbGUgY2xpY2sgZG8gbm90IGNsZWFyIGNvdmVycywgYmVjYXVzZSB1c2VyIG1heSBoYXZlIGNhc3VhbFxuICAgICAgICAgICAgLy8gY2xpY2tzIChmb3IgZXhhbXBsZSwgY2xpY2sgb24gb3RoZXIgY29tcG9uZW50IGFuZCBkbyBub3QgZXhwZWN0IGNvdmVyc1xuICAgICAgICAgICAgLy8gZGlzYXBwZWFyKS5cbiAgICAgICAgICAgIC8vIE9ubHkgc29tZSBjb3ZlciByZW1vdmVkLCB0cmlnZ2VyIGFjdGlvbiwgYnV0IG5vdCBldmVyeSBjbGljayB0cmlnZ2VyIGFjdGlvbi5cbiAgICAgICAgICAgIGlmIChnZXRQYW5lbEJ5UG9pbnQoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCkgJiYgY2xlYXJDb3ZlcnMoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgICBldmVudFBhcmFtcyA9IHtpc0VuZDogaXNFbmQsIHJlbW92ZU9uQ2xpY2s6IHRydWV9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50UGFyYW1zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVybWluZUJydXNoVHlwZShicnVzaFR5cGUsIHBhbmVsKSB7XG4gICAgICAgIGlmIChicnVzaFR5cGUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgICBwYW5lbCAmJiBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlLFxuICAgICAgICAgICAgICAgICAgICAnTVVTVCBoYXZlIGRlZmF1bHRCcnVzaFR5cGUgd2hlbiBicnVzaFR5cGUgaXMgXCJhdHVvXCInXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBicnVzaFR5cGU7XG4gICAgfVxuXG4gICAgdmFyIG1vdXNlSGFuZGxlcnMgPSB7XG5cbiAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBzb21lIGJyb3dzZXIgZG8gbm90IHN1cHBvcnQgZ2xvYmFsT3V0LFxuICAgICAgICAgICAgICAgIC8vIGFuZCByZWxlYXNlIG1vc2Ugb3V0IHNpZGUgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgaGFuZGxlRHJhZ0VuZC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWUudGFyZ2V0IHx8ICFlLnRhcmdldC5kcmFnZ2FibGUpIHtcblxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGluZ0NvdmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZWwgPSB0aGlzLl9jcmVhdGluZ1BhbmVsID0gZ2V0UGFuZWxCeVBvaW50KHRoaXMsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhY2sgPSBbbG9jYWxDdXJzb3JQb2ludC5zbGljZSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG5cbiAgICAgICAgICAgIHJlc2V0Q3Vyc29yKHRoaXMsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcpIHtcblxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50UGFyYW1zID0gdXBkYXRlQ292ZXJCeU1vdXNlKHRoaXMsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zICYmIHRyaWdnZXIodGhpcywgZXZlbnRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNldXA6IGhhbmRsZURyYWdFbmQgLy8sXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gaW4gdG9vbHRpcCwgZ2xvYmFsb3V0IHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkLlxuICAgICAgICAvLyBnbG9iYWxvdXQ6IGhhbmRsZURyYWdFbmRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnZ2luZykge1xuXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgICAgICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgICAgICAgICB2YXIgZXZlbnRQYXJhbXMgPSB1cGRhdGVDb3ZlckJ5TW91c2UodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90cmFjayA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRpbmdDb3ZlciA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgZXZlbnQgc2hvdWxlIGJlIGF0IGZpbmFsLCBhZnRlciBwcm9jZWR1cmUgd2lsbCBiZSBuZXN0ZWQuXG4gICAgICAgICAgICBldmVudFBhcmFtcyAmJiB0cmlnZ2VyKHRoaXMsIGV2ZW50UGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGtleTogYnJ1c2hUeXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgY292ZXJSZW5kZXJlcnMgPSB7XG5cbiAgICAgICAgbGluZVg6IGdldExpbmVSZW5kZXJlcigwKSxcblxuICAgICAgICBsaW5lWTogZ2V0TGluZVJlbmRlcmVyKDEpLFxuXG4gICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgIGNyZWF0ZUNvdmVyOiBmdW5jdGlvbiAoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQmFzZVJlY3RDb3ZlcihcbiAgICAgICAgICAgICAgICAgICAgY3VycnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmlmdFJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICBicnVzaE9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgWyd3JywgJ2UnLCAnbicsICdzJywgJ3NlJywgJ3N3JywgJ25lJywgJ253J11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHMgPSBnZXRUcmFja0VuZHMobG9jYWxUcmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFJlY3RSYW5nZShlbmRzWzFdWzBdLCBlbmRzWzFdWzFdLCBlbmRzWzBdWzBdLCBlbmRzWzBdWzFdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQmFzZVJlY3QoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVDb21tb246IHVwZGF0ZUNvbW1vbixcbiAgICAgICAgICAgIGNvbnRhaW46IG1haW5TaGFwZUNvbnRhaW5cbiAgICAgICAgfSxcblxuICAgICAgICBwb2x5Z29uOiB7XG4gICAgICAgICAgICBjcmVhdGVDb3ZlcjogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB1c2UgZ3JhcGhpYy5Qb2x5Z29uIGJlY2F1c2UgZ3JhcGhpYy5Qb2x5bGluZSBkbyBub3QgY2xvc2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gYm9yZGVyIG9mIHRoZSBzaGFwZSB3aGVuIGRyYXdpbmcsIHdoaWNoIGlzIGEgYmV0dGVyIGV4cGVyaWVuY2UgZm9yIHVzZXIuXG4gICAgICAgICAgICAgICAgY292ZXIuYWRkKG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogbWFrZVN0eWxlKGJydXNoT3B0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdmVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsVHJhY2s7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kQ3JlYXRpbmc6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3Zlcikge1xuICAgICAgICAgICAgICAgIGNvdmVyLnJlbW92ZShjb3Zlci5jaGlsZEF0KDApKTtcbiAgICAgICAgICAgICAgICAvLyBVc2UgZ3JhcGhpYy5Qb2x5Z29uIGNsb3NlIHRoZSBzaGFwZS5cbiAgICAgICAgICAgICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkcmlmdDogY3VycnkoZHJpZnRQb2x5Z29uLCBjb250cm9sbGVyLCBjb3ZlciksXG4gICAgICAgICAgICAgICAgICAgIG9uZHJhZ2VuZDogY3VycnkodHJpZ2dlciwgY29udHJvbGxlciwge2lzRW5kOiB0cnVlfSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlQ292ZXJTaGFwZTogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlLCBicnVzaE9wdGlvbikge1xuICAgICAgICAgICAgICAgIGNvdmVyLmNoaWxkQXQoMCkuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUNvbW1vbjogdXBkYXRlQ29tbW9uLFxuICAgICAgICAgICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldExpbmVSZW5kZXJlcih4eUluZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVDb3ZlcjogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJhc2VSZWN0Q292ZXIoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJpZnRSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RSYW5nZSA9IFtyYW5nZSwgWzAsIDEwMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh5SW5kZXggJiYgcmVjdFJhbmdlLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZWN0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFJhbmdlW3h5SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICBicnVzaE9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgW1sndycsICdlJ10sIFsnbicsICdzJ11dW3h5SW5kZXhdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDcmVhdGluZ1JhbmdlOiBmdW5jdGlvbiAobG9jYWxUcmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBlbmRzID0gZ2V0VHJhY2tFbmRzKGxvY2FsVHJhY2spO1xuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBtYXRoTWluKGVuZHNbMF1beHlJbmRleF0sIGVuZHNbMV1beHlJbmRleF0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSBtYXRoTWF4KGVuZHNbMF1beHlJbmRleF0sIGVuZHNbMV1beHlJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlQ292ZXJTaGFwZTogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlLCBicnVzaE9wdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckV4dGVudDtcbiAgICAgICAgICAgICAgICAvLyBJZiBicnVzaFdpZHRoIG5vdCBzcGVjaWZpZWQsIGZpdCB0aGUgcGFuZWwuXG4gICAgICAgICAgICAgICAgdmFyIHBhbmVsID0gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZWwgIT09IHRydWUgJiYgcGFuZWwuZ2V0TGluZWFyQnJ1c2hPdGhlckV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICBvdGhlckV4dGVudCA9IHBhbmVsLmdldExpbmVhckJydXNoT3RoZXJFeHRlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB4eUluZGV4LCBjb250cm9sbGVyLl90cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6ciA9IGNvbnRyb2xsZXIuX3pyO1xuICAgICAgICAgICAgICAgICAgICBvdGhlckV4dGVudCA9IFswLCBbenIuZ2V0V2lkdGgoKSwgenIuZ2V0SGVpZ2h0KCldWzEgLSB4eUluZGV4XV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZWN0UmFuZ2UgPSBbbG9jYWxSYW5nZSwgb3RoZXJFeHRlbnRdO1xuICAgICAgICAgICAgICAgIHh5SW5kZXggJiYgcmVjdFJhbmdlLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZUJhc2VSZWN0KGNvbnRyb2xsZXIsIGNvdmVyLCByZWN0UmFuZ2UsIGJydXNoT3B0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVDb21tb246IHVwZGF0ZUNvbW1vbixcbiAgICAgICAgICAgIGNvbnRhaW46IG1haW5TaGFwZUNvbnRhaW5cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJydXNoQ29udHJvbGxlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var modelUtil = __webpack_require__(4);\n    var brushHelper = __webpack_require__(135);\n\n    var each = zrUtil.each;\n    var indexOf = zrUtil.indexOf;\n    var curry = zrUtil.curry;\n\n    var COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n\n    // FIXME\n    // how to genarialize to more coordinate systems.\n    var INCLUDE_FINDER_MAIN_TYPES = [\n        'grid', 'xAxis', 'yAxis', 'geo', 'graph',\n        'polar', 'radiusAxis', 'angleAxis', 'bmap'\n    ];\n\n    /**\n     * [option in constructor]:\n     * {\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     * }\n     *\n     *\n     * [targetInfo]:\n     *\n     * There can be multiple axes in a single targetInfo. Consider the case\n     * of `grid` component, a targetInfo represents a grid which contains one or more\n     * cartesian and one or more axes. And consider the case of parallel system,\n     * which has multiple axes in a coordinate system.\n     * Can be {\n     *     panelId: ...,\n     *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n     *     coordSyses: all cartesians.\n     *     gridModel: <grid component>\n     *     xAxes: correspond to coordSyses on index\n     *     yAxes: correspond to coordSyses on index\n     * }\n     * or {\n     *     panelId: ...,\n     *     coordSys: <geo coord sys>\n     *     coordSyses: [<geo coord sys>]\n     *     geoModel: <geo component>\n     * }\n     *\n     *\n     * [panelOpt]:\n     *\n     * Make from targetInfo. Input to BrushController.\n     * {\n     *     panelId: ...,\n     *     rect: ...\n     * }\n     *\n     *\n     * [area]:\n     *\n     * Generated by BrushController or user input.\n     * {\n     *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n     *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     *     range: pixel range.\n     *     coordRange: representitive coord range (the first one of coordRanges).\n     *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n     * }\n     */\n\n    /**\n     * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n     *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} [opt]\n     * @param {Array.<string>} [opt.include] include coordinate system types.\n     */\n    function BrushTargetManager(option, ecModel, opt) {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        var targetInfoList = this._targetInfoList = [];\n        var info = {};\n        var foundCpts = parseFinder(ecModel, option);\n\n        each(targetInfoBuilders, function (builder, type) {\n            if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n                builder(foundCpts, targetInfoList, info);\n            }\n        });\n    }\n\n    var proto = BrushTargetManager.prototype;\n\n    proto.setOutputRanges = function (areas, ecModel) {\n        this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            (area.coordRanges || (area.coordRanges = [])).push(coordRange);\n            // area.coordRange is the first of area.coordRanges\n            if (!area.coordRange) {\n                area.coordRange = coordRange;\n                // In 'category' axis, coord to pixel is not reversible, so we can not\n                // rebuild range by coordRange accrately, which may bring trouble when\n                // brushing only one item. So we use __rangeOffset to rebuilding range\n                // by coordRange. And this it only used in brush component so it is no\n                // need to be adapted to coordRanges.\n                var result = coordConvert[area.brushType](0, coordSys, coordRange);\n                area.__rangeOffset = {\n                    offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n                    xyMinMax: result.xyMinMax\n                };\n            }\n        });\n    };\n\n    proto.matchOutputRanges = function (areas, ecModel, cb) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (targetInfo && targetInfo !== true) {\n                zrUtil.each(\n                    targetInfo.coordSyses,\n                    function (coordSys) {\n                        var result = coordConvert[area.brushType](1, coordSys, area.range);\n                        cb(area, result.values, coordSys, ecModel);\n                    }\n                );\n            }\n        }, this);\n    };\n\n    proto.setInputRanges = function (areas, ecModel) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (__DEV__) {\n                zrUtil.assert(\n                    !targetInfo || targetInfo === true || area.coordRange,\n                    'coordRange must be specified when coord index specified.'\n                );\n                zrUtil.assert(\n                    !targetInfo || targetInfo !== true || area.range,\n                    'range must be specified in global brush.'\n                );\n            }\n\n            area.range = area.range || [];\n\n            // convert coordRange to global range and set panelId.\n            if (targetInfo && targetInfo !== true) {\n                area.panelId = targetInfo.panelId;\n                // (1) area.range shoule always be calculate from coordRange but does\n                // not keep its original value, for the sake of the dataZoom scenario,\n                // where area.coordRange remains unchanged but area.range may be changed.\n                // (2) Only support converting one coordRange to pixel range in brush\n                // component. So do not consider `coordRanges`.\n                // (3) About __rangeOffset, see comment above.\n                var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n                var rangeOffset = area.__rangeOffset;\n                area.range = rangeOffset\n                    ? diffProcessor[area.brushType](\n                        result.values,\n                        rangeOffset.offset,\n                        getScales(result.xyMinMax, rangeOffset.xyMinMax)\n                    )\n                    : result.values;\n            }\n        }, this);\n    };\n\n    proto.makePanelOpts = function (api, getDefaultBrushType) {\n        return zrUtil.map(this._targetInfoList, function (targetInfo) {\n            var rect = targetInfo.getPanelRect();\n            return {\n                panelId: targetInfo.panelId,\n                defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n                clipPath: brushHelper.makeRectPanelClipPath(rect),\n                isTargetByCursor: brushHelper.makeRectIsTargetByCursor(\n                    rect, api, targetInfo.coordSysModel\n                ),\n                getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n            };\n        });\n    };\n\n    proto.controlSeries = function (area, seriesModel, ecModel) {\n        // Check whether area is bound in coord, and series do not belong to that coord.\n        // If do not do this check, some brush (like lineX) will controll all axes.\n        var targetInfo = this.findTargetInfo(area, ecModel);\n        return targetInfo === true || (\n            targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0\n        );\n    };\n\n    /**\n     * If return Object, a coord found.\n     * If reutrn true, global found.\n     * Otherwise nothing found.\n     *\n     * @param {Object} area\n     * @param {Array} targetInfoList\n     * @return {Obejct|boolean}\n     */\n    proto.findTargetInfo = function (area, ecModel) {\n        var targetInfoList = this._targetInfoList;\n        var foundCpts = parseFinder(ecModel, area);\n\n        for (var i = 0; i < targetInfoList.length; i++) {\n            var targetInfo = targetInfoList[i];\n            var areaPanelId = area.panelId;\n            if (areaPanelId) {\n                if (targetInfo.panelId === areaPanelId) {\n                    return targetInfo;\n                }\n            }\n            else {\n                for (var i = 0; i < targetInfoMatchers.length; i++) {\n                    if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n                        return targetInfo;\n                    }\n                }\n            }\n        }\n\n        return true;\n    };\n\n    function formatMinMax(minMax) {\n        minMax[0] > minMax[1] && minMax.reverse();\n        return minMax;\n    }\n\n    function parseFinder(ecModel, option) {\n        return modelUtil.parseFinder(\n            ecModel, option, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES}\n        );\n    }\n\n    var targetInfoBuilders = {\n\n        grid: function (foundCpts, targetInfoList) {\n            var xAxisModels = foundCpts.xAxisModels;\n            var yAxisModels = foundCpts.yAxisModels;\n            var gridModels = foundCpts.gridModels;\n            // Remove duplicated.\n            var gridModelMap = zrUtil.createHashMap();\n            var xAxesHas = {};\n            var yAxesHas = {};\n\n            if (!xAxisModels && !yAxisModels && !gridModels) {\n                return;\n            }\n\n            each(xAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap.set(gridModel.id, gridModel);\n                xAxesHas[gridModel.id] = true;\n            });\n            each(yAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap.set(gridModel.id, gridModel);\n                yAxesHas[gridModel.id] = true;\n            });\n            each(gridModels, function (gridModel) {\n                gridModelMap.set(gridModel.id, gridModel);\n                xAxesHas[gridModel.id] = true;\n                yAxesHas[gridModel.id] = true;\n            });\n\n            gridModelMap.each(function (gridModel) {\n                var grid = gridModel.coordinateSystem;\n                var cartesians = [];\n\n                each(grid.getCartesians(), function (cartesian, index) {\n                    if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0\n                        || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0\n                    ) {\n                        cartesians.push(cartesian);\n                    }\n                });\n                targetInfoList.push({\n                    panelId: 'grid--' + gridModel.id,\n                    gridModel: gridModel,\n                    coordSysModel: gridModel,\n                    // Use the first one as the representitive coordSys.\n                    coordSys: cartesians[0],\n                    coordSyses: cartesians,\n                    getPanelRect: panelRectBuilder.grid,\n                    xAxisDeclared: xAxesHas[gridModel.id],\n                    yAxisDeclared: yAxesHas[gridModel.id]\n                });\n            });\n        },\n\n        geo: function (foundCpts, targetInfoList) {\n            each(foundCpts.geoModels, function (geoModel) {\n                var coordSys = geoModel.coordinateSystem;\n                targetInfoList.push({\n                    panelId: 'geo--' + geoModel.id,\n                    geoModel: geoModel,\n                    coordSysModel: geoModel,\n                    coordSys: coordSys,\n                    coordSyses: [coordSys],\n                    getPanelRect: panelRectBuilder.geo\n                });\n            });\n        }\n    };\n\n    var targetInfoMatchers = [\n\n        // grid\n        function (foundCpts, targetInfo) {\n            var xAxisModel = foundCpts.xAxisModel;\n            var yAxisModel = foundCpts.yAxisModel;\n            var gridModel = foundCpts.gridModel;\n\n            !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n            !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n\n            return gridModel && gridModel === targetInfo.gridModel;\n        },\n\n        // geo\n        function (foundCpts, targetInfo) {\n            var geoModel = foundCpts.geoModel;\n            return geoModel && geoModel === targetInfo.geoModel;\n        }\n    ];\n\n    var panelRectBuilder = {\n\n        grid: function () {\n            // grid is not Transformable.\n            return this.coordSys.grid.getRect().clone();\n        },\n\n        geo: function () {\n            var coordSys = this.coordSys;\n            var rect = coordSys.getBoundingRect().clone();\n            // geo roam and zoom transform\n            rect.applyTransform(graphic.getTransform(coordSys));\n            return rect;\n        }\n    };\n\n    var coordConvert = {\n\n        lineX: curry(axisConvert, 0),\n\n        lineY: curry(axisConvert, 1),\n\n        rect: function (to, coordSys, rangeOrCoordRange) {\n            var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n            var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n            var values = [\n                formatMinMax([xminymin[0], xmaxymax[0]]),\n                formatMinMax([xminymin[1], xmaxymax[1]])\n            ];\n            return {values: values, xyMinMax: values};\n        },\n\n        polygon: function (to, coordSys, rangeOrCoordRange) {\n            var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n            var values = zrUtil.map(rangeOrCoordRange, function (item) {\n                var p = coordSys[COORD_CONVERTS[to]](item);\n                xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n                xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n                xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n                xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n                return p;\n            });\n            return {values: values, xyMinMax: xyMinMax};\n        }\n    };\n\n    function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n        if (__DEV__) {\n            zrUtil.assert(\n                coordSys.type === 'cartesian2d',\n                'lineX/lineY brush is available only in cartesian2d.'\n            );\n        }\n\n        var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n        var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n            return to\n                ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]))\n                : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n        }));\n        var xyMinMax = [];\n        xyMinMax[axisNameIndex] = values;\n        xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n\n        return {values: values, xyMinMax: xyMinMax};\n    }\n\n    var diffProcessor = {\n        lineX: curry(axisDiffProcessor, 0),\n\n        lineY: curry(axisDiffProcessor, 1),\n\n        rect: function (values, refer, scales) {\n            return [\n                [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]],\n                [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]\n            ];\n        },\n\n        polygon: function (values, refer, scales) {\n            return zrUtil.map(values, function (item, idx) {\n                return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n            });\n        }\n    };\n\n    function axisDiffProcessor(axisNameIndex, values, refer, scales) {\n        return [\n            values[0] - scales[axisNameIndex] * refer[0],\n            values[1] - scales[axisNameIndex] * refer[1]\n        ];\n    }\n\n    // We have to process scale caused by dataZoom manually,\n    // although it might be not accurate.\n    function getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n        var sizeCurr = getSize(xyMinMaxCurr);\n        var sizeOrigin = getSize(xyMinMaxOrigin);\n        var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n        isNaN(scales[0]) && (scales[0] = 1);\n        isNaN(scales[1]) && (scales[1] = 1);\n        return scales;\n    }\n\n    function getSize(xyMinMax) {\n        return xyMinMax\n            ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]]\n            : [NaN, NaN];\n    }\n\n    module.exports = BrushTargetManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyLmpzPzFkY2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsMkJBQTJCLHNCQUFzQixTQUFTO0FBQzFELGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgYnJ1c2hIZWxwZXIgPSByZXF1aXJlKCcuL2JydXNoSGVscGVyJyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBpbmRleE9mID0genJVdGlsLmluZGV4T2Y7XG4gICAgdmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xuXG4gICAgdmFyIENPT1JEX0NPTlZFUlRTID0gWydkYXRhVG9Qb2ludCcsICdwb2ludFRvRGF0YSddO1xuXG4gICAgLy8gRklYTUVcbiAgICAvLyBob3cgdG8gZ2VuYXJpYWxpemUgdG8gbW9yZSBjb29yZGluYXRlIHN5c3RlbXMuXG4gICAgdmFyIElOQ0xVREVfRklOREVSX01BSU5fVFlQRVMgPSBbXG4gICAgICAgICdncmlkJywgJ3hBeGlzJywgJ3lBeGlzJywgJ2dlbycsICdncmFwaCcsXG4gICAgICAgICdwb2xhcicsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdibWFwJ1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBbb3B0aW9uIGluIGNvbnN0cnVjdG9yXTpcbiAgICAgKiB7XG4gICAgICogICAgIEluZGV4L0lkL05hbWUgb2YgZ2VvLCB4QXhpcywgeUF4aXMsIGdyaWQ6IFNlZSB1dGlsL21vZGVsI3BhcnNlRmluZGVyLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqXG4gICAgICogW3RhcmdldEluZm9dOlxuICAgICAqXG4gICAgICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIGF4ZXMgaW4gYSBzaW5nbGUgdGFyZ2V0SW5mby4gQ29uc2lkZXIgdGhlIGNhc2VcbiAgICAgKiBvZiBgZ3JpZGAgY29tcG9uZW50LCBhIHRhcmdldEluZm8gcmVwcmVzZW50cyBhIGdyaWQgd2hpY2ggY29udGFpbnMgb25lIG9yIG1vcmVcbiAgICAgKiBjYXJ0ZXNpYW4gYW5kIG9uZSBvciBtb3JlIGF4ZXMuIEFuZCBjb25zaWRlciB0aGUgY2FzZSBvZiBwYXJhbGxlbCBzeXN0ZW0sXG4gICAgICogd2hpY2ggaGFzIG11bHRpcGxlIGF4ZXMgaW4gYSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBDYW4gYmUge1xuICAgICAqICAgICBwYW5lbElkOiAuLi4sXG4gICAgICogICAgIGNvb3JkU3lzOiA8YSByZXByZXNlbnRpdGl2ZSBjYXJ0ZXNpYW4gaW4gZ3JpZCAoZmlyc3QgY2FydGVzaWFuIGJ5IGRlZmF1bHQpPixcbiAgICAgKiAgICAgY29vcmRTeXNlczogYWxsIGNhcnRlc2lhbnMuXG4gICAgICogICAgIGdyaWRNb2RlbDogPGdyaWQgY29tcG9uZW50PlxuICAgICAqICAgICB4QXhlczogY29ycmVzcG9uZCB0byBjb29yZFN5c2VzIG9uIGluZGV4XG4gICAgICogICAgIHlBeGVzOiBjb3JyZXNwb25kIHRvIGNvb3JkU3lzZXMgb24gaW5kZXhcbiAgICAgKiB9XG4gICAgICogb3Ige1xuICAgICAqICAgICBwYW5lbElkOiAuLi4sXG4gICAgICogICAgIGNvb3JkU3lzOiA8Z2VvIGNvb3JkIHN5cz5cbiAgICAgKiAgICAgY29vcmRTeXNlczogWzxnZW8gY29vcmQgc3lzPl1cbiAgICAgKiAgICAgZ2VvTW9kZWw6IDxnZW8gY29tcG9uZW50PlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqXG4gICAgICogW3BhbmVsT3B0XTpcbiAgICAgKlxuICAgICAqIE1ha2UgZnJvbSB0YXJnZXRJbmZvLiBJbnB1dCB0byBCcnVzaENvbnRyb2xsZXIuXG4gICAgICoge1xuICAgICAqICAgICBwYW5lbElkOiAuLi4sXG4gICAgICogICAgIHJlY3Q6IC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqXG4gICAgICogW2FyZWFdOlxuICAgICAqXG4gICAgICogR2VuZXJhdGVkIGJ5IEJydXNoQ29udHJvbGxlciBvciB1c2VyIGlucHV0LlxuICAgICAqIHtcbiAgICAgKiAgICAgcGFuZWxJZDogVXNlZCB0byBsb2NhdGUgY29vcmRJbmZvIGRpcmVjdGx5LiBJZiB1c2VyIGlucHB1dCwgbm8gcGFuZWxJZC5cbiAgICAgKiAgICAgYnJ1c2hUeXBlOiBkZXRlcm1pbmUgaG93IHRvIGNvbnZlcnQgdG8vZnJvbSBjb29yZCgncmVjdCcgb3IgJ3BvbHlnb24nIG9yICdsaW5lWC9ZJykuXG4gICAgICogICAgIEluZGV4L0lkL05hbWUgb2YgZ2VvLCB4QXhpcywgeUF4aXMsIGdyaWQ6IFNlZSB1dGlsL21vZGVsI3BhcnNlRmluZGVyLlxuICAgICAqICAgICByYW5nZTogcGl4ZWwgcmFuZ2UuXG4gICAgICogICAgIGNvb3JkUmFuZ2U6IHJlcHJlc2VudGl0aXZlIGNvb3JkIHJhbmdlICh0aGUgZmlyc3Qgb25lIG9mIGNvb3JkUmFuZ2VzKS5cbiAgICAgKiAgICAgY29vcmRSYW5nZXM6IDxBcnJheT4gY29vcmQgcmFuZ2VzLCB1c2VkIGluIG11bHRpcGxlIGNhcnRlc2lhbiBpbiBvbmUgZ3JpZC5cbiAgICAgKiB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uIGNvbnRhaW5zIEluZGV4L0lkL05hbWUgb2YgeEF4aXMveUF4aXMvZ2VvL2dyaWRcbiAgICAgKiAgICAgICAgRWFjaCBjYW4gYmUge251bWJlcnxBcnJheS48bnVtYmVyPn0uIGxpa2U6IHt4QXhpc0luZGV4OiBbMywgNF19XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbb3B0LmluY2x1ZGVdIGluY2x1ZGUgY29vcmRpbmF0ZSBzeXN0ZW0gdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQnJ1c2hUYXJnZXRNYW5hZ2VyKG9wdGlvbiwgZWNNb2RlbCwgb3B0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGFyZ2V0SW5mb0xpc3QgPSB0aGlzLl90YXJnZXRJbmZvTGlzdCA9IFtdO1xuICAgICAgICB2YXIgaW5mbyA9IHt9O1xuICAgICAgICB2YXIgZm91bmRDcHRzID0gcGFyc2VGaW5kZXIoZWNNb2RlbCwgb3B0aW9uKTtcblxuICAgICAgICBlYWNoKHRhcmdldEluZm9CdWlsZGVycywgZnVuY3Rpb24gKGJ1aWxkZXIsIHR5cGUpIHtcbiAgICAgICAgICAgIGlmICghb3B0IHx8ICFvcHQuaW5jbHVkZSB8fCBpbmRleE9mKG9wdC5pbmNsdWRlLCB0eXBlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRlcihmb3VuZENwdHMsIHRhcmdldEluZm9MaXN0LCBpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gQnJ1c2hUYXJnZXRNYW5hZ2VyLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnNldE91dHB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCkge1xuICAgICAgICB0aGlzLm1hdGNoT3V0cHV0UmFuZ2VzKGFyZWFzLCBlY01vZGVsLCBmdW5jdGlvbiAoYXJlYSwgY29vcmRSYW5nZSwgY29vcmRTeXMpIHtcbiAgICAgICAgICAgIChhcmVhLmNvb3JkUmFuZ2VzIHx8IChhcmVhLmNvb3JkUmFuZ2VzID0gW10pKS5wdXNoKGNvb3JkUmFuZ2UpO1xuICAgICAgICAgICAgLy8gYXJlYS5jb29yZFJhbmdlIGlzIHRoZSBmaXJzdCBvZiBhcmVhLmNvb3JkUmFuZ2VzXG4gICAgICAgICAgICBpZiAoIWFyZWEuY29vcmRSYW5nZSkge1xuICAgICAgICAgICAgICAgIGFyZWEuY29vcmRSYW5nZSA9IGNvb3JkUmFuZ2U7XG4gICAgICAgICAgICAgICAgLy8gSW4gJ2NhdGVnb3J5JyBheGlzLCBjb29yZCB0byBwaXhlbCBpcyBub3QgcmV2ZXJzaWJsZSwgc28gd2UgY2FuIG5vdFxuICAgICAgICAgICAgICAgIC8vIHJlYnVpbGQgcmFuZ2UgYnkgY29vcmRSYW5nZSBhY2NyYXRlbHksIHdoaWNoIG1heSBicmluZyB0cm91YmxlIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBicnVzaGluZyBvbmx5IG9uZSBpdGVtLiBTbyB3ZSB1c2UgX19yYW5nZU9mZnNldCB0byByZWJ1aWxkaW5nIHJhbmdlXG4gICAgICAgICAgICAgICAgLy8gYnkgY29vcmRSYW5nZS4gQW5kIHRoaXMgaXQgb25seSB1c2VkIGluIGJydXNoIGNvbXBvbmVudCBzbyBpdCBpcyBub1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgYWRhcHRlZCB0byBjb29yZFJhbmdlcy5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29vcmRDb252ZXJ0W2FyZWEuYnJ1c2hUeXBlXSgwLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgICAgICAgICAgICAgYXJlYS5fX3JhbmdlT2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGRpZmZQcm9jZXNzb3JbYXJlYS5icnVzaFR5cGVdKHJlc3VsdC52YWx1ZXMsIGFyZWEucmFuZ2UsIFsxLCAxXSksXG4gICAgICAgICAgICAgICAgICAgIHh5TWluTWF4OiByZXN1bHQueHlNaW5NYXhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJvdG8ubWF0Y2hPdXRwdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwsIGNiKSB7XG4gICAgICAgIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRJbmZvICYmIHRhcmdldEluZm8gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5mby5jb29yZFN5c2VzLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb29yZENvbnZlcnRbYXJlYS5icnVzaFR5cGVdKDEsIGNvb3JkU3lzLCBhcmVhLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGFyZWEsIHJlc3VsdC52YWx1ZXMsIGNvb3JkU3lzLCBlY01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBwcm90by5zZXRJbnB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCkge1xuICAgICAgICBlYWNoKGFyZWFzLCBmdW5jdGlvbiAoYXJlYSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgICF0YXJnZXRJbmZvIHx8IHRhcmdldEluZm8gPT09IHRydWUgfHwgYXJlYS5jb29yZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAnY29vcmRSYW5nZSBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkIGluZGV4IHNwZWNpZmllZC4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgICAhdGFyZ2V0SW5mbyB8fCB0YXJnZXRJbmZvICE9PSB0cnVlIHx8IGFyZWEucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdyYW5nZSBtdXN0IGJlIHNwZWNpZmllZCBpbiBnbG9iYWwgYnJ1c2guJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFyZWEucmFuZ2UgPSBhcmVhLnJhbmdlIHx8IFtdO1xuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGNvb3JkUmFuZ2UgdG8gZ2xvYmFsIHJhbmdlIGFuZCBzZXQgcGFuZWxJZC5cbiAgICAgICAgICAgIGlmICh0YXJnZXRJbmZvICYmIHRhcmdldEluZm8gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBhcmVhLnBhbmVsSWQgPSB0YXJnZXRJbmZvLnBhbmVsSWQ7XG4gICAgICAgICAgICAgICAgLy8gKDEpIGFyZWEucmFuZ2Ugc2hvdWxlIGFsd2F5cyBiZSBjYWxjdWxhdGUgZnJvbSBjb29yZFJhbmdlIGJ1dCBkb2VzXG4gICAgICAgICAgICAgICAgLy8gbm90IGtlZXAgaXRzIG9yaWdpbmFsIHZhbHVlLCBmb3IgdGhlIHNha2Ugb2YgdGhlIGRhdGFab29tIHNjZW5hcmlvLFxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGFyZWEuY29vcmRSYW5nZSByZW1haW5zIHVuY2hhbmdlZCBidXQgYXJlYS5yYW5nZSBtYXkgYmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAvLyAoMikgT25seSBzdXBwb3J0IGNvbnZlcnRpbmcgb25lIGNvb3JkUmFuZ2UgdG8gcGl4ZWwgcmFuZ2UgaW4gYnJ1c2hcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQuIFNvIGRvIG5vdCBjb25zaWRlciBgY29vcmRSYW5nZXNgLlxuICAgICAgICAgICAgICAgIC8vICgzKSBBYm91dCBfX3JhbmdlT2Zmc2V0LCBzZWUgY29tbWVudCBhYm92ZS5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29vcmRDb252ZXJ0W2FyZWEuYnJ1c2hUeXBlXSgwLCB0YXJnZXRJbmZvLmNvb3JkU3lzLCBhcmVhLmNvb3JkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZU9mZnNldCA9IGFyZWEuX19yYW5nZU9mZnNldDtcbiAgICAgICAgICAgICAgICBhcmVhLnJhbmdlID0gcmFuZ2VPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgPyBkaWZmUHJvY2Vzc29yW2FyZWEuYnJ1c2hUeXBlXShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZU9mZnNldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTY2FsZXMocmVzdWx0Lnh5TWluTWF4LCByYW5nZU9mZnNldC54eU1pbk1heClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IHJlc3VsdC52YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBwcm90by5tYWtlUGFuZWxPcHRzID0gZnVuY3Rpb24gKGFwaSwgZ2V0RGVmYXVsdEJydXNoVHlwZSkge1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLl90YXJnZXRJbmZvTGlzdCwgZnVuY3Rpb24gKHRhcmdldEluZm8pIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGFyZ2V0SW5mby5nZXRQYW5lbFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFuZWxJZDogdGFyZ2V0SW5mby5wYW5lbElkLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRCcnVzaFR5cGU6IGdldERlZmF1bHRCcnVzaFR5cGUgJiYgZ2V0RGVmYXVsdEJydXNoVHlwZSh0YXJnZXRJbmZvKSxcbiAgICAgICAgICAgICAgICBjbGlwUGF0aDogYnJ1c2hIZWxwZXIubWFrZVJlY3RQYW5lbENsaXBQYXRoKHJlY3QpLFxuICAgICAgICAgICAgICAgIGlzVGFyZ2V0QnlDdXJzb3I6IGJydXNoSGVscGVyLm1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcihcbiAgICAgICAgICAgICAgICAgICAgcmVjdCwgYXBpLCB0YXJnZXRJbmZvLmNvb3JkU3lzTW9kZWxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGdldExpbmVhckJydXNoT3RoZXJFeHRlbnQ6IGJydXNoSGVscGVyLm1ha2VMaW5lYXJCcnVzaE90aGVyRXh0ZW50KHJlY3QpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJvdG8uY29udHJvbFNlcmllcyA9IGZ1bmN0aW9uIChhcmVhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGFyZWEgaXMgYm91bmQgaW4gY29vcmQsIGFuZCBzZXJpZXMgZG8gbm90IGJlbG9uZyB0byB0aGF0IGNvb3JkLlxuICAgICAgICAvLyBJZiBkbyBub3QgZG8gdGhpcyBjaGVjaywgc29tZSBicnVzaCAobGlrZSBsaW5lWCkgd2lsbCBjb250cm9sbCBhbGwgYXhlcy5cbiAgICAgICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0SW5mbyA9PT0gdHJ1ZSB8fCAoXG4gICAgICAgICAgICB0YXJnZXRJbmZvICYmIGluZGV4T2YodGFyZ2V0SW5mby5jb29yZFN5c2VzLCBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtKSA+PSAwXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIElmIHJldHVybiBPYmplY3QsIGEgY29vcmQgZm91bmQuXG4gICAgICogSWYgcmV1dHJuIHRydWUsIGdsb2JhbCBmb3VuZC5cbiAgICAgKiBPdGhlcndpc2Ugbm90aGluZyBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmVhXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SW5mb0xpc3RcbiAgICAgKiBAcmV0dXJuIHtPYmVqY3R8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5maW5kVGFyZ2V0SW5mbyA9IGZ1bmN0aW9uIChhcmVhLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciB0YXJnZXRJbmZvTGlzdCA9IHRoaXMuX3RhcmdldEluZm9MaXN0O1xuICAgICAgICB2YXIgZm91bmRDcHRzID0gcGFyc2VGaW5kZXIoZWNNb2RlbCwgYXJlYSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRJbmZvTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBhcmVhUGFuZWxJZCA9IGFyZWEucGFuZWxJZDtcbiAgICAgICAgICAgIGlmIChhcmVhUGFuZWxJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJbmZvLnBhbmVsSWQgPT09IGFyZWFQYW5lbElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb01hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJbmZvTWF0Y2hlcnNbaV0oZm91bmRDcHRzLCB0YXJnZXRJbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEluZm87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0TWluTWF4KG1pbk1heCkge1xuICAgICAgICBtaW5NYXhbMF0gPiBtaW5NYXhbMV0gJiYgbWluTWF4LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG1pbk1heDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsVXRpbC5wYXJzZUZpbmRlcihcbiAgICAgICAgICAgIGVjTW9kZWwsIG9wdGlvbiwge2luY2x1ZGVNYWluVHlwZXM6IElOQ0xVREVfRklOREVSX01BSU5fVFlQRVN9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldEluZm9CdWlsZGVycyA9IHtcblxuICAgICAgICBncmlkOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgICAgICAgICAgdmFyIHhBeGlzTW9kZWxzID0gZm91bmRDcHRzLnhBeGlzTW9kZWxzO1xuICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWxzID0gZm91bmRDcHRzLnlBeGlzTW9kZWxzO1xuICAgICAgICAgICAgdmFyIGdyaWRNb2RlbHMgPSBmb3VuZENwdHMuZ3JpZE1vZGVscztcbiAgICAgICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVkLlxuICAgICAgICAgICAgdmFyIGdyaWRNb2RlbE1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgICAgICAgICB2YXIgeEF4ZXNIYXMgPSB7fTtcbiAgICAgICAgICAgIHZhciB5QXhlc0hhcyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXhBeGlzTW9kZWxzICYmICF5QXhpc01vZGVscyAmJiAhZ3JpZE1vZGVscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWFjaCh4QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsO1xuICAgICAgICAgICAgICAgIGdyaWRNb2RlbE1hcC5zZXQoZ3JpZE1vZGVsLmlkLCBncmlkTW9kZWwpO1xuICAgICAgICAgICAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlYWNoKHlBeGlzTW9kZWxzLCBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWRNb2RlbCA9IGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWw7XG4gICAgICAgICAgICAgICAgZ3JpZE1vZGVsTWFwLnNldChncmlkTW9kZWwuaWQsIGdyaWRNb2RlbCk7XG4gICAgICAgICAgICAgICAgeUF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVhY2goZ3JpZE1vZGVscywgZnVuY3Rpb24gKGdyaWRNb2RlbCkge1xuICAgICAgICAgICAgICAgIGdyaWRNb2RlbE1hcC5zZXQoZ3JpZE1vZGVsLmlkLCBncmlkTW9kZWwpO1xuICAgICAgICAgICAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHlBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdyaWRNb2RlbE1hcC5lYWNoKGZ1bmN0aW9uIChncmlkTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW5zID0gW107XG5cbiAgICAgICAgICAgICAgICBlYWNoKGdyaWQuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZih4QXhpc01vZGVscywgY2FydGVzaWFuLmdldEF4aXMoJ3gnKS5tb2RlbCkgPj0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgaW5kZXhPZih5QXhpc01vZGVscywgY2FydGVzaWFuLmdldEF4aXMoJ3knKS5tb2RlbCkgPj0gMFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcnRlc2lhbnMucHVzaChjYXJ0ZXNpYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SW5mb0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsSWQ6ICdncmlkLS0nICsgZ3JpZE1vZGVsLmlkLFxuICAgICAgICAgICAgICAgICAgICBncmlkTW9kZWw6IGdyaWRNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRTeXNNb2RlbDogZ3JpZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG9uZSBhcyB0aGUgcmVwcmVzZW50aXRpdmUgY29vcmRTeXMuXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzOiBjYXJ0ZXNpYW5zWzBdLFxuICAgICAgICAgICAgICAgICAgICBjb29yZFN5c2VzOiBjYXJ0ZXNpYW5zLFxuICAgICAgICAgICAgICAgICAgICBnZXRQYW5lbFJlY3Q6IHBhbmVsUmVjdEJ1aWxkZXIuZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgeEF4aXNEZWNsYXJlZDogeEF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgeUF4aXNEZWNsYXJlZDogeUF4ZXNIYXNbZ3JpZE1vZGVsLmlkXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2VvOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgICAgICAgICAgZWFjaChmb3VuZENwdHMuZ2VvTW9kZWxzLCBmdW5jdGlvbiAoZ2VvTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBnZW9Nb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgIHRhcmdldEluZm9MaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYW5lbElkOiAnZ2VvLS0nICsgZ2VvTW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGdlb01vZGVsOiBnZW9Nb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRTeXNNb2RlbDogZ2VvTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzOiBjb29yZFN5cyxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRTeXNlczogW2Nvb3JkU3lzXSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFuZWxSZWN0OiBwYW5lbFJlY3RCdWlsZGVyLmdlb1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRhcmdldEluZm9NYXRjaGVycyA9IFtcblxuICAgICAgICAvLyBncmlkXG4gICAgICAgIGZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm8pIHtcbiAgICAgICAgICAgIHZhciB4QXhpc01vZGVsID0gZm91bmRDcHRzLnhBeGlzTW9kZWw7XG4gICAgICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGZvdW5kQ3B0cy55QXhpc01vZGVsO1xuICAgICAgICAgICAgdmFyIGdyaWRNb2RlbCA9IGZvdW5kQ3B0cy5ncmlkTW9kZWw7XG5cbiAgICAgICAgICAgICFncmlkTW9kZWwgJiYgeEF4aXNNb2RlbCAmJiAoZ3JpZE1vZGVsID0geEF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWwpO1xuICAgICAgICAgICAgIWdyaWRNb2RlbCAmJiB5QXhpc01vZGVsICYmIChncmlkTW9kZWwgPSB5QXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBncmlkTW9kZWwgJiYgZ3JpZE1vZGVsID09PSB0YXJnZXRJbmZvLmdyaWRNb2RlbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBnZW9cbiAgICAgICAgZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mbykge1xuICAgICAgICAgICAgdmFyIGdlb01vZGVsID0gZm91bmRDcHRzLmdlb01vZGVsO1xuICAgICAgICAgICAgcmV0dXJuIGdlb01vZGVsICYmIGdlb01vZGVsID09PSB0YXJnZXRJbmZvLmdlb01vZGVsO1xuICAgICAgICB9XG4gICAgXTtcblxuICAgIHZhciBwYW5lbFJlY3RCdWlsZGVyID0ge1xuXG4gICAgICAgIGdyaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGdyaWQgaXMgbm90IFRyYW5zZm9ybWFibGUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb29yZFN5cy5ncmlkLmdldFJlY3QoKS5jbG9uZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdlbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gdGhpcy5jb29yZFN5cztcbiAgICAgICAgICAgIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vIGdlbyByb2FtIGFuZCB6b29tIHRyYW5zZm9ybVxuICAgICAgICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybShncmFwaGljLmdldFRyYW5zZm9ybShjb29yZFN5cykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNvb3JkQ29udmVydCA9IHtcblxuICAgICAgICBsaW5lWDogY3VycnkoYXhpc0NvbnZlcnQsIDApLFxuXG4gICAgICAgIGxpbmVZOiBjdXJyeShheGlzQ29udmVydCwgMSksXG5cbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHRvLCBjb29yZFN5cywgcmFuZ2VPckNvb3JkUmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB4bWlueW1pbiA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzBdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVswXV0pO1xuICAgICAgICAgICAgdmFyIHhtYXh5bWF4ID0gY29vcmRTeXNbQ09PUkRfQ09OVkVSVFNbdG9dXShbcmFuZ2VPckNvb3JkUmFuZ2VbMF1bMV0sIHJhbmdlT3JDb29yZFJhbmdlWzFdWzFdXSk7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW1xuICAgICAgICAgICAgICAgIGZvcm1hdE1pbk1heChbeG1pbnltaW5bMF0sIHhtYXh5bWF4WzBdXSksXG4gICAgICAgICAgICAgICAgZm9ybWF0TWluTWF4KFt4bWlueW1pblsxXSwgeG1heHltYXhbMV1dKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiB7dmFsdWVzOiB2YWx1ZXMsIHh5TWluTWF4OiB2YWx1ZXN9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvbHlnb246IGZ1bmN0aW9uICh0bywgY29vcmRTeXMsIHJhbmdlT3JDb29yZFJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgeHlNaW5NYXggPSBbW0luZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIC1JbmZpbml0eV1dO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHpyVXRpbC5tYXAocmFuZ2VPckNvb3JkUmFuZ2UsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjb29yZFN5c1tDT09SRF9DT05WRVJUU1t0b11dKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHh5TWluTWF4WzBdWzBdID0gTWF0aC5taW4oeHlNaW5NYXhbMF1bMF0sIHBbMF0pO1xuICAgICAgICAgICAgICAgIHh5TWluTWF4WzFdWzBdID0gTWF0aC5taW4oeHlNaW5NYXhbMV1bMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIHh5TWluTWF4WzBdWzFdID0gTWF0aC5tYXgoeHlNaW5NYXhbMF1bMV0sIHBbMF0pO1xuICAgICAgICAgICAgICAgIHh5TWluTWF4WzFdWzFdID0gTWF0aC5tYXgoeHlNaW5NYXhbMV1bMV0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlczogdmFsdWVzLCB4eU1pbk1heDogeHlNaW5NYXh9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGF4aXNDb252ZXJ0KGF4aXNOYW1lSW5kZXgsIHRvLCBjb29yZFN5cywgcmFuZ2VPckNvb3JkUmFuZ2UpIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyxcbiAgICAgICAgICAgICAgICAnbGluZVgvbGluZVkgYnJ1c2ggaXMgYXZhaWxhYmxlIG9ubHkgaW4gY2FydGVzaWFuMmQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhbJ3gnLCAneSddW2F4aXNOYW1lSW5kZXhdKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGZvcm1hdE1pbk1heCh6clV0aWwubWFwKFswLCAxXSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1xuICAgICAgICAgICAgICAgID8gYXhpcy5jb29yZFRvRGF0YShheGlzLnRvTG9jYWxDb29yZChyYW5nZU9yQ29vcmRSYW5nZVtpXSkpXG4gICAgICAgICAgICAgICAgOiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChyYW5nZU9yQ29vcmRSYW5nZVtpXSkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciB4eU1pbk1heCA9IFtdO1xuICAgICAgICB4eU1pbk1heFtheGlzTmFtZUluZGV4XSA9IHZhbHVlcztcbiAgICAgICAgeHlNaW5NYXhbMSAtIGF4aXNOYW1lSW5kZXhdID0gW05hTiwgTmFOXTtcblxuICAgICAgICByZXR1cm4ge3ZhbHVlczogdmFsdWVzLCB4eU1pbk1heDogeHlNaW5NYXh9O1xuICAgIH1cblxuICAgIHZhciBkaWZmUHJvY2Vzc29yID0ge1xuICAgICAgICBsaW5lWDogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDApLFxuXG4gICAgICAgIGxpbmVZOiBjdXJyeShheGlzRGlmZlByb2Nlc3NvciwgMSksXG5cbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHZhbHVlcywgcmVmZXIsIHNjYWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBbdmFsdWVzWzBdWzBdIC0gc2NhbGVzWzBdICogcmVmZXJbMF1bMF0sIHZhbHVlc1swXVsxXSAtIHNjYWxlc1swXSAqIHJlZmVyWzBdWzFdXSxcbiAgICAgICAgICAgICAgICBbdmFsdWVzWzFdWzBdIC0gc2NhbGVzWzFdICogcmVmZXJbMV1bMF0sIHZhbHVlc1sxXVsxXSAtIHNjYWxlc1sxXSAqIHJlZmVyWzFdWzFdXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2x5Z29uOiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2l0ZW1bMF0gLSBzY2FsZXNbMF0gKiByZWZlcltpZHhdWzBdLCBpdGVtWzFdIC0gc2NhbGVzWzFdICogcmVmZXJbaWR4XVsxXV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBheGlzRGlmZlByb2Nlc3NvcihheGlzTmFtZUluZGV4LCB2YWx1ZXMsIHJlZmVyLCBzY2FsZXMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHZhbHVlc1swXSAtIHNjYWxlc1theGlzTmFtZUluZGV4XSAqIHJlZmVyWzBdLFxuICAgICAgICAgICAgdmFsdWVzWzFdIC0gc2NhbGVzW2F4aXNOYW1lSW5kZXhdICogcmVmZXJbMV1cbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIHRvIHByb2Nlc3Mgc2NhbGUgY2F1c2VkIGJ5IGRhdGFab29tIG1hbnVhbGx5LFxuICAgIC8vIGFsdGhvdWdoIGl0IG1pZ2h0IGJlIG5vdCBhY2N1cmF0ZS5cbiAgICBmdW5jdGlvbiBnZXRTY2FsZXMoeHlNaW5NYXhDdXJyLCB4eU1pbk1heE9yaWdpbikge1xuICAgICAgICB2YXIgc2l6ZUN1cnIgPSBnZXRTaXplKHh5TWluTWF4Q3Vycik7XG4gICAgICAgIHZhciBzaXplT3JpZ2luID0gZ2V0U2l6ZSh4eU1pbk1heE9yaWdpbik7XG4gICAgICAgIHZhciBzY2FsZXMgPSBbc2l6ZUN1cnJbMF0gLyBzaXplT3JpZ2luWzBdLCBzaXplQ3VyclsxXSAvIHNpemVPcmlnaW5bMV1dO1xuICAgICAgICBpc05hTihzY2FsZXNbMF0pICYmIChzY2FsZXNbMF0gPSAxKTtcbiAgICAgICAgaXNOYU4oc2NhbGVzWzFdKSAmJiAoc2NhbGVzWzFdID0gMSk7XG4gICAgICAgIHJldHVybiBzY2FsZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2l6ZSh4eU1pbk1heCkge1xuICAgICAgICByZXR1cm4geHlNaW5NYXhcbiAgICAgICAgICAgID8gW3h5TWluTWF4WzBdWzFdIC0geHlNaW5NYXhbMF1bMF0sIHh5TWluTWF4WzFdWzFdIC0geHlNaW5NYXhbMV1bMF1dXG4gICAgICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCcnVzaFRhcmdldE1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var cursorHelper = __webpack_require__(136);\n    var BoundingRect = __webpack_require__(11);\n    var graphicUtil = __webpack_require__(2);\n\n    var helper = {};\n\n    helper.makeRectPanelClipPath = function (rect) {\n        rect = normalizeRect(rect);\n        return function (localPoints, transform) {\n            return graphicUtil.clipPointsByRect(localPoints, rect);\n        };\n    };\n\n    helper.makeLinearBrushOtherExtent = function (rect, specifiedXYIndex) {\n        rect = normalizeRect(rect);\n        return function (xyIndex) {\n            var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n            var brushWidth = idx ? rect.width : rect.height;\n            var base = idx ? rect.x : rect.y;\n            return [base, base + (brushWidth || 0)];\n        };\n    };\n\n    helper.makeRectIsTargetByCursor = function (rect, api, targetModel) {\n        rect = normalizeRect(rect);\n        return function (e, localCursorPoint, transform) {\n            return rect.contain(localCursorPoint[0], localCursorPoint[1])\n                && !cursorHelper.onIrrelevantElement(e, api, targetModel);\n        };\n    };\n\n    // Consider width/height is negative.\n    function normalizeRect(rect) {\n        return BoundingRect.create(rect);\n    }\n\n    module.exports = helper;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvYnJ1c2hIZWxwZXIuanM/ZjIyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGN1cnNvckhlbHBlciA9IHJlcXVpcmUoJy4vY3Vyc29ySGVscGVyJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIGdyYXBoaWNVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICBoZWxwZXIubWFrZVJlY3RQYW5lbENsaXBQYXRoID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobG9jYWxQb2ludHMsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyYXBoaWNVdGlsLmNsaXBQb2ludHNCeVJlY3QobG9jYWxQb2ludHMsIHJlY3QpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBoZWxwZXIubWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQgPSBmdW5jdGlvbiAocmVjdCwgc3BlY2lmaWVkWFlJbmRleCkge1xuICAgICAgICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4eUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc3BlY2lmaWVkWFlJbmRleCAhPSBudWxsID8gc3BlY2lmaWVkWFlJbmRleCA6IHh5SW5kZXg7XG4gICAgICAgICAgICB2YXIgYnJ1c2hXaWR0aCA9IGlkeCA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHZhciBiYXNlID0gaWR4ID8gcmVjdC54IDogcmVjdC55O1xuICAgICAgICAgICAgcmV0dXJuIFtiYXNlLCBiYXNlICsgKGJydXNoV2lkdGggfHwgMCldO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBoZWxwZXIubWFrZVJlY3RJc1RhcmdldEJ5Q3Vyc29yID0gZnVuY3Rpb24gKHJlY3QsIGFwaSwgdGFyZ2V0TW9kZWwpIHtcbiAgICAgICAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgbG9jYWxDdXJzb3JQb2ludCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5jb250YWluKGxvY2FsQ3Vyc29yUG9pbnRbMF0sIGxvY2FsQ3Vyc29yUG9pbnRbMV0pXG4gICAgICAgICAgICAgICAgJiYgIWN1cnNvckhlbHBlci5vbklycmVsZXZhbnRFbGVtZW50KGUsIGFwaSwgdGFyZ2V0TW9kZWwpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBDb25zaWRlciB3aWR0aC9oZWlnaHQgaXMgbmVnYXRpdmUuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgICAgIHJldHVybiBCb3VuZGluZ1JlY3QuY3JlYXRlKHJlY3QpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9icnVzaEhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 136 */
/***/ (function(module, exports) {

eval("\n\n    var helper = {};\n\n    var IRRELEVANT_EXCLUDES = {'axisPointer': 1, 'tooltip': 1, 'brush': 1};\n\n    /**\n     * Avoid that: mouse click on a elements that is over geo or graph,\n     * but roam is triggered.\n     */\n    helper.onIrrelevantElement = function (e, api, targetCoordSysModel) {\n        var model = api.getComponentByElement(e.topTarget);\n        // If model is axisModel, it works only if it is injected with coordinateSystem.\n        var coordSys = model && model.coordinateSystem;\n        return model\n            && model !== targetCoordSysModel\n            && !IRRELEVANT_EXCLUDES[model.mainType]\n            && (coordSys && coordSys.model !== targetCoordSysModel);\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvY3Vyc29ySGVscGVyLmpzPzY2OWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGhlbHBlciA9IHt9O1xuXG4gICAgdmFyIElSUkVMRVZBTlRfRVhDTFVERVMgPSB7J2F4aXNQb2ludGVyJzogMSwgJ3Rvb2x0aXAnOiAxLCAnYnJ1c2gnOiAxfTtcblxuICAgIC8qKlxuICAgICAqIEF2b2lkIHRoYXQ6IG1vdXNlIGNsaWNrIG9uIGEgZWxlbWVudHMgdGhhdCBpcyBvdmVyIGdlbyBvciBncmFwaCxcbiAgICAgKiBidXQgcm9hbSBpcyB0cmlnZ2VyZWQuXG4gICAgICovXG4gICAgaGVscGVyLm9uSXJyZWxldmFudEVsZW1lbnQgPSBmdW5jdGlvbiAoZSwgYXBpLCB0YXJnZXRDb29yZFN5c01vZGVsKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IGFwaS5nZXRDb21wb25lbnRCeUVsZW1lbnQoZS50b3BUYXJnZXQpO1xuICAgICAgICAvLyBJZiBtb2RlbCBpcyBheGlzTW9kZWwsIGl0IHdvcmtzIG9ubHkgaWYgaXQgaXMgaW5qZWN0ZWQgd2l0aCBjb29yZGluYXRlU3lzdGVtLlxuICAgICAgICB2YXIgY29vcmRTeXMgPSBtb2RlbCAmJiBtb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICByZXR1cm4gbW9kZWxcbiAgICAgICAgICAgICYmIG1vZGVsICE9PSB0YXJnZXRDb29yZFN5c01vZGVsXG4gICAgICAgICAgICAmJiAhSVJSRUxFVkFOVF9FWENMVURFU1ttb2RlbC5tYWluVHlwZV1cbiAgICAgICAgICAgICYmIChjb29yZFN5cyAmJiBjb29yZFN5cy5tb2RlbCAhPT0gdGFyZ2V0Q29vcmRTeXNNb2RlbCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvY3Vyc29ySGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var ATTR = '\\0_ec_interaction_mutex';\n\n    var interactionMutex = {\n\n        take: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            store[resourceKey] = userKey;\n        },\n\n        release: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            var uKey = store[resourceKey];\n\n            if (uKey === userKey) {\n                store[resourceKey] = null;\n            }\n        },\n\n        isTaken: function (zr, resourceKey) {\n            return !!getStore(zr)[resourceKey];\n        }\n    };\n\n    function getStore(zr) {\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    /**\n     * payload: {\n     *     type: 'takeGlobalCursor',\n     *     key: 'dataZoomSelect', or 'brush', or ...,\n     *         If no userKey, release global cursor.\n     * }\n     */\n    __webpack_require__(1).registerAction(\n        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n        function () {}\n    );\n\n    module.exports = interactionMutex;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qcz9mZjY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1RUFBdUU7QUFDaEY7QUFDQTs7QUFFQSIsImZpbGUiOiIxMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBBVFRSID0gJ1xcMF9lY19pbnRlcmFjdGlvbl9tdXRleCc7XG5cbiAgICB2YXIgaW50ZXJhY3Rpb25NdXRleCA9IHtcblxuICAgICAgICB0YWtlOiBmdW5jdGlvbiAoenIsIHJlc291cmNlS2V5LCB1c2VyS2V5KSB7XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh6cik7XG4gICAgICAgICAgICBzdG9yZVtyZXNvdXJjZUtleV0gPSB1c2VyS2V5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uICh6ciwgcmVzb3VyY2VLZXksIHVzZXJLZXkpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGdldFN0b3JlKHpyKTtcbiAgICAgICAgICAgIHZhciB1S2V5ID0gc3RvcmVbcmVzb3VyY2VLZXldO1xuXG4gICAgICAgICAgICBpZiAodUtleSA9PT0gdXNlcktleSkge1xuICAgICAgICAgICAgICAgIHN0b3JlW3Jlc291cmNlS2V5XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUYWtlbjogZnVuY3Rpb24gKHpyLCByZXNvdXJjZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuICEhZ2V0U3RvcmUoenIpW3Jlc291cmNlS2V5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRTdG9yZSh6cikge1xuICAgICAgICByZXR1cm4genJbQVRUUl0gfHwgKHpyW0FUVFJdID0ge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBheWxvYWQ6IHtcbiAgICAgKiAgICAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICAgICAqICAgICBrZXk6ICdkYXRhWm9vbVNlbGVjdCcsIG9yICdicnVzaCcsIG9yIC4uLixcbiAgICAgKiAgICAgICAgIElmIG5vIHVzZXJLZXksIHJlbGVhc2UgZ2xvYmFsIGN1cnNvci5cbiAgICAgKiB9XG4gICAgICovXG4gICAgcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICB7dHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLCBldmVudDogJ2dsb2JhbEN1cnNvclRha2VuJywgdXBkYXRlOiAndXBkYXRlJ30sXG4gICAgICAgIGZ1bmN0aW9uICgpIHt9XG4gICAgKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW50ZXJhY3Rpb25NdXRleDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2ludGVyYWN0aW9uTXV0ZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 138 */
/***/ (function(module, exports) {

eval("\n\n    /**\n     * Calculate slider move result.\n     * Usage:\n     * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n     * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n     * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n     *\n     * @param {number} delta Move length.\n     * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n     *              handleEnds will be modified in this method.\n     * @param {Array.<number>} extent handleEnds is restricted by extent.\n     *              extent[0] should less or equals than extent[1].\n     * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n     *              where the input minSpan and maxSpan will not work.\n     * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n     *              If not set, handle0 and cross handle1. If set as a non-negative\n     *              number (including `0`), handles will push each other when reaching\n     *              the minSpan.\n     * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n     * @return {Array.<number>} The input handleEnds.\n     */\n    module.exports = function (delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n        // Normalize firstly.\n        handleEnds[0] = restrict(handleEnds[0], extent);\n        handleEnds[1] = restrict(handleEnds[1], extent);\n\n        delta = delta || 0;\n\n        var extentSpan = extent[1] - extent[0];\n\n        // Notice maxSpan and minSpan can be null/undefined.\n        if (minSpan != null) {\n            minSpan = restrict(minSpan, [0, extentSpan]);\n        }\n        if (maxSpan != null) {\n            maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n        }\n        if (handleIndex === 'all') {\n            minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n            handleIndex = 0;\n        }\n\n        var originalDistSign = getSpanSign(handleEnds, handleIndex);\n\n        handleEnds[handleIndex] += delta;\n\n        // Restrict in extent.\n        var extentMinSpan = minSpan || 0;\n        var realExtent = extent.slice();\n        originalDistSign.sign < 0 ? (realExtent[0] += extentMinSpan) : (realExtent[1] -= extentMinSpan);\n        handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);\n\n        // Expand span.\n        var currDistSign = getSpanSign(handleEnds, handleIndex);\n        if (minSpan != null && (\n            currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan\n        )) {\n            // If minSpan exists, 'cross' is forbinden.\n            handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n        }\n\n        // Shrink span.\n        var currDistSign = getSpanSign(handleEnds, handleIndex);\n        if (maxSpan != null && currDistSign.span > maxSpan) {\n            handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n        }\n\n        return handleEnds;\n    };\n\n    function getSpanSign(handleEnds, handleIndex) {\n        var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];\n        // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n        // is at left of handleEnds[1] for non-cross case.\n        return {span: Math.abs(dist), sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1};\n    }\n\n    function restrict(value, extend) {\n        return Math.min(extend[1], Math.max(extend[0], value));\n    }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZS5qcz80NTkyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc2xpZGVyIG1vdmUgcmVzdWx0LlxuICAgICAqIFVzYWdlOlxuICAgICAqICgxKSBJZiBib3RoIGhhbmRsZTAgYW5kIGhhbmRsZTEgYXJlIG5lZWRlZCB0byBiZSBtb3ZlZCwgc2V0IG1pblNwYW4gdGhlIHNhbWUgYXNcbiAgICAgKiBtYXhTcGFuIGFuZCB0aGUgc2FtZSBhcyBgTWF0aC5hYnMoaGFuZGxlRW5kWzFdIC0gaGFuZGxlRW5kc1swXSlgLlxuICAgICAqICgyKSBJZiBoYW5kbGUwIGlzIGZvcmJpZGRlbiB0byBjcm9zcyBoYW5kbGUxLCBzZXQgbWluU3BhbiBhcyBgMGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgTW92ZSBsZW5ndGguXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaGFuZGxlRW5kcyBoYW5kbGVFbmRzWzBdIGNhbiBiZSBiaWdnZXIgdGhlbiBoYW5kbGVFbmRzWzFdLlxuICAgICAqICAgICAgICAgICAgICBoYW5kbGVFbmRzIHdpbGwgYmUgbW9kaWZpZWQgaW4gdGhpcyBtZXRob2QuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZXh0ZW50IGhhbmRsZUVuZHMgaXMgcmVzdHJpY3RlZCBieSBleHRlbnQuXG4gICAgICogICAgICAgICAgICAgIGV4dGVudFswXSBzaG91bGQgbGVzcyBvciBlcXVhbHMgdGhhbiBleHRlbnRbMV0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBoYW5kbGVJbmRleCBDYW4gYmUgJ2FsbCcsIG1lYW5zIHRoYXQgYm90aCBtb3ZlIHRoZSB0d28gaGFuZGxlRW5kcyxcbiAgICAgKiAgICAgICAgICAgICAgd2hlcmUgdGhlIGlucHV0IG1pblNwYW4gYW5kIG1heFNwYW4gd2lsbCBub3Qgd29yay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pblNwYW5dIFRoZSByYW5nZSBvZiBkYXRhWm9vbSBjYW4gbm90IGJlIHNtYWxsZXIgdGhhbiB0aGF0LlxuICAgICAqICAgICAgICAgICAgICBJZiBub3Qgc2V0LCBoYW5kbGUwIGFuZCBjcm9zcyBoYW5kbGUxLiBJZiBzZXQgYXMgYSBub24tbmVnYXRpdmVcbiAgICAgKiAgICAgICAgICAgICAgbnVtYmVyIChpbmNsdWRpbmcgYDBgKSwgaGFuZGxlcyB3aWxsIHB1c2ggZWFjaCBvdGhlciB3aGVuIHJlYWNoaW5nXG4gICAgICogICAgICAgICAgICAgIHRoZSBtaW5TcGFuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4U3Bhbl0gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVGhlIGlucHV0IGhhbmRsZUVuZHMuXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVsdGEsIGhhbmRsZUVuZHMsIGV4dGVudCwgaGFuZGxlSW5kZXgsIG1pblNwYW4sIG1heFNwYW4pIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIGZpcnN0bHkuXG4gICAgICAgIGhhbmRsZUVuZHNbMF0gPSByZXN0cmljdChoYW5kbGVFbmRzWzBdLCBleHRlbnQpO1xuICAgICAgICBoYW5kbGVFbmRzWzFdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1sxXSwgZXh0ZW50KTtcblxuICAgICAgICBkZWx0YSA9IGRlbHRhIHx8IDA7XG5cbiAgICAgICAgdmFyIGV4dGVudFNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG5cbiAgICAgICAgLy8gTm90aWNlIG1heFNwYW4gYW5kIG1pblNwYW4gY2FuIGJlIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICBpZiAobWluU3BhbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBtaW5TcGFuID0gcmVzdHJpY3QobWluU3BhbiwgWzAsIGV4dGVudFNwYW5dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4U3BhbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXhTcGFuID0gTWF0aC5tYXgobWF4U3BhbiwgbWluU3BhbiAhPSBudWxsID8gbWluU3BhbiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVJbmRleCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIG1pblNwYW4gPSBtYXhTcGFuID0gTWF0aC5hYnMoaGFuZGxlRW5kc1sxXSAtIGhhbmRsZUVuZHNbMF0pO1xuICAgICAgICAgICAgaGFuZGxlSW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsRGlzdFNpZ24gPSBnZXRTcGFuU2lnbihoYW5kbGVFbmRzLCBoYW5kbGVJbmRleCk7XG5cbiAgICAgICAgaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKz0gZGVsdGE7XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgaW4gZXh0ZW50LlxuICAgICAgICB2YXIgZXh0ZW50TWluU3BhbiA9IG1pblNwYW4gfHwgMDtcbiAgICAgICAgdmFyIHJlYWxFeHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgICAgb3JpZ2luYWxEaXN0U2lnbi5zaWduIDwgMCA/IChyZWFsRXh0ZW50WzBdICs9IGV4dGVudE1pblNwYW4pIDogKHJlYWxFeHRlbnRbMV0gLT0gZXh0ZW50TWluU3Bhbik7XG4gICAgICAgIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIHJlYWxFeHRlbnQpO1xuXG4gICAgICAgIC8vIEV4cGFuZCBzcGFuLlxuICAgICAgICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuICAgICAgICBpZiAobWluU3BhbiAhPSBudWxsICYmIChcbiAgICAgICAgICAgIGN1cnJEaXN0U2lnbi5zaWduICE9PSBvcmlnaW5hbERpc3RTaWduLnNpZ24gfHwgY3VyckRpc3RTaWduLnNwYW4gPCBtaW5TcGFuXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIC8vIElmIG1pblNwYW4gZXhpc3RzLCAnY3Jvc3MnIGlzIGZvcmJpbmRlbi5cbiAgICAgICAgICAgIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XSA9IGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgb3JpZ2luYWxEaXN0U2lnbi5zaWduICogbWluU3BhbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNocmluayBzcGFuLlxuICAgICAgICB2YXIgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuICAgICAgICBpZiAobWF4U3BhbiAhPSBudWxsICYmIGN1cnJEaXN0U2lnbi5zcGFuID4gbWF4U3Bhbikge1xuICAgICAgICAgICAgaGFuZGxlRW5kc1sxIC0gaGFuZGxlSW5kZXhdID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyBjdXJyRGlzdFNpZ24uc2lnbiAqIG1heFNwYW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFuZGxlRW5kcztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpIHtcbiAgICAgICAgdmFyIGRpc3QgPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSAtIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XTtcbiAgICAgICAgLy8gSWYgYGhhbmRsZUVuZHNbMF0gPT09IGhhbmRsZUVuZHNbMV1gLCBhbHdheXMgYmVsaWV2ZSB0aGF0IGhhbmRsZUVuZFswXVxuICAgICAgICAvLyBpcyBhdCBsZWZ0IG9mIGhhbmRsZUVuZHNbMV0gZm9yIG5vbi1jcm9zcyBjYXNlLlxuICAgICAgICByZXR1cm4ge3NwYW46IE1hdGguYWJzKGRpc3QpLCBzaWduOiBkaXN0ID4gMCA/IC0xIDogZGlzdCA8IDAgPyAxIDogaGFuZGxlSW5kZXggPyAtMSA6IDF9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc3RyaWN0KHZhbHVlLCBleHRlbmQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGV4dGVuZFsxXSwgTWF0aC5tYXgoZXh0ZW5kWzBdLCB2YWx1ZSkpO1xuICAgIH1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NsaWRlck1vdmUuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Legend component entry file8\n */\n\n\n    __webpack_require__(140);\n    __webpack_require__(142);\n    __webpack_require__(141);\n\n    var echarts = __webpack_require__(1);\n    // Series Filter\n    echarts.registerProcessor(__webpack_require__(143));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQuanM/NmVlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMZWdlbmQgY29tcG9uZW50IGVudHJ5IGZpbGU4XG4gKi9cblxuXG4gICAgcmVxdWlyZSgnLi9sZWdlbmQvTGVnZW5kTW9kZWwnKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC9sZWdlbmRBY3Rpb24nKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC9MZWdlbmRWaWV3Jyk7XG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcbiAgICAvLyBTZXJpZXMgRmlsdGVyXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihyZXF1aXJlKCcuL2xlZ2VuZC9sZWdlbmRGaWx0ZXInKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var Model = __webpack_require__(9);\n\n    var LegendModel = __webpack_require__(1).extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 4,\n            show: true,\n\n            // 布局方式，默认为水平布局，可选为：\n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right'\n            // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // 图例边框颜色\n            borderColor: '#ccc',\n            // 图例边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n            // 图例内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n            // 各个item之间的间隔，单位px，默认为10，\n            // 横向布局时为水平间隔，纵向布局时为纵向间隔\n            itemGap: 10,\n            // 图例图形宽度\n            itemWidth: 25,\n            // 图例图形高度\n            itemHeight: 14,\n\n            // 图例关闭时候的颜色\n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // 图例文字颜色\n                color: '#333'\n            },\n            // formatter: '',\n            // 选择模式，默认开启图例开关\n            selectedMode: true,\n            // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n            // selected: null,\n            // 图例内容（详见legend.data，数组中每一项代表一个item\n            // data: [],\n\n            // Tooltip 相关配置\n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanM/ZTI3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcblxuICAgIHZhciBMZWdlbmRNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ2xlZ2VuZCcsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ3NlcmllcyddLFxuXG4gICAgICAgIGxheW91dE1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib3gnLFxuICAgICAgICAgICAgaWdub3JlU2l6ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi5zZWxlY3RlZCB8fCB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgTGVnZW5kTW9kZWwuc3VwZXJDYWxsKHRoaXMsICdtZXJnZU9wdGlvbicsIG9wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGF0YSh0aGlzLmVjTW9kZWwpO1xuXG4gICAgICAgICAgICB2YXIgbGVnZW5kRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdGVkTW9kZSBpcyBzaW5nbGUsIHRyeSB0byBzZWxlY3Qgb25lXG4gICAgICAgICAgICBpZiAobGVnZW5kRGF0YVswXSAmJiB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gSWYgaGFzIGFueSBzZWxlY3RlZCBpbiBvcHRpb24uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBsZWdlbmREYXRhW2ldLmdldCgnbmFtZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSB0byB1bnNlbGVjdCBvdGhlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuICAgICAgICAgICAgICAgICFoYXNTZWxlY3RlZCAmJiB0aGlzLnNlbGVjdChsZWdlbmREYXRhWzBdLmdldCgnbmFtZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlRGF0YTogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsZWdlbmREYXRhID0genJVdGlsLm1hcCh0aGlzLmdldCgnZGF0YScpIHx8IFtdLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4gYmUgc3RyaW5nIG9yIG51bWJlclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YUl0ZW0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRhSXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhSXRlbVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsKGRhdGFJdGVtLCB0aGlzLCB0aGlzLmVjTW9kZWwpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbGVnZW5kRGF0YTtcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZU5hbWVzID0genJVdGlsLm1hcChlY01vZGVsLmdldFNlcmllcygpLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzLmNvbmNhdChkYXRhLm1hcEFycmF5KGRhdGEuZ2V0TmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChkYXRhLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbZGF0YUl0ZW0uZ2V0KCduYW1lJyldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1blNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgIT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb24uc2VsZWN0ZWRbbmFtZV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGlzIHRydWVcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW3NlbGVjdGVkW25hbWVdID8gJ3VuU2VsZWN0JyA6ICdzZWxlY3QnXShuYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIHJldHVybiAhKHNlbGVjdGVkLmhhc093blByb3BlcnR5KG5hbWUpICYmICFzZWxlY3RlZFtuYW1lXSlcbiAgICAgICAgICAgICAgICAmJiB6clV0aWwuaW5kZXhPZih0aGlzLl9hdmFpbGFibGVOYW1lcywgbmFtZSkgPj0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgejogNCxcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIOW4g+WxgOaWueW8j++8jOm7mOiupOS4uuawtOW5s+W4g+WxgO+8jOWPr+mAieS4uu+8mlxuICAgICAgICAgICAgLy8gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG5cbiAgICAgICAgICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgLy8gcmlnaHQ6ICdjZW50ZXInLFxuXG4gICAgICAgICAgICB0b3A6ICd0b3AnLFxuICAgICAgICAgICAgLy8gYm90dG9tOiAndG9wJyxcblxuICAgICAgICAgICAgLy8g5rC05bmz5a+56b2QXG4gICAgICAgICAgICAvLyAnYXV0bycgfCAnbGVmdCcgfCAncmlnaHQnXG4gICAgICAgICAgICAvLyDpu5jorqTkuLogJ2F1dG8nLCDmoLnmja4geCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICAgICAgICAgIGFsaWduOiAnYXV0bycsXG5cbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgICAgICAgLy8g5Zu+5L6L6L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuICAgICAgICAgICAgLy8g5Zu+5L6L6L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgICAgICAgICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXG4gICAgICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICAgICAgLy8g5ZCE5LiqaXRlbeS5i+mXtOeahOmXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICAgICAgICAgIC8vIOaoquWQkeW4g+WxgOaXtuS4uuawtOW5s+mXtOmalO+8jOe6teWQkeW4g+WxgOaXtuS4uue6teWQkemXtOmalFxuICAgICAgICAgICAgaXRlbUdhcDogMTAsXG4gICAgICAgICAgICAvLyDlm77kvovlm77lvaLlrr3luqZcbiAgICAgICAgICAgIGl0ZW1XaWR0aDogMjUsXG4gICAgICAgICAgICAvLyDlm77kvovlm77lvaLpq5jluqZcbiAgICAgICAgICAgIGl0ZW1IZWlnaHQ6IDE0LFxuXG4gICAgICAgICAgICAvLyDlm77kvovlhbPpl63ml7blgJnnmoTpopzoibJcbiAgICAgICAgICAgIGluYWN0aXZlQ29sb3I6ICcjY2NjJyxcblxuICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8g5Zu+5L6L5paH5a2X6aKc6ImyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzMzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogJycsXG4gICAgICAgICAgICAvLyDpgInmi6nmqKHlvI/vvIzpu5jorqTlvIDlkK/lm77kvovlvIDlhbNcbiAgICAgICAgICAgIHNlbGVjdGVkTW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOmFjee9rum7mOiupOmAieS4reeKtuaAge+8jOWPr+mFjeWQiExFR0VORC5TRUxFQ1RFROS6i+S7tuWBmuWKqOaAgeaVsOaNrui9veWFpVxuICAgICAgICAgICAgLy8gc2VsZWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAvLyDlm77kvovlhoXlrrnvvIjor6bop4FsZWdlbmQuZGF0Ye+8jOaVsOe7hOS4reavj+S4gOmhueS7o+ihqOS4gOS4qml0ZW1cbiAgICAgICAgICAgIC8vIGRhdGE6IFtdLFxuXG4gICAgICAgICAgICAvLyBUb29sdGlwIOebuOWFs+mFjee9rlxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGVnZW5kTW9kZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var symbolCreator = __webpack_require__(38);\n    var graphic = __webpack_require__(2);\n    var listComponentHelper = __webpack_require__(56);\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = __webpack_require__(1).extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = zrUtil.createHashMap();\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap.get(name)) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap.set(name, true);\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap.get(name)) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap.set(name, true);\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap.get(name)) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qcz9hNjE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTQxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHN5bWJvbENyZWF0b3IgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N5bWJvbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGxpc3RDb21wb25lbnRIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvbGlzdENvbXBvbmVudCcpO1xuXG4gICAgdmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZWxlY3RBY3Rpb24obmFtZSwgYXBpKSB7XG4gICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnbGVnZW5kVG9nZ2xlU2VsZWN0JyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24oc2VyaWVzTW9kZWwsIGRhdGFOYW1lLCBhcGkpIHtcbiAgICAgICAgLy8gSWYgZWxlbWVudCBob3ZlciB3aWxsIG1vdmUgdG8gYSBob3ZlckxheWVyLlxuICAgICAgICB2YXIgZWwgPSBhcGkuZ2V0WnIoKS5zdG9yYWdlLmdldERpc3BsYXlMaXN0KClbMF07XG4gICAgICAgIGlmICghKGVsICYmIGVsLnVzZUhvdmVyTGF5ZXIpKSB7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ2xlZ2VuZEhvdmVyTGluaycpICYmIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaERvd25wbGF5QWN0aW9uKHNlcmllc01vZGVsLCBkYXRhTmFtZSwgYXBpKSB7XG4gICAgICAgIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgICAgICAgdmFyIGVsID0gYXBpLmdldFpyKCkuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpWzBdO1xuICAgICAgICBpZiAoIShlbCAmJiBlbC51c2VIb3ZlckxheWVyKSkge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdsZWdlbmRIb3ZlckxpbmsnKSAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnbGVnZW5kJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xUeXBlU3RvcmUgPSB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIGlmICghbGVnZW5kTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RNb2RlID0gbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICAgICAgICAgIHZhciBpdGVtQWxpZ24gPSBsZWdlbmRNb2RlbC5nZXQoJ2FsaWduJyk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtQWxpZ24gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIGl0ZW1BbGlnbiA9IChsZWdlbmRNb2RlbC5nZXQoJ2xlZnQnKSA9PT0gJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAmJiBsZWdlbmRNb2RlbC5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnKVxuICAgICAgICAgICAgICAgICAgICA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsZWdlbmREcmF3ZWRNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChsZWdlbmRNb2RlbC5nZXREYXRhKCksIGZ1bmN0aW9uIChpdGVtTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGl0ZW1Nb2RlbC5nZXQoJ25hbWUnKTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBlbXB0eSBzdHJpbmcgb3IgXFxuIGFzIGEgbmV3bGluZSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJycgfHwgbmFtZSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKG5ldyBncmFwaGljLkdyb3VwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeU5hbWUobmFtZSlbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kRHJhd2VkTWFwLmdldChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXZlIGJlZW4gZHJhd2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXJpZXMgbGVnZW5kXG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldFZpc3VhbCgnY29sb3InKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb2xvciBpcyBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcihzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIHJlY3Qgc3ltYm9sIGRlZmF1bHRseVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVnZW5kU3ltYm9sVHlwZSA9IGRhdGEuZ2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnKSB8fCAncm91bmRSZWN0JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnc3ltYm9sJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHRoaXMuX2NyZWF0ZUl0ZW0oXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1BbGlnbiwgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RNb2RlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbUdyb3VwLm9uKCdjbGljaycsIGN1cnJ5KGRpc3BhdGNoU2VsZWN0QWN0aW9uLCBuYW1lLCBhcGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBjdXJyeShkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgY3VycnkoZGlzcGF0Y2hEb3ducGxheUFjdGlvbiwgc2VyaWVzTW9kZWwsIG51bGwsIGFwaSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZERyYXdlZE1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBEYXRhIGxlZ2VuZCBvZiBwaWUsIGZ1bm5lbFxuICAgICAgICAgICAgICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG11bHRpcGxlIHNlcmllcyBoYXMgc2FtZSBkYXRhIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWdlbmREcmF3ZWRNYXAuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGRhdGEuaW5kZXhPZk5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSAncm91bmRSZWN0JztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRTeW1ib2xUeXBlLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgU2hvdWxkIG5vdCBzcGVjaWZ5IHRoZSBzZXJpZXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBzZXJpZXNNb2RlbCwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZERyYXdlZE1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kRHJhd2VkTWFwLmdldChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyAnIHNlcmllcyBub3QgZXhpc3RzLiBMZWdlbmQgZGF0YSBzaG91bGQgYmUgc2FtZSB3aXRoIHNlcmllcyBuYW1lIG9yIGRhdGEgbmFtZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBsaXN0Q29tcG9uZW50SGVscGVyLmxheW91dChncm91cCwgbGVnZW5kTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAvLyBSZW5kZXIgYmFja2dyb3VuZCBhZnRlciBncm91cCBpcyBsYXlvdXRcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBsaXN0Q29tcG9uZW50SGVscGVyLmFkZEJhY2tncm91bmQoZ3JvdXAsIGxlZ2VuZE1vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlSXRlbTogZnVuY3Rpb24gKFxuICAgICAgICAgICAgbmFtZSwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCxcbiAgICAgICAgICAgIGxlZ2VuZFN5bWJvbFR5cGUsIHN5bWJvbFR5cGUsXG4gICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGl0ZW1XaWR0aCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbVdpZHRoJyk7XG4gICAgICAgICAgICB2YXIgaXRlbUhlaWdodCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbUhlaWdodCcpO1xuICAgICAgICAgICAgdmFyIGluYWN0aXZlQ29sb3IgPSBsZWdlbmRNb2RlbC5nZXQoJ2luYWN0aXZlQ29sb3InKTtcblxuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKG5hbWUpO1xuICAgICAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG5cbiAgICAgICAgICAgIHZhciBpdGVtSWNvbiA9IGl0ZW1Nb2RlbC5nZXQoJ2ljb24nKTtcblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgndG9vbHRpcCcpO1xuICAgICAgICAgICAgdmFyIGxlZ2VuZEdsb2JhbFRvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbC5wYXJlbnRNb2RlbDtcblxuICAgICAgICAgICAgLy8gVXNlIHVzZXIgZ2l2ZW4gaWNvbiBmaXJzdFxuICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSA9IGl0ZW1JY29uIHx8IGxlZ2VuZFN5bWJvbFR5cGU7XG4gICAgICAgICAgICBpdGVtR3JvdXAuYWRkKHN5bWJvbENyZWF0b3IuY3JlYXRlU3ltYm9sKFxuICAgICAgICAgICAgICAgIGxlZ2VuZFN5bWJvbFR5cGUsIDAsIDAsIGl0ZW1XaWR0aCwgaXRlbUhlaWdodCwgaXNTZWxlY3RlZCA/IGNvbG9yIDogaW5hY3RpdmVDb2xvclxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIC8vIENvbXBvc2Ugc3ltYm9sc1xuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgaWYgKCFpdGVtSWNvbiAmJiBzeW1ib2xUeXBlXG4gICAgICAgICAgICAgICAgLy8gQXQgbGVhc3Qgc2hvdyBvbmUgc3ltYm9sLCBjYW4ndCBiZSBhbGwgbm9uZVxuICAgICAgICAgICAgICAgICYmICgoc3ltYm9sVHlwZSAhPT0gbGVnZW5kU3ltYm9sVHlwZSkgfHwgc3ltYm9sVHlwZSA9PSAnbm9uZScpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGl0ZW1IZWlnaHQgKiAwLjg7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ2NpcmNsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFB1dCBzeW1ib2wgaW4gdGhlIGNlbnRlclxuICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQoc3ltYm9sQ3JlYXRvci5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUsIChpdGVtV2lkdGggLSBzaXplKSAvIDIsIChpdGVtSGVpZ2h0IC0gc2l6ZSkgLyAyLCBzaXplLCBzaXplLFxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRleHRcbiAgICAgICAgICAgIHZhciB0ZXh0WCA9IGl0ZW1BbGlnbiA9PT0gJ2xlZnQnID8gaXRlbVdpZHRoICsgNSA6IC01O1xuICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IGl0ZW1BbGlnbjtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGxlZ2VuZE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycgJiYgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGZvcm1hdHRlci5yZXBsYWNlKCd7bmFtZX0nLCBuYW1lICE9IG51bGwgPyBuYW1lIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmb3JtYXR0ZXIobmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgeDogdGV4dFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGl0ZW1IZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBpc1NlbGVjdGVkID8gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgOiBpbmFjdGl2ZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdGVtR3JvdXAuYWRkKHRleHQpO1xuXG4gICAgICAgICAgICAvLyBBZGQgYSBpbnZpc2libGUgcmVjdCB0byBpbmNyZWFzZSB0aGUgYXJlYSBvZiBtb3VzZSBob3ZlclxuICAgICAgICAgICAgdmFyIGhpdFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICBzaGFwZTogaXRlbUdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLFxuICAgICAgICAgICAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykgPyB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsIGZvcm1hdHRlclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGxlZ2VuZEdsb2JhbFRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlcicsIHRydWUpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdsZWdlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kSW5kZXg6IGxlZ2VuZE1vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdG9vbHRpcE1vZGVsLm9wdGlvbikgOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQoaGl0UmVjdCk7XG5cbiAgICAgICAgICAgIGl0ZW1Hcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBoaXRSZWN0LnNpbGVudCA9ICFzZWxlY3RNb2RlO1xuXG5cblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoaXRlbUdyb3VwKTtcblxuICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKGl0ZW1Hcm91cCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtR3JvdXA7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Legend action\n */\n\n\n    var echarts = __webpack_require__(1);\n    var zrUtil = __webpack_require__(0);\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (selectedMap.hasOwnProperty(name)) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzPzYyNjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTGVnZW5kIGFjdGlvblxuICovXG5cblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIGZ1bmN0aW9uIGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIobWV0aG9kTmFtZSwgcGF5bG9hZCwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRNYXAgPSB7fTtcbiAgICAgICAgdmFyIGlzVG9nZ2xlU2VsZWN0ID0gbWV0aG9kTmFtZSA9PT0gJ3RvZ2dsZVNlbGVjdGVkJztcbiAgICAgICAgdmFyIGlzU2VsZWN0ZWQ7XG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgbGVnZW5kIGNvbXBvbmVudHNcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdsZWdlbmQnLCBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc1RvZ2dsZVNlbGVjdCAmJiBpc1NlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBvdGhlciBsZWdlbmQgaGFzIHNhbWUgc2VsZWN0ZWQgc3RhdHVzXG4gICAgICAgICAgICAgICAgLy8gT3IgdGhlIGZpcnN0IGlzIHRvZ2dsZWQgdG8gdHJ1ZSBhbmQgb3RoZXIgYXJlIHRvZ2dsZWQgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvbmUgbGVnZW5kIGhhcyBzb21lIGl0ZW0gdW5TZWxlY3RlZCBpbiBvcHRpb24uIEFuZCBpZiBvdGhlciBsZWdlbmRcbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IGhhcyB0aGUgaXRlbSwgdGhleSB3aWxsIGFzc3VtZSBpdCBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICBsZWdlbmRNb2RlbFtpc1NlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5TZWxlY3QnXShwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kTW9kZWxbbWV0aG9kTmFtZV0ocGF5bG9hZC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlZ2VuZERhdGEgPSBsZWdlbmRNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChsZWdlbmREYXRhLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1vZGVsLmdldCgnbmFtZScpO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnXFxuJyB8fCBuYW1lID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpc0l0ZW1TZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2VsZWN0ZWQgaWYgYW55IGxlZ2VuZCBpcyB1bnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTWFwW25hbWVdID0gc2VsZWN0ZWRNYXBbbmFtZV0gJiYgaXNJdGVtU2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IGlzSXRlbVNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBldmVudCBleHBsaWNpdGx5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBwYXlsb2FkLm5hbWUsXG4gICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRNYXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV2ZW50IGxlZ2VuZFRvZ2dsZVNlbGVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFRvZ2dsZVNlbGVjdCdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2Zyb21dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICAnbGVnZW5kVG9nZ2xlU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGNoYW5nZWQnLFxuICAgICAgICB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3RvZ2dsZVNlbGVjdGVkJylcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IGxlZ2VuZFNlbGVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFNlbGVjdCdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgICdsZWdlbmRTZWxlY3QnLCAnbGVnZW5kc2VsZWN0ZWQnLFxuICAgICAgICB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3NlbGVjdCcpXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBsZWdlbmRVblNlbGVjdFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFVuU2VsZWN0J1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbihcbiAgICAgICAgJ2xlZ2VuZFVuU2VsZWN0JywgJ2xlZ2VuZHVuc2VsZWN0ZWQnLFxuICAgICAgICB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3VuU2VsZWN0JylcbiAgICApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 143 */
/***/ (function(module, exports) {

eval("\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzPzE0NDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBIiwiZmlsZSI6IjE0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICB2YXIgbGVnZW5kTW9kZWxzID0gZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgICAgICAgICBtYWluVHlwZTogJ2xlZ2VuZCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsZWdlbmRNb2RlbHMgJiYgbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWNNb2RlbC5maWx0ZXJTZXJpZXMoZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgaW4gbGVnZW5kIHNlcmllcyBpcyBhc3N1bWVkIHNlbGVjdGVkIHdoZW4gaXQgaXMgbm90IGluIHRoZSBsZWdlbmQgZGF0YS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKHNlcmllcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var echarts = __webpack_require__(1);\n    var graphic = __webpack_require__(2);\n    var layout = __webpack_require__(15);\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 6,\n            show: true,\n\n            text: '',\n            // 超链接跳转\n            // link: null,\n            // 仅支持self | blank\n            target: 'blank',\n            subtext: '',\n\n            // 超链接跳转\n            // sublink: null,\n            // 仅支持self | blank\n            subtarget: 'blank',\n\n            // 'center' ¦ 'left' ¦ 'right'\n            // ¦ {number}（x坐标，单位px）\n            left: 0,\n            // 'top' ¦ 'bottom' ¦ 'center'\n            // ¦ {number}（y坐标，单位px）\n            top: 0,\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right' | 'center'\n            // 默认根据 left 的位置判断是左对齐还是右对齐\n            // textAlign: null\n            //\n            // 垂直对齐\n            // 'auto' | 'top' | 'bottom' | 'middle'\n            // 默认根据 top 位置判断是上对齐还是下对齐\n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // 标题边框颜色\n            borderColor: '#ccc',\n\n            // 标题边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 标题内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // 主副标题纵向间隔，单位px，默认为10，\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90aXRsZS5qcz9jMzAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsOEJBQThCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiIxNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvLyBNb2RlbFxuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICd0aXRsZScsXG5cbiAgICAgICAgbGF5b3V0TW9kZToge3R5cGU6ICdib3gnLCBpZ25vcmVTaXplOiB0cnVlfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgejogNixcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgICAgICAgICAvLyBsaW5rOiBudWxsLFxuICAgICAgICAgICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgICAgICAgICB0YXJnZXQ6ICdibGFuaycsXG4gICAgICAgICAgICBzdWJ0ZXh0OiAnJyxcblxuICAgICAgICAgICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgICAgICAgICAvLyBzdWJsaW5rOiBudWxsLFxuICAgICAgICAgICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgICAgICAgICBzdWJ0YXJnZXQ6ICdibGFuaycsXG5cbiAgICAgICAgICAgIC8vICdjZW50ZXInIMKmICdsZWZ0JyDCpiAncmlnaHQnXG4gICAgICAgICAgICAvLyDCpiB7bnVtYmVyfe+8iHjlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIC8vICd0b3AnIMKmICdib3R0b20nIMKmICdjZW50ZXInXG4gICAgICAgICAgICAvLyDCpiB7bnVtYmVyfe+8iHnlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgICAgICAgICAgdG9wOiAwLFxuXG4gICAgICAgICAgICAvLyDmsLTlubPlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJ1xuICAgICAgICAgICAgLy8g6buY6K6k5qC55o2uIGxlZnQg55qE5L2N572u5Yik5pat5piv5bem5a+56b2Q6L+Y5piv5Y+z5a+56b2QXG4gICAgICAgICAgICAvLyB0ZXh0QWxpZ246IG51bGxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyDlnoLnm7Tlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICd0b3AnIHwgJ2JvdHRvbScgfCAnbWlkZGxlJ1xuICAgICAgICAgICAgLy8g6buY6K6k5qC55o2uIHRvcCDkvY3nva7liKTmlq3mmK/kuIrlr7npvZDov5jmmK/kuIvlr7npvZBcbiAgICAgICAgICAgIC8vIHRleHRCYXNlbGluZTogbnVsbFxuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcblxuICAgICAgICAgICAgLy8g5qCH6aKY6L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuXG4gICAgICAgICAgICAvLyDmoIfpopjovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuXG4gICAgICAgICAgICAvLyDmoIfpopjlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcbiAgICAgICAgICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgICAgICAgICAgcGFkZGluZzogNSxcblxuICAgICAgICAgICAgLy8g5Li75Ymv5qCH6aKY57q15ZCR6Ze06ZqU77yM5Y2V5L2NcHjvvIzpu5jorqTkuLoxMO+8jFxuICAgICAgICAgICAgaXRlbUdhcDogMTAsXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTgsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGRlcicsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzMzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1YnRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2FhYSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVmlld1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ3RpdGxlJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICh0aXRsZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIGlmICghdGl0bGVNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGl0bGVNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgc3VidGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCdzdWJ0ZXh0U3R5bGUnKTtcblxuICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCd0ZXh0QWxpZ24nKTtcbiAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aXRsZU1vZGVsLmdldCgndGV4dEJhc2VsaW5lJyk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aXRsZU1vZGVsLmdldCgndGV4dCcpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dEVsLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICAgICAgICB2YXIgc3ViVGV4dCA9IHRpdGxlTW9kZWwuZ2V0KCdzdWJ0ZXh0Jyk7XG4gICAgICAgICAgICB2YXIgc3ViVGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3ViVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHN1YnRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogc3VidGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgICAgICAgICAgICAgIHk6IHRleHRSZWN0LmhlaWdodCArIHRpdGxlTW9kZWwuZ2V0KCdpdGVtR2FwJyksXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHoyOiAxMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ2xpbmsnKTtcbiAgICAgICAgICAgIHZhciBzdWJsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ3N1YmxpbmsnKTtcblxuICAgICAgICAgICAgdGV4dEVsLnNpbGVudCA9ICFsaW5rO1xuICAgICAgICAgICAgc3ViVGV4dEVsLnNpbGVudCA9ICFzdWJsaW5rO1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIHRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCd0YXJnZXQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VibGluaykge1xuICAgICAgICAgICAgICAgIHN1YlRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHN1YmxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCdzdWJ0YXJnZXQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgICAgICAgICAgc3ViVGV4dCAmJiBncm91cC5hZGQoc3ViVGV4dEVsKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHN1YlRleHQsIGJ1dCBhZGQgc3ViVGV4dEVsLCB0aGVyZSB3aWxsIGJlIGFuIGVtcHR5IGxpbmUuXG5cbiAgICAgICAgICAgIHZhciBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRPcHRpb24gPSB0aXRsZU1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgICAgICAgICAgbGF5b3V0T3B0aW9uLndpZHRoID0gZ3JvdXBSZWN0LndpZHRoO1xuICAgICAgICAgICAgbGF5b3V0T3B0aW9uLmhlaWdodCA9IGdyb3VwUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KFxuICAgICAgICAgICAgICAgIGxheW91dE9wdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICAgICAgfSwgdGl0bGVNb2RlbC5nZXQoJ3BhZGRpbmcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0ZXh0IGFsaWduIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAoIXRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgIC8vIEFsaWduIGxlZnQgaWYgdGl0bGUgaXMgb24gdGhlIGxlZnQuIGNlbnRlciBhbmQgcmlnaHQgaXMgc2FtZVxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCdsZWZ0JykgfHwgdGl0bGVNb2RlbC5nZXQoJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBsYXlvdXQgYnkgdGV4dCBhbGlnblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC54ICs9IGxheW91dFJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC54ICs9IGxheW91dFJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gdGl0bGVNb2RlbC5nZXQoJ3RvcCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdib3R0b20nKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC55ICs9IGxheW91dFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICd0b3AnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5hdHRyKCdwb3NpdGlvbicsIFtsYXlvdXRSZWN0LngsIGxheW91dFJlY3QueV0pO1xuICAgICAgICAgICAgdmFyIGFsaWduU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRCYXNlbGluZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcbiAgICAgICAgICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIGJhY2tncm91bmRcbiAgICAgICAgICAgIC8vIEdldCBncm91cFJlY3QgYWdhaW4gYmVjYXVzZSB0ZXh0QWxpZ24gaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgICAgICAgZ3JvdXBSZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IGxheW91dFJlY3QubWFyZ2luO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgICAgICAgICAgc3R5bGUuZmlsbCA9IHRpdGxlTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZ3JvdXBSZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICB5OiBncm91cFJlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBncm91cFJlY3Qud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBncm91cFJlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcblxuICAgICAgICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(146);\n    __webpack_require__(147);\n\n    __webpack_require__(152);\n    __webpack_require__(150);\n    __webpack_require__(148);\n    __webpack_require__(149);\n    __webpack_require__(151);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94LmpzPzk5NGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQ1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICByZXF1aXJlKCcuL3Rvb2xib3gvVG9vbGJveE1vZGVsJyk7XG4gICAgcmVxdWlyZSgnLi90b29sYm94L1Rvb2xib3hWaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuL3Rvb2xib3gvZmVhdHVyZS9TYXZlQXNJbWFnZScpO1xuICAgIHJlcXVpcmUoJy4vdG9vbGJveC9mZWF0dXJlL01hZ2ljVHlwZScpO1xuICAgIHJlcXVpcmUoJy4vdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3Jyk7XG4gICAgcmVxdWlyZSgnLi90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20nKTtcbiAgICByZXF1aXJlKCcuL3Rvb2xib3gvZmVhdHVyZS9SZXN0b3JlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3guanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var featureManager = __webpack_require__(14);\n    var zrUtil = __webpack_require__(0);\n\n    var ToolboxModel = __webpack_require__(1).extendComponentModel({\n\n        type: 'toolbox',\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        mergeDefaultAndTheme: function (option) {\n            ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n\n            zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n                var Feature = featureManager.get(featureName);\n                Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n            });\n        },\n\n        defaultOption: {\n\n            show: true,\n\n            z: 6,\n\n            zlevel: 0,\n\n            orient: 'horizontal',\n\n            left: 'right',\n\n            top: 'top',\n\n            // right\n            // bottom\n\n            backgroundColor: 'transparent',\n\n            borderColor: '#ccc',\n\n            borderWidth: 0,\n\n            padding: 5,\n\n            itemSize: 15,\n\n            itemGap: 8,\n\n            showTitle: true,\n\n            iconStyle: {\n                normal: {\n                    borderColor: '#666',\n                    color: 'none'\n                },\n                emphasis: {\n                    borderColor: '#3E98C5'\n                }\n            }\n            // textStyle: {},\n\n            // feature\n        }\n    });\n\n    module.exports = ToolboxModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hNb2RlbC5qcz84MjkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuL2ZlYXR1cmVNYW5hZ2VyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIFRvb2xib3hNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ3Rvb2xib3gnLFxuXG4gICAgICAgIGxheW91dE1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib3gnLFxuICAgICAgICAgICAgaWdub3JlU2l6ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBUb29sYm94TW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnbWVyZ2VEZWZhdWx0QW5kVGhlbWUnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aGlzLm9wdGlvbi5mZWF0dXJlLCBmdW5jdGlvbiAoZmVhdHVyZU9wdCwgZmVhdHVyZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmVhdHVyZSA9IGZlYXR1cmVNYW5hZ2VyLmdldChmZWF0dXJlTmFtZSk7XG4gICAgICAgICAgICAgICAgRmVhdHVyZSAmJiB6clV0aWwubWVyZ2UoZmVhdHVyZU9wdCwgRmVhdHVyZS5kZWZhdWx0T3B0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcblxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcblxuICAgICAgICAgICAgejogNixcblxuICAgICAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgICAgICBvcmllbnQ6ICdob3Jpem9udGFsJyxcblxuICAgICAgICAgICAgbGVmdDogJ3JpZ2h0JyxcblxuICAgICAgICAgICAgdG9wOiAndG9wJyxcblxuICAgICAgICAgICAgLy8gcmlnaHRcbiAgICAgICAgICAgIC8vIGJvdHRvbVxuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG5cbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuXG4gICAgICAgICAgICBwYWRkaW5nOiA1LFxuXG4gICAgICAgICAgICBpdGVtU2l6ZTogMTUsXG5cbiAgICAgICAgICAgIGl0ZW1HYXA6IDgsXG5cbiAgICAgICAgICAgIHNob3dUaXRsZTogdHJ1ZSxcblxuICAgICAgICAgICAgaWNvblN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzY2NicsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnbm9uZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzNFOThDNSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0U3R5bGU6IHt9LFxuXG4gICAgICAgICAgICAvLyBmZWF0dXJlXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9vbGJveE1vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var featureManager = __webpack_require__(14);\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var Model = __webpack_require__(9);\n    var DataDiffer = __webpack_require__(34);\n    var listComponentHelper = __webpack_require__(56);\n    var textContain = __webpack_require__(16);\n\n    module.exports = __webpack_require__(1).extendComponentView({\n\n        type: 'toolbox',\n\n        render: function (toolboxModel, ecModel, api, payload) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!toolboxModel.get('show')) {\n                return;\n            }\n\n            var itemSize = +toolboxModel.get('itemSize');\n            var featureOpts = toolboxModel.get('feature') || {};\n            var features = this._features || (this._features = {});\n\n            var featureNames = [];\n            zrUtil.each(featureOpts, function (opt, name) {\n                featureNames.push(name);\n            });\n\n            (new DataDiffer(this._featureNames || [], featureNames))\n                .add(process)\n                .update(process)\n                .remove(zrUtil.curry(process, null))\n                .execute();\n\n            // Keep for diff.\n            this._featureNames = featureNames;\n\n            function process(newIndex, oldIndex) {\n                var featureName = featureNames[newIndex];\n                var oldName = featureNames[oldIndex];\n                var featureOpt = featureOpts[featureName];\n                var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n                var feature;\n\n                if (featureName && !oldName) { // Create\n                    if (isUserFeatureName(featureName)) {\n                        feature = {\n                            model: featureModel,\n                            onclick: featureModel.option.onclick,\n                            featureName: featureName\n                        };\n                    }\n                    else {\n                        var Feature = featureManager.get(featureName);\n                        if (!Feature) {\n                            return;\n                        }\n                        feature = new Feature(featureModel, ecModel, api);\n                    }\n                    features[featureName] = feature;\n                }\n                else {\n                    feature = features[oldName];\n                    // If feature does not exsit.\n                    if (!feature) {\n                        return;\n                    }\n                    feature.model = featureModel;\n                    feature.ecModel = ecModel;\n                    feature.api = api;\n                }\n\n                if (!featureName && oldName) {\n                    feature.dispose && feature.dispose(ecModel, api);\n                    return;\n                }\n\n                if (!featureModel.get('show') || feature.unusable) {\n                    feature.remove && feature.remove(ecModel, api);\n                    return;\n                }\n\n                createIconPaths(featureModel, feature, featureName);\n\n                featureModel.setIconStatus = function (iconName, status) {\n                    var option = this.option;\n                    var iconPaths = this.iconPaths;\n                    option.iconStatus = option.iconStatus || {};\n                    option.iconStatus[iconName] = status;\n                    // FIXME\n                    iconPaths[iconName] && iconPaths[iconName].trigger(status);\n                };\n\n                if (feature.render) {\n                    feature.render(featureModel, ecModel, api, payload);\n                }\n            }\n\n            function createIconPaths(featureModel, feature, featureName) {\n                var iconStyleModel = featureModel.getModel('iconStyle');\n\n                // If one feature has mutiple icon. they are orginaized as\n                // {\n                //     icon: {\n                //         foo: '',\n                //         bar: ''\n                //     },\n                //     title: {\n                //         foo: '',\n                //         bar: ''\n                //     }\n                // }\n                var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n                var titles = featureModel.get('title') || {};\n                if (typeof icons === 'string') {\n                    var icon = icons;\n                    var title = titles;\n                    icons = {};\n                    titles = {};\n                    icons[featureName] = icon;\n                    titles[featureName] = title;\n                }\n                var iconPaths = featureModel.iconPaths = {};\n                zrUtil.each(icons, function (icon, iconName) {\n                    var normalStyle = iconStyleModel.getModel('normal').getItemStyle();\n                    var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\n                    var style = {\n                        x: -itemSize / 2,\n                        y: -itemSize / 2,\n                        width: itemSize,\n                        height: itemSize\n                    };\n                    var path = icon.indexOf('image://') === 0\n                        ? (\n                            style.image = icon.slice(8),\n                            new graphic.Image({style: style})\n                        )\n                        : graphic.makePath(\n                            icon.replace('path://', ''),\n                            {\n                                style: normalStyle,\n                                hoverStyle: hoverStyle,\n                                rectHover: true\n                            },\n                            style,\n                            'center'\n                        );\n\n                    graphic.setHoverStyle(path);\n\n                    if (toolboxModel.get('showTitle')) {\n                        path.__title = titles[iconName];\n                        path.on('mouseover', function () {\n                                // Should not reuse above hoverStyle, which might be modified.\n                                var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n                                path.setStyle({\n                                    text: titles[iconName],\n                                    textPosition: hoverStyle.textPosition || 'bottom',\n                                    textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n                                    textAlign: hoverStyle.textAlign || 'center'\n                                });\n                            })\n                            .on('mouseout', function () {\n                                path.setStyle({\n                                    textFill: null\n                                });\n                            });\n                    }\n                    path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n\n                    group.add(path);\n                    path.on('click', zrUtil.bind(\n                        feature.onclick, feature, ecModel, api, iconName\n                    ));\n\n                    iconPaths[iconName] = path;\n                });\n            }\n\n            listComponentHelper.layout(group, toolboxModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, toolboxModel);\n\n            // Adjust icon title positions to avoid them out of screen\n            group.eachChild(function (icon) {\n                var titleText = icon.__title;\n                var hoverStyle = icon.hoverStyle;\n                // May be background element\n                if (hoverStyle && titleText) {\n                    var rect = textContain.getBoundingRect(\n                        titleText, hoverStyle.font\n                    );\n                    var offsetX = icon.position[0] + group.position[0];\n                    var offsetY = icon.position[1] + group.position[1] + itemSize;\n\n                    var needPutOnTop = false;\n                    if (offsetY + rect.height > api.getHeight()) {\n                        hoverStyle.textPosition = 'top';\n                        needPutOnTop = true;\n                    }\n                    var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);\n                    if (offsetX + rect.width /  2 > api.getWidth()) {\n                        hoverStyle.textPosition = ['100%', topOffset];\n                        hoverStyle.textAlign = 'right';\n                    }\n                    else if (offsetX - rect.width / 2 < 0) {\n                        hoverStyle.textPosition = [0, topOffset];\n                        hoverStyle.textAlign = 'left';\n                    }\n                }\n            });\n        },\n\n        updateView: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n            });\n        },\n\n        updateLayout: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n            });\n        },\n\n        remove: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.remove && feature.remove(ecModel, api);\n            });\n            this.group.removeAll();\n        },\n\n        dispose: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.dispose && feature.dispose(ecModel, api);\n            });\n        }\n    });\n\n    function isUserFeatureName(featureName) {\n        return featureName.indexOf('my') === 0;\n    }\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hWaWV3LmpzP2RkMTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuL2ZlYXR1cmVNYW5hZ2VyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvRGF0YURpZmZlcicpO1xuICAgIHZhciBsaXN0Q29tcG9uZW50SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL2xpc3RDb21wb25lbnQnKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sYm94JyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2xib3hNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZW1TaXplID0gK3Rvb2xib3hNb2RlbC5nZXQoJ2l0ZW1TaXplJyk7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZU9wdHMgPSB0b29sYm94TW9kZWwuZ2V0KCdmZWF0dXJlJykgfHwge307XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9mZWF0dXJlcyB8fCAodGhpcy5fZmVhdHVyZXMgPSB7fSk7XG5cbiAgICAgICAgICAgIHZhciBmZWF0dXJlTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGZlYXR1cmVPcHRzLCBmdW5jdGlvbiAob3B0LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZU5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgKG5ldyBEYXRhRGlmZmVyKHRoaXMuX2ZlYXR1cmVOYW1lcyB8fCBbXSwgZmVhdHVyZU5hbWVzKSlcbiAgICAgICAgICAgICAgICAuYWRkKHByb2Nlc3MpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShwcm9jZXNzKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoenJVdGlsLmN1cnJ5KHByb2Nlc3MsIG51bGwpKVxuICAgICAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgIC8vIEtlZXAgZm9yIGRpZmYuXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTmFtZXMgPSBmZWF0dXJlTmFtZXM7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3MobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVOYW1lID0gZmVhdHVyZU5hbWVzW25ld0luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkTmFtZSA9IGZlYXR1cmVOYW1lc1tvbGRJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVPcHQgPSBmZWF0dXJlT3B0c1tmZWF0dXJlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVNb2RlbCA9IG5ldyBNb2RlbChmZWF0dXJlT3B0LCB0b29sYm94TW9kZWwsIHRvb2xib3hNb2RlbC5lY01vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZTtcblxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTmFtZSAmJiAhb2xkTmFtZSkgeyAvLyBDcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVXNlckZlYXR1cmVOYW1lKGZlYXR1cmVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogZmVhdHVyZU1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZlYXR1cmVNb2RlbC5vcHRpb24ub25jbGljayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTmFtZTogZmVhdHVyZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgRmVhdHVyZSA9IGZlYXR1cmVNYW5hZ2VyLmdldChmZWF0dXJlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlID0gbmV3IEZlYXR1cmUoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW2ZlYXR1cmVOYW1lXSA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlID0gZmVhdHVyZXNbb2xkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgZG9lcyBub3QgZXhzaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubW9kZWwgPSBmZWF0dXJlTW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuYXBpID0gYXBpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZU5hbWUgJiYgb2xkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmRpc3Bvc2UgJiYgZmVhdHVyZS5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZlYXR1cmVNb2RlbC5nZXQoJ3Nob3cnKSB8fCBmZWF0dXJlLnVudXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucmVtb3ZlICYmIGZlYXR1cmUucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjcmVhdGVJY29uUGF0aHMoZmVhdHVyZU1vZGVsLCBmZWF0dXJlLCBmZWF0dXJlTmFtZSk7XG5cbiAgICAgICAgICAgICAgICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cyA9IGZ1bmN0aW9uIChpY29uTmFtZSwgc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGljb25QYXRocyA9IHRoaXMuaWNvblBhdGhzO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uaWNvblN0YXR1cyA9IG9wdGlvbi5pY29uU3RhdHVzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uaWNvblN0YXR1c1tpY29uTmFtZV0gPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIGljb25QYXRoc1tpY29uTmFtZV0gJiYgaWNvblBhdGhzW2ljb25OYW1lXS50cmlnZ2VyKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnJlbmRlcihmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVJY29uUGF0aHMoZmVhdHVyZU1vZGVsLCBmZWF0dXJlLCBmZWF0dXJlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBpY29uU3R5bGVNb2RlbCA9IGZlYXR1cmVNb2RlbC5nZXRNb2RlbCgnaWNvblN0eWxlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBvbmUgZmVhdHVyZSBoYXMgbXV0aXBsZSBpY29uLiB0aGV5IGFyZSBvcmdpbmFpemVkIGFzXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgICBpY29uOiB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBmb286ICcnLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgYmFyOiAnJ1xuICAgICAgICAgICAgICAgIC8vICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZm9vOiAnJyxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB2YXIgaWNvbnMgPSBmZWF0dXJlLmdldEljb25zID8gZmVhdHVyZS5nZXRJY29ucygpIDogZmVhdHVyZU1vZGVsLmdldCgnaWNvbicpO1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZXMgPSBmZWF0dXJlTW9kZWwuZ2V0KCd0aXRsZScpIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaWNvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpY29uID0gaWNvbnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IHRpdGxlcztcbiAgICAgICAgICAgICAgICAgICAgaWNvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGljb25zW2ZlYXR1cmVOYW1lXSA9IGljb247XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlc1tmZWF0dXJlTmFtZV0gPSB0aXRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGljb25QYXRocyA9IGZlYXR1cmVNb2RlbC5pY29uUGF0aHMgPSB7fTtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChpY29ucywgZnVuY3Rpb24gKGljb24sIGljb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IGljb25TdHlsZU1vZGVsLmdldE1vZGVsKCdub3JtYWwnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpY29uU3R5bGVNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKS5nZXRJdGVtU3R5bGUoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtaXRlbVNpemUgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogLWl0ZW1TaXplIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBpY29uLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmltYWdlID0gaWNvbi5zbGljZSg4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgZ3JhcGhpYy5JbWFnZSh7c3R5bGU6IHN0eWxlfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZ3JhcGhpYy5tYWtlUGF0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uLnJlcGxhY2UoJ3BhdGg6Ly8nLCAnJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogbm9ybWFsU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyU3R5bGU6IGhvdmVyU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RIb3ZlcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHBhdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sYm94TW9kZWwuZ2V0KCdzaG93VGl0bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5fX3RpdGxlID0gdGl0bGVzW2ljb25OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZXVzZSBhYm92ZSBob3ZlclN0eWxlLCB3aGljaCBtaWdodCBiZSBtb2RpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpY29uU3R5bGVNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aXRsZXNbaWNvbk5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBob3ZlclN0eWxlLnRleHRQb3NpdGlvbiB8fCAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGaWxsOiBob3ZlclN0eWxlLmZpbGwgfHwgaG92ZXJTdHlsZS5zdHJva2UgfHwgJyMwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBob3ZlclN0eWxlLnRleHRBbGlnbiB8fCAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZpbGw6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aC50cmlnZ2VyKGZlYXR1cmVNb2RlbC5nZXQoJ2ljb25TdGF0dXMuJyArIGljb25OYW1lKSB8fCAnbm9ybWFsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLm9uKCdjbGljaycsIHpyVXRpbC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5vbmNsaWNrLCBmZWF0dXJlLCBlY01vZGVsLCBhcGksIGljb25OYW1lXG4gICAgICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGljb25QYXRoc1tpY29uTmFtZV0gPSBwYXRoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0Q29tcG9uZW50SGVscGVyLmxheW91dChncm91cCwgdG9vbGJveE1vZGVsLCBhcGkpO1xuICAgICAgICAgICAgLy8gUmVuZGVyIGJhY2tncm91bmQgYWZ0ZXIgZ3JvdXAgaXMgbGF5b3V0XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgbGlzdENvbXBvbmVudEhlbHBlci5hZGRCYWNrZ3JvdW5kKGdyb3VwLCB0b29sYm94TW9kZWwpO1xuXG4gICAgICAgICAgICAvLyBBZGp1c3QgaWNvbiB0aXRsZSBwb3NpdGlvbnMgdG8gYXZvaWQgdGhlbSBvdXQgb2Ygc2NyZWVuXG4gICAgICAgICAgICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGljb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGVUZXh0ID0gaWNvbi5fX3RpdGxlO1xuICAgICAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gaWNvbi5ob3ZlclN0eWxlO1xuICAgICAgICAgICAgICAgIC8vIE1heSBiZSBiYWNrZ3JvdW5kIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJTdHlsZSAmJiB0aXRsZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZVRleHQsIGhvdmVyU3R5bGUuZm9udFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IGljb24ucG9zaXRpb25bMF0gKyBncm91cC5wb3NpdGlvblswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBpY29uLnBvc2l0aW9uWzFdICsgZ3JvdXAucG9zaXRpb25bMV0gKyBpdGVtU2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZFB1dE9uVG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRZICsgcmVjdC5oZWlnaHQgPiBhcGkuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkUHV0T25Ub3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BPZmZzZXQgPSBuZWVkUHV0T25Ub3AgPyAoLTUgLSByZWN0LmhlaWdodCkgOiAoaXRlbVNpemUgKyA4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldFggKyByZWN0LndpZHRoIC8gIDIgPiBhcGkuZ2V0V2lkdGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJTdHlsZS50ZXh0UG9zaXRpb24gPSBbJzEwMCUnLCB0b3BPZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJTdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldFggLSByZWN0LndpZHRoIC8gMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uID0gWzAsIHRvcE9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlclN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS51cGRhdGVWaWV3ICYmIGZlYXR1cmUudXBkYXRlVmlldyhmZWF0dXJlLm1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAodG9vbGJveE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUudXBkYXRlTGF5b3V0ICYmIGZlYXR1cmUudXBkYXRlTGF5b3V0KGZlYXR1cmUubW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucmVtb3ZlICYmIGZlYXR1cmUucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5kaXNwb3NlICYmIGZlYXR1cmUuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzVXNlckZlYXR1cmVOYW1lKGZlYXR1cmVOYW1lKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlTmFtZS5pbmRleE9mKCdteScpID09PSAwO1xuICAgIH1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/component/toolbox/feature/DataView\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var eventTool = __webpack_require__(19);\n\n\n    var BLOCK_SPLITER = new Array(60).join('-');\n    var ITEM_SPLITER = '\\t';\n    /**\n     * Group series into two types\n     *  1. on category axis, like line, bar\n     *  2. others, like scatter, pie\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object}\n     * @inner\n     */\n    function groupSeries(ecModel) {\n        var seriesGroupByCategoryAxis = {};\n        var otherSeries = [];\n        var meta = [];\n        ecModel.eachRawSeries(function (seriesModel) {\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n                var baseAxis = coordSys.getBaseAxis();\n                if (baseAxis.type === 'category') {\n                    var key = baseAxis.dim + '_' + baseAxis.index;\n                    if (!seriesGroupByCategoryAxis[key]) {\n                        seriesGroupByCategoryAxis[key] = {\n                            categoryAxis: baseAxis,\n                            valueAxis: coordSys.getOtherAxis(baseAxis),\n                            series: []\n                        };\n                        meta.push({\n                            axisDim: baseAxis.dim,\n                            axisIndex: baseAxis.index\n                        });\n                    }\n                    seriesGroupByCategoryAxis[key].series.push(seriesModel);\n                }\n                else {\n                    otherSeries.push(seriesModel);\n                }\n            }\n            else {\n                otherSeries.push(seriesModel);\n            }\n        });\n\n        return {\n            seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n            other: otherSeries,\n            meta: meta\n        };\n    }\n\n    /**\n     * Assemble content of series on cateogory axis\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleSeriesWithCategoryAxis(series) {\n        var tables = [];\n        zrUtil.each(series, function (group, key) {\n            var categoryAxis = group.categoryAxis;\n            var valueAxis = group.valueAxis;\n            var valueAxisDim = valueAxis.dim;\n\n            var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n                return series.name;\n            }));\n            var columns = [categoryAxis.model.getCategories()];\n            zrUtil.each(group.series, function (series) {\n                columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n                    return val;\n                }));\n            });\n            // Assemble table content\n            var lines = [headers.join(ITEM_SPLITER)];\n            for (var i = 0; i < columns[0].length; i++) {\n                var items = [];\n                for (var j = 0; j < columns.length; j++) {\n                    items.push(columns[j][i]);\n                }\n                lines.push(items.join(ITEM_SPLITER));\n            }\n            tables.push(lines.join('\\n'));\n        });\n        return tables.join('\\n\\n' +  BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * Assemble content of other series\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleOtherSeries(series) {\n        return zrUtil.map(series, function (series) {\n            var data = series.getRawData();\n            var lines = [series.name];\n            var vals = [];\n            data.each(data.dimensions, function () {\n                var argLen = arguments.length;\n                var dataIndex = arguments[argLen - 1];\n                var name = data.getName(dataIndex);\n                for (var i = 0; i < argLen - 1; i++) {\n                    vals[i] = arguments[i];\n                }\n                lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));\n            });\n            return lines.join('\\n');\n        }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * @param {module:echarts/model/Global}\n     * @return {string}\n     * @inner\n     */\n    function getContentFromModel(ecModel) {\n\n        var result = groupSeries(ecModel);\n\n        return {\n            value: zrUtil.filter([\n                    assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),\n                    assembleOtherSeries(result.other)\n                ], function (str) {\n                    return str.replace(/[\\n\\t\\s]/g, '');\n                }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n\n            meta: result.meta\n        };\n    }\n\n\n    function trim(str) {\n        return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n    /**\n     * If a block is tsv format\n     */\n    function isTSVFormat(block) {\n        // Simple method to find out if a block is tsv format\n        var firstLine = block.slice(0, block.indexOf('\\n'));\n        if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n            return true;\n        }\n    }\n\n    var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n    /**\n     * @param {string} tsv\n     * @return {Array.<Object>}\n     */\n    function parseTSVContents(tsv) {\n        var tsvLines = tsv.split(/\\n+/g);\n        var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n\n        var categories = [];\n        var series = zrUtil.map(headers, function (header) {\n            return {\n                name: header,\n                data: []\n            };\n        });\n        for (var i = 0; i < tsvLines.length; i++) {\n            var items = trim(tsvLines[i]).split(itemSplitRegex);\n            categories.push(items.shift());\n            for (var j = 0; j < items.length; j++) {\n                series[j] && (series[j].data[i] = items[j]);\n            }\n        }\n        return {\n            series: series,\n            categories: categories\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @return {Array.<Object>}\n     * @inner\n     */\n    function parseListContents(str) {\n        var lines = str.split(/\\n+/g);\n        var seriesName = trim(lines.shift());\n\n        var data = [];\n        for (var i = 0; i < lines.length; i++) {\n            var items = trim(lines[i]).split(itemSplitRegex);\n            var name = '';\n            var value;\n            var hasName = false;\n            if (isNaN(items[0])) { // First item is name\n                hasName = true;\n                name = items[0];\n                items = items.slice(1);\n                data[i] = {\n                    name: name,\n                    value: []\n                };\n                value = data[i].value;\n            }\n            else {\n                value = data[i] = [];\n            }\n            for (var j = 0; j < items.length; j++) {\n                value.push(+items[j]);\n            }\n            if (value.length === 1) {\n                hasName ? (data[i].value = value[0]) : (data[i] = value[0]);\n            }\n        }\n\n        return {\n            name: seriesName,\n            data: data\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @param {Array.<Object>} blockMetaList\n     * @return {Object}\n     * @inner\n     */\n    function parseContents(str, blockMetaList) {\n        var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n        var newOption = {\n            series: []\n        };\n        zrUtil.each(blocks, function (block, idx) {\n            if (isTSVFormat(block)) {\n                var result = parseTSVContents(block);\n                var blockMeta = blockMetaList[idx];\n                var axisKey = blockMeta.axisDim + 'Axis';\n\n                if (blockMeta) {\n                    newOption[axisKey] = newOption[axisKey] || [];\n                    newOption[axisKey][blockMeta.axisIndex] = {\n                        data: result.categories\n                    };\n                    newOption.series = newOption.series.concat(result.series);\n                }\n            }\n            else {\n                var result = parseListContents(block);\n                newOption.series.push(result);\n            }\n        });\n        return newOption;\n    }\n\n    /**\n     * @alias {module:echarts/component/toolbox/feature/DataView}\n     * @constructor\n     * @param {module:echarts/model/Model} model\n     */\n    function DataView(model) {\n\n        this._dom = null;\n\n        this.model = model;\n    }\n\n    DataView.defaultOption = {\n        show: true,\n        readOnly: false,\n        optionToContent: null,\n        contentToOption: null,\n\n        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n        title: '数据视图',\n        lang: ['数据视图', '关闭', '刷新'],\n        backgroundColor: '#fff',\n        textColor: '#000',\n        textareaColor: '#fff',\n        textareaBorderColor: '#333',\n        buttonColor: '#c23531',\n        buttonTextColor: '#fff'\n    };\n\n    DataView.prototype.onclick = function (ecModel, api) {\n        var container = api.getDom();\n        var model = this.model;\n        if (this._dom) {\n            container.removeChild(this._dom);\n        }\n        var root = document.createElement('div');\n        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n        root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n\n        // Create elements\n        var header = document.createElement('h4');\n        var lang = model.get('lang') || [];\n        header.innerHTML = lang[0] || model.get('title');\n        header.style.cssText = 'margin: 10px 20px;';\n        header.style.color = model.get('textColor');\n\n        var viewMain = document.createElement('div');\n        var textarea = document.createElement('textarea');\n        viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n\n        var optionToContent = model.get('optionToContent');\n        var contentToOption = model.get('contentToOption');\n        var result = getContentFromModel(ecModel);\n        if (typeof optionToContent === 'function') {\n            var htmlOrDom = optionToContent(api.getOption());\n            if (typeof htmlOrDom === 'string') {\n                viewMain.innerHTML = htmlOrDom;\n            }\n            else if (zrUtil.isDom(htmlOrDom)) {\n                viewMain.appendChild(htmlOrDom);\n            }\n        }\n        else {\n            // Use default textarea\n            viewMain.appendChild(textarea);\n            textarea.readOnly = model.get('readOnly');\n            textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n            textarea.style.color = model.get('textColor');\n            textarea.style.borderColor = model.get('textareaBorderColor');\n            textarea.style.backgroundColor = model.get('textareaColor');\n            textarea.value = result.value;\n        }\n\n        var blockMetaList = result.meta;\n\n        var buttonContainer = document.createElement('div');\n        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n\n        var buttonStyle = 'float:right;margin-right:20px;border:none;'\n            + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n        var closeButton = document.createElement('div');\n        var refreshButton = document.createElement('div');\n\n        buttonStyle += ';background-color:' + model.get('buttonColor');\n        buttonStyle += ';color:' + model.get('buttonTextColor');\n\n        var self = this;\n\n        function close() {\n            container.removeChild(root);\n            self._dom = null;\n        }\n        eventTool.addEventListener(closeButton, 'click', close);\n\n        eventTool.addEventListener(refreshButton, 'click', function () {\n            var newOption;\n            try {\n                if (typeof contentToOption === 'function') {\n                    newOption = contentToOption(viewMain, api.getOption());\n                }\n                else {\n                    newOption = parseContents(textarea.value, blockMetaList);\n                }\n            }\n            catch (e) {\n                close();\n                throw new Error('Data view format error ' + e);\n            }\n            if (newOption) {\n                api.dispatchAction({\n                    type: 'changeDataView',\n                    newOption: newOption\n                });\n            }\n\n            close();\n        });\n\n        closeButton.innerHTML = lang[1];\n        refreshButton.innerHTML = lang[2];\n        refreshButton.style.cssText = buttonStyle;\n        closeButton.style.cssText = buttonStyle;\n\n        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n        buttonContainer.appendChild(closeButton);\n\n        // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n        eventTool.addEventListener(textarea, 'keydown', function (e) {\n            if ((e.keyCode || e.which) === 9) {\n                // get caret position/selection\n                var val = this.value;\n                var start = this.selectionStart;\n                var end = this.selectionEnd;\n\n                // set textarea value to: text before caret + tab + text after caret\n                this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);\n\n                // put caret at right position again\n                this.selectionStart = this.selectionEnd = start + 1;\n\n                // prevent the focus lose\n                eventTool.stop(e);\n            }\n        });\n\n        root.appendChild(header);\n        root.appendChild(viewMain);\n        root.appendChild(buttonContainer);\n\n        viewMain.style.height = (container.clientHeight - 80) + 'px';\n\n        container.appendChild(root);\n        this._dom = root;\n    };\n\n    DataView.prototype.remove = function (ecModel, api) {\n        this._dom && api.getDom().removeChild(this._dom);\n    };\n\n    DataView.prototype.dispose = function (ecModel, api) {\n        this.remove(ecModel, api);\n    };\n\n    /**\n     * @inner\n     */\n    function tryMergeDataOption(newData, originalData) {\n        return zrUtil.map(newData, function (newVal, idx) {\n            var original = originalData && originalData[idx];\n            if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n                if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n                    newVal = newVal.value;\n                }\n                // Original data has option\n                return zrUtil.defaults({\n                    value: newVal\n                }, original);\n            }\n            else {\n                return newVal;\n            }\n        });\n    }\n\n    __webpack_require__(14).register('dataView', DataView);\n\n    __webpack_require__(1).registerAction({\n        type: 'changeDataView',\n        event: 'dataViewChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        var newSeriesOptList = [];\n        zrUtil.each(payload.newOption.series, function (seriesOpt) {\n            var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n            if (!seriesModel) {\n                // New created series\n                // Geuss the series type\n                newSeriesOptList.push(zrUtil.extend({\n                    // Default is scatter\n                    type: 'scatter'\n                }, seriesOpt));\n            }\n            else {\n                var originalData = seriesModel.get('data');\n                newSeriesOptList.push({\n                    name: seriesOpt.name,\n                    data: tryMergeDataOption(seriesOpt.data, originalData)\n                });\n            }\n        });\n\n        ecModel.mergeOption(zrUtil.defaults({\n            series: newSeriesOptList\n        }, payload.newOption));\n    });\n\n    module.exports = DataView;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXcuanM/MmRjMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTLFFBQVEsV0FBVyxVQUFVO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxjQUFjOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZLHNCQUFzQixlQUFlLG1CQUFtQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkRBQTJELFNBQVMsT0FBTyxRQUFROztBQUVuRix1Q0FBdUMsa0JBQWtCLFlBQVk7QUFDckUsOEJBQThCLGdCQUFnQixlQUFlO0FBQzdEO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTCIsImZpbGUiOiIxNDguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3XG4gKi9cblxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcblxuXG4gICAgdmFyIEJMT0NLX1NQTElURVIgPSBuZXcgQXJyYXkoNjApLmpvaW4oJy0nKTtcbiAgICB2YXIgSVRFTV9TUExJVEVSID0gJ1xcdCc7XG4gICAgLyoqXG4gICAgICogR3JvdXAgc2VyaWVzIGludG8gdHdvIHR5cGVzXG4gICAgICogIDEuIG9uIGNhdGVnb3J5IGF4aXMsIGxpa2UgbGluZSwgYmFyXG4gICAgICogIDIuIG90aGVycywgbGlrZSBzY2F0dGVyLCBwaWVcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cFNlcmllcyhlY01vZGVsKSB7XG4gICAgICAgIHZhciBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzID0ge307XG4gICAgICAgIHZhciBvdGhlclNlcmllcyA9IFtdO1xuICAgICAgICB2YXIgbWV0YSA9IFtdO1xuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgICAgICBpZiAoY29vcmRTeXMgJiYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBiYXNlQXhpcy5kaW0gKyAnXycgKyBiYXNlQXhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeUF4aXM6IGJhc2VBeGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXhpczogY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzRGltOiBiYXNlQXhpcy5kaW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4OiBiYXNlQXhpcy5pbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpc1trZXldLnNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpczogc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpcyxcbiAgICAgICAgICAgIG90aGVyOiBvdGhlclNlcmllcyxcbiAgICAgICAgICAgIG1ldGE6IG1ldGFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZSBjb250ZW50IG9mIHNlcmllcyBvbiBjYXRlb2dvcnkgYXhpc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZVNlcmllc1dpdGhDYXRlZ29yeUF4aXMoc2VyaWVzKSB7XG4gICAgICAgIHZhciB0YWJsZXMgPSBbXTtcbiAgICAgICAgenJVdGlsLmVhY2goc2VyaWVzLCBmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhpcyA9IGdyb3VwLmNhdGVnb3J5QXhpcztcbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXMgPSBncm91cC52YWx1ZUF4aXM7XG4gICAgICAgICAgICB2YXIgdmFsdWVBeGlzRGltID0gdmFsdWVBeGlzLmRpbTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBbJyAnXS5jb25jYXQoenJVdGlsLm1hcChncm91cC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IFtjYXRlZ29yeUF4aXMubW9kZWwuZ2V0Q2F0ZWdvcmllcygpXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGdyb3VwLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChzZXJpZXMuZ2V0UmF3RGF0YSgpLm1hcEFycmF5KHZhbHVlQXhpc0RpbSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXNzZW1ibGUgdGFibGUgY29udGVudFxuICAgICAgICAgICAgdmFyIGxpbmVzID0gW2hlYWRlcnMuam9pbihJVEVNX1NQTElURVIpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNvbHVtbnNbal1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGl0ZW1zLmpvaW4oSVRFTV9TUExJVEVSKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZXMucHVzaChsaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFibGVzLmpvaW4oJ1xcblxcbicgKyAgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZSBjb250ZW50IG9mIG90aGVyIHNlcmllc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZU90aGVyU2VyaWVzKHNlcmllcykge1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzLmdldFJhd0RhdGEoKTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IFtzZXJpZXMubmFtZV07XG4gICAgICAgICAgICB2YXIgdmFscyA9IFtdO1xuICAgICAgICAgICAgZGF0YS5lYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBhcmd1bWVudHNbYXJnTGVuIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0xlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWxzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKChuYW1lID8gKG5hbWUgKyBJVEVNX1NQTElURVIpIDogJycpICsgdmFscy5qb2luKElURU1fU1BMSVRFUikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgIH0pLmpvaW4oJ1xcblxcbicgKyBCTE9DS19TUExJVEVSICsgJ1xcblxcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb250ZW50RnJvbU1vZGVsKGVjTW9kZWwpIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gZ3JvdXBTZXJpZXMoZWNNb2RlbCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB6clV0aWwuZmlsdGVyKFtcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVTZXJpZXNXaXRoQ2F0ZWdvcnlBeGlzKHJlc3VsdC5zZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzKSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVPdGhlclNlcmllcyhyZXN1bHQub3RoZXIpXG4gICAgICAgICAgICAgICAgXSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG5cXHRcXHNdL2csICcnKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKSxcblxuICAgICAgICAgICAgbWV0YTogcmVzdWx0Lm1ldGFcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGEgYmxvY2sgaXMgdHN2IGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVFNWRm9ybWF0KGJsb2NrKSB7XG4gICAgICAgIC8vIFNpbXBsZSBtZXRob2QgdG8gZmluZCBvdXQgaWYgYSBibG9jayBpcyB0c3YgZm9ybWF0XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBibG9jay5zbGljZSgwLCBibG9jay5pbmRleE9mKCdcXG4nKSk7XG4gICAgICAgIGlmIChmaXJzdExpbmUuaW5kZXhPZihJVEVNX1NQTElURVIpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1TcGxpdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnWycgKyBJVEVNX1NQTElURVIgKyAnXSsnLCAnZycpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0c3ZcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVRTVkNvbnRlbnRzKHRzdikge1xuICAgICAgICB2YXIgdHN2TGluZXMgPSB0c3Yuc3BsaXQoL1xcbisvZyk7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdHJpbSh0c3ZMaW5lcy5zaGlmdCgpKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG5cbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgdmFyIHNlcmllcyA9IHpyVXRpbC5tYXAoaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBoZWFkZXIsXG4gICAgICAgICAgICAgICAgZGF0YTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRzdkxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0cmltKHRzdkxpbmVzW2ldKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goaXRlbXMuc2hpZnQoKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzW2pdICYmIChzZXJpZXNbal0uZGF0YVtpXSA9IGl0ZW1zW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlTGlzdENvbnRlbnRzKHN0cikge1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xcbisvZyk7XG4gICAgICAgIHZhciBzZXJpZXNOYW1lID0gdHJpbShsaW5lcy5zaGlmdCgpKTtcblxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0cmltKGxpbmVzW2ldKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFyIGhhc05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc05hTihpdGVtc1swXSkpIHsgLy8gRmlyc3QgaXRlbSBpcyBuYW1lXG4gICAgICAgICAgICAgICAgaGFzTmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGl0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgZGF0YVtpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGFbaV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKCtpdGVtc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaGFzTmFtZSA/IChkYXRhW2ldLnZhbHVlID0gdmFsdWVbMF0pIDogKGRhdGFbaV0gPSB2YWx1ZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogc2VyaWVzTmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmxvY2tNZXRhTGlzdFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRlbnRzKHN0ciwgYmxvY2tNZXRhTGlzdCkge1xuICAgICAgICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KG5ldyBSZWdFeHAoJ1xcbionICsgQkxPQ0tfU1BMSVRFUiArICdcXG4qJywgJ2cnKSk7XG4gICAgICAgIHZhciBuZXdPcHRpb24gPSB7XG4gICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHpyVXRpbC5lYWNoKGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrLCBpZHgpIHtcbiAgICAgICAgICAgIGlmIChpc1RTVkZvcm1hdChibG9jaykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VUU1ZDb250ZW50cyhibG9jayk7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrTWV0YSA9IGJsb2NrTWV0YUxpc3RbaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc0tleSA9IGJsb2NrTWV0YS5heGlzRGltICsgJ0F4aXMnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb25bYXhpc0tleV0gPSBuZXdPcHRpb25bYXhpc0tleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbltheGlzS2V5XVtibG9ja01ldGEuYXhpc0luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5jYXRlZ29yaWVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbi5zZXJpZXMgPSBuZXdPcHRpb24uc2VyaWVzLmNvbmNhdChyZXN1bHQuc2VyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaXN0Q29udGVudHMoYmxvY2spO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbi5zZXJpZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXd9XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhVmlldyhtb2RlbCkge1xuXG4gICAgICAgIHRoaXMuX2RvbSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cblxuICAgIERhdGFWaWV3LmRlZmF1bHRPcHRpb24gPSB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgICAgb3B0aW9uVG9Db250ZW50OiBudWxsLFxuICAgICAgICBjb250ZW50VG9PcHRpb246IG51bGwsXG5cbiAgICAgICAgaWNvbjogJ00xNy41LDE3LjNIMzMgTTE3LjUsMTcuM0gzMyBNNDUuNCwyOS41aC0yOCBNMTEuNSwydjU2SDUxVjE0LjhMMzguNCwySDExLjV6IE0zOC40LDIuMnYxMi43SDUxIE00NS40LDQxLjdoLTI4JyxcbiAgICAgICAgdGl0bGU6ICfmlbDmja7op4blm74nLFxuICAgICAgICBsYW5nOiBbJ+aVsOaNruinhuWbvicsICflhbPpl60nLCAn5Yi35pawJ10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxuICAgICAgICB0ZXh0Q29sb3I6ICcjMDAwJyxcbiAgICAgICAgdGV4dGFyZWFDb2xvcjogJyNmZmYnLFxuICAgICAgICB0ZXh0YXJlYUJvcmRlckNvbG9yOiAnIzMzMycsXG4gICAgICAgIGJ1dHRvbkNvbG9yOiAnI2MyMzUzMScsXG4gICAgICAgIGJ1dHRvblRleHRDb2xvcjogJyNmZmYnXG4gICAgfTtcblxuICAgIERhdGFWaWV3LnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gYXBpLmdldERvbSgpO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICBpZiAodGhpcy5fZG9tKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICByb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDo1cHg7dG9wOjVweDtib3R0b206NXB4O3JpZ2h0OjVweDsnO1xuICAgICAgICByb290LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnO1xuXG4gICAgICAgIC8vIENyZWF0ZSBlbGVtZW50c1xuICAgICAgICB2YXIgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDQnKTtcbiAgICAgICAgdmFyIGxhbmcgPSBtb2RlbC5nZXQoJ2xhbmcnKSB8fCBbXTtcbiAgICAgICAgaGVhZGVyLmlubmVySFRNTCA9IGxhbmdbMF0gfHwgbW9kZWwuZ2V0KCd0aXRsZScpO1xuICAgICAgICBoZWFkZXIuc3R5bGUuY3NzVGV4dCA9ICdtYXJnaW46IDEwcHggMjBweDsnO1xuICAgICAgICBoZWFkZXIuc3R5bGUuY29sb3IgPSBtb2RlbC5nZXQoJ3RleHRDb2xvcicpO1xuXG4gICAgICAgIHZhciB2aWV3TWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB2aWV3TWFpbi5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtvdmVyZmxvdzphdXRvOyc7XG5cbiAgICAgICAgdmFyIG9wdGlvblRvQ29udGVudCA9IG1vZGVsLmdldCgnb3B0aW9uVG9Db250ZW50Jyk7XG4gICAgICAgIHZhciBjb250ZW50VG9PcHRpb24gPSBtb2RlbC5nZXQoJ2NvbnRlbnRUb09wdGlvbicpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0Q29udGVudEZyb21Nb2RlbChlY01vZGVsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25Ub0NvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBodG1sT3JEb20gPSBvcHRpb25Ub0NvbnRlbnQoYXBpLmdldE9wdGlvbigpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHRtbE9yRG9tID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZpZXdNYWluLmlubmVySFRNTCA9IGh0bWxPckRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc0RvbShodG1sT3JEb20pKSB7XG4gICAgICAgICAgICAgICAgdmlld01haW4uYXBwZW5kQ2hpbGQoaHRtbE9yRG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBkZWZhdWx0IHRleHRhcmVhXG4gICAgICAgICAgICB2aWV3TWFpbi5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG4gICAgICAgICAgICB0ZXh0YXJlYS5yZWFkT25seSA9IG1vZGVsLmdldCgncmVhZE9ubHknKTtcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmb250LWZhbWlseTptb25vc3BhY2U7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS42cmVtOyc7XG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5jb2xvciA9IG1vZGVsLmdldCgndGV4dENvbG9yJyk7XG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5ib3JkZXJDb2xvciA9IG1vZGVsLmdldCgndGV4dGFyZWFCb3JkZXJDb2xvcicpO1xuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0YXJlYUNvbG9yJyk7XG4gICAgICAgICAgICB0ZXh0YXJlYS52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBibG9ja01ldGFMaXN0ID0gcmVzdWx0Lm1ldGE7XG5cbiAgICAgICAgdmFyIGJ1dHRvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBidXR0b25Db250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDsnO1xuXG4gICAgICAgIHZhciBidXR0b25TdHlsZSA9ICdmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MjBweDtib3JkZXI6bm9uZTsnXG4gICAgICAgICAgICArICdjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjJweCA1cHg7Zm9udC1zaXplOjEycHg7Ym9yZGVyLXJhZGl1czozcHgnO1xuICAgICAgICB2YXIgY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIHJlZnJlc2hCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBidXR0b25TdHlsZSArPSAnO2JhY2tncm91bmQtY29sb3I6JyArIG1vZGVsLmdldCgnYnV0dG9uQ29sb3InKTtcbiAgICAgICAgYnV0dG9uU3R5bGUgKz0gJztjb2xvcjonICsgbW9kZWwuZ2V0KCdidXR0b25UZXh0Q29sb3InKTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdCk7XG4gICAgICAgICAgICBzZWxmLl9kb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50VG9vbC5hZGRFdmVudExpc3RlbmVyKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBjbG9zZSk7XG5cbiAgICAgICAgZXZlbnRUb29sLmFkZEV2ZW50TGlzdGVuZXIocmVmcmVzaEJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld09wdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50VG9PcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gY29udGVudFRvT3B0aW9uKHZpZXdNYWluLCBhcGkuZ2V0T3B0aW9uKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gcGFyc2VDb250ZW50cyh0ZXh0YXJlYS52YWx1ZSwgYmxvY2tNZXRhTGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSB2aWV3IGZvcm1hdCBlcnJvciAnICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoYW5nZURhdGFWaWV3JyxcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uOiBuZXdPcHRpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gbGFuZ1sxXTtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5pbm5lckhUTUwgPSBsYW5nWzJdO1xuICAgICAgICByZWZyZXNoQnV0dG9uLnN0eWxlLmNzc1RleHQgPSBidXR0b25TdHlsZTtcbiAgICAgICAgY2xvc2VCdXR0b24uc3R5bGUuY3NzVGV4dCA9IGJ1dHRvblN0eWxlO1xuXG4gICAgICAgICFtb2RlbC5nZXQoJ3JlYWRPbmx5JykgJiYgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlZnJlc2hCdXR0b24pO1xuICAgICAgICBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24pO1xuXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjYzNzM0MS91c2UtdGFiLXRvLWluZGVudC1pbi10ZXh0YXJlYVxuICAgICAgICBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcih0ZXh0YXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKChlLmtleUNvZGUgfHwgZS53aGljaCkgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY2FyZXQgcG9zaXRpb24vc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGV4dGFyZWEgdmFsdWUgdG86IHRleHQgYmVmb3JlIGNhcmV0ICsgdGFiICsgdGV4dCBhZnRlciBjYXJldFxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWwuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIElURU1fU1BMSVRFUiArIHZhbC5zdWJzdHJpbmcoZW5kKTtcblxuICAgICAgICAgICAgICAgIC8vIHB1dCBjYXJldCBhdCByaWdodCBwb3NpdGlvbiBhZ2FpblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZCA9IHN0YXJ0ICsgMTtcblxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdGhlIGZvY3VzIGxvc2VcbiAgICAgICAgICAgICAgICBldmVudFRvb2wuc3RvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHZpZXdNYWluKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChidXR0b25Db250YWluZXIpO1xuXG4gICAgICAgIHZpZXdNYWluLnN0eWxlLmhlaWdodCA9IChjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gODApICsgJ3B4JztcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocm9vdCk7XG4gICAgICAgIHRoaXMuX2RvbSA9IHJvb3Q7XG4gICAgfTtcblxuICAgIERhdGFWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHRoaXMuX2RvbSAmJiBhcGkuZ2V0RG9tKCkucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKTtcbiAgICB9O1xuXG4gICAgRGF0YVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyeU1lcmdlRGF0YU9wdGlvbihuZXdEYXRhLCBvcmlnaW5hbERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAobmV3RGF0YSwgZnVuY3Rpb24gKG5ld1ZhbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBvcmlnaW5hbERhdGEgJiYgb3JpZ2luYWxEYXRhW2lkeF07XG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG9yaWdpbmFsKSAmJiAhenJVdGlsLmlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChuZXdWYWwpICYmICF6clV0aWwuaXNBcnJheShuZXdWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IG5ld1ZhbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgZGF0YSBoYXMgb3B0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWxcbiAgICAgICAgICAgICAgICB9LCBvcmlnaW5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXF1aXJlKCcuLi9mZWF0dXJlTWFuYWdlcicpLnJlZ2lzdGVyKCdkYXRhVmlldycsIERhdGFWaWV3KTtcblxuICAgIHJlcXVpcmUoJy4uLy4uLy4uL2VjaGFydHMnKS5yZWdpc3RlckFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdjaGFuZ2VEYXRhVmlldycsXG4gICAgICAgIGV2ZW50OiAnZGF0YVZpZXdDaGFuZ2VkJyxcbiAgICAgICAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbiAgICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgbmV3U2VyaWVzT3B0TGlzdCA9IFtdO1xuICAgICAgICB6clV0aWwuZWFjaChwYXlsb2FkLm5ld09wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlOYW1lKHNlcmllc09wdC5uYW1lKVswXTtcbiAgICAgICAgICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgY3JlYXRlZCBzZXJpZXNcbiAgICAgICAgICAgICAgICAvLyBHZXVzcyB0aGUgc2VyaWVzIHR5cGVcbiAgICAgICAgICAgICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goenJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgaXMgc2NhdHRlclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2NhdHRlcidcbiAgICAgICAgICAgICAgICB9LCBzZXJpZXNPcHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbERhdGEgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICAgICAgICAgICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXJpZXNPcHQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdHJ5TWVyZ2VEYXRhT3B0aW9uKHNlcmllc09wdC5kYXRhLCBvcmlnaW5hbERhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVjTW9kZWwubWVyZ2VPcHRpb24oenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgIHNlcmllczogbmV3U2VyaWVzT3B0TGlzdFxuICAgICAgICB9LCBwYXlsb2FkLm5ld09wdGlvbikpO1xuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var BrushController = __webpack_require__(133);\n    var BrushTargetManager = __webpack_require__(134);\n    var history = __webpack_require__(54);\n    var sliderMove = __webpack_require__(138);\n\n    var each = zrUtil.each;\n\n    // Use dataZoomSelect\n    __webpack_require__(126);\n\n    // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n    var DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\n    function DataZoom(model, ecModel, api) {\n\n        /**\n         * @private\n         * @type {module:echarts/component/helper/BrushController}\n         */\n        (this._brushController = new BrushController(api.getZr()))\n            .on('brush', zrUtil.bind(this._onBrush, this))\n            .mount();\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._isZoomActive;\n    }\n\n    DataZoom.defaultOption = {\n        show: true,\n        // Icon group\n        icon: {\n            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n        },\n        title: {\n            zoom: '区域缩放',\n            back: '区域缩放还原'\n        }\n    };\n\n    var proto = DataZoom.prototype;\n\n    proto.render = function (featureModel, ecModel, api, payload) {\n        this.model = featureModel;\n        this.ecModel = ecModel;\n        this.api = api;\n\n        updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n        updateBackBtnStatus(featureModel, ecModel);\n    };\n\n    proto.onclick = function (ecModel, api, type) {\n        handlers[type].call(this);\n    };\n\n    proto.remove = function (ecModel, api) {\n        this._brushController.unmount();\n    };\n\n    proto.dispose = function (ecModel, api) {\n        this._brushController.dispose();\n    };\n\n    /**\n     * @private\n     */\n    var handlers = {\n\n        zoom: function () {\n            var nextActive = !this._isZoomActive;\n\n            this.api.dispatchAction({\n                type: 'takeGlobalCursor',\n                key: 'dataZoomSelect',\n                dataZoomSelectActive: nextActive\n            });\n        },\n\n        back: function () {\n            this._dispatchZoomAction(history.pop(this.ecModel));\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._onBrush = function (areas, opt) {\n        if (!opt.isEnd || !areas.length) {\n            return;\n        }\n        var snapshot = {};\n        var ecModel = this.ecModel;\n\n        this._brushController.updateCovers([]); // remove cover\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(this.model.option), ecModel, {include: ['grid']}\n        );\n        brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            if (coordSys.type !== 'cartesian2d') {\n                return;\n            }\n\n            var brushType = area.brushType;\n            if (brushType === 'rect') {\n                setBatch('x', coordSys, coordRange[0]);\n                setBatch('y', coordSys, coordRange[1]);\n            }\n            else {\n                setBatch(({lineX: 'x', lineY: 'y'})[brushType], coordSys, coordRange);\n            }\n        });\n\n        history.push(ecModel, snapshot);\n\n        this._dispatchZoomAction(snapshot);\n\n        function setBatch(dimName, coordSys, minMax) {\n            var axis = coordSys.getAxis(dimName);\n            var axisModel = axis.model;\n            var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);\n\n            // Restrict range.\n            var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n            if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n                minMax = sliderMove(\n                    0, minMax.slice(), axis.scale.getExtent(), 0,\n                    minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan\n                );\n            }\n\n            dataZoomModel && (snapshot[dataZoomModel.id] = {\n                dataZoomId: dataZoomModel.id,\n                startValue: minMax[0],\n                endValue: minMax[1]\n            });\n        }\n\n        function findDataZoom(dimName, axisModel, ecModel) {\n            var found;\n            ecModel.eachComponent({mainType: 'dataZoom', subType: 'select'}, function (dzModel) {\n                var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n                has && (found = dzModel);\n            });\n            return found;\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._dispatchZoomAction = function (snapshot) {\n        var batch = [];\n\n        // Convert from hash map to array.\n        each(snapshot, function (batchItem, dataZoomId) {\n            batch.push(zrUtil.clone(batchItem));\n        });\n\n        batch.length && this.api.dispatchAction({\n            type: 'dataZoom',\n            from: this.uid,\n            batch: batch\n        });\n    };\n\n    function retrieveAxisSetting(option) {\n        var setting = {};\n        // Compatible with previous setting: null => all axis, false => no axis.\n        zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n            setting[name] = option[name];\n            setting[name] == null && (setting[name] = 'all');\n            (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n        });\n        return setting;\n    }\n\n    function updateBackBtnStatus(featureModel, ecModel) {\n        featureModel.setIconStatus(\n            'back',\n            history.count(ecModel) > 1 ? 'emphasis' : 'normal'\n        );\n    }\n\n    function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n        var zoomActive = view._isZoomActive;\n\n        if (payload && payload.type === 'takeGlobalCursor') {\n            zoomActive = payload.key === 'dataZoomSelect'\n                ? payload.dataZoomSelectActive : false;\n        }\n\n        view._isZoomActive = zoomActive;\n\n        featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(featureModel.option), ecModel, {include: ['grid']}\n        );\n\n        view._brushController\n            .setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n                return (targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared)\n                    ? 'lineX'\n                    : (!targetInfo.xAxisDeclared && targetInfo.yAxisDeclared)\n                    ? 'lineY'\n                    : 'rect';\n            }))\n            .enableBrush(\n                zoomActive\n                ? {\n                    brushType: 'auto',\n                    brushStyle: {\n                        // FIXME user customized?\n                        lineWidth: 0,\n                        fill: 'rgba(0,0,0,0.2)'\n                    }\n                }\n                : false\n            );\n    }\n\n\n    __webpack_require__(14).register('dataZoom', DataZoom);\n\n\n    // Create special dataZoom option for select\n    __webpack_require__(1).registerPreprocessor(function (option) {\n        if (!option) {\n            return;\n        }\n\n        var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n        if (!zrUtil.isArray(dataZoomOpts)) {\n            option.dataZoom = dataZoomOpts = [dataZoomOpts];\n        }\n\n        var toolboxOpt = option.toolbox;\n        if (toolboxOpt) {\n            // Assume there is only one toolbox\n            if (zrUtil.isArray(toolboxOpt)) {\n                toolboxOpt = toolboxOpt[0];\n            }\n\n            if (toolboxOpt && toolboxOpt.feature) {\n                var dataZoomOpt = toolboxOpt.feature.dataZoom;\n                addForAxis('xAxis', dataZoomOpt);\n                addForAxis('yAxis', dataZoomOpt);\n            }\n        }\n\n        function addForAxis(axisName, dataZoomOpt) {\n            if (!dataZoomOpt) {\n                return;\n            }\n\n            // Try not to modify model, because it is not merged yet.\n            var axisIndicesName = axisName + 'Index';\n            var givenAxisIndices = dataZoomOpt[axisIndicesName];\n            if (givenAxisIndices != null\n                && givenAxisIndices != 'all'\n                && !zrUtil.isArray(givenAxisIndices)\n            ) {\n                givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];\n            }\n\n            forEachComponent(axisName, function (axisOpt, axisIndex) {\n                if (givenAxisIndices != null\n                    && givenAxisIndices != 'all'\n                    && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1\n                ) {\n                    return;\n                }\n                var newOpt = {\n                    type: 'select',\n                    $fromToolbox: true,\n                    // Id for merge mapping.\n                    id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n                };\n                // FIXME\n                // Only support one axis now.\n                newOpt[axisIndicesName] = axisIndex;\n                dataZoomOpts.push(newOpt);\n            });\n        }\n\n        function forEachComponent(mainType, cb) {\n            var opts = option[mainType];\n            if (!zrUtil.isArray(opts)) {\n                opts = opts ? [opts] : [];\n            }\n            each(opts, cb);\n        }\n    });\n\n    module.exports = DataZoom;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20uanM/ZTc4YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHdDQUF3QztBQUMzRTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwiLCJmaWxlIjoiMTQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIEJydXNoQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXInKTtcbiAgICB2YXIgQnJ1c2hUYXJnZXRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vLi4vaGVscGVyL0JydXNoVGFyZ2V0TWFuYWdlcicpO1xuICAgIHZhciBoaXN0b3J5ID0gcmVxdWlyZSgnLi4vLi4vZGF0YVpvb20vaGlzdG9yeScpO1xuICAgIHZhciBzbGlkZXJNb3ZlID0gcmVxdWlyZSgnLi4vLi4vaGVscGVyL3NsaWRlck1vdmUnKTtcblxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG5cbiAgICAvLyBVc2UgZGF0YVpvb21TZWxlY3RcbiAgICByZXF1aXJlKCcuLi8uLi9kYXRhWm9vbVNlbGVjdCcpO1xuXG4gICAgLy8gU3BlY3RpYWwgY29tcG9uZW50IGlkIHN0YXJ0IHdpdGggXFwwZWNcXDAsIHNlZSBlY2hhcnRzL21vZGVsL0dsb2JhbC5qc35oYXNJbm5lcklkXG4gICAgdmFyIERBVEFfWk9PTV9JRF9CQVNFID0gJ1xcMF9lY19cXDB0b29sYm94LWRhdGFab29tXyc7XG5cbiAgICBmdW5jdGlvbiBEYXRhWm9vbShtb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlcn1cbiAgICAgICAgICovXG4gICAgICAgICh0aGlzLl9icnVzaENvbnRyb2xsZXIgPSBuZXcgQnJ1c2hDb250cm9sbGVyKGFwaS5nZXRacigpKSlcbiAgICAgICAgICAgIC5vbignYnJ1c2gnLCB6clV0aWwuYmluZCh0aGlzLl9vbkJydXNoLCB0aGlzKSlcbiAgICAgICAgICAgIC5tb3VudCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzWm9vbUFjdGl2ZTtcbiAgICB9XG5cbiAgICBEYXRhWm9vbS5kZWZhdWx0T3B0aW9uID0ge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAvLyBJY29uIGdyb3VwXG4gICAgICAgIGljb246IHtcbiAgICAgICAgICAgIHpvb206ICdNMCwxMy41aDI2LjkgTTEzLjUsMjYuOVYwIE0zMi4xLDEzLjVINThWNThIMTMuNSBWMzIuMScsXG4gICAgICAgICAgICBiYWNrOiAnTTIyLDEuNEw5LjksMTMuNWwxMi4zLDEyLjMgTTEwLjMsMTMuNUg1NC45djQ0LjYgSDEwLjN2LTI2J1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgem9vbTogJ+WMuuWfn+e8qeaUvicsXG4gICAgICAgICAgICBiYWNrOiAn5Yy65Z+f57yp5pS+6L+Y5Y6fJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IERhdGFab29tLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlbmRlciA9IGZ1bmN0aW9uIChmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gZmVhdHVyZU1vZGVsO1xuICAgICAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcblxuICAgICAgICB1cGRhdGVab29tQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgdGhpcywgcGF5bG9hZCwgYXBpKTtcbiAgICAgICAgdXBkYXRlQmFja0J0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwpO1xuICAgIH07XG5cbiAgICBwcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICAgICAgICBoYW5kbGVyc1t0eXBlXS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHRoaXMuX2JydXNoQ29udHJvbGxlci51bm1vdW50KCk7XG4gICAgfTtcblxuICAgIHByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHRoaXMuX2JydXNoQ29udHJvbGxlci5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIGhhbmRsZXJzID0ge1xuXG4gICAgICAgIHpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0QWN0aXZlID0gIXRoaXMuX2lzWm9vbUFjdGl2ZTtcblxuICAgICAgICAgICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YWtlR2xvYmFsQ3Vyc29yJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdkYXRhWm9vbVNlbGVjdCcsXG4gICAgICAgICAgICAgICAgZGF0YVpvb21TZWxlY3RBY3RpdmU6IG5leHRBY3RpdmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihoaXN0b3J5LnBvcCh0aGlzLmVjTW9kZWwpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLl9vbkJydXNoID0gZnVuY3Rpb24gKGFyZWFzLCBvcHQpIHtcbiAgICAgICAgaWYgKCFvcHQuaXNFbmQgfHwgIWFyZWFzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzbmFwc2hvdCA9IHt9O1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcblxuICAgICAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIudXBkYXRlQ292ZXJzKFtdKTsgLy8gcmVtb3ZlIGNvdmVyXG5cbiAgICAgICAgdmFyIGJydXNoVGFyZ2V0TWFuYWdlciA9IG5ldyBCcnVzaFRhcmdldE1hbmFnZXIoXG4gICAgICAgICAgICByZXRyaWV2ZUF4aXNTZXR0aW5nKHRoaXMubW9kZWwub3B0aW9uKSwgZWNNb2RlbCwge2luY2x1ZGU6IFsnZ3JpZCddfVxuICAgICAgICApO1xuICAgICAgICBicnVzaFRhcmdldE1hbmFnZXIubWF0Y2hPdXRwdXRSYW5nZXMoYXJlYXMsIGVjTW9kZWwsIGZ1bmN0aW9uIChhcmVhLCBjb29yZFJhbmdlLCBjb29yZFN5cykge1xuICAgICAgICAgICAgaWYgKGNvb3JkU3lzLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBicnVzaFR5cGUgPSBhcmVhLmJydXNoVHlwZTtcbiAgICAgICAgICAgIGlmIChicnVzaFR5cGUgPT09ICdyZWN0Jykge1xuICAgICAgICAgICAgICAgIHNldEJhdGNoKCd4JywgY29vcmRTeXMsIGNvb3JkUmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgIHNldEJhdGNoKCd5JywgY29vcmRTeXMsIGNvb3JkUmFuZ2VbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0QmF0Y2goKHtsaW5lWDogJ3gnLCBsaW5lWTogJ3knfSlbYnJ1c2hUeXBlXSwgY29vcmRTeXMsIGNvb3JkUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBoaXN0b3J5LnB1c2goZWNNb2RlbCwgc25hcHNob3QpO1xuXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihzbmFwc2hvdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0QmF0Y2goZGltTmFtZSwgY29vcmRTeXMsIG1pbk1heCkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpO1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICAgICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGZpbmREYXRhWm9vbShkaW1OYW1lLCBheGlzTW9kZWwsIGVjTW9kZWwpO1xuXG4gICAgICAgICAgICAvLyBSZXN0cmljdCByYW5nZS5cbiAgICAgICAgICAgIHZhciBtaW5NYXhTcGFuID0gZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoYXhpc01vZGVsKS5nZXRNaW5NYXhTcGFuKCk7XG4gICAgICAgICAgICBpZiAobWluTWF4U3Bhbi5taW5WYWx1ZVNwYW4gIT0gbnVsbCB8fCBtaW5NYXhTcGFuLm1heFZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWluTWF4ID0gc2xpZGVyTW92ZShcbiAgICAgICAgICAgICAgICAgICAgMCwgbWluTWF4LnNsaWNlKCksIGF4aXMuc2NhbGUuZ2V0RXh0ZW50KCksIDAsXG4gICAgICAgICAgICAgICAgICAgIG1pbk1heFNwYW4ubWluVmFsdWVTcGFuLCBtaW5NYXhTcGFuLm1heFZhbHVlU3BhblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFab29tTW9kZWwgJiYgKHNuYXBzaG90W2RhdGFab29tTW9kZWwuaWRdID0ge1xuICAgICAgICAgICAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tTW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogbWluTWF4WzBdLFxuICAgICAgICAgICAgICAgIGVuZFZhbHVlOiBtaW5NYXhbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZERhdGFab29tKGRpbU5hbWUsIGF4aXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kO1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHttYWluVHlwZTogJ2RhdGFab29tJywgc3ViVHlwZTogJ3NlbGVjdCd9LCBmdW5jdGlvbiAoZHpNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXMgPSBkek1vZGVsLmdldEF4aXNNb2RlbChkaW1OYW1lLCBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIGhhcyAmJiAoZm91bmQgPSBkek1vZGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uX2Rpc3BhdGNoWm9vbUFjdGlvbiA9IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgICB2YXIgYmF0Y2ggPSBbXTtcblxuICAgICAgICAvLyBDb252ZXJ0IGZyb20gaGFzaCBtYXAgdG8gYXJyYXkuXG4gICAgICAgIGVhY2goc25hcHNob3QsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICAgICAgICAgIGJhdGNoLnB1c2goenJVdGlsLmNsb25lKGJhdGNoSXRlbSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBiYXRjaC5sZW5ndGggJiYgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICAgICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICAgICAgYmF0Y2g6IGJhdGNoXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZXRyaWV2ZUF4aXNTZXR0aW5nKG9wdGlvbikge1xuICAgICAgICB2YXIgc2V0dGluZyA9IHt9O1xuICAgICAgICAvLyBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgc2V0dGluZzogbnVsbCA9PiBhbGwgYXhpcywgZmFsc2UgPT4gbm8gYXhpcy5cbiAgICAgICAgenJVdGlsLmVhY2goWyd4QXhpc0luZGV4JywgJ3lBeGlzSW5kZXgnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHNldHRpbmdbbmFtZV0gPSBvcHRpb25bbmFtZV07XG4gICAgICAgICAgICBzZXR0aW5nW25hbWVdID09IG51bGwgJiYgKHNldHRpbmdbbmFtZV0gPSAnYWxsJyk7XG4gICAgICAgICAgICAoc2V0dGluZ1tuYW1lXSA9PT0gZmFsc2UgfHwgc2V0dGluZ1tuYW1lXSA9PT0gJ25vbmUnKSAmJiAoc2V0dGluZ1tuYW1lXSA9IFtdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXR0aW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJhY2tCdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgIGZlYXR1cmVNb2RlbC5zZXRJY29uU3RhdHVzKFxuICAgICAgICAgICAgJ2JhY2snLFxuICAgICAgICAgICAgaGlzdG9yeS5jb3VudChlY01vZGVsKSA+IDEgPyAnZW1waGFzaXMnIDogJ25vcm1hbCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVab29tQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgdmlldywgcGF5bG9hZCwgYXBpKSB7XG4gICAgICAgIHZhciB6b29tQWN0aXZlID0gdmlldy5faXNab29tQWN0aXZlO1xuXG4gICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ3Rha2VHbG9iYWxDdXJzb3InKSB7XG4gICAgICAgICAgICB6b29tQWN0aXZlID0gcGF5bG9hZC5rZXkgPT09ICdkYXRhWm9vbVNlbGVjdCdcbiAgICAgICAgICAgICAgICA/IHBheWxvYWQuZGF0YVpvb21TZWxlY3RBY3RpdmUgOiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXcuX2lzWm9vbUFjdGl2ZSA9IHpvb21BY3RpdmU7XG5cbiAgICAgICAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXMoJ3pvb20nLCB6b29tQWN0aXZlID8gJ2VtcGhhc2lzJyA6ICdub3JtYWwnKTtcblxuICAgICAgICB2YXIgYnJ1c2hUYXJnZXRNYW5hZ2VyID0gbmV3IEJydXNoVGFyZ2V0TWFuYWdlcihcbiAgICAgICAgICAgIHJldHJpZXZlQXhpc1NldHRpbmcoZmVhdHVyZU1vZGVsLm9wdGlvbiksIGVjTW9kZWwsIHtpbmNsdWRlOiBbJ2dyaWQnXX1cbiAgICAgICAgKTtcblxuICAgICAgICB2aWV3Ll9icnVzaENvbnRyb2xsZXJcbiAgICAgICAgICAgIC5zZXRQYW5lbHMoYnJ1c2hUYXJnZXRNYW5hZ2VyLm1ha2VQYW5lbE9wdHMoYXBpLCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGFyZ2V0SW5mby54QXhpc0RlY2xhcmVkICYmICF0YXJnZXRJbmZvLnlBeGlzRGVjbGFyZWQpXG4gICAgICAgICAgICAgICAgICAgID8gJ2xpbmVYJ1xuICAgICAgICAgICAgICAgICAgICA6ICghdGFyZ2V0SW5mby54QXhpc0RlY2xhcmVkICYmIHRhcmdldEluZm8ueUF4aXNEZWNsYXJlZClcbiAgICAgICAgICAgICAgICAgICAgPyAnbGluZVknXG4gICAgICAgICAgICAgICAgICAgIDogJ3JlY3QnO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAuZW5hYmxlQnJ1c2goXG4gICAgICAgICAgICAgICAgem9vbUFjdGl2ZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBicnVzaFR5cGU6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgdXNlciBjdXN0b21pemVkP1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMC4yKSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICApO1xuICAgIH1cblxuXG4gICAgcmVxdWlyZSgnLi4vZmVhdHVyZU1hbmFnZXInKS5yZWdpc3RlcignZGF0YVpvb20nLCBEYXRhWm9vbSk7XG5cblxuICAgIC8vIENyZWF0ZSBzcGVjaWFsIGRhdGFab29tIG9wdGlvbiBmb3Igc2VsZWN0XG4gICAgcmVxdWlyZSgnLi4vLi4vLi4vZWNoYXJ0cycpLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhWm9vbU9wdHMgPSBvcHRpb24uZGF0YVpvb20gfHwgKG9wdGlvbi5kYXRhWm9vbSA9IFtdKTtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkYXRhWm9vbU9wdHMpKSB7XG4gICAgICAgICAgICBvcHRpb24uZGF0YVpvb20gPSBkYXRhWm9vbU9wdHMgPSBbZGF0YVpvb21PcHRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b29sYm94T3B0ID0gb3B0aW9uLnRvb2xib3g7XG4gICAgICAgIGlmICh0b29sYm94T3B0KSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdGhlcmUgaXMgb25seSBvbmUgdG9vbGJveFxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KHRvb2xib3hPcHQpKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJveE9wdCA9IHRvb2xib3hPcHRbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b29sYm94T3B0ICYmIHRvb2xib3hPcHQuZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhWm9vbU9wdCA9IHRvb2xib3hPcHQuZmVhdHVyZS5kYXRhWm9vbTtcbiAgICAgICAgICAgICAgICBhZGRGb3JBeGlzKCd4QXhpcycsIGRhdGFab29tT3B0KTtcbiAgICAgICAgICAgICAgICBhZGRGb3JBeGlzKCd5QXhpcycsIGRhdGFab29tT3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZvckF4aXMoYXhpc05hbWUsIGRhdGFab29tT3B0KSB7XG4gICAgICAgICAgICBpZiAoIWRhdGFab29tT3B0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcnkgbm90IHRvIG1vZGlmeSBtb2RlbCwgYmVjYXVzZSBpdCBpcyBub3QgbWVyZ2VkIHlldC5cbiAgICAgICAgICAgIHZhciBheGlzSW5kaWNlc05hbWUgPSBheGlzTmFtZSArICdJbmRleCc7XG4gICAgICAgICAgICB2YXIgZ2l2ZW5BeGlzSW5kaWNlcyA9IGRhdGFab29tT3B0W2F4aXNJbmRpY2VzTmFtZV07XG4gICAgICAgICAgICBpZiAoZ2l2ZW5BeGlzSW5kaWNlcyAhPSBudWxsXG4gICAgICAgICAgICAgICAgJiYgZ2l2ZW5BeGlzSW5kaWNlcyAhPSAnYWxsJ1xuICAgICAgICAgICAgICAgICYmICF6clV0aWwuaXNBcnJheShnaXZlbkF4aXNJbmRpY2VzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2l2ZW5BeGlzSW5kaWNlcyA9IChnaXZlbkF4aXNJbmRpY2VzID09PSBmYWxzZSB8fCBnaXZlbkF4aXNJbmRpY2VzID09PSAnbm9uZScpID8gW10gOiBbZ2l2ZW5BeGlzSW5kaWNlc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvckVhY2hDb21wb25lbnQoYXhpc05hbWUsIGZ1bmN0aW9uIChheGlzT3B0LCBheGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2l2ZW5BeGlzSW5kaWNlcyAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmIGdpdmVuQXhpc0luZGljZXMgIT0gJ2FsbCdcbiAgICAgICAgICAgICAgICAgICAgJiYgenJVdGlsLmluZGV4T2YoZ2l2ZW5BeGlzSW5kaWNlcywgYXhpc0luZGV4KSA9PT0gLTFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV3T3B0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJGZyb21Ub29sYm94OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBJZCBmb3IgbWVyZ2UgbWFwcGluZy5cbiAgICAgICAgICAgICAgICAgICAgaWQ6IERBVEFfWk9PTV9JRF9CQVNFICsgYXhpc05hbWUgKyBheGlzSW5kZXhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gT25seSBzdXBwb3J0IG9uZSBheGlzIG5vdy5cbiAgICAgICAgICAgICAgICBuZXdPcHRbYXhpc0luZGljZXNOYW1lXSA9IGF4aXNJbmRleDtcbiAgICAgICAgICAgICAgICBkYXRhWm9vbU9wdHMucHVzaChuZXdPcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JFYWNoQ29tcG9uZW50KG1haW5UeXBlLCBjYikge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBvcHRpb25bbWFpblR5cGVdO1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvcHRzKSkge1xuICAgICAgICAgICAgICAgIG9wdHMgPSBvcHRzID8gW29wdHNdIDogW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYWNoKG9wdHMsIGNiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhWm9vbTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0RhdGFab29tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n\n    function MagicType(model) {\n        this.model = model;\n    }\n\n    MagicType.defaultOption = {\n        show: true,\n        type: [],\n        // Icon group\n        icon: {\n            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line\n            tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n        },\n        title: {\n            line: '切换为折线图',\n            bar: '切换为柱状图',\n            stack: '切换为堆叠',\n            tiled: '切换为平铺'\n        },\n        option: {},\n        seriesIndex: {}\n    };\n\n    var proto = MagicType.prototype;\n\n    proto.getIcons = function () {\n        var model = this.model;\n        var availableIcons = model.get('icon');\n        var icons = {};\n        zrUtil.each(model.get('type'), function (type) {\n            if (availableIcons[type]) {\n                icons[type] = availableIcons[type];\n            }\n        });\n        return icons;\n    };\n\n    var seriesOptGenreator = {\n        'line': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'line',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.line') || {}, true);\n            }\n        },\n        'bar': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'bar',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.bar') || {}, true);\n            }\n        },\n        'stack': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: '__ec_magicType_stack__'\n                }, model.get('option.stack') || {}, true);\n            }\n        },\n        'tiled': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: ''\n                }, model.get('option.tiled') || {}, true);\n            }\n        }\n    };\n\n    var radioTypes = [\n        ['line', 'bar'],\n        ['stack', 'tiled']\n    ];\n\n    proto.onclick = function (ecModel, api, type) {\n        var model = this.model;\n        var seriesIndex = model.get('seriesIndex.' + type);\n        // Not supported magicType\n        if (!seriesOptGenreator[type]) {\n            return;\n        }\n        var newOption = {\n            series: []\n        };\n        var generateNewSeriesTypes = function (seriesModel) {\n            var seriesType = seriesModel.subType;\n            var seriesId = seriesModel.id;\n            var newSeriesOpt = seriesOptGenreator[type](\n                seriesType, seriesId, seriesModel, model\n            );\n            if (newSeriesOpt) {\n                // PENDING If merge original option?\n                zrUtil.defaults(newSeriesOpt, seriesModel.option);\n                newOption.series.push(newSeriesOpt);\n            }\n            // Modify boundaryGap\n            var coordSys = seriesModel.coordinateSystem;\n            if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n                var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n                if (categoryAxis) {\n                    var axisDim = categoryAxis.dim;\n                    var axisType = axisDim + 'Axis';\n                    var axisModel = ecModel.queryComponents({\n                        mainType: axisType,\n                        index: seriesModel.get(name + 'Index'),\n                        id: seriesModel.get(name + 'Id')\n                    })[0];\n                    var axisIndex = axisModel.componentIndex;\n\n                    newOption[axisType] = newOption[axisType] || [];\n                    for (var i = 0; i <= axisIndex; i++) {\n                        newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n                    }\n                    newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n                }\n            }\n        };\n\n        zrUtil.each(radioTypes, function (radio) {\n            if (zrUtil.indexOf(radio, type) >= 0) {\n                zrUtil.each(radio, function (item) {\n                    model.setIconStatus(item, 'normal');\n                });\n            }\n        });\n\n        model.setIconStatus(type, 'emphasis');\n\n        ecModel.eachComponent(\n            {\n                mainType: 'series',\n                query: seriesIndex == null ? null : {\n                    seriesIndex: seriesIndex\n                }\n            }, generateNewSeriesTypes\n        );\n        api.dispatchAction({\n            type: 'changeMagicType',\n            currentType: type,\n            newOption: newOption\n        });\n    };\n\n    var echarts = __webpack_require__(1);\n    echarts.registerAction({\n        type: 'changeMagicType',\n        event: 'magicTypeChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        ecModel.mergeOption(payload.newOption);\n    });\n\n    __webpack_require__(14).register('magicType', MagicType);\n\n    module.exports = MagicType;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvTWFnaWNUeXBlLmpzPzcwMjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMOztBQUVBIiwiZmlsZSI6IjE1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgZnVuY3Rpb24gTWFnaWNUeXBlKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG5cbiAgICBNYWdpY1R5cGUuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgdHlwZTogW10sXG4gICAgICAgIC8vIEljb24gZ3JvdXBcbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgbGluZTogJ000LjEsMjguOWg3LjFsOS4zLTIybDcuNCwzOGw5LjctMTkuN2wzLDEyLjhoMTQuOU00LjEsNThoNTEuNCcsXG4gICAgICAgICAgICBiYXI6ICdNNi43LDIyLjloMTBWNDhoLTEwVjIyLjl6TTI0LjksMTNoMTB2MzVoLTEwVjEzek00My4yLDJoMTB2NDZoLTEwVjJ6TTMuMSw1OGg1My43JyxcbiAgICAgICAgICAgIHN0YWNrOiAnTTguMiwzOC40bC04LjQsNC4xbDMwLjYsMTUuM0w2MCw0Mi41bC04LjEtNC4xbC0yMS41LDExTDguMiwzOC40eiBNNTEuOSwzMGwtOC4xLDQuMmwtMTMuNCw2LjlsLTEzLjktNi45TDguMiwzMGwtOC40LDQuMmw4LjQsNC4ybDIyLjIsMTFsMjEuNS0xMWw4LjEtNC4yTDUxLjksMzB6IE01MS45LDIxLjdsLTguMSw0LjJMMzUuNywzMGwtNS4zLDIuOEwyNC45LDMwbC04LjQtNC4xbC04LjMtNC4ybC04LjQsNC4yTDguMiwzMGw4LjMsNC4ybDEzLjksNi45bDEzLjQtNi45bDguMS00LjJsOC4xLTQuMUw1MS45LDIxLjd6TTMwLjQsMi4yTC0wLjIsMTcuNWw4LjQsNC4xbDguMyw0LjJsOC40LDQuMmw1LjUsMi43bDUuMy0yLjdsOC4xLTQuMmw4LjEtNC4ybDguMS00LjFMMzAuNCwyLjJ6JywgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICB0aWxlZDogJ00yLjMsMi4yaDIyLjhWMjVIMi4zVjIuMnogTTM1LDIuMmgyMi44VjI1SDM1VjIuMnpNMi4zLDM1aDIyLjh2MjIuOEgyLjNWMzV6IE0zNSwzNWgyMi44djIyLjhIMzVWMzV6J1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgbGluZTogJ+WIh+aNouS4uuaKmOe6v+WbvicsXG4gICAgICAgICAgICBiYXI6ICfliIfmjaLkuLrmn7Hnirblm74nLFxuICAgICAgICAgICAgc3RhY2s6ICfliIfmjaLkuLrloIblj6AnLFxuICAgICAgICAgICAgdGlsZWQ6ICfliIfmjaLkuLrlubPpk7onXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbjoge30sXG4gICAgICAgIHNlcmllc0luZGV4OiB7fVxuICAgIH07XG5cbiAgICB2YXIgcHJvdG8gPSBNYWdpY1R5cGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uZ2V0SWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBhdmFpbGFibGVJY29ucyA9IG1vZGVsLmdldCgnaWNvbicpO1xuICAgICAgICB2YXIgaWNvbnMgPSB7fTtcbiAgICAgICAgenJVdGlsLmVhY2gobW9kZWwuZ2V0KCd0eXBlJyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlSWNvbnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpY29uc1t0eXBlXSA9IGF2YWlsYWJsZUljb25zW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGljb25zO1xuICAgIH07XG5cbiAgICB2YXIgc2VyaWVzT3B0R2VucmVhdG9yID0ge1xuICAgICAgICAnbGluZSc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGRhdGEgcmVsYXRlZCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcmtQb2ludDogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrUG9pbnQnKSxcbiAgICAgICAgICAgICAgICAgICAgbWFya0xpbmU6IHNlcmllc01vZGVsLmdldCgnbWFya0xpbmUnKVxuICAgICAgICAgICAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLmxpbmUnKSB8fCB7fSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdiYXInOiBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCkge1xuICAgICAgICAgICAgaWYgKHNlcmllc1R5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdiYXInLFxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBkYXRhIHJlbGF0ZWQgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlcmllc01vZGVsLmdldCgnZGF0YScpLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpLFxuICAgICAgICAgICAgICAgICAgICBtYXJrUG9pbnQ6IHNlcmllc01vZGVsLmdldCgnbWFya1BvaW50JyksXG4gICAgICAgICAgICAgICAgICAgIG1hcmtMaW5lOiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtMaW5lJylcbiAgICAgICAgICAgICAgICB9LCBtb2RlbC5nZXQoJ29wdGlvbi5iYXInKSB8fCB7fSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdzdGFjayc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnIHx8IHNlcmllc1R5cGUgPT09ICdiYXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6ICdfX2VjX21hZ2ljVHlwZV9zdGFja19fJ1xuICAgICAgICAgICAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLnN0YWNrJykgfHwge30sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndGlsZWQnOiBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCkge1xuICAgICAgICAgICAgaWYgKHNlcmllc1R5cGUgPT09ICdsaW5lJyB8fCBzZXJpZXNUeXBlID09PSAnYmFyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAnJ1xuICAgICAgICAgICAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLnRpbGVkJykgfHwge30sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByYWRpb1R5cGVzID0gW1xuICAgICAgICBbJ2xpbmUnLCAnYmFyJ10sXG4gICAgICAgIFsnc3RhY2snLCAndGlsZWQnXVxuICAgIF07XG5cbiAgICBwcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBtb2RlbC5nZXQoJ3Nlcmllc0luZGV4LicgKyB0eXBlKTtcbiAgICAgICAgLy8gTm90IHN1cHBvcnRlZCBtYWdpY1R5cGVcbiAgICAgICAgaWYgKCFzZXJpZXNPcHRHZW5yZWF0b3JbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3T3B0aW9uID0ge1xuICAgICAgICAgICAgc2VyaWVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2VuZXJhdGVOZXdTZXJpZXNUeXBlcyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHNlcmllc1R5cGUgPSBzZXJpZXNNb2RlbC5zdWJUeXBlO1xuICAgICAgICAgICAgdmFyIHNlcmllc0lkID0gc2VyaWVzTW9kZWwuaWQ7XG4gICAgICAgICAgICB2YXIgbmV3U2VyaWVzT3B0ID0gc2VyaWVzT3B0R2VucmVhdG9yW3R5cGVdKFxuICAgICAgICAgICAgICAgIHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobmV3U2VyaWVzT3B0KSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBJZiBtZXJnZSBvcmlnaW5hbCBvcHRpb24/XG4gICAgICAgICAgICAgICAgenJVdGlsLmRlZmF1bHRzKG5ld1Nlcmllc09wdCwgc2VyaWVzTW9kZWwub3B0aW9uKTtcbiAgICAgICAgICAgICAgICBuZXdPcHRpb24uc2VyaWVzLnB1c2gobmV3U2VyaWVzT3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vZGlmeSBib3VuZGFyeUdhcFxuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnICYmICh0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ2JhcicpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNvb3JkU3lzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF07XG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5QXhpcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc0RpbSA9IGNhdGVnb3J5QXhpcy5kaW07XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzVHlwZSA9IGF4aXNEaW0gKyAnQXhpcyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogYXhpc1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJZCcpXG4gICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc0luZGV4ID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbltheGlzVHlwZV0gPSBuZXdPcHRpb25bYXhpc1R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBheGlzSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdID0gbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbltheGlzVHlwZV1bYXhpc0luZGV4XS5ib3VuZGFyeUdhcCA9IHR5cGUgPT09ICdiYXInID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB6clV0aWwuZWFjaChyYWRpb1R5cGVzLCBmdW5jdGlvbiAocmFkaW8pIHtcbiAgICAgICAgICAgIGlmICh6clV0aWwuaW5kZXhPZihyYWRpbywgdHlwZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKHJhZGlvLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXRJY29uU3RhdHVzKGl0ZW0sICdub3JtYWwnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kZWwuc2V0SWNvblN0YXR1cyh0eXBlLCAnZW1waGFzaXMnKTtcblxuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBzZXJpZXNJbmRleCA9PSBudWxsID8gbnVsbCA6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZ2VuZXJhdGVOZXdTZXJpZXNUeXBlc1xuICAgICAgICApO1xuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2NoYW5nZU1hZ2ljVHlwZScsXG4gICAgICAgICAgICBjdXJyZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgIG5ld09wdGlvbjogbmV3T3B0aW9uXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2VjaGFydHMnKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2NoYW5nZU1hZ2ljVHlwZScsXG4gICAgICAgIGV2ZW50OiAnbWFnaWNUeXBlQ2hhbmdlZCcsXG4gICAgICAgIHVwZGF0ZTogJ3ByZXBhcmVBbmRVcGRhdGUnXG4gICAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICAgICAgZWNNb2RlbC5tZXJnZU9wdGlvbihwYXlsb2FkLm5ld09wdGlvbik7XG4gICAgfSk7XG5cbiAgICByZXF1aXJlKCcuLi9mZWF0dXJlTWFuYWdlcicpLnJlZ2lzdGVyKCdtYWdpY1R5cGUnLCBNYWdpY1R5cGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYWdpY1R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9NYWdpY1R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var history = __webpack_require__(54);\n\n    function Restore(model) {\n        this.model = model;\n    }\n\n    Restore.defaultOption = {\n        show: true,\n        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n        title: '还原'\n    };\n\n    var proto = Restore.prototype;\n\n    proto.onclick = function (ecModel, api, type) {\n        history.clear(ecModel);\n\n        api.dispatchAction({\n            type: 'restore',\n            from: this.uid\n        });\n    };\n\n\n    __webpack_require__(14).register('restore', Restore);\n\n\n    __webpack_require__(1).registerAction(\n        {type: 'restore', event: 'restore', update: 'prepareAndUpdate'},\n        function (payload, ecModel) {\n            ecModel.resetOption('recreate');\n        }\n    );\n\n    module.exports = Restore;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvUmVzdG9yZS5qcz8wMzJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7OztBQUdBO0FBQ0EsU0FBUyw4REFBOEQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTUxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgaGlzdG9yeSA9IHJlcXVpcmUoJy4uLy4uL2RhdGFab29tL2hpc3RvcnknKTtcblxuICAgIGZ1bmN0aW9uIFJlc3RvcmUobW9kZWwpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cblxuICAgIFJlc3RvcmUuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgaWNvbjogJ00zLjgsMzMuNCBNNDcsMTguOWg5LjhWOC43IE01Ni4zLDIwLjEgQzUyLjEsOSw0MC41LDAuNiwyNi44LDIuMUMxMi42LDMuNywxLjYsMTYuMiwyLjEsMzAuNiBNMTMsNDEuMUgzLjF2MTAuMiBNMy43LDM5LjljNC4yLDExLjEsMTUuOCwxOS41LDI5LjUsMTggYzE0LjItMS42LDI1LjItMTQuMSwyNC43LTI4LjUnLFxuICAgICAgICB0aXRsZTogJ+i/mOWOnydcbiAgICB9O1xuXG4gICAgdmFyIHByb3RvID0gUmVzdG9yZS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICAgICAgICBoaXN0b3J5LmNsZWFyKGVjTW9kZWwpO1xuXG4gICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAncmVzdG9yZScsXG4gICAgICAgICAgICBmcm9tOiB0aGlzLnVpZFxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICByZXF1aXJlKCcuLi9mZWF0dXJlTWFuYWdlcicpLnJlZ2lzdGVyKCdyZXN0b3JlJywgUmVzdG9yZSk7XG5cblxuICAgIHJlcXVpcmUoJy4uLy4uLy4uL2VjaGFydHMnKS5yZWdpc3RlckFjdGlvbihcbiAgICAgICAge3R5cGU6ICdyZXN0b3JlJywgZXZlbnQ6ICdyZXN0b3JlJywgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSd9LFxuICAgICAgICBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgICAgICAgICAgZWNNb2RlbC5yZXNldE9wdGlvbigncmVjcmVhdGUnKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlc3RvcmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9SZXN0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var env = __webpack_require__(6);\n\n    function SaveAsImage (model) {\n        this.model = model;\n    }\n\n    SaveAsImage.defaultOption = {\n        show: true,\n        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n        title: '保存为图片',\n        type: 'png',\n        // Default use option.backgroundColor\n        // backgroundColor: '#fff',\n        name: '',\n        excludeComponents: ['toolbox'],\n        pixelRatio: 1,\n        lang: ['右键另存为图片']\n    };\n\n    SaveAsImage.prototype.unusable = !env.canvasSupported;\n\n    var proto = SaveAsImage.prototype;\n\n    proto.onclick = function (ecModel, api) {\n        var model = this.model;\n        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n        var $a = document.createElement('a');\n        var type = model.get('type', true) || 'png';\n        $a.download = title + '.' + type;\n        $a.target = '_blank';\n        var url = api.getConnectedDataURL({\n            type: type,\n            backgroundColor: model.get('backgroundColor', true)\n                || ecModel.get('backgroundColor') || '#fff',\n            excludeComponents: model.get('excludeComponents'),\n            pixelRatio: model.get('pixelRatio')\n        });\n        $a.href = url;\n        // Chrome and Firefox\n        if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n            var evt = new MouseEvent('click', {\n                view: window,\n                bubbles: true,\n                cancelable: false\n            });\n            $a.dispatchEvent(evt);\n        }\n        // IE\n        else {\n            var lang = model.get('lang');\n            var html = ''\n                + '<body style=\"margin:0;\">'\n                + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + ((lang && lang[0]) || '') + '\" />'\n                + '</body>';\n            var tab = window.open();\n            tab.document.write(html);\n        }\n    };\n\n    __webpack_require__(14).register(\n        'saveAsImage', SaveAsImage\n    );\n\n    module.exports = SaveAsImage;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvU2F2ZUFzSW1hZ2UuanM/NDM5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxNTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuXG4gICAgZnVuY3Rpb24gU2F2ZUFzSW1hZ2UgKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG5cbiAgICBTYXZlQXNJbWFnZS5kZWZhdWx0T3B0aW9uID0ge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBpY29uOiAnTTQuNywyMi45TDI5LjMsNDUuNUw1NC43LDIzLjRNNC42LDQzLjZMNC42LDU4TDUzLjgsNThMNTMuOCw0My42TTI5LjIsNDUuMUwyOS4yLDAnLFxuICAgICAgICB0aXRsZTogJ+S/neWtmOS4uuWbvueJhycsXG4gICAgICAgIHR5cGU6ICdwbmcnLFxuICAgICAgICAvLyBEZWZhdWx0IHVzZSBvcHRpb24uYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgZXhjbHVkZUNvbXBvbmVudHM6IFsndG9vbGJveCddLFxuICAgICAgICBwaXhlbFJhdGlvOiAxLFxuICAgICAgICBsYW5nOiBbJ+WPs+mUruWPpuWtmOS4uuWbvueJhyddXG4gICAgfTtcblxuICAgIFNhdmVBc0ltYWdlLnByb3RvdHlwZS51bnVzYWJsZSA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHByb3RvID0gU2F2ZUFzSW1hZ2UucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIHRpdGxlID0gbW9kZWwuZ2V0KCduYW1lJykgfHwgZWNNb2RlbC5nZXQoJ3RpdGxlLjAudGV4dCcpIHx8ICdlY2hhcnRzJztcbiAgICAgICAgdmFyICRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICB2YXIgdHlwZSA9IG1vZGVsLmdldCgndHlwZScsIHRydWUpIHx8ICdwbmcnO1xuICAgICAgICAkYS5kb3dubG9hZCA9IHRpdGxlICsgJy4nICsgdHlwZTtcbiAgICAgICAgJGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgIHZhciB1cmwgPSBhcGkuZ2V0Q29ubmVjdGVkRGF0YVVSTCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicsIHRydWUpXG4gICAgICAgICAgICAgICAgfHwgZWNNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICcjZmZmJyxcbiAgICAgICAgICAgIGV4Y2x1ZGVDb21wb25lbnRzOiBtb2RlbC5nZXQoJ2V4Y2x1ZGVDb21wb25lbnRzJyksXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiBtb2RlbC5nZXQoJ3BpeGVsUmF0aW8nKVxuICAgICAgICB9KTtcbiAgICAgICAgJGEuaHJlZiA9IHVybDtcbiAgICAgICAgLy8gQ2hyb21lIGFuZCBGaXJlZm94XG4gICAgICAgIGlmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZW52LmJyb3dzZXIuaWUgJiYgIWVudi5icm93c2VyLmVkZ2UpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgdmlldzogd2luZG93LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGEuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElFXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhbmcgPSBtb2RlbC5nZXQoJ2xhbmcnKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gJydcbiAgICAgICAgICAgICAgICArICc8Ym9keSBzdHlsZT1cIm1hcmdpbjowO1wiPidcbiAgICAgICAgICAgICAgICArICc8aW1nIHNyYz1cIicgKyB1cmwgKyAnXCIgc3R5bGU9XCJtYXgtd2lkdGg6MTAwJTtcIiB0aXRsZT1cIicgKyAoKGxhbmcgJiYgbGFuZ1swXSkgfHwgJycpICsgJ1wiIC8+J1xuICAgICAgICAgICAgICAgICsgJzwvYm9keT4nO1xuICAgICAgICAgICAgdmFyIHRhYiA9IHdpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgICB0YWIuZG9jdW1lbnQud3JpdGUoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWlyZSgnLi4vZmVhdHVyZU1hbmFnZXInKS5yZWdpc3RlcihcbiAgICAgICAgJ3NhdmVBc0ltYWdlJywgU2F2ZUFzSW1hZ2VcbiAgICApO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTYXZlQXNJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL1NhdmVBc0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

eval("// FIXME Better way to pack data in graphic element\n\n\n    __webpack_require__(119);\n\n    __webpack_require__(155);\n\n    __webpack_require__(156);\n\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    __webpack_require__(1).registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    __webpack_require__(1).registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwLmpzP2UyYjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIHBhY2sgZGF0YSBpbiBncmFwaGljIGVsZW1lbnRcblxuXG4gICAgcmVxdWlyZSgnLi9heGlzUG9pbnRlcicpO1xuXG4gICAgcmVxdWlyZSgnLi90b29sdGlwL1Rvb2x0aXBNb2RlbCcpO1xuXG4gICAgcmVxdWlyZSgnLi90b29sdGlwL1Rvb2x0aXBWaWV3Jyk7XG5cblxuICAgIC8vIFNob3cgdGlwIGFjdGlvblxuICAgIC8qKlxuICAgICAqIEBhY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZXJpZXNJbmRleFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3hdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt5XVxuICAgICAqL1xuICAgIHJlcXVpcmUoJy4uL2VjaGFydHMnKS5yZWdpc3RlckFjdGlvbihcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgICAgZXZlbnQ6ICdzaG93VGlwJyxcbiAgICAgICAgICAgIHVwZGF0ZTogJ3Rvb2x0aXA6bWFudWFsbHlTaG93VGlwJ1xuICAgICAgICB9LFxuICAgICAgICAvLyBub29wXG4gICAgICAgIGZ1bmN0aW9uICgpIHt9XG4gICAgKTtcbiAgICAvLyBIaWRlIHRpcCBhY3Rpb25cbiAgICByZXF1aXJlKCcuLi9lY2hhcnRzJykucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdoaWRlVGlwJyxcbiAgICAgICAgICAgIGV2ZW50OiAnaGlkZVRpcCcsXG4gICAgICAgICAgICB1cGRhdGU6ICd0b29sdGlwOm1hbnVhbGx5SGlkZVRpcCdcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbm9vcFxuICAgICAgICBmdW5jdGlvbiAoKSB7fVxuICAgICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var zrColor = __webpack_require__(22);\n    var eventUtil = __webpack_require__(19);\n    var formatUtil = __webpack_require__(10);\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = __webpack_require__(6);\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition. Do not animate when transitionDuration is 0.\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = this._zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self._enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self._enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self._enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            // FIXME\n            // Move this logic to ec main?\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            this.el.innerHTML = content == null ? '' : content;\n        },\n\n        setEnterable: function (enterable) {\n            this._enterable = enterable;\n        },\n\n        getSize: function () {\n            var el = this.el;\n            return [el.clientWidth, el.clientHeight];\n        },\n\n        moveTo: function (x, y) {\n            // xy should be based on canvas root. But tooltipContent is\n            // the sibling of canvas root. So padding of ec container\n            // should be considered here.\n            var zr = this._zr;\n            var viewportRoot;\n            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\n                x += viewportRoot.offsetLeft || 0;\n                y += viewportRoot.offsetTop || 0;\n            }\n\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this._enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50LmpzPzg1M2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsY0FBYyxtQkFBbUIsbUJBQW1CLGdCQUFnQjs7QUFFMUc7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLE9BQU87QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QixzQkFBc0I7QUFDakU7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudFxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgenJDb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9ldmVudCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciB0b0NhbWVsQ2FzZSA9IGZvcm1hdFV0aWwudG9DYW1lbENhc2U7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG5cbiAgICB2YXIgdmVuZG9ycyA9IFsnJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddO1xuXG4gICAgdmFyIGdDc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXN0eWxlOnNvbGlkO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4Ojk5OTk5OTk7JztcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZVRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25DdXJ2ZSA9ICdjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSknO1xuICAgICAgICB2YXIgdHJhbnNpdGlvblRleHQgPSAnbGVmdCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlICsgJywnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAndG9wICcgKyBkdXJhdGlvbiArICdzICcgKyB0cmFuc2l0aW9uQ3VydmU7XG4gICAgICAgIHJldHVybiB6clV0aWwubWFwKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3JQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZW5kb3JQcmVmaXggKyAndHJhbnNpdGlvbjonICsgdHJhbnNpdGlvblRleHQ7XG4gICAgICAgIH0pLmpvaW4oJzsnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkge1xuICAgICAgICB2YXIgY3NzVGV4dCA9IFtdO1xuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRleHRTdHlsZU1vZGVsLmdldCgnZm9udFNpemUnKTtcbiAgICAgICAgdmFyIGNvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCk7XG5cbiAgICAgICAgY29sb3IgJiYgY3NzVGV4dC5wdXNoKCdjb2xvcjonICsgY29sb3IpO1xuXG4gICAgICAgIGNzc1RleHQucHVzaCgnZm9udDonICsgdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpKTtcblxuICAgICAgICBmb250U2l6ZSAmJlxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdsaW5lLWhlaWdodDonICsgTWF0aC5yb3VuZChmb250U2l6ZSAqIDMgLyAyKSArICdweCcpO1xuXG4gICAgICAgIGVhY2goWydkZWNvcmF0aW9uJywgJ2FsaWduJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgdmFsICYmIGNzc1RleHQucHVzaCgndGV4dC0nICsgbmFtZSArICc6JyArIHZhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjc3NUZXh0LmpvaW4oJzsnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbHRpcE1vZGVsXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpIHtcblxuICAgICAgICB2YXIgY3NzVGV4dCA9IFtdO1xuXG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmFuc2l0aW9uRHVyYXRpb24nKTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHRvb2x0aXBNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0b29sdGlwTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRvb2x0aXBNb2RlbC5nZXQoJ3BhZGRpbmcnKTtcblxuICAgICAgICAvLyBBbmltYXRpb24gdHJhbnNpdGlvbi4gRG8gbm90IGFuaW1hdGUgd2hlbiB0cmFuc2l0aW9uRHVyYXRpb24gaXMgMC5cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uICYmXG4gICAgICAgICAgICBjc3NUZXh0LnB1c2goYXNzZW1ibGVUcmFuc2l0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikpO1xuXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIGlmIChlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdiYWNrZ3JvdW5kLUNvbG9yOicgKyBiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGllXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1Db2xvcjojJyArIHpyQ29sb3IudG9IZXgoYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdmaWx0ZXI6YWxwaGEob3BhY2l0eT03MCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJvcmRlciBzdHlsZVxuICAgICAgICBlYWNoKFsnd2lkdGgnLCAnY29sb3InLCAncmFkaXVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgYm9yZGVyTmFtZSA9ICdib3JkZXItJyArIG5hbWU7XG4gICAgICAgICAgICB2YXIgY2FtZWxDYXNlID0gdG9DYW1lbENhc2UoYm9yZGVyTmFtZSk7XG4gICAgICAgICAgICB2YXIgdmFsID0gdG9vbHRpcE1vZGVsLmdldChjYW1lbENhc2UpO1xuICAgICAgICAgICAgdmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBjc3NUZXh0LnB1c2goYm9yZGVyTmFtZSArICc6JyArIHZhbCArIChuYW1lID09PSAnY29sb3InID8gJycgOiAncHgnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRleHQgc3R5bGVcbiAgICAgICAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkpO1xuXG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgaWYgKHBhZGRpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdwYWRkaW5nOicgKyBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzVGV4dC5qb2luKCc7JykgKyAnOyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcENvbnRlbnQoY29udGFpbmVyLCBhcGkpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyID0gYXBpLmdldFpyKCk7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuXG4gICAgICAgIHRoaXMuX3ggPSBhcGkuZ2V0V2lkdGgoKSAvIDI7XG4gICAgICAgIHRoaXMuX3kgPSBhcGkuZ2V0SGVpZ2h0KCkgLyAyO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0O1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIHRpbWVvdXQgaW4gaGlkZUxhdGVyIGFuZCBrZWVwIHNob3dpbmcgdG9vbHRpcFxuICAgICAgICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9oaWRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2hvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9pbkNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBlbC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0cmlnZ2VyIHpyZW5kZXIgZXZlbnQgdG8gYXZvaWQgbW91c2VcbiAgICAgICAgICAgICAgICAvLyBpbiBhbmQgb3V0IHNoYXBlIHRvbyBmcmVxdWVudGx5XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB6ci5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIGV2ZW50VXRpbC5ub3JtYWxpemVFdmVudChjb250YWluZXIsIGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZGlzcGF0Y2goJ21vdXNlbW92ZScsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbC5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlTGF0ZXIoc2VsZi5faGlkZURlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9pbkNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBUb29sdGlwQ29udGVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFRvb2x0aXBDb250ZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF9lbnRlcmFibGU6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB3aGVuIHRvb2x0aXAgaXMgcmVuZGVyZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIE1vdmUgdGhpcyBsb2dpYyB0byBlYyBtYWluP1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBzdGwgPSBjb250YWluZXIuY3VycmVudFN0eWxlXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgICAgICAgICAgaWYgKGRvbVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0bC5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgICAgICAgIGRvbVN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIC8vIHRoaXMuaGlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gZ0Nzc1RleHQgKyBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKVxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExMjU1ODcvY3NzMy10cmFuc2l0aW9uLW5vdC13b3JraW5nLWluLWNocm9tZS1hbnltb3JlXG4gICAgICAgICAgICAgICAgKyAnO2xlZnQ6JyArIHRoaXMuX3ggKyAncHg7dG9wOicgKyB0aGlzLl95ICsgJ3B4OydcbiAgICAgICAgICAgICAgICArICh0b29sdGlwTW9kZWwuZ2V0KCdleHRyYUNzc1RleHQnKSB8fCAnJyk7XG5cbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5pbm5lckhUTUwgPyAgJ2Jsb2NrJyA6ICdub25lJztcblxuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gY29udGVudCA9PSBudWxsID8gJycgOiBjb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVudGVyYWJsZTogZnVuY3Rpb24gKGVudGVyYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZW50ZXJhYmxlID0gZW50ZXJhYmxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICByZXR1cm4gW2VsLmNsaWVudFdpZHRoLCBlbC5jbGllbnRIZWlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIC8vIHh5IHNob3VsZCBiZSBiYXNlZCBvbiBjYW52YXMgcm9vdC4gQnV0IHRvb2x0aXBDb250ZW50IGlzXG4gICAgICAgICAgICAvLyB0aGUgc2libGluZyBvZiBjYW52YXMgcm9vdC4gU28gcGFkZGluZyBvZiBlYyBjb250YWluZXJcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBjb25zaWRlcmVkIGhlcmUuXG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydFJvb3Q7XG4gICAgICAgICAgICBpZiAoenIgJiYgenIucGFpbnRlciAmJiAodmlld3BvcnRSb290ID0genIucGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkpIHtcbiAgICAgICAgICAgICAgICB4ICs9IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgICAgICAgICAgeSArPSB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgICAgICBzdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUxhdGVyOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3cgJiYgISh0aGlzLl9pbkNvbnRlbnQgJiYgdGhpcy5fZW50ZXJhYmxlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVEZWxheSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBzaG93IGZhbHNlIHRvIGF2b2lkIGludm9rZSBoaWRlTGF0ZXIgbXV0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dCh6clV0aWwuYmluZCh0aGlzLmhpZGUsIHRoaXMpLCB0aW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc1Nob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9vbHRpcENvbnRlbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(1).extendComponentModel({\n\n        type: 'tooltip',\n\n        dependencies: ['axisPointer'],\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip主体内容\n            showContent: true,\n\n            // 'trigger' only works on coordinate system.\n            // 'item' | 'axis' | 'none'\n            trigger: 'item',\n\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove|click',\n\n            alwaysShowContent: false,\n\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n            // 位置 {Array} | {Function}\n            // position: null\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n            // align: null,\n            // verticalAlign: null,\n\n            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n            confine: false,\n\n            // 内容格式器：{string}（Template） ¦ {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // 隐藏延迟，单位ms\n            hideDelay: 100,\n\n            // 动画变换时间，单位s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 提示背景颜色，默认为透明度为0.7的黑色\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // 提示边框颜色\n            borderColor: '#333',\n\n            // 提示边框圆角，单位px，默认为4\n            borderRadius: 4,\n\n            // 提示边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 提示内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // 坐标轴指示器，坐标轴触发有效\n            axisPointer: {\n                // 默认为直线\n                // 可选为：'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n                // 极坐标系会默认选择 angle 轴\n                axis: 'auto',\n\n                animation: 'auto',\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                crossStyle: {\n                    color: '#999',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                }\n\n                // lineStyle and shadowStyle should not be specified here,\n                // otherwise it will always override those styles on option.axisPointer.\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qcz84MTFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixNQUFNLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTyxjQUFjO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sdGlwJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnYXhpc1BvaW50ZXInXSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgICAgIHo6IDgsXG5cbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIHRvb2x0aXDkuLvkvZPlhoXlrrlcbiAgICAgICAgICAgIHNob3dDb250ZW50OiB0cnVlLFxuXG4gICAgICAgICAgICAvLyAndHJpZ2dlcicgb25seSB3b3JrcyBvbiBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICAgIC8vICdpdGVtJyB8ICdheGlzJyB8ICdub25lJ1xuICAgICAgICAgICAgdHJpZ2dlcjogJ2l0ZW0nLFxuXG4gICAgICAgICAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICAgICAgICAgIHRyaWdnZXJPbjogJ21vdXNlbW92ZXxjbGljaycsXG5cbiAgICAgICAgICAgIGFsd2F5c1Nob3dDb250ZW50OiBmYWxzZSxcblxuICAgICAgICAgICAgZGlzcGxheU1vZGU6ICdzaW5nbGUnLCAvLyAnc2luZ2xlJyB8ICdtdWx0aXBsZUJ5Q29vcmRTeXMnXG5cbiAgICAgICAgICAgIC8vIOS9jee9riB7QXJyYXl9IHwge0Z1bmN0aW9ufVxuICAgICAgICAgICAgLy8gcG9zaXRpb246IG51bGxcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyIGhhbmRsZSwgdmVydGljYWxBbGlnbiBzaG91bGQgYmUgJ21pZGRsZSdcbiAgICAgICAgICAgIC8vIGFsaWduOiBudWxsLFxuICAgICAgICAgICAgLy8gdmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAgICAgLy8g5piv5ZCm57qm5p2fIGNvbnRlbnQg5ZyoIHZpZXdSZWN0IOS4reOAgum7mOiupCBmYWxzZSDmmK/kuLrkuoblhbzlrrnku6XliY3niYjmnKzjgIJcbiAgICAgICAgICAgIGNvbmZpbmU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDlhoXlrrnmoLzlvI/lmajvvJp7c3RyaW5nfe+8iFRlbXBsYXRl77yJIMKmIHtGdW5jdGlvbn1cbiAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogbnVsbFxuXG4gICAgICAgICAgICBzaG93RGVsYXk6IDAsXG5cbiAgICAgICAgICAgIC8vIOmakOiXj+W7tui/n++8jOWNleS9jW1zXG4gICAgICAgICAgICBoaWRlRGVsYXk6IDEwMCxcblxuICAgICAgICAgICAgLy8g5Yqo55S75Y+Y5o2i5pe26Ze077yM5Y2V5L2Nc1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLjQsXG5cbiAgICAgICAgICAgIGVudGVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIOaPkOekuuiDjOaZr+minOiJsu+8jOm7mOiupOS4uumAj+aYjuW6puS4ujAuN+eahOm7keiJslxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1MCw1MCw1MCwwLjcpJyxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMzMzMnLFxuXG4gICAgICAgICAgICAvLyDmj5DnpLrovrnmoYblnIbop5LvvIzljZXkvY1weO+8jOm7mOiupOS4ujRcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcblxuICAgICAgICAgICAgLy8g5o+Q56S65YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgICAgICAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhIGNzcyB0ZXh0XG4gICAgICAgICAgICBleHRyYUNzc1RleHQ6ICcnLFxuXG4gICAgICAgICAgICAvLyDlnZDmoIfovbTmjIfnpLrlmajvvIzlnZDmoIfovbTop6blj5HmnInmlYhcbiAgICAgICAgICAgIGF4aXNQb2ludGVyOiB7XG4gICAgICAgICAgICAgICAgLy8g6buY6K6k5Li655u057q/XG4gICAgICAgICAgICAgICAgLy8g5Y+v6YCJ5Li677yaJ2xpbmUnIHwgJ3NoYWRvdycgfCAnY3Jvc3MnXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgICAgICAgICAgICAgLy8gdHlwZSDkuLogbGluZSDnmoTml7blgJnmnInmlYjvvIzmjIflrpogdG9vbHRpcCBsaW5lIOaJgOWcqOeahOi9tO+8jOWPr+mAiVxuICAgICAgICAgICAgICAgIC8vIOWPr+mAiSAneCcgfCAneScgfCAnYW5nbGUnIHwgJ3JhZGl1cycgfCAnYXV0bydcbiAgICAgICAgICAgICAgICAvLyDpu5jorqQgJ2F1dG8n77yM5Lya6YCJ5oup57G75Z6L5Li6IGNhdGVvZ3J5IOeahOi9tO+8jOWvueS6juWPjOaVsOWAvOi9tO+8jOesm+WNoeWwlOWdkOagh+ezu+S8mum7mOiupOmAieaLqSB4IOi9tFxuICAgICAgICAgICAgICAgIC8vIOaegeWdkOagh+ezu+S8mum7mOiupOmAieaLqSBhbmdsZSDovbRcbiAgICAgICAgICAgICAgICBheGlzOiAnYXV0bycsXG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb246ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMjAwLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2V4cG9uZW50aWFsT3V0JyxcblxuICAgICAgICAgICAgICAgIGNyb3NzU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjOTk5JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYXNoZWQnLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgICAgIHRleHRTdHlsZToge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsaW5lU3R5bGUgYW5kIHNoYWRvd1N0eWxlIHNob3VsZCBub3QgYmUgc3BlY2lmaWVkIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYWx3YXlzIG92ZXJyaWRlIHRob3NlIHN0eWxlcyBvbiBvcHRpb24uYXhpc1BvaW50ZXIuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var TooltipContent = __webpack_require__(154);\n    var zrUtil = __webpack_require__(0);\n    var formatUtil = __webpack_require__(10);\n    var numberUtil = __webpack_require__(5);\n    var graphic = __webpack_require__(2);\n    var findPointFromSeries = __webpack_require__(46);\n    var layoutUtil = __webpack_require__(15);\n    var env = __webpack_require__(6);\n    var Model = __webpack_require__(9);\n    var globalListener = __webpack_require__(47);\n    var axisHelper = __webpack_require__(17);\n    var axisPointerViewHelper = __webpack_require__(48);\n\n    var bind = zrUtil.bind;\n    var each = zrUtil.each;\n    var parsePercent = numberUtil.parsePercent;\n\n\n    var proxyRect = new graphic.Rect({\n        shape: {x: -1, y: -1, width: 2, height: 2}\n    });\n\n    __webpack_require__(1).extendComponentView({\n\n        type: 'tooltip',\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * Should be cleaned when render.\n             * @private\n             * @type {Array.<Array.<Object>>}\n             */\n            this._lastDataByCoordSys = null;\n\n            /**\n             * @private\n             * @type {boolean}\n             */\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n            this._initGlobalListener();\n\n            this._keepShow();\n        },\n\n        _initGlobalListener: function () {\n            var tooltipModel = this._tooltipModel;\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            globalListener.register(\n                'itemTooltip',\n                this._api,\n                bind(function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none') {\n                        if (triggerOn.indexOf(currTrigger) >= 0) {\n                            this._tryShow(e, dispatchAction);\n                        }\n                        else if (currTrigger === 'leave') {\n                            this._hide(dispatchAction);\n                        }\n                    }\n                }, this)\n            );\n        },\n\n        _keepShow: function () {\n            var tooltipModel = this._tooltipModel;\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && tooltipModel.get('triggerOn') !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid || env.node) {\n                return;\n            }\n\n            var dispatchAction = makeDispatchAction(payload, api);\n\n            // Reset ticket\n            this._ticket = '';\n\n            // When triggered from axisPointer.\n            var dataByCoordSys = payload.dataByCoordSys;\n\n            if (payload.tooltip && payload.x != null && payload.y != null) {\n                var el = proxyRect;\n                el.position = [payload.x, payload.y];\n                el.update();\n                el.tooltip = payload.tooltip;\n                // Manually show tooltip while view is not using zrender elements.\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    target: el\n                }, dispatchAction);\n            }\n            else if (dataByCoordSys) {\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    event: {},\n                    dataByCoordSys: payload.dataByCoordSys,\n                    tooltipOption: payload.tooltipOption\n                }, dispatchAction);\n            }\n            else if (payload.seriesIndex != null) {\n\n                if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                    return;\n                }\n\n                var pointInfo = findPointFromSeries(payload, ecModel);\n                var cx = pointInfo.point[0];\n                var cy = pointInfo.point[1];\n                if (cx != null && cy != null) {\n                    this._tryShow({\n                        offsetX: cx,\n                        offsetY: cy,\n                        position: payload.position,\n                        target: pointInfo.el,\n                        event: {}\n                    }, dispatchAction);\n                }\n            }\n            else if (payload.x != null && payload.y != null) {\n                // FIXME\n                // should wrap dispatchAction like `axisPointer/globalListener` ?\n                api.dispatchAction({\n                    type: 'updateAxisPointer',\n                    x: payload.x,\n                    y: payload.y\n                });\n\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: api.getZr().findHover(payload.x, payload.y).target,\n                    event: {}\n                }, dispatchAction);\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            var tooltipContent = this._tooltipContent;\n\n            if (!this._alwaysShowContent) {\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._lastX = this._lastY = null;\n\n            if (payload.from !== this.uid) {\n                this._hide(makeDispatchAction(payload, api));\n            }\n        },\n\n        // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n        // and tooltip.\n        _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n            var seriesIndex = payload.seriesIndex;\n            var dataIndex = payload.dataIndex;\n            var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n            if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            if (!seriesModel) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                seriesModel,\n                (seriesModel.coordinateSystem || {}).model,\n                tooltipModel\n            ]);\n\n            if (tooltipModel.get('trigger') !== 'axis') {\n                return;\n            }\n\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                seriesIndex: seriesIndex,\n                dataIndex: dataIndex,\n                position: payload.position\n            });\n\n            return true;\n        },\n\n        _tryShow: function (e, dispatchAction) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            var dataByCoordSys = e.dataByCoordSys;\n            if (dataByCoordSys && dataByCoordSys.length) {\n                this._showAxisTooltip(dataByCoordSys, e);\n            }\n            // Always show item tooltip if mouse is on the element with dataIndex\n            else if (el && el.dataIndex != null) {\n                this._lastDataByCoordSys = null;\n                this._showSeriesItemTooltip(e, el, dispatchAction);\n            }\n            // Tooltip provided directly. Like legend.\n            else if (el && el.tooltip) {\n                this._lastDataByCoordSys = null;\n                this._showComponentItemTooltip(e, el, dispatchAction);\n            }\n            else {\n                this._lastDataByCoordSys = null;\n                this._hide(dispatchAction);\n            }\n        },\n\n        _showOrMove: function (tooltipModel, cb) {\n            // showDelay is used in this case: tooltip.enterable is set\n            // as true. User intent to move mouse into tooltip and click\n            // something. `showDelay` makes it easyer to enter the content\n            // but tooltip do not move immediately.\n            var delay = tooltipModel.get('showDelay');\n            cb = zrUtil.bind(cb, this);\n            clearTimeout(this._showTimout);\n            delay > 0\n                ? (this._showTimout = setTimeout(cb, delay))\n                : cb();\n        },\n\n        _showAxisTooltip: function (dataByCoordSys, e) {\n            var ecModel = this._ecModel;\n            var globalTooltipModel = this._tooltipModel;\n            var point = [e.offsetX, e.offsetY];\n            var singleDefaultHTML = [];\n            var singleParamsList = [];\n            var singleTooltipModel = buildTooltipModel([\n                e.tooltipOption,\n                globalTooltipModel\n            ]);\n\n            each(dataByCoordSys, function (itemCoordSys) {\n                // var coordParamList = [];\n                // var coordDefaultHTML = [];\n                // var coordTooltipModel = buildTooltipModel([\n                //     e.tooltipOption,\n                //     itemCoordSys.tooltipOption,\n                //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n                //     globalTooltipModel\n                // ]);\n                // var displayMode = coordTooltipModel.get('displayMode');\n                // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n                each(itemCoordSys.dataByAxis, function (item) {\n                    var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                    var axisValue = item.value;\n                    var seriesDefaultHTML = [];\n\n                    if (!axisModel || axisValue == null) {\n                        return;\n                    }\n\n                    var valueLabel = axisPointerViewHelper.getValueLabel(\n                        axisValue, axisModel.axis, ecModel,\n                        item.seriesDataIndices,\n                        item.valueLabelOpt\n                    );\n\n                    zrUtil.each(item.seriesDataIndices, function (idxItem) {\n                        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                        var dataIndex = idxItem.dataIndexInside;\n                        var dataParams = series && series.getDataParams(dataIndex);\n                        dataParams.axisDim = item.axisDim;\n                        dataParams.axisIndex = item.axisIndex;\n                        dataParams.axisType = item.axisType;\n                        dataParams.axisId = item.axisId;\n                        dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n                        dataParams.axisValueLabel = valueLabel;\n\n                        if (dataParams) {\n                            singleParamsList.push(dataParams);\n                            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                        }\n                    });\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = valueLabel;\n                    singleDefaultHTML.push(\n                        (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + seriesDefaultHTML.join('<br />')\n                    );\n                });\n            }, this);\n\n            // In most case, the second axis is shown upper than the first one.\n            singleDefaultHTML.reverse();\n            singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n            var positionExpr = e.position;\n            this._showOrMove(singleTooltipModel, function () {\n                if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                    this._updatePosition(\n                        singleTooltipModel,\n                        positionExpr,\n                        point[0], point[1],\n                        this._tooltipContent,\n                        singleParamsList\n                    );\n                }\n                else {\n                    this._showTooltipContent(\n                        singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                        point[0], point[1], positionExpr\n                    );\n                }\n            });\n\n            // Do not trigger events here, because this branch only be entered\n            // from dispatchAction.\n        },\n\n        _showSeriesItemTooltip: function (e, el, dispatchAction) {\n            var ecModel = this._ecModel;\n            // Use dataModel in element if possible\n            // Used when mouseover on a element like markPoint or edge\n            // In which case, the data is not main data in series.\n            var seriesIndex = el.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n            // For example, graph link.\n            var dataModel = el.dataModel || seriesModel;\n            var dataIndex = el.dataIndex;\n            var dataType = el.dataType;\n            var data = dataModel.getData();\n\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                dataModel,\n                seriesModel && (seriesModel.coordinateSystem || {}).model,\n                this._tooltipModel\n            ]);\n\n            var tooltipTrigger = tooltipModel.get('trigger');\n            if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n                return;\n            }\n\n            var params = dataModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n            var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n            this._showOrMove(tooltipModel, function () {\n                this._showTooltipContent(\n                    tooltipModel, defaultHtml, params, asyncTicket,\n                    e.offsetX, e.offsetY, e.position, e.target\n                );\n            });\n\n            // FIXME\n            // duplicated showtip if manuallyShowTip is called from dispatchAction.\n            dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                dataIndex: data.getRawIndex(dataIndex),\n                seriesIndex: seriesIndex,\n                from: this.uid\n            });\n        },\n\n        _showComponentItemTooltip: function (e, el, dispatchAction) {\n            var tooltipOpt = el.tooltip;\n            if (typeof tooltipOpt === 'string') {\n                var content = tooltipOpt;\n                tooltipOpt = {\n                    content: content,\n                    // Fixed formatter\n                    formatter: content\n                };\n            }\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n            var defaultHtml = subTooltipModel.get('content');\n            var asyncTicket = Math.random();\n\n            // Do not check whether `trigger` is 'none' here, because `trigger`\n            // only works on cooridinate system. In fact, we have not found case\n            // that requires setting `trigger` nothing on component yet.\n\n            this._showOrMove(subTooltipModel, function () {\n                this._showTooltipContent(\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\n                );\n            });\n\n            // If not dispatch showTip, tip may be hide triggered by axis.\n            dispatchAction({\n                type: 'showTip',\n                from: this.uid\n            });\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n                return;\n            }\n\n            var tooltipContent = this._tooltipContent;\n\n            var formatter = tooltipModel.get('formatter');\n            positionExpr = positionExpr || tooltipModel.get('position');\n            var html = defaultHtml;\n\n            if (formatter && typeof formatter === 'string') {\n                html = formatUtil.formatTpl(formatter, params, true);\n            }\n            else if (typeof formatter === 'function') {\n                var callback = bind(function (cbTicket, html) {\n                    if (cbTicket === this._ticket) {\n                        tooltipContent.setContent(html);\n                        this._updatePosition(\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                        );\n                    }\n                }, this);\n                this._ticket = asyncTicket;\n                html = formatter(params, asyncTicket, callback);\n            }\n\n            tooltipContent.setContent(html);\n            tooltipContent.show(tooltipModel);\n\n            this._updatePosition(\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\n            );\n        },\n\n        /**\n         * @param  {string|Function|Array.<number>} positionExpr\n         * @param  {number} x Mouse x\n         * @param  {number} y Mouse y\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\n         * @param  {Object|<Array.<Object>} params\n         * @param  {module:zrender/Element} el target element\n         * @param  {module:echarts/ExtensionAPI} api\n         * @return {Array.<number>}\n         */\n        _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n            var viewWidth = this._api.getWidth();\n            var viewHeight = this._api.getHeight();\n            positionExpr = positionExpr || tooltipModel.get('position');\n\n            var contentSize = content.getSize();\n            var align = tooltipModel.get('align');\n            var vAlign = tooltipModel.get('verticalAlign');\n            var rect = el && el.getBoundingRect().clone();\n            el && rect.applyTransform(el.transform);\n\n            if (typeof positionExpr === 'function') {\n                // Callback of position can be an array or a string specify the position\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\n                    viewSize: [viewWidth, viewHeight],\n                    contentSize: contentSize.slice()\n                });\n            }\n\n            if (zrUtil.isArray(positionExpr)) {\n                x = parsePercent(positionExpr[0], viewWidth);\n                y = parsePercent(positionExpr[1], viewHeight);\n            }\n            else if (zrUtil.isObject(positionExpr)) {\n                positionExpr.width = contentSize[0];\n                positionExpr.height = contentSize[1];\n                var layoutRect = layoutUtil.getLayoutRect(\n                    positionExpr, {width: viewWidth, height: viewHeight}\n                );\n                x = layoutRect.x;\n                y = layoutRect.y;\n                align = null;\n                // When positionExpr is left/top/right/bottom,\n                // align and verticalAlign will not work.\n                vAlign = null;\n            }\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n            else if (typeof positionExpr === 'string' && el) {\n                var pos = calcTooltipPosition(\n                    positionExpr, rect, contentSize\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n            else {\n                var pos = refixTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n            if (tooltipModel.get('confine')) {\n                var pos = confineTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            content.moveTo(x, y);\n        },\n\n        // FIXME\n        // Should we remove this but leave this to user?\n        _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n            var lastCoordSys = this._lastDataByCoordSys;\n            var contentNotChanged = !!lastCoordSys\n                && lastCoordSys.length === dataByCoordSys.length;\n\n            contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n                var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n                var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n                var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n                contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n                contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n                    var thisItem = thisDataByAxis[indexAxis] || {};\n                    var lastIndices = lastItem.seriesDataIndices || [];\n                    var newIndices = thisItem.seriesDataIndices || [];\n\n                    contentNotChanged &=\n                        lastItem.value === thisItem.value\n                        && lastItem.axisType === thisItem.axisType\n                        && lastItem.axisId === thisItem.axisId\n                        && lastIndices.length === newIndices.length;\n\n                    contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n                        var newIdxItem = newIndices[j];\n                        contentNotChanged &=\n                            lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                            && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                    });\n                });\n            });\n\n            this._lastDataByCoordSys = dataByCoordSys;\n\n            return !!contentNotChanged;\n        },\n\n        _hide: function (dispatchAction) {\n            // Do not directly hideLater here, because this behavior may be prevented\n            // in dispatchAction when showTip is dispatched.\n\n            // FIXME\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n            this._lastDataByCoordSys = null;\n            dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            this._tooltipContent.hide();\n            globalListener.unregister('itemTooltip', api);\n        }\n    });\n\n\n    /**\n     * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n     * From top to bottom. (the last one should be globalTooltipModel);\n     */\n    function buildTooltipModel(modelCascade) {\n        var resultModel = modelCascade.pop();\n        while (modelCascade.length) {\n            var tooltipOpt = modelCascade.pop();\n            if (tooltipOpt) {\n                if (tooltipOpt instanceof Model) {\n                    tooltipOpt = tooltipOpt.get('tooltip', true);\n                }\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                if (typeof tooltipOpt === 'string') {\n                    tooltipOpt = {formatter: tooltipOpt};\n                }\n                resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n            }\n        }\n        return resultModel;\n    }\n\n    function makeDispatchAction(payload, api) {\n        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        if (gapH != null) {\n            if (x + width + gapH > viewWidth) {\n                x -= width + gapH;\n            }\n            else {\n                x += gapH;\n            }\n        }\n        if (gapV != null) {\n            if (y + height + gapV > viewHeight) {\n                y -= height + gapV;\n            }\n            else {\n                y += gapV;\n            }\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n        var domWidth = contentSize[0];\n        var domHeight = contentSize[1];\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    function isCenterAlign(align) {\n        return align === 'center' || align === 'middle';\n    }\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBWaWV3LmpzPzk5NmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQsb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUIsb0JBQW9CLHVCQUF1QjtBQUMzQyxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQiw0QkFBNEI7QUFDaEQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBUb29sdGlwQ29udGVudCA9IHJlcXVpcmUoJy4vVG9vbHRpcENvbnRlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBmaW5kUG9pbnRGcm9tU2VyaWVzID0gcmVxdWlyZSgnLi4vYXhpc1BvaW50ZXIvZmluZFBvaW50RnJvbVNlcmllcycpO1xuICAgIHZhciBsYXlvdXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyJyk7XG4gICAgdmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9jb29yZC9heGlzSGVscGVyJyk7XG4gICAgdmFyIGF4aXNQb2ludGVyVmlld0hlbHBlciA9IHJlcXVpcmUoJy4uL2F4aXNQb2ludGVyL3ZpZXdIZWxwZXInKTtcblxuICAgIHZhciBiaW5kID0genJVdGlsLmJpbmQ7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG5cblxuICAgIHZhciBwcm94eVJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc2hhcGU6IHt4OiAtMSwgeTogLTEsIHdpZHRoOiAyLCBoZWlnaHQ6IDJ9XG4gICAgfSk7XG5cbiAgICByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ3Rvb2x0aXAnLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b29sdGlwQ29udGVudCA9IG5ldyBUb29sdGlwQ29udGVudChhcGkuZ2V0RG9tKCksIGFwaSk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudCA9IHRvb2x0aXBDb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwTW9kZWwgPSB0b29sdGlwTW9kZWw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2VjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2hvdWxkIGJlIGNsZWFuZWQgd2hlbiByZW5kZXIuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxBcnJheS48T2JqZWN0Pj59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQudXBkYXRlKCk7XG4gICAgICAgICAgICB0b29sdGlwQ29udGVudC5zZXRFbnRlcmFibGUodG9vbHRpcE1vZGVsLmdldCgnZW50ZXJhYmxlJykpO1xuXG4gICAgICAgICAgICB0aGlzLl9pbml0R2xvYmFsTGlzdGVuZXIoKTtcblxuICAgICAgICAgICAgdGhpcy5fa2VlcFNob3coKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEdsb2JhbExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJPbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpO1xuXG4gICAgICAgICAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcihcbiAgICAgICAgICAgICAgICAnaXRlbVRvb2x0aXAnLFxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaSxcbiAgICAgICAgICAgICAgICBiaW5kKGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coZSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyclRyaWdnZXIgPT09ICdsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9rZWVwU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBrZWVwIHRoZSB0b29sdGlwIHNob3cgd2hlbiByZWZyZXNoaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFggIT0gbnVsbFxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2xhc3RZICE9IG51bGxcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzZXIgaXMgd2lsbGluZyB0byBjb250cm9sIHRvb2x0aXAgdG90YWxseSB1c2luZyBBUEksXG4gICAgICAgICAgICAgICAgLy8gc2VsZi5tYW51YWxseVNob3dUaXAoe3gsIHl9KSBtaWdodCBjYXVzZSB0b29sdGlwIGhpZGUsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgbm90IGV4cGVjdGVkLlxuICAgICAgICAgICAgICAgICYmIHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpICE9PSAnbm9uZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaFVwZGF0ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGlwIG5leHQgdGljayBhZnRlciBvdGhlciBjaGFydHMgYXJlIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaGlnaGxpZ2h0IGFjdGlvbiBoYXMgd3JvbmcgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWFudWFsbHlTaG93VGlwKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLl9sYXN0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYuX2xhc3RZXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRpcCBtYW51YWxseSBieVxuICAgICAgICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAqICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAqICAgICB4OiAxMCxcbiAgICAgICAgICogICAgIHk6IDEwXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBPclxuICAgICAgICAgKiBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAqICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgKiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICAgKiAgICAgIGRhdGFJbmRleCBvciBkYXRhSW5kZXhJbnNpZGUgb3IgbmFtZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogIFRPRE8gQmF0Y2hcbiAgICAgICAgICovXG4gICAgICAgIG1hbnVhbGx5U2hvd1RpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCB8fCBlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc3BhdGNoQWN0aW9uID0gbWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSk7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHRpY2tldFxuICAgICAgICAgICAgdGhpcy5fdGlja2V0ID0gJyc7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdHJpZ2dlcmVkIGZyb20gYXhpc1BvaW50ZXIuXG4gICAgICAgICAgICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSBwYXlsb2FkLmRhdGFCeUNvb3JkU3lzO1xuXG4gICAgICAgICAgICBpZiAocGF5bG9hZC50b29sdGlwICYmIHBheWxvYWQueCAhPSBudWxsICYmIHBheWxvYWQueSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gcHJveHlSZWN0O1xuICAgICAgICAgICAgICAgIGVsLnBvc2l0aW9uID0gW3BheWxvYWQueCwgcGF5bG9hZC55XTtcbiAgICAgICAgICAgICAgICBlbC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBlbC50b29sdGlwID0gcGF5bG9hZC50b29sdGlwO1xuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNob3cgdG9vbHRpcCB3aGlsZSB2aWV3IGlzIG5vdCB1c2luZyB6cmVuZGVyIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBwYXlsb2FkLngsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IHBheWxvYWQueSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlbFxuICAgICAgICAgICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICBkYXRhQnlDb29yZFN5czogcGF5bG9hZC5kYXRhQnlDb29yZFN5cyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE9wdGlvbjogcGF5bG9hZC50b29sdGlwT3B0aW9uXG4gICAgICAgICAgICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5zZXJpZXNJbmRleCAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWFudWFsbHlBeGlzU2hvd1RpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludEluZm8gPSBmaW5kUG9pbnRGcm9tU2VyaWVzKHBheWxvYWQsIGVjTW9kZWwpO1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHBvaW50SW5mby5wb2ludFswXTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSBwb2ludEluZm8ucG9pbnRbMV07XG4gICAgICAgICAgICAgICAgaWYgKGN4ICE9IG51bGwgJiYgY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IGN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogcG9pbnRJbmZvLmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkLnggIT0gbnVsbCAmJiBwYXlsb2FkLnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdyYXAgZGlzcGF0Y2hBY3Rpb24gbGlrZSBgYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXJgID9cbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICB4OiBwYXlsb2FkLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHBheWxvYWQueVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBhcGkuZ2V0WnIoKS5maW5kSG92ZXIocGF5bG9hZC54LCBwYXlsb2FkLnkpLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHt9XG4gICAgICAgICAgICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1hbnVhbGx5SGlkZVRpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hbHdheXNTaG93Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LmhpZGVMYXRlcih0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdoaWRlRGVsYXknKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RYID0gdGhpcy5fbGFzdFkgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mcm9tICE9PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUobWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEJlIGNvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBkZXNpZ24sIHRoYXQgaXMsIHdoZW4gdG9vbHRpcC50eXBlIGlzICdheGlzJyBhbmRcbiAgICAgICAgLy8gZGlzcGF0Y2hBY3Rpb24gJ3Nob3dUaXAnIHdpdGggc2VyaWVzSW5kZXggYW5kIGRhdGFJbmRleCB3aWxsIHRyaWdnZXIgYXhpcyBwb2ludGVyXG4gICAgICAgIC8vIGFuZCB0b29sdGlwLlxuICAgICAgICBfbWFudWFsbHlBeGlzU2hvd1RpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBwYXlsb2FkLnNlcmllc0luZGV4O1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IHBheWxvYWQuZGF0YUluZGV4O1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvO1xuXG4gICAgICAgICAgICBpZiAoc2VyaWVzSW5kZXggPT0gbnVsbCB8fCBkYXRhSW5kZXggPT0gbnVsbCB8fCBjb29yZFN5c0F4ZXNJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICBpZiAoIXNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KSxcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCxcbiAgICAgICAgICAgICAgICAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCB7fSkubW9kZWwsXG4gICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKSAhPT0gJ2F4aXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RyeVNob3c6IGZ1bmN0aW9uIChlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXBNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2F2ZSBtb3VzZSB4LCBtb3VzZSB5LiBTbyB3ZSBjYW4gdHJ5IHRvIGtlZXAgc2hvd2luZyB0aGUgdGlwIGlmIGNoYXJ0IGlzIHJlZnJlc2hlZFxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICB0aGlzLl9sYXN0WSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgdmFyIGRhdGFCeUNvb3JkU3lzID0gZS5kYXRhQnlDb29yZFN5cztcbiAgICAgICAgICAgIGlmIChkYXRhQnlDb29yZFN5cyAmJiBkYXRhQnlDb29yZFN5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93QXhpc1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWx3YXlzIHNob3cgaXRlbSB0b29sdGlwIGlmIG1vdXNlIGlzIG9uIHRoZSBlbGVtZW50IHdpdGggZGF0YUluZGV4XG4gICAgICAgICAgICBlbHNlIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Nlcmllc0l0ZW1Ub29sdGlwKGUsIGVsLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb29sdGlwIHByb3ZpZGVkIGRpcmVjdGx5LiBMaWtlIGxlZ2VuZC5cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsICYmIGVsLnRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd09yTW92ZTogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgY2IpIHtcbiAgICAgICAgICAgIC8vIHNob3dEZWxheSBpcyB1c2VkIGluIHRoaXMgY2FzZTogdG9vbHRpcC5lbnRlcmFibGUgaXMgc2V0XG4gICAgICAgICAgICAvLyBhcyB0cnVlLiBVc2VyIGludGVudCB0byBtb3ZlIG1vdXNlIGludG8gdG9vbHRpcCBhbmQgY2xpY2tcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZy4gYHNob3dEZWxheWAgbWFrZXMgaXQgZWFzeWVyIHRvIGVudGVyIHRoZSBjb250ZW50XG4gICAgICAgICAgICAvLyBidXQgdG9vbHRpcCBkbyBub3QgbW92ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIHZhciBkZWxheSA9IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dEZWxheScpO1xuICAgICAgICAgICAgY2IgPSB6clV0aWwuYmluZChjYiwgdGhpcyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbW91dCk7XG4gICAgICAgICAgICBkZWxheSA+IDBcbiAgICAgICAgICAgICAgICA/ICh0aGlzLl9zaG93VGltb3V0ID0gc2V0VGltZW91dChjYiwgZGVsYXkpKVxuICAgICAgICAgICAgICAgIDogY2IoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd0F4aXNUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUJ5Q29vcmRTeXMsIGUpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBnbG9iYWxUb29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBbZS5vZmZzZXRYLCBlLm9mZnNldFldO1xuICAgICAgICAgICAgdmFyIHNpbmdsZURlZmF1bHRIVE1MID0gW107XG4gICAgICAgICAgICB2YXIgc2luZ2xlUGFyYW1zTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHNpbmdsZVRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtcbiAgICAgICAgICAgICAgICBlLnRvb2x0aXBPcHRpb24sXG4gICAgICAgICAgICAgICAgZ2xvYmFsVG9vbHRpcE1vZGVsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgZWFjaChkYXRhQnlDb29yZFN5cywgZnVuY3Rpb24gKGl0ZW1Db29yZFN5cykge1xuICAgICAgICAgICAgICAgIC8vIHZhciBjb29yZFBhcmFtTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIHZhciBjb29yZERlZmF1bHRIVE1MID0gW107XG4gICAgICAgICAgICAgICAgLy8gdmFyIGNvb3JkVG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW1xuICAgICAgICAgICAgICAgIC8vICAgICBlLnRvb2x0aXBPcHRpb24sXG4gICAgICAgICAgICAgICAgLy8gICAgIGl0ZW1Db29yZFN5cy50b29sdGlwT3B0aW9uLFxuICAgICAgICAgICAgICAgIC8vICAgICBlY01vZGVsLmdldENvbXBvbmVudChpdGVtQ29vcmRTeXMuY29vcmRTeXNNYWluVHlwZSwgaXRlbUNvb3JkU3lzLmNvb3JkU3lzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC8vICAgICBnbG9iYWxUb29sdGlwTW9kZWxcbiAgICAgICAgICAgICAgICAvLyBdKTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgZGlzcGxheU1vZGUgPSBjb29yZFRvb2x0aXBNb2RlbC5nZXQoJ2Rpc3BsYXlNb2RlJyk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHBhcmFtc0xpc3QgPSBkaXNwbGF5TW9kZSA9PT0gJ3NpbmdsZScgPyBzaW5nbGVQYXJhbXNMaXN0IDogW107XG5cbiAgICAgICAgICAgICAgICBlYWNoKGl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoaXRlbS5heGlzRGltICsgJ0F4aXMnLCBpdGVtLmF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzVmFsdWUgPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRGVmYXVsdEhUTUwgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCB8fCBheGlzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTGFiZWwgPSBheGlzUG9pbnRlclZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNWYWx1ZSwgYXhpc01vZGVsLmF4aXMsIGVjTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNlcmllc0RhdGFJbmRpY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS52YWx1ZUxhYmVsT3B0XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goaXRlbS5zZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gaWR4SXRlbS5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVBhcmFtcyA9IHNlcmllcyAmJiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBhcmFtcy5heGlzRGltID0gaXRlbS5heGlzRGltO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBhcmFtcy5heGlzSW5kZXggPSBpdGVtLmF4aXNJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc1R5cGUgPSBpdGVtLmF4aXNUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBhcmFtcy5heGlzSWQgPSBpdGVtLmF4aXNJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc1ZhbHVlID0gYXhpc0hlbHBlci5nZXRBeGlzUmF3VmFsdWUoYXhpc01vZGVsLmF4aXMsIGF4aXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNWYWx1ZUxhYmVsID0gdmFsdWVMYWJlbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGVQYXJhbXNMaXN0LnB1c2goZGF0YVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzRGVmYXVsdEhUTUwucHVzaChzZXJpZXMuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgLy8gKDEpIHNob2xkIGJlIHRoZSBmaXJzdCBkYXRhIHdoaWNoIGhhcyBuYW1lP1xuICAgICAgICAgICAgICAgICAgICAvLyAoMikgdGhlbWVSaXZlciwgZmlyc3REYXRhSW5kZXggaXMgYXJyYXksIGFuZCBmaXJzdCBsaW5lIGlzIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RMaW5lID0gdmFsdWVMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRGVmYXVsdEhUTUwucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIChmaXJzdExpbmUgPyBmb3JtYXRVdGlsLmVuY29kZUhUTUwoZmlyc3RMaW5lKSArICc8YnIgLz4nIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHNlcmllc0RlZmF1bHRIVE1MLmpvaW4oJzxiciAvPicpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSW4gbW9zdCBjYXNlLCB0aGUgc2Vjb25kIGF4aXMgaXMgc2hvd24gdXBwZXIgdGhhbiB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgc2luZ2xlRGVmYXVsdEhUTUwucmV2ZXJzZSgpO1xuICAgICAgICAgICAgc2luZ2xlRGVmYXVsdEhUTUwgPSBzaW5nbGVEZWZhdWx0SFRNTC5qb2luKCc8YnIgLz48YnIgLz4nKTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRXhwciA9IGUucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLl9zaG93T3JNb3ZlKHNpbmdsZVRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGVDb250ZW50Tm90Q2hhbmdlZE9uQXhpcyhkYXRhQnlDb29yZFN5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGVUb29sdGlwTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZVBhcmFtc0xpc3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZVRvb2x0aXBNb2RlbCwgc2luZ2xlRGVmYXVsdEhUTUwsIHNpbmdsZVBhcmFtc0xpc3QsIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0sIHBvc2l0aW9uRXhwclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgdHJpZ2dlciBldmVudHMgaGVyZSwgYmVjYXVzZSB0aGlzIGJyYW5jaCBvbmx5IGJlIGVudGVyZWRcbiAgICAgICAgICAgIC8vIGZyb20gZGlzcGF0Y2hBY3Rpb24uXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3dTZXJpZXNJdGVtVG9vbHRpcDogZnVuY3Rpb24gKGUsIGVsLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9lY01vZGVsO1xuICAgICAgICAgICAgLy8gVXNlIGRhdGFNb2RlbCBpbiBlbGVtZW50IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyBVc2VkIHdoZW4gbW91c2VvdmVyIG9uIGEgZWxlbWVudCBsaWtlIG1hcmtQb2ludCBvciBlZGdlXG4gICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlLCB0aGUgZGF0YSBpcyBub3QgbWFpbiBkYXRhIGluIHNlcmllcy5cbiAgICAgICAgICAgIHZhciBzZXJpZXNJbmRleCA9IGVsLnNlcmllc0luZGV4O1xuICAgICAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KTtcblxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGdyYXBoIGxpbmsuXG4gICAgICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IHNlcmllc01vZGVsO1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGVsLmRhdGFJbmRleDtcbiAgICAgICAgICAgIHZhciBkYXRhVHlwZSA9IGVsLmRhdGFUeXBlO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW1xuICAgICAgICAgICAgICAgIGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksXG4gICAgICAgICAgICAgICAgZGF0YU1vZGVsLFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsICYmIChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtIHx8IHt9KS5tb2RlbCxcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwTW9kZWxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcFRyaWdnZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJyk7XG4gICAgICAgICAgICBpZiAodG9vbHRpcFRyaWdnZXIgIT0gbnVsbCAmJiB0b29sdGlwVHJpZ2dlciAhPT0gJ2l0ZW0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSBkYXRhTW9kZWwuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIGZhbHNlLCBkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgYXN5bmNUaWNrZXQgPSAnaXRlbV8nICsgZGF0YU1vZGVsLm5hbWUgKyAnXycgKyBkYXRhSW5kZXg7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3dPck1vdmUodG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LFxuICAgICAgICAgICAgICAgICAgICBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZS50YXJnZXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBkdXBsaWNhdGVkIHNob3d0aXAgaWYgbWFudWFsbHlTaG93VGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgICAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXhJbnNpZGU6IGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KSxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXA6IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gZWwudG9vbHRpcDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbHRpcE9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHRvb2x0aXBPcHQ7XG4gICAgICAgICAgICAgICAgdG9vbHRpcE9wdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgZm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY29udGVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ViVG9vbHRpcE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHRoaXMuX3Rvb2x0aXBNb2RlbCwgdGhpcy5fZWNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSBzdWJUb29sdGlwTW9kZWwuZ2V0KCdjb250ZW50Jyk7XG4gICAgICAgICAgICB2YXIgYXN5bmNUaWNrZXQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgY2hlY2sgd2hldGhlciBgdHJpZ2dlcmAgaXMgJ25vbmUnIGhlcmUsIGJlY2F1c2UgYHRyaWdnZXJgXG4gICAgICAgICAgICAvLyBvbmx5IHdvcmtzIG9uIGNvb3JpZGluYXRlIHN5c3RlbS4gSW4gZmFjdCwgd2UgaGF2ZSBub3QgZm91bmQgY2FzZVxuICAgICAgICAgICAgLy8gdGhhdCByZXF1aXJlcyBzZXR0aW5nIGB0cmlnZ2VyYCBub3RoaW5nIG9uIGNvbXBvbmVudCB5ZXQuXG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3dPck1vdmUoc3ViVG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICBzdWJUb29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBzdWJUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXJQYXJhbXMnKSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnBvc2l0aW9uLCBlbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgbm90IGRpc3BhdGNoIHNob3dUaXAsIHRpcCBtYXkgYmUgaGlkZSB0cmlnZ2VyZWQgYnkgYXhpcy5cbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHBhcmFtcywgYXN5bmNUaWNrZXQsIHgsIHksIHBvc2l0aW9uRXhwciwgZWxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aWNrZXRcbiAgICAgICAgICAgIHRoaXMuX3RpY2tldCA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dDb250ZW50JykgfHwgIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICAgICAgICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwciB8fCB0b29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkZWZhdWx0SHRtbDtcblxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGh0bWwgPSBmb3JtYXRVdGlsLmZvcm1hdFRwbChmb3JtYXR0ZXIsIHBhcmFtcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYmluZChmdW5jdGlvbiAoY2JUaWNrZXQsIGh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiVGlja2V0ID09PSB0aGlzLl90aWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgdG9vbHRpcENvbnRlbnQsIHBhcmFtcywgZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrZXQgPSBhc3luY1RpY2tldDtcbiAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0dGVyKHBhcmFtcywgYXN5bmNUaWNrZXQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNob3codG9vbHRpcE1vZGVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb258QXJyYXkuPG51bWJlcj59IHBvc2l0aW9uRXhwclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggTW91c2UgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgTW91c2UgeVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjb25maW5lIFdoZXRoZXIgY29uZmluZSB0b29sdGlwIGNvbnRlbnQgaW4gdmlldyByZWN0LlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R8PEFycmF5LjxPYmplY3Q+fSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgY29udGVudCwgcGFyYW1zLCBlbCkge1xuICAgICAgICAgICAgdmFyIHZpZXdXaWR0aCA9IHRoaXMuX2FwaS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnRTaXplID0gY29udGVudC5nZXRTaXplKCk7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSB0b29sdGlwTW9kZWwuZ2V0KCdhbGlnbicpO1xuICAgICAgICAgICAgdmFyIHZBbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3ZlcnRpY2FsQWxpZ24nKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwgJiYgZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgICAgIGVsICYmIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsYmFjayBvZiBwb3NpdGlvbiBjYW4gYmUgYW4gYXJyYXkgb3IgYSBzdHJpbmcgc3BlY2lmeSB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIoW3gsIHldLCBwYXJhbXMsIGNvbnRlbnQuZWwsIHJlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld1NpemU6IFt2aWV3V2lkdGgsIHZpZXdIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUuc2xpY2UoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkocG9zaXRpb25FeHByKSkge1xuICAgICAgICAgICAgICAgIHggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzBdLCB2aWV3V2lkdGgpO1xuICAgICAgICAgICAgICAgIHkgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzFdLCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChwb3NpdGlvbkV4cHIpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLndpZHRoID0gY29udGVudFNpemVbMF07XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLmhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0VXRpbC5nZXRMYXlvdXRSZWN0KFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHt3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHR9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gbGF5b3V0UmVjdC54O1xuICAgICAgICAgICAgICAgIHkgPSBsYXlvdXRSZWN0Lnk7XG4gICAgICAgICAgICAgICAgYWxpZ24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gcG9zaXRpb25FeHByIGlzIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSxcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiBhbmQgdmVydGljYWxBbGlnbiB3aWxsIG5vdCB3b3JrLlxuICAgICAgICAgICAgICAgIHZBbGlnbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTcGVjaWZ5IHRvb2x0aXAgcG9zaXRpb24gYnkgc3RyaW5nICd0b3AnICdib3R0b20nICdsZWZ0JyAncmlnaHQnIGFyb3VuZCBncmFwaGljIGVsZW1lbnRcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdzdHJpbmcnICYmIGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGNhbGNUb29sdGlwUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwciwgcmVjdCwgY29udGVudFNpemVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSBwb3NbMF07XG4gICAgICAgICAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSByZWZpeFRvb2x0aXBQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgeCwgeSwgY29udGVudC5lbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCBhbGlnbiA/IG51bGwgOiAyMCwgdkFsaWduID8gbnVsbCA6IDIwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICAgICAgICAgIHkgPSBwb3NbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFsaWduICYmICh4IC09IGlzQ2VudGVyQWxpZ24oYWxpZ24pID8gY29udGVudFNpemVbMF0gLyAyIDogYWxpZ24gPT09ICdyaWdodCcgPyBjb250ZW50U2l6ZVswXSA6IDApO1xuICAgICAgICAgICAgdkFsaWduICYmICh5IC09IGlzQ2VudGVyQWxpZ24odkFsaWduKSA/IGNvbnRlbnRTaXplWzFdIC8gMiA6IHZBbGlnbiA9PT0gJ2JvdHRvbScgPyBjb250ZW50U2l6ZVsxXSA6IDApO1xuXG4gICAgICAgICAgICBpZiAodG9vbHRpcE1vZGVsLmdldCgnY29uZmluZScpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGNvbmZpbmVUb29sdGlwUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHBvc1swXTtcbiAgICAgICAgICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBTaG91bGQgd2UgcmVtb3ZlIHRoaXMgYnV0IGxlYXZlIHRoaXMgdG8gdXNlcj9cbiAgICAgICAgX3VwZGF0ZUNvbnRlbnROb3RDaGFuZ2VkT25BeGlzOiBmdW5jdGlvbiAoZGF0YUJ5Q29vcmRTeXMpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q29vcmRTeXMgPSB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXM7XG4gICAgICAgICAgICB2YXIgY29udGVudE5vdENoYW5nZWQgPSAhIWxhc3RDb29yZFN5c1xuICAgICAgICAgICAgICAgICYmIGxhc3RDb29yZFN5cy5sZW5ndGggPT09IGRhdGFCeUNvb3JkU3lzLmxlbmd0aDtcblxuICAgICAgICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0Q29vcmRTeXMsIGZ1bmN0aW9uIChsYXN0SXRlbUNvb3JkU3lzLCBpbmRleENvb3JkU3lzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3REYXRhQnlBeGlzID0gbGFzdEl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzSXRlbUNvb3JkU3lzID0gZGF0YUJ5Q29vcmRTeXNbaW5kZXhDb29yZFN5c10gfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNEYXRhQnlBeGlzID0gdGhpc0l0ZW1Db29yZFN5cy5kYXRhQnlBeGlzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9IGxhc3REYXRhQnlBeGlzLmxlbmd0aCA9PT0gdGhpc0RhdGFCeUF4aXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0RGF0YUJ5QXhpcywgZnVuY3Rpb24gKGxhc3RJdGVtLCBpbmRleEF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNJdGVtID0gdGhpc0RhdGFCeUF4aXNbaW5kZXhBeGlzXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RJbmRpY2VzID0gbGFzdEl0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRpY2VzID0gdGhpc0l0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGVudE5vdENoYW5nZWQgJj1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RJdGVtLnZhbHVlID09PSB0aGlzSXRlbS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGFzdEl0ZW0uYXhpc1R5cGUgPT09IHRoaXNJdGVtLmF4aXNUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBsYXN0SXRlbS5heGlzSWQgPT09IHRoaXNJdGVtLmF4aXNJZFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGFzdEluZGljZXMubGVuZ3RoID09PSBuZXdJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmJiBlYWNoKGxhc3RJbmRpY2VzLCBmdW5jdGlvbiAobGFzdElkeEl0ZW0sIGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdJZHhJdGVtID0gbmV3SW5kaWNlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdElkeEl0ZW0uc2VyaWVzSW5kZXggPT09IG5ld0lkeEl0ZW0uc2VyaWVzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBsYXN0SWR4SXRlbS5kYXRhSW5kZXggPT09IG5ld0lkeEl0ZW0uZGF0YUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBkYXRhQnlDb29yZFN5cztcblxuICAgICAgICAgICAgcmV0dXJuICEhY29udGVudE5vdENoYW5nZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hpZGU6IGZ1bmN0aW9uIChkaXNwYXRjaEFjdGlvbikge1xuICAgICAgICAgICAgLy8gRG8gbm90IGRpcmVjdGx5IGhpZGVMYXRlciBoZXJlLCBiZWNhdXNlIHRoaXMgYmVoYXZpb3IgbWF5IGJlIHByZXZlbnRlZFxuICAgICAgICAgICAgLy8gaW4gZGlzcGF0Y2hBY3Rpb24gd2hlbiBzaG93VGlwIGlzIGRpc3BhdGNoZWQuXG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBkdXBsaWNhdGVkIGhpZGVUaXAgaWYgbWFudWFsbHlIaWRlVGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGlkZVRpcCcsXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50LmhpZGUoKTtcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgYXBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fSBtb2RlbENhc2NhZGVcbiAgICAgKiBGcm9tIHRvcCB0byBib3R0b20uICh0aGUgbGFzdCBvbmUgc2hvdWxkIGJlIGdsb2JhbFRvb2x0aXBNb2RlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gYnVpbGRUb29sdGlwTW9kZWwobW9kZWxDYXNjYWRlKSB7XG4gICAgICAgIHZhciByZXN1bHRNb2RlbCA9IG1vZGVsQ2FzY2FkZS5wb3AoKTtcbiAgICAgICAgd2hpbGUgKG1vZGVsQ2FzY2FkZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gbW9kZWxDYXNjYWRlLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBPcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcE9wdCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBPcHQgPSB0b29sdGlwT3B0LmdldCgndG9vbHRpcCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbiBlYWNoIGRhdGEgaXRlbSB0b29sdGlwIGNhbiBiZSBzaW1wbHkgd3JpdGU6XG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICB2YWx1ZTogMTAsXG4gICAgICAgICAgICAgICAgLy8gIHRvb2x0aXA6ICdTb21ldGhpbmcgeW91IG5lZWQgdG8ga25vdydcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sdGlwT3B0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwT3B0ID0ge2Zvcm1hdHRlcjogdG9vbHRpcE9wdH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHJlc3VsdE1vZGVsLCByZXN1bHRNb2RlbC5lY01vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TW9kZWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiB8fCB6clV0aWwuYmluZChhcGkuZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmaXhUb29sdGlwUG9zaXRpb24oeCwgeSwgZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgZ2FwSCwgZ2FwVikge1xuICAgICAgICB2YXIgd2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICBpZiAoZ2FwSCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoeCArIHdpZHRoICsgZ2FwSCA+IHZpZXdXaWR0aCkge1xuICAgICAgICAgICAgICAgIHggLT0gd2lkdGggKyBnYXBIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCArPSBnYXBIO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnYXBWICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh5ICsgaGVpZ2h0ICsgZ2FwViA+IHZpZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB5IC09IGhlaWdodCArIGdhcFY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ICs9IGdhcFY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgeCA9IE1hdGgubWluKHggKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICAgICAgICB5ID0gTWF0aC5taW4oeSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gICAgICAgIHggPSBNYXRoLm1heCh4LCAwKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KHksIDApO1xuXG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbiwgcmVjdCwgY29udGVudFNpemUpIHtcbiAgICAgICAgdmFyIGRvbVdpZHRoID0gY29udGVudFNpemVbMF07XG4gICAgICAgIHZhciBkb21IZWlnaHQgPSBjb250ZW50U2l6ZVsxXTtcbiAgICAgICAgdmFyIGdhcCA9IDU7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55IC0gZG9tSGVpZ2h0IC0gZ2FwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCArIGdhcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggLSBkb21XaWR0aCAtIGdhcDtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggKyBnYXA7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ2VudGVyQWxpZ24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJyB8fCBhbGlnbiA9PT0gJ21pZGRsZSc7XG4gICAgfVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // 一级层叠\n        z: 0,                       // 二级层叠\n        // 反向坐标轴\n        inverse: false,\n\n        // 坐标轴名字，默认为空\n        name: '',\n        // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // 坐标轴名字旋转，degree。\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // 坐标轴文字样式，默认取全局样式\n        nameTextStyle: {},\n        // 文字与轴线距离\n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        axisPointer: {},\n\n        // 坐标轴线\n        axisLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            onZero: true,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // 属性show控制显示与否，默认显示\n            show: true,\n            // 控制小标记是否在grid里\n            inside: false,\n            // 属性length控制线长\n            length: 5,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                width: 1\n            }\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            show: true,\n            // 控制文本标签是否在grid里\n            inside: false,\n            rotate: 0,\n            showMinLabel: null, // true | false | null (auto)\n            showMaxLabel: null, // true | false | null (auto)\n            margin: 8,\n            // formatter: null,\n            // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // 分隔线\n        splitLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            // 属性lineStyle（详见lineStyle）控制线条样式\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 分隔区域\n        splitArea: {\n            // 默认不显示，属性show控制显示与否\n            show: false,\n            // 属性areaStyle（详见areaStyle）控制区域样式\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // 类目起始和结束两端空白策略\n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // 数值起始和结束两端空白策略\n        boundaryGap: [0, 0],\n        // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n        // min: null,\n        // 最大值，设置成 'dataMax' 则从数据中计算最大值\n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 脱离0值比例，放大聚焦到最终_min，_max区间\n        // scale: false,\n        // 分割段数，默认为5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n\n    var logAxis = zrUtil.defaults({\n        scale: true,\n        logBase: 10\n    }, valueAxis);\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzPzVhOWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICB6OiAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgIC8vIOWPjeWQkeWdkOagh+i9tFxuICAgICAgICBpbnZlcnNlOiBmYWxzZSxcblxuICAgICAgICAvLyDlnZDmoIfovbTlkI3lrZfvvIzpu5jorqTkuLrnqbpcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+S9jee9ru+8jOaUr+aMgSdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnXG4gICAgICAgIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+aXi+i9rO+8jGRlZ3JlZeOAglxuICAgICAgICBuYW1lUm90YXRlOiBudWxsLCAvLyBBZGFwdCB0byBheGlzIHJvdGF0ZSwgd2hlbiBuYW1lTG9jYXRpb24gaXMgJ21pZGRsZScuXG4gICAgICAgIG5hbWVUcnVuY2F0ZToge1xuICAgICAgICAgICAgbWF4V2lkdGg6IG51bGwsXG4gICAgICAgICAgICBlbGxpcHNpczogJy4uLicsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOaWh+Wtl+agt+W8j++8jOm7mOiupOWPluWFqOWxgOagt+W8j1xuICAgICAgICBuYW1lVGV4dFN0eWxlOiB7fSxcbiAgICAgICAgLy8g5paH5a2X5LiO6L2057q/6Led56a7XG4gICAgICAgIG5hbWVHYXA6IDE1LFxuXG4gICAgICAgIHNpbGVudDogZmFsc2UsIC8vIERlZmF1bHQgZmFsc2UgdG8gc3VwcG9ydCB0b29sdGlwLlxuICAgICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLCAvLyBEZWZhdWx0IGZhbHNlIHRvIGF2b2lkIGxlZ2FjeSB1c2VyIGV2ZW50IGxpc3RlbmVyIGZhaWwuXG5cbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBheGlzUG9pbnRlcjoge30sXG5cbiAgICAgICAgLy8g5Z2Q5qCH6L2057q/XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgb25aZXJvOiB0cnVlLFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgICAgIGF4aXNUaWNrOiB7XG4gICAgICAgICAgICAvLyDlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCm77yM6buY6K6k5pi+56S6XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgLy8g5o6n5Yi25bCP5qCH6K6w5piv5ZCm5ZyoZ3JpZOmHjFxuICAgICAgICAgICAgaW5zaWRlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xlbmd0aOaOp+WItue6v+mVv1xuICAgICAgICAgICAgbGVuZ3RoOiA1LFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAvLyDmjqfliLbmlofmnKzmoIfnrb7mmK/lkKblnKhncmlk6YeMXG4gICAgICAgICAgICBpbnNpZGU6IGZhbHNlLFxuICAgICAgICAgICAgcm90YXRlOiAwLFxuICAgICAgICAgICAgc2hvd01pbkxhYmVsOiBudWxsLCAvLyB0cnVlIHwgZmFsc2UgfCBudWxsIChhdXRvKVxuICAgICAgICAgICAgc2hvd01heExhYmVsOiBudWxsLCAvLyB0cnVlIHwgZmFsc2UgfCBudWxsIChhdXRvKVxuICAgICAgICAgICAgbWFyZ2luOiA4LFxuICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgLy8g5YW25L2Z5bGe5oCn6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU57q/XG4gICAgICAgIHNwbGl0TGluZToge1xuICAgICAgICAgICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZe+8iOivpuingWxpbmVTdHlsZe+8ieaOp+WItue6v+adoeagt+W8j1xuICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFsnI2NjYyddLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU5Yy65Z+fXG4gICAgICAgIHNwbGl0QXJlYToge1xuICAgICAgICAgICAgLy8g6buY6K6k5LiN5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAvLyDlsZ7mgKdhcmVhU3R5bGXvvIjor6bop4FhcmVhU3R5bGXvvInmjqfliLbljLrln5/moLflvI9cbiAgICAgICAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBbJ3JnYmEoMjUwLDI1MCwyNTAsMC4zKScsJ3JnYmEoMjAwLDIwMCwyMDAsMC4zKSddXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIC8vIOexu+ebrui1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICAgICAgICBib3VuZGFyeUdhcDogdHJ1ZSxcbiAgICAgICAgLy8gc3BsaXRBcmVhOiB7XG4gICAgICAgICAgICAvLyBzaG93OiBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICBzcGxpdExpbmU6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOWwj+agh+iusFxuICAgICAgICBheGlzVGljazoge1xuICAgICAgICAgICAgLy8gSWYgdGljayBpcyBhbGlnbiB3aXRoIGxhYmVsIHdoZW4gYm91bmRhcnlHYXAgaXMgdHJ1ZVxuICAgICAgICAgICAgYWxpZ25XaXRoTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgIGludGVydmFsOiAnYXV0bydcbiAgICAgICAgfVxuICAgIH0sIGRlZmF1bHRPcHRpb24pO1xuXG4gICAgdmFyIHZhbHVlQXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIC8vIOaVsOWAvOi1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICAgICAgICBib3VuZGFyeUdhcDogWzAsIDBdLFxuICAgICAgICAvLyDmnIDlsI/lgLwsIOiuvue9ruaIkCAnZGF0YU1pbicg5YiZ5LuO5pWw5o2u5Lit6K6h566X5pyA5bCP5YC8XG4gICAgICAgIC8vIG1pbjogbnVsbCxcbiAgICAgICAgLy8g5pyA5aSn5YC877yM6K6+572u5oiQICdkYXRhTWF4JyDliJnku47mlbDmja7kuK3orqHnrpfmnIDlpKflgLxcbiAgICAgICAgLy8gbWF4OiBudWxsLFxuICAgICAgICAvLyBSZWFkb25seSBwcm9wLCBzcGVjaWZpZXMgc3RhcnQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAgICAgICAvLyByYW5nZVN0YXJ0OiBudWxsXG4gICAgICAgIC8vIFJlYWRvbmx5IHByb3AsIHNwZWNpZmllcyBlbmQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAgICAgICAvLyByYW5nZUVuZDogbnVsbFxuICAgICAgICAvLyDohLHnprsw5YC85q+U5L6L77yM5pS+5aSn6IGa54Sm5Yiw5pyA57uIX21pbu+8jF9tYXjljLrpl7RcbiAgICAgICAgLy8gc2NhbGU6IGZhbHNlLFxuICAgICAgICAvLyDliIblibLmrrXmlbDvvIzpu5jorqTkuLo1XG4gICAgICAgIHNwbGl0TnVtYmVyOiA1XG4gICAgICAgIC8vIE1pbmltdW0gaW50ZXJ2YWxcbiAgICAgICAgLy8gbWluSW50ZXJ2YWw6IG51bGxcbiAgICB9LCBkZWZhdWx0T3B0aW9uKTtcblxuICAgIC8vIEZJWE1FXG4gICAgdmFyIHRpbWVBeGlzID0genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgc2NhbGU6IHRydWUsXG4gICAgICAgIG1pbjogJ2RhdGFNaW4nLFxuICAgICAgICBtYXg6ICdkYXRhTWF4J1xuICAgIH0sIHZhbHVlQXhpcyk7XG5cbiAgICB2YXIgbG9nQXhpcyA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgICBsb2dCYXNlOiAxMFxuICAgIH0sIHZhbHVlQXhpcyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2F0ZWdvcnlBeGlzOiBjYXRlZ29yeUF4aXMsXG4gICAgICAgIHZhbHVlQXhpczogdmFsdWVBeGlzLFxuICAgICAgICB0aW1lQXhpczogdGltZUF4aXMsXG4gICAgICAgIGxvZ0F4aXM6IGxvZ0F4aXNcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var axisDefault = __webpack_require__(157);\n    var zrUtil = __webpack_require__(0);\n    var ComponentModel = __webpack_require__(13);\n    var layout = __webpack_require__(15);\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanM/MDlkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLCtCQUErQjtBQUM5QyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBheGlzRGVmYXVsdCA9IHJlcXVpcmUoJy4vYXhpc0RlZmF1bHQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvLyBGSVhNRSBheGlzVHlwZSBpcyBmaXhlZCA/XG4gICAgdmFyIEFYSVNfVFlQRVMgPSBbJ3ZhbHVlJywgJ2NhdGVnb3J5JywgJ3RpbWUnLCAnbG9nJ107XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBzdWIgYXhpcyBtb2RlbCBjbGFzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBheGlzTmFtZSAneCcgJ3knICdyYWRpdXMnICdhbmdsZScgJ3BhcmFsbGVsJ1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBCYXNlQXhpc01vZGVsQ2xhc3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBheGlzVHlwZURlZmF1bHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFEZWZhdWx0T3B0aW9uXVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGF4aXNOYW1lLCBCYXNlQXhpc01vZGVsQ2xhc3MsIGF4aXNUeXBlRGVmYXVsdGVyLCBleHRyYURlZmF1bHRPcHRpb24pIHtcblxuICAgICAgICB6clV0aWwuZWFjaChBWElTX1RZUEVTLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcblxuICAgICAgICAgICAgQmFzZUF4aXNNb2RlbENsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgICAgICAgICB0eXBlOiBheGlzTmFtZSArICdBeGlzLicgKyBheGlzVHlwZSxcblxuICAgICAgICAgICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoZW1lTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0F4aXMnKSk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb24udHlwZSA9IGF4aXNUeXBlRGVmYXVsdGVyKGF4aXNOYW1lLCBvcHRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb246IHpyVXRpbC5tZXJnZUFsbChcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzRGVmYXVsdFtheGlzVHlwZSArICdBeGlzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYURlZmF1bHRPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBDb21wb25lbnRNb2RlbC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoXG4gICAgICAgICAgICBheGlzTmFtZSArICdBeGlzJyxcbiAgICAgICAgICAgIHpyVXRpbC5jdXJyeShheGlzVHlwZURlZmF1bHRlciwgYXhpc05hbWUpXG4gICAgICAgICk7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n    var Axis = __webpack_require__(57);\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        /**\n         * Each item cooresponds to this.getExtent(), which\n         * means globalExtent[0] may greater than globalExtent[1],\n         * unless `asc` is input.\n         *\n         * @param {boolean} [asc]\n         * @return {Array.<number>}\n         */\n        getGlobalExtent: function (asc) {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            asc && ret[0] > ret[1] && ret.reverse();\n            return ret;\n        },\n\n        getOtherAxis: function () {\n            this.grid.getOtherAxis();\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * @override\n         */\n        pointToData: function (point, clamp) {\n            return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanM/YTk1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQXhpcyA9IHJlcXVpcmUoJy4uL0F4aXMnKTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBheGlzIDJkXG4gICAgICogQGNvbnN0cnVjdG9yIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkRcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXN9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7Kn0gc2NhbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjb29yZEV4dGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBheGlzVHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblxuICAgICAqL1xuICAgIHZhciBBeGlzMkQgPSBmdW5jdGlvbiAoZGltLCBzY2FsZSwgY29vcmRFeHRlbnQsIGF4aXNUeXBlLCBwb3NpdGlvbikge1xuICAgICAgICBBeGlzLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyB0eXBlXG4gICAgICAgICAqICAtICdjYXRlZ29yeSdcbiAgICAgICAgICogIC0gJ3ZhbHVlJ1xuICAgICAgICAgKiAgLSAndGltZSdcbiAgICAgICAgICogIC0gJ2xvZydcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IGF4aXNUeXBlIHx8ICd2YWx1ZSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgcG9zaXRpb25cbiAgICAgICAgICogIC0gJ3RvcCdcbiAgICAgICAgICogIC0gJ2JvdHRvbSdcbiAgICAgICAgICogIC0gJ2xlZnQnXG4gICAgICAgICAqICAtICdyaWdodCdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbiAgICB9O1xuXG4gICAgQXhpczJELnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQXhpczJELFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYXhpcyBpcyBvbiB0aGUgemVybyBwb3NpdGlvbiBvZiB0aGUgb3RoZXIgYXhpc1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIG9uWmVybzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgbW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IG51bGwsXG5cbiAgICAgICAgaXNIb3Jpem9udGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVhY2ggaXRlbSBjb29yZXNwb25kcyB0byB0aGlzLmdldEV4dGVudCgpLCB3aGljaFxuICAgICAgICAgKiBtZWFucyBnbG9iYWxFeHRlbnRbMF0gbWF5IGdyZWF0ZXIgdGhhbiBnbG9iYWxFeHRlbnRbMV0sXG4gICAgICAgICAqIHVubGVzcyBgYXNjYCBpcyBpbnB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbYXNjXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEdsb2JhbEV4dGVudDogZnVuY3Rpb24gKGFzYykge1xuICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICByZXRbMF0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzBdKTtcbiAgICAgICAgICAgIHJldFsxXSA9IHRoaXMudG9HbG9iYWxDb29yZChyZXRbMV0pO1xuICAgICAgICAgICAgYXNjICYmIHJldFswXSA+IHJldFsxXSAmJiByZXQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRPdGhlckF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5nZXRPdGhlckF4aXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGFiZWwgaXMgaWdub3JlZC5cbiAgICAgICAgICogQXV0b21hdGljYWxseSB1c2VkIHdoZW4gYXhpcyBpcyBjYXRlZ29yeSBhbmQgbGFiZWwgY2FuIG5vdCBiZSBhbGwgc2hvd25cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgaWR4XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0xhYmVsSWdub3JlZDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5nZXRMYWJlbEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIGxhYmVsSW50ZXJ2YWwgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICYmICFsYWJlbEludGVydmFsKGlkeCwgdGhpcy5zY2FsZS5nZXRMYWJlbChpZHgpKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgaWR4ICUgKGxhYmVsSW50ZXJ2YWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludFRvRGF0YTogZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRUb0RhdGEodGhpcy50b0xvY2FsQ29vcmQocG9pbnRbdGhpcy5kaW0gPT09ICd4JyA/IDAgOiAxXSksIGNsYW1wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmb3JtIGdsb2JhbCBjb29yZCB0byBsb2NhbCBjb29yZCxcbiAgICAgICAgICogaS5lLiB2YXIgbG9jYWxDb29yZCA9IGF4aXMudG9Mb2NhbENvb3JkKDgwKTtcbiAgICAgICAgICogZGVzaWduYXRlIGJ5IG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0b0xvY2FsQ29vcmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBnbG9iYWwgY29vcmQgdG8gbG9jYWwgY29vcmQsXG4gICAgICAgICAqIGkuZS4gdmFyIGdsb2JhbENvb3JkID0gYXhpcy50b0xvY2FsQ29vcmQoNDApO1xuICAgICAgICAgKiBkZXNpZ25hdGUgYnkgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRvR2xvYmFsQ29vcmQ6IG51bGxcblxuICAgIH07XG4gICAgenJVdGlsLmluaGVyaXRzKEF4aXMyRCwgQXhpcyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXMyRDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQXhpczJELmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = __webpack_require__(0);\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanM/ZGZhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiBAbW9kdWxlICBlY2hhcnRzL2Nvb3JkL0NhcnRlc2lhblxuICpcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBkaW1BeGlzTWFwcGVyKGRpbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ2FydGVzaWFuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fYXhlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2RpbUxpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJyc7XG4gICAgfTtcblxuICAgIENhcnRlc2lhbi5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENhcnRlc2lhbixcblxuICAgICAgICB0eXBlOiAnY2FydGVzaWFuJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGF4aXNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gZGltXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbn5BeGlzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpczogZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXNbZGltXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGF4ZXMgbGlzdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFufkF4aXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5fZGltTGlzdCwgZGltQXhpc01hcHBlciwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBheGVzIGxpc3QgYnkgZ2l2ZW4gc2NhbGUgdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhlc0J5U2NhbGU6IGZ1bmN0aW9uIChzY2FsZVR5cGUpIHtcbiAgICAgICAgICAgIHNjYWxlVHlwZSA9IHNjYWxlVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBeGVzKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBheGlzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuLkF4aXN9XG4gICAgICAgICAqL1xuICAgICAgICBhZGRBeGlzOiBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGF4aXMuZGltO1xuXG4gICAgICAgICAgICB0aGlzLl9heGVzW2RpbV0gPSBheGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9kaW1MaXN0LnB1c2goZGltKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBkYXRhIHRvIGNvb3JkIGluIG5kIHNwYWNlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFUb0Nvb3JkOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdkYXRhVG9Db29yZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGNvb3JkIGluIG5kIHNwYWNlIHRvIGRhdGFcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdjb29yZFRvRGF0YScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXRhQ29vcmRDb252ZXJ0OiBmdW5jdGlvbiAoaW5wdXQsIG1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIGRpbUxpc3QgPSB0aGlzLl9kaW1MaXN0O1xuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBkaW1MaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy5fYXhlc1tkaW1dO1xuXG4gICAgICAgICAgICAgICAgb3V0cHV0W2RpbV0gPSBheGlzW21ldGhvZF0oaW5wdXRbZGltXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbi5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var Cartesian = __webpack_require__(160);\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qcz9lYzgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6IjE2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBDYXJ0ZXNpYW4gPSByZXF1aXJlKCcuL0NhcnRlc2lhbicpO1xuXG4gICAgZnVuY3Rpb24gQ2FydGVzaWFuMkQobmFtZSkge1xuXG4gICAgICAgIENhcnRlc2lhbi5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIH1cblxuICAgIENhcnRlc2lhbjJELnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2FydGVzaWFuMkQsXG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbjJkJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGRpbWVuc2lvbnM6IFsneCcsICd5J10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2UgYXhpcyB3aWxsIGJlIHVzZWQgb24gc3RhY2tpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ3RpbWUnKVswXVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjb250YWluIHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgdmFyIGF4aXNYID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgICAgICAgICB2YXIgYXhpc1kgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICAgICAgICAgIHJldHVybiBheGlzWC5jb250YWluKGF4aXNYLnRvTG9jYWxDb29yZChwb2ludFswXSkpXG4gICAgICAgICAgICAgICAgJiYgYXhpc1kuY29udGFpbihheGlzWS50b0xvY2FsQ29vcmQocG9pbnRbMV0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgY29udGFpbiBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5EYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhpcygneCcpLmNvbnRhaW5EYXRhKGRhdGFbMF0pXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5nZXRBeGlzKCd5JykuY29udGFpbkRhdGEoZGF0YVsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgc2VyaWVzIGRhdGEgdG8gYW4gYXJyYXkgb2YgcG9pbnRzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqICBSZXR1cm4gYXJyYXkgb2YgcG9pbnRzLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICogIGBbWzEwLCAxMF0sIFsyMCwgMjBdLCBbMzAsIDMwXV1gXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Qb2ludHM6IGZ1bmN0aW9uIChkYXRhLCBzdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwQXJyYXkoWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVG9Qb2ludChbeCwgeV0pO1xuICAgICAgICAgICAgfSwgc3RhY2ssIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFUb1BvaW50OiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICAgICAgICAgIHZhciB4QXhpcyA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgdmFyIHlBeGlzID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHhBeGlzLnRvR2xvYmFsQ29vcmQoeEF4aXMuZGF0YVRvQ29vcmQoZGF0YVswXSwgY2xhbXApKSxcbiAgICAgICAgICAgICAgICB5QXhpcy50b0dsb2JhbENvb3JkKHlBeGlzLmRhdGFUb0Nvb3JkKGRhdGFbMV0sIGNsYW1wKSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB4QXhpcy5jb29yZFRvRGF0YSh4QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMF0pLCBjbGFtcCksXG4gICAgICAgICAgICAgICAgeUF4aXMuY29vcmRUb0RhdGEoeUF4aXMudG9Mb2NhbENvb3JkKHBvaW50WzFdKSwgY2xhbXApXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgb3RoZXIgYXhpc1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9IGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIGdldE90aGVyQXhpczogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4aXMoYXhpcy5kaW0gPT09ICd4JyA/ICd5JyA6ICd4Jyk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoQ2FydGVzaWFuMkQsIENhcnRlc2lhbik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENhcnRlc2lhbjJEO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\n\n\n    __webpack_require__(59);\n\n    var ComponentModel = __webpack_require__(13);\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanM/NDYzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQyx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMTYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gR3JpZCDmmK/lnKjmnInnm7Top5LlnZDmoIfns7vnmoTml7blgJnlv4XpobvopoHlrZjlnKjnmoRcbi8vIOaJgOS7pei/memHjOS5n+imgeiiqyBDYXJ0ZXNpYW4yRCDkvp3otZZcblxuXG4gICAgcmVxdWlyZSgnLi9BeGlzTW9kZWwnKTtcblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL0NvbXBvbmVudCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdncmlkJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsneEF4aXMnLCAneUF4aXMnXSxcblxuICAgICAgICBsYXlvdXRNb2RlOiAnYm94JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkfVxuICAgICAgICAgKi9cbiAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogbnVsbCxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICBsZWZ0OiAnMTAlJyxcbiAgICAgICAgICAgIHRvcDogNjAsXG4gICAgICAgICAgICByaWdodDogJzEwJScsXG4gICAgICAgICAgICBib3R0b206IDYwLFxuICAgICAgICAgICAgLy8gSWYgZ3JpZCBzaXplIGNvbnRhaW4gbGFiZWxcbiAgICAgICAgICAgIGNvbnRhaW5MYWJlbDogZmFsc2UsXG4gICAgICAgICAgICAvLyB3aWR0aDoge3RvdGFsV2lkdGh9IC0gbGVmdCAtIHJpZ2h0LFxuICAgICAgICAgICAgLy8gaGVpZ2h0OiB7dG90YWxIZWlnaHR9IC0gdG9wIC0gYm90dG9tLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2NjYydcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var createListFromArray = __webpack_require__(32);\n    var symbolUtil = __webpack_require__(38);\n    var axisHelper = __webpack_require__(17);\n    var axisModelCommonMixin = __webpack_require__(58);\n    var Model = __webpack_require__(9);\n    var util = __webpack_require__(0);\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: __webpack_require__(62),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2hlbHBlci5qcz9hYTJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgY3JlYXRlTGlzdEZyb21BcnJheSA9IHJlcXVpcmUoJy4vY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXknKTtcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9zeW1ib2wnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4vY29vcmQvYXhpc0hlbHBlcicpO1xuICAgIHZhciBheGlzTW9kZWxDb21tb25NaXhpbiA9IHJlcXVpcmUoJy4vY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4nKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbXV0aSBkaW1lbnNpb24gTGlzdCBzdHJ1Y3R1cmUgZnJvbSBzZXJpZXNNb2RlbC5cbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHNlcmllc01vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTGlzdDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldCgnZGF0YScpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkoZGF0YSwgc2VyaWVzTW9kZWwsIHNlcmllc01vZGVsLmVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gICAgICAgICAqL1xuICAgICAgICBjb21wbGV0ZURpbWVuc2lvbnM6IHJlcXVpcmUoJy4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly9lY2hhcnRzLmJhaWR1LmNvbS9vcHRpb24uaHRtbCNzZXJpZXMtc2NhdHRlci5zeW1ib2xcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbERlc2NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTeW1ib2w6IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6ZWNoYXJ0cy9Nb2RlbH0gb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTY2FsZTogZnVuY3Rpb24gKGRhdGFFeHRlbnQsIG9wdGlvbikge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IG9wdGlvbjtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbiBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgICAgICAgICAgIGF4aXNNb2RlbCA9IG5ldyBNb2RlbChvcHRpb24pO1xuICAgICAgICAgICAgICAgIHV0aWwubWl4aW4oYXhpc01vZGVsLCBheGlzTW9kZWxDb21tb25NaXhpbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGF4aXNIZWxwZXIuY3JlYXRlU2NhbGVCeU1vZGVsKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoZGF0YUV4dGVudFswXSwgZGF0YUV4dGVudFsxXSk7XG5cbiAgICAgICAgICAgIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50KHNjYWxlLCBheGlzTW9kZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaXhpbiBjb21tb24gbWV0aG9kcyB0byBheGlzIG1vZGVsLFxuICAgICAgICAgKlxuICAgICAgICAgKiBJbmxjdWRlIG1ldGhvZHNcbiAgICAgICAgICogYGdldEZvcm1hdHRlZExhYmVscygpID0+IEFycmF5LjxzdHJpbmc+YFxuICAgICAgICAgKiBgZ2V0Q2F0ZWdvcmllcygpID0+IEFycmF5LjxzdHJpbmc+YFxuICAgICAgICAgKiBgZ2V0TWluKG9yaWdpbjogYm9vbGVhbikgPT4gbnVtYmVyYFxuICAgICAgICAgKiBgZ2V0TWF4KG9yaWdpbjogYm9vbGVhbikgPT4gbnVtYmVyYFxuICAgICAgICAgKiBgZ2V0TmVlZENyb3NzWmVybygpID0+IGJvb2xlYW5gXG4gICAgICAgICAqIGBzZXRSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcilgXG4gICAgICAgICAqIGByZXNldFJhbmdlKClgXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbkF4aXNNb2RlbENvbW1vbk1ldGhvZHM6IGZ1bmN0aW9uIChNb2RlbCkge1xuICAgICAgICAgICAgdXRpbC5taXhpbihNb2RlbCwgYXhpc01vZGVsQ29tbW9uTWl4aW4pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n    var numberUtil = __webpack_require__(5);\n    var parsePercent = numberUtil.parsePercent;\n\n    var STACK_PREFIX = '__ec_stack_';\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    /**\n     * @param {Object} opt\n     * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n     * @param {number} opt.count Positive interger.\n     * @param {number} [opt.barWidth]\n     * @param {number} [opt.barMaxWidth]\n     * @param {number} [opt.barGap]\n     * @param {number} [opt.barCategoryGap]\n     * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n     */\n    function getLayoutOnAxis(opt, api) {\n        var params = [];\n        var baseAxis = opt.axis;\n        var axisKey = 'axis0';\n\n        if (baseAxis.type !== 'category') {\n            return;\n        }\n        var bandWidth = baseAxis.getBandWidth();\n\n        for (var i = 0; i < opt.count || 0; i++) {\n            params.push(zrUtil.defaults({\n                bandWidth: bandWidth,\n                axisKey: axisKey,\n                stackId: STACK_PREFIX + i\n            }, opt));\n        }\n        var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n\n        var result = [];\n        for (var i = 0; i < opt.count; i++) {\n            var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n            item.offsetCenter = item.offset + item.width / 2;\n            result.push(item);\n        }\n\n        return result;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            return {\n                bandWidth: bandWidth,\n                barWidth: barWidth,\n                barMaxWidth: barMaxWidth,\n                barGap: barGap,\n                barCategoryGap: barCategoryGap,\n                axisKey: getAxisKey(baseAxis),\n                stackId: getSeriesStackId(seriesModel)\n            };\n        });\n\n        return doCalBarWidthAndOffset(seriesInfoList, api);\n    }\n\n    function doCalBarWidthAndOffset(seriesInfoList, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n            var axisKey = seriesInfo.axisKey;\n            var bandWidth = seriesInfo.bandWidth;\n            var columnsOnAxis = columnsMap[axisKey] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[axisKey] = columnsOnAxis;\n\n            var stackId = seriesInfo.stackId;\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            var barWidth = seriesInfo.barWidth;\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            var barMaxWidth = seriesInfo.barMaxWidth;\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            var barGap = seriesInfo.barGap;\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            var barCategoryGap = seriesInfo.barCategoryGap;\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    if (column.width) {\n                        maxWidth = Math.min(maxWidth, column.width);\n                    }\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            // Check series coordinate, do layout for cartesian2d only\n            if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    barLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\n\n    module.exports = barLayoutGrid;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2xheW91dC9iYXJHcmlkLmpzPzNiZTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU8sRUFBRSw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLDRCQUE0QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWIsU0FBUztBQUNUOztBQUVBOztBQUVBIiwiZmlsZSI6IjE2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG5cbiAgICB2YXIgU1RBQ0tfUFJFRklYID0gJ19fZWNfc3RhY2tfJztcblxuICAgIGZ1bmN0aW9uIGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldCgnc3RhY2snKSB8fCBTVEFDS19QUkVGSVggKyBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzS2V5KGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXMuZGltICsgYXhpcy5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBvcHQuYXhpcyBPbmx5IHN1cHBvcnQgY2F0ZWdvcnkgYXhpcyBjdXJyZW50bHkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdC5jb3VudCBQb3NpdGl2ZSBpbnRlcmdlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJXaWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJNYXhXaWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5iYXJHYXBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuYmFyQ2F0ZWdvcnlHYXBdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGgsIG9mZnNldCwgb2Zmc2V0Q2VudGVyfSBJZiBheGlzLnR5cGUgaXMgbm90ICdjYXRlZ29yeScsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TGF5b3V0T25BeGlzKG9wdCwgYXBpKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gb3B0LmF4aXM7XG4gICAgICAgIHZhciBheGlzS2V5ID0gJ2F4aXMwJztcblxuICAgICAgICBpZiAoYmFzZUF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy5nZXRCYW5kV2lkdGgoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5jb3VudCB8fCAwOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgYXhpc0tleTogYXhpc0tleSxcbiAgICAgICAgICAgICAgICBzdGFja0lkOiBTVEFDS19QUkVGSVggKyBpXG4gICAgICAgICAgICB9LCBvcHQpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGhBbmRPZmZzZXRzID0gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChwYXJhbXMsIGFwaSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdC5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHdpZHRoQW5kT2Zmc2V0c1theGlzS2V5XVtTVEFDS19QUkVGSVggKyBpXTtcbiAgICAgICAgICAgIGl0ZW0ub2Zmc2V0Q2VudGVyID0gaXRlbS5vZmZzZXQgKyBpdGVtLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxCYXJXaWR0aEFuZE9mZnNldChiYXJTZXJpZXMsIGFwaSkge1xuICAgICAgICB2YXIgc2VyaWVzSW5mb0xpc3QgPSB6clV0aWwubWFwKGJhclNlcmllcywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeSdcbiAgICAgICAgICAgICAgICA/IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpXG4gICAgICAgICAgICAgICAgOiAoTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pIC8gZGF0YS5jb3VudCgpKTtcblxuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyV2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhck1heFdpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyTWF4V2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhckdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyR2FwJyk7XG4gICAgICAgICAgICB2YXIgYmFyQ2F0ZWdvcnlHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckNhdGVnb3J5R2FwJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGJhck1heFdpZHRoOiBiYXJNYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBiYXJHYXA6IGJhckdhcCxcbiAgICAgICAgICAgICAgICBiYXJDYXRlZ29yeUdhcDogYmFyQ2F0ZWdvcnlHYXAsXG4gICAgICAgICAgICAgICAgYXhpc0tleTogZ2V0QXhpc0tleShiYXNlQXhpcyksXG4gICAgICAgICAgICAgICAgc3RhY2tJZDogZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkb0NhbEJhcldpZHRoQW5kT2Zmc2V0KHNlcmllc0luZm9MaXN0LCBhcGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2FsQmFyV2lkdGhBbmRPZmZzZXQoc2VyaWVzSW5mb0xpc3QsIGFwaSkge1xuICAgICAgICAvLyBDb2x1bW5zIGluZm8gb24gZWFjaCBjYXRlZ29yeSBheGlzLiBLZXkgaXMgY2FydGVzaWFuIG5hbWVcbiAgICAgICAgdmFyIGNvbHVtbnNNYXAgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChzZXJpZXNJbmZvTGlzdCwgZnVuY3Rpb24gKHNlcmllc0luZm8sIGlkeCkge1xuICAgICAgICAgICAgdmFyIGF4aXNLZXkgPSBzZXJpZXNJbmZvLmF4aXNLZXk7XG4gICAgICAgICAgICB2YXIgYmFuZFdpZHRoID0gc2VyaWVzSW5mby5iYW5kV2lkdGg7XG4gICAgICAgICAgICB2YXIgY29sdW1uc09uQXhpcyA9IGNvbHVtbnNNYXBbYXhpc0tleV0gfHwge1xuICAgICAgICAgICAgICAgIGJhbmRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgICAgICAgICAgIHJlbWFpbmVkV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgICAgICAgICAgICBhdXRvV2lkdGhDb3VudDogMCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUdhcDogJzIwJScsXG4gICAgICAgICAgICAgICAgZ2FwOiAnMzAlJyxcbiAgICAgICAgICAgICAgICBzdGFja3M6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN0YWNrcyA9IGNvbHVtbnNPbkF4aXMuc3RhY2tzO1xuICAgICAgICAgICAgY29sdW1uc01hcFtheGlzS2V5XSA9IGNvbHVtbnNPbkF4aXM7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gc2VyaWVzSW5mby5zdGFja0lkO1xuXG4gICAgICAgICAgICBpZiAoIXN0YWNrc1tzdGFja0lkXSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrc1tzdGFja0lkXSA9IHN0YWNrc1tzdGFja0lkXSB8fCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENhdXRpb246IEluIGEgc2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtLCB0aGVzZSBiYXJHcmlkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgc2hhcmVkIGJ5IHNlcmllcy4gQ29uc2lkZXIgdGhhdCB0aGV5IGhhdmUgZGVmYXVsdCB2YWx1ZXMsXG4gICAgICAgICAgICAvLyBvbmx5IHRoZSBhdHRyaWJ1dGVzIHNldCBvbiB0aGUgbGFzdCBzZXJpZXMgd2lsbCB3b3JrLlxuICAgICAgICAgICAgLy8gRG8gbm90IGNoYW5nZSB0aGlzIGZhY3QgdW5sZXNzIHRoZXJlIHdpbGwgYmUgYSBicmVhayBjaGFuZ2UuXG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIHZhciBiYXJXaWR0aCA9IHNlcmllc0luZm8uYmFyV2lkdGg7XG4gICAgICAgICAgICBpZiAoYmFyV2lkdGggJiYgIXN0YWNrc1tzdGFja0lkXS53aWR0aCkge1xuICAgICAgICAgICAgICAgIGJhcldpZHRoID0gTWF0aC5taW4oY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoLCBiYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgc3RhY2tzW3N0YWNrSWRdLndpZHRoID0gYmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoIC09IGJhcldpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmFyTWF4V2lkdGggPSBzZXJpZXNJbmZvLmJhck1heFdpZHRoO1xuICAgICAgICAgICAgYmFyTWF4V2lkdGggJiYgKHN0YWNrc1tzdGFja0lkXS5tYXhXaWR0aCA9IGJhck1heFdpZHRoKTtcbiAgICAgICAgICAgIHZhciBiYXJHYXAgPSBzZXJpZXNJbmZvLmJhckdhcDtcbiAgICAgICAgICAgIChiYXJHYXAgIT0gbnVsbCkgJiYgKGNvbHVtbnNPbkF4aXMuZ2FwID0gYmFyR2FwKTtcbiAgICAgICAgICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc0luZm8uYmFyQ2F0ZWdvcnlHYXA7XG4gICAgICAgICAgICAoYmFyQ2F0ZWdvcnlHYXAgIT0gbnVsbCkgJiYgKGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAgPSBiYXJDYXRlZ29yeUdhcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdFtjb29yZFN5c05hbWVdID0ge307XG5cbiAgICAgICAgICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICAgICAgICAgIHZhciBiYW5kV2lkdGggPSBjb2x1bW5zT25BeGlzLmJhbmRXaWR0aDtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgICAgICAgICAgdmFyIGJhckdhcFBlcmNlbnQgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5nYXAsIDEpO1xuXG4gICAgICAgICAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhdXRvV2lkdGhDb3VudCA9IGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQ7XG4gICAgICAgICAgICB2YXIgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcClcbiAgICAgICAgICAgICAgICAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChtYXhXaWR0aCAmJiBtYXhXaWR0aCA8IGF1dG9XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCByZW1haW5lZFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgY29sdW1uLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW5cbiAgICAgICAgICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApXG4gICAgICAgICAgICAgICAgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgICAgICAgICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoU3VtID0gMDtcbiAgICAgICAgICAgIHZhciBsYXN0Q29sdW1uO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgd2lkdGhTdW0gKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzVHlwZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhckxheW91dEdyaWQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGJhcldpZHRoQW5kT2Zmc2V0ID0gY2FsQmFyV2lkdGhBbmRPZmZzZXQoXG4gICAgICAgICAgICB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSA9PT0gJ2NhcnRlc2lhbjJkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGxhc3RTdGFja0Nvb3JkcyA9IHt9O1xuICAgICAgICB2YXIgbGFzdFN0YWNrQ29vcmRzT3JpZ2luID0ge307XG5cbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBzZXJpZXMgY29vcmRpbmF0ZSwgZG8gbGF5b3V0IGZvciBjYXJ0ZXNpYW4yZCBvbmx5XG4gICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGF5b3V0SW5mbyA9IGJhcldpZHRoQW5kT2Zmc2V0W2dldEF4aXNLZXkoYmFzZUF4aXMpXVtzdGFja0lkXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5PZmZzZXQgPSBjb2x1bW5MYXlvdXRJbmZvLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgICAgICAgICB2YXIgdmFsdWVBeGlzID0gY2FydGVzaWFuLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG5cbiAgICAgICAgICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXNTdGFydCA9IGJhc2VBeGlzLm9uWmVyb1xuICAgICAgICAgICAgICAgID8gdmFsdWVBeGlzLnRvR2xvYmFsQ29vcmQodmFsdWVBeGlzLmRhdGFUb0Nvb3JkKDApKVxuICAgICAgICAgICAgICAgIDogdmFsdWVBeGlzLmdldEdsb2JhbEV4dGVudCgpWzBdO1xuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gY2FydGVzaWFuLmRhdGFUb1BvaW50cyhkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSB8fCBbXTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSB8fCBbXTsgLy8gRml4ICM0MjQzXG5cbiAgICAgICAgICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgICAgICAgICAgICBzaXplOiBjb2x1bW5XaWR0aFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEuZWFjaCh2YWx1ZUF4aXMuZGltLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCwgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHZhbHVlQXhpc1N0YXJ0ICAvLyBOZWdhdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHZhbHVlQXhpc1N0YXJ0LCAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgbjogdmFsdWVBeGlzU3RhcnQgIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gdmFsdWUgPj0gMCA/ICdwJyA6ICduJztcbiAgICAgICAgICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENvb3JkID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF1bc2lnbl07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDb29yZE9yaWdpbiA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dO1xuICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlQXhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB5ID0gY29vcmRbMV0gKyBjb2x1bW5PZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY29vcmRbMF0gLSBsYXN0Q29vcmRPcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbHVtbldpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMod2lkdGgpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNvb3JkWzBdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB5ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb29yZFsxXSAtIGxhc3RDb29yZE9yaWdpbjtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XVtzaWduXSArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHplcm8gdG8gaGFzIGEgcG9zaXRpdmUgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0IDw9IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGJhckxheW91dEdyaWQuZ2V0TGF5b3V0T25BeGlzID0gZ2V0TGF5b3V0T25BeGlzO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYXJMYXlvdXRHcmlkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2xheW91dC9iYXJHcmlkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 165 */
/***/ (function(module, exports) {

eval("\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (!coordSys) {\n                return;\n            }\n\n            var dims = [];\n            var coordDims = coordSys.dimensions;\n            for (var i = 0; i < coordDims.length; i++) {\n                dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);\n            }\n\n            if (dims.length === 1) {\n                data.each(dims[0], function (x, idx) {\n                    // Also {Array.<number>}, not undefined to avoid if...else... statement\n                    data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                });\n            }\n            else if (dims.length === 2) {\n                data.each(dims, function (x, y, idx) {\n                    // Also {Array.<number>}, not undefined to avoid if...else... statement\n                    data.setItemLayout(\n                        idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                    );\n                }, true);\n            }\n        });\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2xheW91dC9wb2ludHMuanM/NWQzYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QiLCJmaWxlIjoiMTY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICAgICAgaWYgKCFjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpbXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb29yZERpbXMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZERpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaW1zLnB1c2goc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oY29vcmRTeXMuZGltZW5zaW9uc1tpXSlbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2goZGltc1swXSwgZnVuY3Rpb24gKHgsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIHtBcnJheS48bnVtYmVyPn0sIG5vdCB1bmRlZmluZWQgdG8gYXZvaWQgaWYuLi5lbHNlLi4uIHN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBpc05hTih4KSA/IFtOYU4sIE5hTl0gOiBjb29yZFN5cy5kYXRhVG9Qb2ludCh4KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGRhdGEuZWFjaChkaW1zLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCwgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSA/IFtOYU4sIE5hTl0gOiBjb29yZFN5cy5kYXRhVG9Qb2ludChbeCwgeV0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL2xvYWRpbmcvZGVmYXVsdC5qcz80ZjEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbG9yXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50ZXh0Q29sb3JdXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcGksIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XG4gICAgICAgICAgICB0ZXh0OiAnbG9hZGluZycsXG4gICAgICAgICAgICBjb2xvcjogJyNjMjM1MzEnLFxuICAgICAgICAgICAgdGV4dENvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICBtYXNrQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCknLFxuICAgICAgICAgICAgemxldmVsOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWFzayA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHRzLm1hc2tDb2xvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgICAgICAgICB6OiAxMDAwMFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFyYyA9IG5ldyBncmFwaGljLkFyYyh7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IC1QSSAvIDIsXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IC1QSSAvIDIgKyAwLjEsXG4gICAgICAgICAgICAgICAgcjogMTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogb3B0cy5jb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lQ2FwOiAncm91bmQnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgICAgICAgICB6OiAxMDAwMVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhYmVsUmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgdGV4dDogb3B0cy50ZXh0LFxuICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IDEwLFxuICAgICAgICAgICAgICAgIHRleHRGaWxsOiBvcHRzLnRleHRDb2xvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgICAgICAgICB6OiAxMDAwMVxuICAgICAgICB9KTtcblxuICAgICAgICBhcmMuYW5pbWF0ZVNoYXBlKHRydWUpXG4gICAgICAgICAgICAud2hlbigxMDAwLCB7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IFBJICogMyAvIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhcnQoJ2NpcmN1bGFySW5PdXQnKTtcbiAgICAgICAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKVxuICAgICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IFBJICogMyAvIDJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVsYXkoMzAwKVxuICAgICAgICAgICAgLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgICAgZ3JvdXAuYWRkKGFyYyk7XG4gICAgICAgIGdyb3VwLmFkZChsYWJlbFJlY3QpO1xuICAgICAgICBncm91cC5hZGQobWFzayk7XG4gICAgICAgIC8vIEluamVjdCByZXNpemVcbiAgICAgICAgZ3JvdXAucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN4ID0gYXBpLmdldFdpZHRoKCkgLyAyO1xuICAgICAgICAgICAgdmFyIGN5ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcbiAgICAgICAgICAgIGFyYy5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgIGN5OiBjeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgciA9IGFyYy5zaGFwZS5yO1xuICAgICAgICAgICAgbGFiZWxSZWN0LnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICB4OiBjeCAtIHIsXG4gICAgICAgICAgICAgICAgeTogY3kgLSByLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByICogMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHIgKiAyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFzay5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGdyb3VwLnJlc2l6ZSgpO1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n    var Model = __webpack_require__(9);\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = __webpack_require__(13);\n\n    var globalDefault = __webpack_require__(169);\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            // 如果不存在对应的 component model 则直接 merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION 同步是否要改回原来的\n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, __webpack_require__(63));\n\n    module.exports = GlobalModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL0dsb2JhbC5qcz8wZGQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixzQkFBc0I7QUFDekMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQ7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPLHlCQUF5Qix5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGdCQUFnQiw4QkFBOEIsbUJBQW1CO0FBQ2pFLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsZ0JBQWdCLDRDQUE0QyxtQkFBbUI7QUFDL0Usd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvREFBb0QsV0FBVzs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGdCQUFnQixPQUFPLE9BQU8sT0FBTyxlQUFlLGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMTY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFQ2hhcnRzIGdsb2JhbCBtb2RlbFxuICpcbiAqIEBtb2R1bGUge2VjaGFydHMvbW9kZWwvR2xvYmFsfVxuICovXG5cblxuXG4gICAgLyoqXG4gICAgICogQ2F1dGlvbjogSWYgdGhlIG1lY2hhbmlzbSBzaG91bGQgYmUgY2hhbmdlZCBzb21lIGRheSwgdGhlc2UgY2FzZXNcbiAgICAgKiBzaG91bGQgYmUgY29uc2lkZXJlZDpcbiAgICAgKlxuICAgICAqICgxKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiB1c2luZyB0aGUgc2FtZSBvcHRpb24gdG8gY2FsbCBgc2V0T3B0aW9uYFxuICAgICAqIG1hbnkgdGltZXMsIHRoZSByZXN1bHQgc2hvdWxkIGJlIHRoZSBzYW1lICh0cnkgb3VyIGJlc3QgdG8gZW5zdXJlIHRoYXQpLlxuICAgICAqICgyKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiBhIGNvbXBvbmVudCBoYXMgbm8gaWQvbmFtZSBzcGVjaWZpZWQsIGl0XG4gICAgICogd2lsbCBiZSBtZXJnZWQgYnkgaW5kZXgsIGFuZCB0aGUgcmVzdWx0IHNlcXVlbmNlIG9mIHRoZSBjb21wb25lbnRzIGlzXG4gICAgICogY29uc2lzdGVudCB0byB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXG4gICAgICogKDMpIGByZXNldGAgZmVhdHVyZSAoaW4gdG9vbGJveCkuIEZpbmQgZGV0YWlsZWQgaW5mbyBpbiBjb21tZW50cyBhYm91dFxuICAgICAqIGBtZXJnZU9wdGlvbmAgaW4gbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlci5cbiAgICAgKi9cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBmaWx0ZXIgPSB6clV0aWwuZmlsdGVyO1xuICAgIHZhciBtYXAgPSB6clV0aWwubWFwO1xuICAgIHZhciBpc0FycmF5ID0genJVdGlsLmlzQXJyYXk7XG4gICAgdmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbiAgICB2YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG5cbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xuXG4gICAgdmFyIGdsb2JhbERlZmF1bHQgPSByZXF1aXJlKCcuL2dsb2JhbERlZmF1bHQnKTtcblxuICAgIHZhciBPUFRJT05fSU5ORVJfS0VZID0gJ1xcMF9lY19pbm5lcic7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gcGFyZW50TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhlbWVcbiAgICAgKi9cbiAgICB2YXIgR2xvYmFsTW9kZWwgPSBNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHbG9iYWxNb2RlbCxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoZW1lID0gdGhlbWUgfHwge307XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9uID0gbnVsbDsgLy8gTWFyayBhcyBub3QgaW5pdGlhbGl6ZWQuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fdGhlbWUgPSBuZXcgTW9kZWwodGhlbWUpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYW5hZ2VyID0gb3B0aW9uTWFuYWdlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICEoT1BUSU9OX0lOTkVSX0tFWSBpbiBvcHRpb24pLFxuICAgICAgICAgICAgICAgICdwbGVhc2UgdXNlIGNoYXJ0LmdldE9wdGlvbigpJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFuYWdlci5zZXRPcHRpb24ob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVzZXRPcHRpb24obnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIG51bGwvdW5kZWZpbmVkOiByZXNldCBhbGwuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICdyZWNyZWF0ZSc6IGZvcmNlIHJlY3JlYXRlIGFsbC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ3RpbWVsaW5lJzogb25seSByZXNldCB0aW1lbGluZSBvcHRpb25cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ21lZGlhJzogb25seSByZXNldCBtZWRpYSBxdWVyeSBvcHRpb25cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvcHRpb24gY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0T3B0aW9uOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBvcHRpb25NYW5hZ2VyID0gdGhpcy5fb3B0aW9uTWFuYWdlcjtcblxuICAgICAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIubW91bnRPcHRpb24odHlwZSA9PT0gJ3JlY3JlYXRlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdEJhc2UuY2FsbCh0aGlzLCBiYXNlT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihiYXNlT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGltZWxpbmUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICd0aW1lbGluZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVPcHRpb24gPSBvcHRpb25NYW5hZ2VyLmdldFRpbWVsaW5lT3B0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9uICYmICh0aGlzLm1lcmdlT3B0aW9uKHRpbWVsaW5lT3B0aW9uKSwgb3B0aW9uQ2hhbmdlZCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJyB8fCB0eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhT3B0aW9ucyA9IG9wdGlvbk1hbmFnZXIuZ2V0TWVkaWFPcHRpb24odGhpcywgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKG1lZGlhT3B0aW9ucywgZnVuY3Rpb24gKG1lZGlhT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKG1lZGlhT3B0aW9uLCBvcHRpb25DaGFuZ2VkID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbkNoYW5nZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG4gICAgICAgICAgICB2YXIgbmV3Q3B0VHlwZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8g5aaC5p6c5LiN5a2Y5Zyo5a+55bqU55qEIGNvbXBvbmVudCBtb2RlbCDliJnnm7TmjqUgbWVyZ2VcbiAgICAgICAgICAgIGVhY2gobmV3T3B0aW9uLCBmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9uLCBtYWluVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRPcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXSA9IG9wdGlvblttYWluVHlwZV0gPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB6clV0aWwuY2xvbmUoY29tcG9uZW50T3B0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB6clV0aWwubWVyZ2Uob3B0aW9uW21haW5UeXBlXSwgY29tcG9uZW50T3B0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NwdFR5cGVzLnB1c2gobWFpblR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBPUFRJT04g5ZCM5q2l5piv5ZCm6KaB5pS55Zue5Y6f5p2l55qEXG4gICAgICAgICAgICBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbChcbiAgICAgICAgICAgICAgICBuZXdDcHRUeXBlcywgQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMoKSwgdmlzaXRDb21wb25lbnQsIHRoaXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSB0aGlzLl9zZXJpZXNJbmRpY2VzIHx8IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB2aXNpdENvbXBvbmVudChtYWluVHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NwdE9wdGlvbkxpc3QgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShuZXdPcHRpb25bbWFpblR5cGVdKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwLmdldChtYWluVHlwZSksIG5ld0NwdE9wdGlvbkxpc3RcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgbW9kZWxVdGlsLm1ha2VJZEFuZE5hbWUobWFwUmVzdWx0KTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBtYWluVHlwZSBhbmQgY29tcGxldGUgc3ViVHlwZS5cbiAgICAgICAgICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ua2V5SW5mby5tYWluVHlwZSA9IG1haW5UeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5rZXlJbmZvLnN1YlR5cGUgPSBkZXRlcm1pbmVTdWJUeXBlKG1haW5UeXBlLCBvcHQsIGl0ZW0uZXhpc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW50TW9kZWxzID0gZ2V0Q29tcG9uZW50c0J5VHlwZXMoXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNNYXAsIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gW107XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c01hcC5zZXQobWFpblR5cGUsIFtdKTtcblxuICAgICAgICAgICAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gcmVzdWx0SXRlbS5leGlzdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NwdE9wdGlvbiA9IHJlc3VsdEl0ZW0ub3B0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBpc09iamVjdChuZXdDcHRPcHRpb24pIHx8IGNvbXBvbmVudE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VtcHR5IGNvbXBvbmVudCBkZWZpbml0aW9uJ1xuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHdoZXJlIGlzIG5vIG5ldyBvcHRpb24gYW5kIHNob3VsZCBiZSBtZXJnZWQgdXNpbmcge30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZSByZW1vdmVFZGdlQW5kQWRkIGluIHRvcG9sb2dpY2FsVHJhdmVsIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdDcHRPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm1lcmdlT3B0aW9uKHt9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQoe30sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDb21wb25lbnRNb2RlbENsYXNzID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpblR5cGUsIHJlc3VsdEl0ZW0ua2V5SW5mby5zdWJUeXBlLCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50TW9kZWwgJiYgY29tcG9uZW50TW9kZWwgaW5zdGFuY2VvZiBDb21wb25lbnRNb2RlbENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubmFtZSA9IHJlc3VsdEl0ZW0ua2V5SW5mby5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm1lcmdlT3B0aW9uKG5ld0NwdE9wdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZChuZXdDcHRPcHRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgR2xvYmFsIGFzIHBhcmVudCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJhT3B0ID0genJVdGlsLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW50TW9kZWxzOiBkZXBlbmRlbnRNb2RlbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0SXRlbS5rZXlJbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbCA9IG5ldyBDb21wb25lbnRNb2RlbENsYXNzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDcHRPcHRpb24sIHRoaXMsIHRoaXMsIGV4dHJhT3B0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuZXh0ZW5kKGNvbXBvbmVudE1vZGVsLCBleHRyYU9wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwuaW5pdChuZXdDcHRPcHRpb24sIHRoaXMsIHRoaXMsIGV4dHJhT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIG9wdGlvblVwZGF0ZWQgYWZ0ZXIgaW5pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXdDcHRPcHRpb24gaGFzIGJlZW4gdXNlZCBhcyBjb21wb25lbnRNb2RlbC5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWF5IGJlIG1lcmdlZCB3aXRoIHRoZW1lIGFuZCBkZWZhdWx0LCBzbyBwYXNzIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBjb25mdXNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZChudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKVtpbmRleF0gPSBjb21wb25lbnRNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXVtpbmRleF0gPSBjb21wb25lbnRNb2RlbC5vcHRpb247XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBCYWNrdXAgc2VyaWVzIGZvciBmaWx0ZXJpbmcuXG4gICAgICAgICAgICAgICAgaWYgKG1haW5UeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gY3JlYXRlU2VyaWVzSW5kaWNlcyhjb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG9wdGlvbiBmb3Igb3V0cHV0IChjbG9uZWQgb3B0aW9uIGFuZCBpbm5lciBpbmZvIHJlbW92ZWQpXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0T3B0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0genJVdGlsLmNsb25lKHRoaXMub3B0aW9uKTtcblxuICAgICAgICAgICAgZWFjaChvcHRpb24sIGZ1bmN0aW9uIChvcHRzLCBtYWluVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9wdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvcHRpb25zIHdpdGggaW5uZXIgaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzSWRJbm5lcihvcHRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBvcHRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uW09QVElPTl9JTk5FUl9LRVldO1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRoZW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2lkeD0wXVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIChtYWluVHlwZSwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcbiAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaWR4IHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBub25lIG9mIGluZGV4IGFuZCBpZCBhbmQgbmFtZSB1c2VkLCByZXR1cm4gYWxsIGNvbXBvbmVudHMgd2l0aCBtYWluVHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZGl0aW9uLm1haW5UeXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZGl0aW9uLnN1YlR5cGVdIElmIGlnbm9yZSwgb25seSBxdWVyeSBieSBtYWluVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW2NvbmRpdGlvbi5pbmRleF0gRWl0aGVyIGlucHV0IGluZGV4IG9yIGlkIG9yIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbY29uZGl0aW9uLmlkXSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtjb25kaXRpb24ubmFtZV0gRWl0aGVyIGlucHV0IGluZGV4IG9yIGlkIG9yIG5hbWUuXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlDb21wb25lbnRzOiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWFpblR5cGUgPSBjb25kaXRpb24ubWFpblR5cGU7XG4gICAgICAgICAgICBpZiAoIW1haW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjb25kaXRpb24uaW5kZXg7XG4gICAgICAgICAgICB2YXIgaWQgPSBjb25kaXRpb24uaWQ7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGNvbmRpdGlvbi5uYW1lO1xuXG4gICAgICAgICAgICB2YXIgY3B0cyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcblxuICAgICAgICAgICAgaWYgKCFjcHRzIHx8ICFjcHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyKG1hcChpbmRleCwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3B0c1tpZHhdO1xuICAgICAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNJZEFycmF5ID0gaXNBcnJheShpZCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyKGNwdHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpc0lkQXJyYXkgJiYgaW5kZXhPZihpZCwgY3B0LmlkKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKCFpc0lkQXJyYXkgJiYgY3B0LmlkID09PSBpZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNOYW1lQXJyYXkgPSBpc0FycmF5KG5hbWUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcihjcHRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNOYW1lQXJyYXkgJiYgaW5kZXhPZihuYW1lLCBjcHQubmFtZSkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICghaXNOYW1lQXJyYXkgJiYgY3B0Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCBjb21wb25lbnRzIHdpdGggbWFpblR5cGVcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjcHRzLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCeVN1YlR5cGUocmVzdWx0LCBjb25kaXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW50ZXJmYWNlIGlzIGRpZmZlcmVudCBmcm9tIHF1ZXJ5Q29tcG9uZW50cyxcbiAgICAgICAgICogd2hpY2ggaXMgY29udmVuaWVudCBmb3IgaW5uZXIgdXNhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZVxuICAgICAgICAgKiB2YXIgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdkYXRhWm9vbScsIHF1ZXJ5OiB7ZGF0YVpvb21JZDogJ2FiYyd9fVxuICAgICAgICAgKiApO1xuICAgICAgICAgKiB2YXIgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiAncGllJywgcXVlcnk6IHtzZXJpZXNOYW1lOiAndWlvJ319XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICAgICAgICogICAgIHttYWluVHlwZTogJ3Nlcmllcyd9LFxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICAgICAgICogKTtcbiAgICAgICAgICogLy8gcmVzdWx0IGxpa2UgW2NvbXBvbmVudDAsIGNvbXBvbm5ldDEsIC4uLl1cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZGl0aW9uLm1haW5UeXBlIE1hbmRhdG9yeS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25kaXRpb24uc3ViVHlwZV0gT3B0aW9uYWwuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uLnF1ZXJ5XSBsaWtlIHt4eHhJbmRleCwgeHh4SWQsIHh4eE5hbWV9LFxuICAgICAgICAgKiAgICAgICAgd2hlcmUgeHh4IGlzIG1haW5UeXBlLlxuICAgICAgICAgKiAgICAgICAgSWYgcXVlcnkgYXR0cmlidXRlIGlzIG51bGwvdW5kZWZpbmVkIG9yIGhhcyBubyBpbmRleC9pZC9uYW1lLFxuICAgICAgICAgKiAgICAgICAgZG8gbm90IGZpbHRlcmluZyBieSBxdWVyeSBjb25kaXRpb25zLCB3aGljaCBpcyBjb252ZW5pZW50IGZvclxuICAgICAgICAgKiAgICAgICAgbm8tcGF5bG9hZCBzaXR1YXRpb25zIG9yIHdoZW4gdGFyZ2V0IG9mIGFjdGlvbiBpcyBnbG9iYWwuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25kaXRpb24uZmlsdGVyXSBwYXJhbWV0ZXI6IGNvbXBvbmVudCwgcmV0dXJuIGJvb2xlYW4uXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fVxuICAgICAgICAgKi9cbiAgICAgICAgZmluZENvbXBvbmVudHM6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IGNvbmRpdGlvbi5xdWVyeTtcbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IGNvbmRpdGlvbi5tYWluVHlwZTtcblxuICAgICAgICAgICAgdmFyIHF1ZXJ5Q29uZCA9IGdldFF1ZXJ5Q29uZChxdWVyeSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcXVlcnlDb25kXG4gICAgICAgICAgICAgICAgPyB0aGlzLnF1ZXJ5Q29tcG9uZW50cyhxdWVyeUNvbmQpXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9jb21wb25lbnRzTWFwLmdldChtYWluVHlwZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkb0ZpbHRlcihmaWx0ZXJCeVN1YlR5cGUocmVzdWx0LCBjb25kaXRpb24pKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UXVlcnlDb25kKHEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhBdHRyID0gbWFpblR5cGUgKyAnSW5kZXgnO1xuICAgICAgICAgICAgICAgIHZhciBpZEF0dHIgPSBtYWluVHlwZSArICdJZCc7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gbWFpblR5cGUgKyAnTmFtZSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcVtpbmRleEF0dHJdICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHFbaWRBdHRyXSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBxW25hbWVBdHRyXSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJUeXBlIHdpbGwgYmUgZmlsdGVyZWQgZmluYWxseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBxW2luZGV4QXR0cl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcVtpZEF0dHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcVtuYW1lQXR0cl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvRmlsdGVyKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24uZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICA/IGZpbHRlcihyZXMsIGNvbmRpdGlvbi5maWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHVzYWdlXG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICogICAgIC4uLlxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogZWFjaENvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAqICAgICAvLyBjb21wb25lbnRUeXBlIGRvZXMgbm90IGluY2x1ZGUgc3ViVHlwZVxuICAgICAgICAgKiAgICAgLy8gKGNvbXBvbmVudFR5cGUgaXMgJ3h4eCcgYnV0IG5vdCAneHh4LmFhJylcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdkYXRhWm9vbScsIHF1ZXJ5OiB7ZGF0YVpvb21JZDogJ2FiYyd9fSxcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiAncGllJywgcXVlcnk6IHtzZXJpZXNOYW1lOiAndWlvJ319LFxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICAgICAgICogKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0PX0gbWFpblR5cGUgV2hlbiBtYWluVHlwZSBpcyBvYmplY3QsIHRoZSBkZWZpbml0aW9uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRoZSBzYW1lIGFzIHRoZSBtZXRob2QgJ2ZpbmRDb21wb25lbnRzJy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoQ29tcG9uZW50OiBmdW5jdGlvbiAobWFpblR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFpblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2I7XG4gICAgICAgICAgICAgICAgY2IgPSBtYWluVHlwZTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwLmVhY2goZnVuY3Rpb24gKGNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaChjb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjb21wb25lbnRUeXBlLCBjb21wb25lbnQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNTdHJpbmcobWFpblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZWFjaChjb21wb25lbnRzTWFwLmdldChtYWluVHlwZSksIGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVJlc3VsdCA9IHRoaXMuZmluZENvbXBvbmVudHMobWFpblR5cGUpO1xuICAgICAgICAgICAgICAgIGVhY2gocXVlcnlSZXN1bHQsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJpZXNCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25lU2VyaWVzLm5hbWUgPT09IG5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZGV4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc31cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcmllc0J5SW5kZXg6IGZ1bmN0aW9uIChzZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtzZXJpZXNJbmRleF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJUeXBlXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSkge1xuICAgICAgICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKTtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoc2VyaWVzLCBmdW5jdGlvbiAob25lU2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uZVNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFmdGVyIGZpbHRlcmluZywgc2VyaWVzIG1heSBiZSBkaWZmZXJlbnRcbiAgICAgICAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoU2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgICAgICAgICAgZWFjaCh0aGlzLl9zZXJpZXNJbmRpY2VzLCBmdW5jdGlvbiAocmF3U2VyaWVzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpW3Jhd1Nlcmllc0luZGV4XTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgcmF3U2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaFJhd1NlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSwgY2IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZnRlciBmaWx0ZXJpbmcsIHNlcmllcyBtYXkgYmUgZGlmZmVyZW50LlxuICAgICAgICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFybWEge3N0cmluZ30gc3ViVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hTZXJpZXNCeVR5cGU6IGZ1bmN0aW9uIChzdWJUeXBlLCBjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJylbcmF3U2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgcmF3U2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHJhdyBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkIG9mIGdpdmVuIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJtYSB7c3RyaW5nfSBzdWJUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaFJhd1Nlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZWFjaCh0aGlzLmdldFNlcmllc0J5VHlwZShzdWJUeXBlKSwgY2IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VyaWVzRmlsdGVyZWQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YodGhpcy5fc2VyaWVzSW5kaWNlcywgc2VyaWVzTW9kZWwuY29tcG9uZW50SW5kZXgpIDwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDdXJyZW50U2VyaWVzSW5kaWNlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9zZXJpZXNJbmRpY2VzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlclNlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZFNlcmllcyA9IGZpbHRlcihcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGNiLCBjb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoZmlsdGVyZWRTZXJpZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSk7XG5cbiAgICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlcyA9IFtdO1xuICAgICAgICAgICAgY29tcG9uZW50c01hcC5lYWNoKGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZXMucHVzaChjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbChcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaChjb21wb25lbnRzTWFwLmdldChjb21wb25lbnRUeXBlKSwgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlc3RvcmVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VUaGVtZShvcHRpb24sIHRoZW1lKSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKHRoZW1lLCBmdW5jdGlvbiAodGhlbWVJdGVtLCBuYW1lKSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzmnIkgY29tcG9uZW50IG1vZGVsIOWImeaKiuWFt+S9k+eahCBtZXJnZSDpgLvovpHkuqTnu5nor6UgbW9kZWwg5aSE55CGXG4gICAgICAgICAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGVtZUl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbltuYW1lXSA9ICFvcHRpb25bbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgID8genJVdGlsLmNsb25lKHRoZW1lSXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogenJVdGlsLm1lcmdlKG9wdGlvbltuYW1lXSwgdGhlbWVJdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbltuYW1lXSA9IHRoZW1lSXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEJhc2UoYmFzZU9wdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9uID0gYmFzZU9wdGlvbjtcblxuICAgICAgICAvLyBVc2luZyBPUFRJT05fSU5ORVJfS0VZIHRvIG1hcmsgdGhhdCB0aGlzIG9wdGlvbiBjYW4gbm90IGJlIHVzZWQgb3V0c2lkZSxcbiAgICAgICAgLy8gaS5lLiBgY2hhcnQuc2V0T3B0aW9uKGNoYXJ0LmdldE1vZGVsKCkub3B0aW9uKTtgIGlzIGZvcmJpZGVuLlxuICAgICAgICB0aGlzLm9wdGlvbiA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbltPUFRJT05fSU5ORVJfS0VZXSA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgd2l0aCBzZXJpZXM6IFtdLCBpbiBjYXNlIG9mIGNhbGxpbmcgZmluZFNlcmllcyBtZXRob2RcbiAgICAgICAgICogYmVmb3JlIHNlcmllcyBpbml0aWFsaXplZC5cbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCh7c2VyaWVzOiBbXX0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBwaW5nIGJldHdlZW4gZmlsdGVyZWQgc2VyaWVzIGxpc3QgYW5kIHJhdyBzZXJpZXMgbGlzdC5cbiAgICAgICAgICoga2V5OiBmaWx0ZXJlZCBzZXJpZXMgaW5kaWNlcywgdmFsdWU6IHJhdyBzZXJpZXMgaW5kaWNlcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudWJtZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IG51bGw7XG5cbiAgICAgICAgbWVyZ2VUaGVtZShiYXNlT3B0aW9uLCB0aGlzLl90aGVtZS5vcHRpb24pO1xuXG4gICAgICAgIC8vIFRPRE8gTmVlZHMgY2xvbmUgd2hlbiBtZXJnaW5nIHRvIHRoZSB1bmV4aXN0ZWQgcHJvcGVydHlcbiAgICAgICAgenJVdGlsLm1lcmdlKGJhc2VPcHRpb24sIGdsb2JhbERlZmF1bHQsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSB0eXBlcyBtb2RlbCB0eXBlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0ga2V5OiB7c3RyaW5nfSB0eXBlLCB2YWx1ZToge0FycmF5LjxPYmplY3Q+fSBtb2RlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCB0eXBlcykge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHR5cGVzKSkge1xuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcyA/IFt0eXBlc10gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZWFjaCh0eXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldFt0eXBlXSA9IChjb21wb25lbnRzTWFwLmdldCh0eXBlKSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVTdWJUeXBlKG1haW5UeXBlLCBuZXdDcHRPcHRpb24sIGV4aXN0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBzdWJUeXBlID0gbmV3Q3B0T3B0aW9uLnR5cGVcbiAgICAgICAgICAgID8gbmV3Q3B0T3B0aW9uLnR5cGVcbiAgICAgICAgICAgIDogZXhpc3RDb21wb25lbnRcbiAgICAgICAgICAgID8gZXhpc3RDb21wb25lbnQuc3ViVHlwZVxuICAgICAgICAgICAgLy8gVXNlIGRldGVybWluZVN1YlR5cGUgb25seSB3aGVuIHRoZXJlIGlzIG5vIGV4aXN0Q29tcG9uZW50LlxuICAgICAgICAgICAgOiBDb21wb25lbnRNb2RlbC5kZXRlcm1pbmVTdWJUeXBlKG1haW5UeXBlLCBuZXdDcHRPcHRpb24pO1xuXG4gICAgICAgIC8vIHRvb2x0aXAsIG1hcmtsaW5lLCBtYXJrcG9pbnQgbWF5IGFsd2F5cyBoYXMgbm8gc3ViVHlwZVxuICAgICAgICByZXR1cm4gc3ViVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTZXJpZXNJbmRpY2VzKHNlcmllc01vZGVscykge1xuICAgICAgICByZXR1cm4gbWFwKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5jb21wb25lbnRJbmRleDtcbiAgICAgICAgfSkgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyQnlTdWJUeXBlKGNvbXBvbmVudHMsIGNvbmRpdGlvbikge1xuICAgICAgICAvLyBVc2luZyBoYXNPd25Qcm9wZXJ0eSBmb3IgcmVzdHJpY3QuIENvbnNpZGVyXG4gICAgICAgIC8vIHN1YlR5cGUgaXMgdW5kZWZpbmVkIGluIHVzZXIgcGF5bG9hZC5cbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbi5oYXNPd25Qcm9wZXJ0eSgnc3ViVHlwZScpXG4gICAgICAgICAgICA/IGZpbHRlcihjb21wb25lbnRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNwdC5zdWJUeXBlID09PSBjb25kaXRpb24uc3ViVHlwZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGNvbXBvbmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQoZWNNb2RlbCkge1xuICAgICAgICAvLyBDb21wb25lbnRzIHRoYXQgdXNlIF9zZXJpZXNJbmRpY2VzIHNob3VsZCBkZXBlbmRzIG9uIHNlcmllcyBjb21wb25lbnQsXG4gICAgICAgIC8vIHdoaWNoIG1ha2Ugc3VyZSB0aGF0IHRoZWlyIGluaXRpYWxpemF0aW9uIGlzIGFmdGVyIHNlcmllcy5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmICghZWNNb2RlbC5fc2VyaWVzSW5kaWNlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIHNob3VsZCBjb250YWlucyBzZXJpZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB6clV0aWwubWl4aW4oR2xvYmFsTW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vY29sb3JQYWxldHRlJykpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHbG9iYWxNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9tb2RlbC9HbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(4);\n    var ComponentModel = __webpack_require__(13);\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // 如果没有reset功能则不clone。\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL09wdGlvbk1hbmFnZXIuanM/MmZiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCLHdCQUF3QixJQUFJO0FBQzVCLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQiw0QkFBNEIsSUFBSTtBQUNoQztBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsMEJBQTBCLElBQUk7QUFDOUI7QUFDQSxvQkFBb0IsUUFBUSxJQUFJLFdBQVcsYUFBYTtBQUN4RCxvQkFBb0IsUUFBUSxJQUFJLFdBQVcsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLGdDQUFnQyxTQUFTLE1BQU0sY0FBYztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVELGdDQUFnQyxTQUFTLE9BQU8sY0FBYztBQUM5RCxvQkFBb0I7QUFDcEI7QUFDQSxnQ0FBZ0MsU0FBUyxRQUFRLGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLGdCQUFnQixNQUFNO0FBQ2pFLGdDQUFnQyxXQUFXLGVBQWUsTUFBTTs7QUFFaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLGlCQUFpQjtBQUNwQyxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBIiwiZmlsZSI6IjE2OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRUNoYXJ0cyBvcHRpb24gbWFuYWdlclxuICpcbiAqIEBtb2R1bGUge2VjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlcn1cbiAqL1xuXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG4gICAgdmFyIG1hcCA9IHpyVXRpbC5tYXA7XG4gICAgdmFyIG1lcmdlID0genJVdGlsLm1lcmdlO1xuXG4gICAgdmFyIFFVRVJZX1JFRyA9IC9eKG1pbnxtYXgpPyguKykkLztcblxuICAgIC8qKlxuICAgICAqIFRFUk0gRVhQTEFOQVRJT05TOlxuICAgICAqXG4gICAgICogW29wdGlvbl06XG4gICAgICpcbiAgICAgKiAgICAgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZGVmaW5pdGlvbnMgb2YgY29tcG9uZW50cy4gRm9yIGV4YW1wbGU6XG4gICAgICogICAgIHZhciBvcHRpb24gPSB7XG4gICAgICogICAgICAgICB0aXRsZTogey4uLn0sXG4gICAgICogICAgICAgICBsZWdlbmQ6IHsuLi59LFxuICAgICAqICAgICAgICAgdmlzdWFsTWFwOiB7Li4ufSxcbiAgICAgKiAgICAgICAgIHNlcmllczogW1xuICAgICAqICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAgICAgKiAgICAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgIF1cbiAgICAgKiAgICAgfTtcbiAgICAgKlxuICAgICAqIFtyYXdPcHRpb25dOlxuICAgICAqXG4gICAgICogICAgIEFuIG9iamVjdCBpbnB1dCB0byBlY2hhcnRzLnNldE9wdGlvbi4gJ3Jhd09wdGlvbicgbWF5IGJlIGFuXG4gICAgICogICAgICdvcHRpb24nLCBvciBtYXkgYmUgYW4gb2JqZWN0IGNvbnRhaW5zIG11bHRpLW9wdGlvbnMuIEZvciBleGFtcGxlOlxuICAgICAqICAgICB2YXIgb3B0aW9uID0ge1xuICAgICAqICAgICAgICAgYmFzZU9wdGlvbjoge1xuICAgICAqICAgICAgICAgICAgIHRpdGxlOiB7Li4ufSxcbiAgICAgKiAgICAgICAgICAgICBsZWdlbmQ6IHsuLi59LFxuICAgICAqICAgICAgICAgICAgIHNlcmllczogW1xuICAgICAqICAgICAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICAgICAqICAgICAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICAgICAqICAgICAgICAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgICAgICBdXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgICAgdGltZWxpbmU6IHsuLi59LFxuICAgICAqICAgICAgICAgb3B0aW9uczogW1xuICAgICAqICAgICAgICAgICAgIHt0aXRsZTogey4uLn0sIHNlcmllczoge2RhdGE6IFsuLi5dfX0sXG4gICAgICogICAgICAgICAgICAge3RpdGxlOiB7Li4ufSwgc2VyaWVzOiB7ZGF0YTogWy4uLl19fSxcbiAgICAgKiAgICAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgIF0sXG4gICAgICogICAgICAgICBtZWRpYTogW1xuICAgICAqICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgcXVlcnk6IHttYXhXaWR0aDogMzIwfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogMjB9LCB2aXN1YWxNYXA6IHtzaG93OiBmYWxzZX19XG4gICAgICogICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWluV2lkdGg6IDMyMCwgbWF4V2lkdGg6IDcyMH0sXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDUwMH0sIHZpc3VhbE1hcDoge3Nob3c6IHRydWV9fVxuICAgICAqICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb246IHtzZXJpZXM6IHt4OiAxMjAwfSwgdmlzdWFsTWFwOiB7c2hvdzogdHJ1ZX19XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgXVxuICAgICAqICAgICB9O1xuICAgICAqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3B0aW9uTWFuYWdlcihhcGkpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FwaSA9IGFwaTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21lZGlhTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWVkaWFEZWZhdWx0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAtMSwgbWVhbnMgZGVmYXVsdC5cbiAgICAgICAgICogZW1wdHkgbWVhbnMgbm8gbWVkaWEuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29wdGlvbkJhY2t1cDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25ld0Jhc2VPcHRpb247XG4gICAgfVxuXG4gICAgLy8gdGltZWxpbmUubm90TWVyZ2UgaXMgbm90IHN1cHBvcnRlZCBpbiBlYzMuIEZpcnN0bHkgdGhlcmUgaXMgcmVhcmx5XG4gICAgLy8gY2FzZSB0aGF0IG5vdE1lcmdlIGlzIG5lZWRlZC4gU2Vjb25kbHkgc3VwcG9ydGluZyAnbm90TWVyZ2UnIHJlcXVpcmVzXG4gICAgLy8gcmF3T3B0aW9uIGNsb25lZCBhbmQgYmFja3VwZWQgd2hlbiB0aW1lbGluZSBjaGFuZ2VkLCB3aGljaCBkb2VzIG5vXG4gICAgLy8gZ29vZCB0byBwZXJmb3JtYW5jZS4gV2hhdCdzIG1vcmUsIHRoYXQgYm90aCB0aW1lbGluZSBhbmQgc2V0T3B0aW9uXG4gICAgLy8gbWV0aG9kIHN1cHBseSAnbm90TWVyZ2UnIGJyaW5ncyBjb21wbGV4IGFuZCBzb21lIHByb2JsZW1zLlxuICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTpcbiAgICAvLyAoc3RlcDEpIGNoYXJ0LnNldE9wdGlvbih7dGltZWxpbmU6IHtub3RNZXJnZTogZmFsc2V9LCAuLi59LCBmYWxzZSk7XG4gICAgLy8gKHN0ZXAyKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IHRydWV9LCAuLi59LCBmYWxzZSk7XG5cbiAgICBPcHRpb25NYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogT3B0aW9uTWFuYWdlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmF3T3B0aW9uIFJhdyBvcHRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPEZ1bmN0aW9uPn0gb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3NcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBJbml0IG9wdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0T3B0aW9uOiBmdW5jdGlvbiAocmF3T3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcykge1xuICAgICAgICAgICAgcmF3T3B0aW9uID0gY2xvbmUocmF3T3B0aW9uLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIOWmguaenCB0aW1lbGluZSBvcHRpb25zIOaIluiAhSBtZWRpYSDkuK3orr7nva7kuobmn5DkuKrlsZ7mgKfvvIzogIxiYXNlT3B0aW9u5Lit5rKh5pyJ6K6+572u77yM5YiZ6L+b6KGM6K2m5ZGK44CCXG5cbiAgICAgICAgICAgIHZhciBvbGRPcHRpb25CYWNrdXAgPSB0aGlzLl9vcHRpb25CYWNrdXA7XG4gICAgICAgICAgICB2YXIgbmV3UGFyc2VkT3B0aW9uID0gcGFyc2VSYXdPcHRpb24uY2FsbChcbiAgICAgICAgICAgICAgICB0aGlzLCByYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCAhb2xkT3B0aW9uQmFja3VwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fbmV3QmFzZU9wdGlvbiA9IG5ld1BhcnNlZE9wdGlvbi5iYXNlT3B0aW9uO1xuXG4gICAgICAgICAgICAvLyBGb3Igc2V0T3B0aW9uIGF0IHNlY29uZCB0aW1lICh1c2luZyBtZXJnZSBtb2RlKTtcbiAgICAgICAgICAgIGlmIChvbGRPcHRpb25CYWNrdXApIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGJhc2VPcHRpb24gY2FuIGJlIG1lcmdlZC5cbiAgICAgICAgICAgICAgICBtZXJnZU9wdGlvbihvbGRPcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHRpbWVsaW5lIG9wdGlvbnMgYW5kIG1lZGlhIG9wdGlvbnMgZG8gbm90IHN1cHBvcnQgbWVyZ2UsXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBpcywgaWYgeW91IGBzZXRPcHRpb25gIHR3aWNlIGFuZCBib3RoIGhhcyB0aW1lbGluZSBvcHRpb25zLCB0aGUgbGF0dGVyXG4gICAgICAgICAgICAgICAgLy8gdGltZWxpbmUgb3BpdG9ucyB3aWxsIG5vdCBiZSBtZXJnZWQgdG8gdGhlIGZvcm1lcnMsIGJ1dCBqdXN0IHN1YnN0aXR1ZGUgdGhlbS5cbiAgICAgICAgICAgICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLnRpbWVsaW5lT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT3B0aW9uQmFja3VwLnRpbWVsaW5lT3B0aW9ucyA9IG5ld1BhcnNlZE9wdGlvbi50aW1lbGluZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPcHRpb25CYWNrdXAubWVkaWFMaXN0ID0gbmV3UGFyc2VkT3B0aW9uLm1lZGlhTGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi5tZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT3B0aW9uQmFja3VwLm1lZGlhRGVmYXVsdCA9IG5ld1BhcnNlZE9wdGlvbi5tZWRpYURlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9uQmFja3VwID0gbmV3UGFyc2VkT3B0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVjcmVhdGVcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRPcHRpb246IGZ1bmN0aW9uIChpc1JlY3JlYXRlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uQmFja3VwID0gdGhpcy5fb3B0aW9uQmFja3VwO1xuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyDlpoLmnpzmsqHmnIlyZXNldOWKn+iDveWImeS4jWNsb25l44CCXG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lT3B0aW9ucyA9IG1hcChvcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zLCBjbG9uZSk7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYUxpc3QgPSBtYXAob3B0aW9uQmFja3VwLm1lZGlhTGlzdCwgY2xvbmUpO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFEZWZhdWx0ID0gY2xvbmUob3B0aW9uQmFja3VwLm1lZGlhRGVmYXVsdCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gW107XG5cbiAgICAgICAgICAgIHJldHVybiBjbG9uZShpc1JlY3JlYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fb3B0aW9uQmFja3VwLmJhc2VPcHRpb24sIHdoaWNoIGlzIGNyZWF0ZWQgYXQgdGhlIGZpcnN0IGBzZXRPcHRpb25gXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkLCBhbmQgaXMgbWVyZ2VkIGludG8gZXZlcnkgbmV3IG9wdGlvbiBieSBpbm5lciBtZXRob2QgYG1lcmdlT3B0aW9uYFxuICAgICAgICAgICAgICAgIC8vIGVhY2ggdGltZSBgc2V0T3B0aW9uYCBjYWxsZWQsIGNhbiBiZSBvbmx5IHVzZWQgaW4gYGlzUmVjcmVhdGVgLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gaXRzIHJlbGlhYmlsaXR5IGlzIHVuZGVyIHN1c3BpY2lvbi4gSW4gb3RoZXIgY2FzZXMgb3B0aW9uIG1lcmdlIGlzXG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybWVkIGJ5IGBtb2RlbC5tZXJnZU9wdGlvbmAuXG4gICAgICAgICAgICAgICAgPyBvcHRpb25CYWNrdXAuYmFzZU9wdGlvbiA6IHRoaXMuX25ld0Jhc2VPcHRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpbWVsaW5lT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbjtcbiAgICAgICAgICAgIHZhciB0aW1lbGluZU9wdGlvbnMgPSB0aGlzLl90aW1lbGluZU9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICh0aW1lbGluZU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0VGltZWxpbmVPcHRpb24gY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGVjTW9kZWwgaW5pdGVkLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbiBnZXQgY3VycmVudEluZGV4IGZyb20gdGltZWxpbmVNb2RlbC5cbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0aW1lbGluZScpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IGNsb25lKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVPcHRpb25zW3RpbWVsaW5lTW9kZWwuZ2V0Q3VycmVudEluZGV4KCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRNZWRpYU9wdGlvbjogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBlY1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgZWNIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICB2YXIgbWVkaWFMaXN0ID0gdGhpcy5fbWVkaWFMaXN0O1xuICAgICAgICAgICAgdmFyIG1lZGlhRGVmYXVsdCA9IHRoaXMuX21lZGlhRGVmYXVsdDtcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIC8vIE5vIG1lZGlhIGRlZmluZWQuXG4gICAgICAgICAgICBpZiAoIW1lZGlhTGlzdC5sZW5ndGggJiYgIW1lZGlhRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE11bHRpIG1lZGlhIG1heSBiZSBhcHBsaWVkLCB0aGUgbGF0dGVyIGRlZmluZWQgbWVkaWEgaGFzIGhpZ2hlciBwcmlvcml0eS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtZWRpYUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbHlNZWRpYVF1ZXJ5KG1lZGlhTGlzdFtpXS5xdWVyeSwgZWNXaWR0aCwgZWNIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyDmmK/lkKZtZWRpYURlZmF1bHTlupTor6XlvLrliLbnlKjmiLforr7nva7vvIzlkKbliJnlj6/og73kv67mlLnkuI3og73lm57lvZLjgIJcbiAgICAgICAgICAgIGlmICghaW5kaWNlcy5sZW5ndGggJiYgbWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcyA9IFstMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCAmJiAhaW5kaWNlc0VxdWFscyhpbmRpY2VzLCB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hcChpbmRpY2VzLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPT09IC0xID8gbWVkaWFEZWZhdWx0Lm9wdGlvbiA6IG1lZGlhTGlzdFtpbmRleF0ub3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIG5vdGhpbmcuXG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBpbmRpY2VzO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUmF3T3B0aW9uKHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsIGlzTmV3KSB7XG4gICAgICAgIHZhciB0aW1lbGluZU9wdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIG1lZGlhTGlzdCA9IFtdO1xuICAgICAgICB2YXIgbWVkaWFEZWZhdWx0O1xuICAgICAgICB2YXIgYmFzZU9wdGlvbjtcblxuICAgICAgICAvLyBDb21wYXRpYmxlIHdpdGggZWMyLlxuICAgICAgICB2YXIgdGltZWxpbmVPcHQgPSByYXdPcHRpb24udGltZWxpbmU7XG5cbiAgICAgICAgaWYgKHJhd09wdGlvbi5iYXNlT3B0aW9uKSB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uID0gcmF3T3B0aW9uLmJhc2VPcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgdGltZWxpbmVcbiAgICAgICAgaWYgKHRpbWVsaW5lT3B0IHx8IHJhd09wdGlvbi5vcHRpb25zKSB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uID0gYmFzZU9wdGlvbiB8fCB7fTtcbiAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9ucyA9IChyYXdPcHRpb24ub3B0aW9ucyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBtZWRpYSBxdWVyeVxuICAgICAgICBpZiAocmF3T3B0aW9uLm1lZGlhKSB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uID0gYmFzZU9wdGlvbiB8fCB7fTtcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHJhd09wdGlvbi5tZWRpYTtcbiAgICAgICAgICAgIGVhY2gobWVkaWEsIGZ1bmN0aW9uIChzaW5nbGVNZWRpYSkge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVNZWRpYSAmJiBzaW5nbGVNZWRpYS5vcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZU1lZGlhLnF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYUxpc3QucHVzaChzaW5nbGVNZWRpYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW1lZGlhRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBtZWRpYSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFEZWZhdWx0ID0gc2luZ2xlTWVkaWE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBub3JtYWwgb3B0aW9uXG4gICAgICAgIGlmICghYmFzZU9wdGlvbikge1xuICAgICAgICAgICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aW1lbGluZU9wdCB0byBiYXNlT3B0aW9uIGluIGVjMyxcbiAgICAgICAgLy8gd2hpY2ggaXMgY29udmVuaWVudCBmb3IgbWVyZ2Ugb3B0aW9uLlxuICAgICAgICBpZiAoIWJhc2VPcHRpb24udGltZWxpbmUpIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24udGltZWxpbmUgPSB0aW1lbGluZU9wdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXByb2Nlc3MuXG4gICAgICAgIGVhY2goW2Jhc2VPcHRpb25dLmNvbmNhdCh0aW1lbGluZU9wdGlvbnMpXG4gICAgICAgICAgICAuY29uY2F0KHpyVXRpbC5tYXAobWVkaWFMaXN0LCBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWEub3B0aW9uO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIGVhY2gob3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsIGZ1bmN0aW9uIChwcmVQcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVByb2Nlc3Mob3B0aW9uLCBpc05ldyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb246IGJhc2VPcHRpb24sXG4gICAgICAgICAgICB0aW1lbGluZU9wdGlvbnM6IHRpbWVsaW5lT3B0aW9ucyxcbiAgICAgICAgICAgIG1lZGlhRGVmYXVsdDogbWVkaWFEZWZhdWx0LFxuICAgICAgICAgICAgbWVkaWFMaXN0OiBtZWRpYUxpc3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLW1lZGlhcXVlcmllcy8jbWVkaWExPlxuICAgICAqIFN1cHBvcnQ6IHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvXG4gICAgICogQ2FuIHVzZSBtYXggb3IgbWluIGFzIHByZWZpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHBseU1lZGlhUXVlcnkocXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSB7XG4gICAgICAgIHZhciByZWFsTWFwID0ge1xuICAgICAgICAgICAgd2lkdGg6IGVjV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGVjSGVpZ2h0LFxuICAgICAgICAgICAgYXNwZWN0cmF0aW86IGVjV2lkdGggLyBlY0hlaWdodCAvLyBsb3dzZXIgY2FzZSBmb3IgY29udmVuaWVudGNlLlxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcHBsaWNhdGFibGUgPSB0cnVlO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHF1ZXJ5LCBmdW5jdGlvbiAodmFsdWUsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gYXR0ci5tYXRjaChRVUVSWV9SRUcpO1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoZWQgfHwgIW1hdGNoZWRbMV0gfHwgIW1hdGNoZWRbMl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgICB2YXIgcmVhbEF0dHIgPSBtYXRjaGVkWzJdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmICghY29tcGFyZShyZWFsTWFwW3JlYWxBdHRyXSwgdmFsdWUsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIGFwcGxpY2F0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBwbGljYXRhYmxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmUocmVhbCwgZXhwZWN0LCBvcGVyYXRvcikge1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdtaW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhbCA+PSBleHBlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0b3IgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhbCA8PSBleHBlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEVxdWFsc1xuICAgICAgICAgICAgcmV0dXJuIHJlYWwgPT09IGV4cGVjdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluZGljZXNFcXVhbHMoaW5kaWNlczEsIGluZGljZXMyKSB7XG4gICAgICAgIC8vIGluZGljZXMgaXMgYWx3YXlzIG9yZGVyIGJ5IGFzYyBhbmQgaGFzIG9ubHkgZmluaXRlIG51bWJlci5cbiAgICAgICAgcmV0dXJuIGluZGljZXMxLmpvaW4oJywnKSA9PT0gaW5kaWNlczIuam9pbignLCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnNpZGVyIGNhc2U6XG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTtgXG4gICAgICogVGhlbiB1c2VyIGRvIHNvbWUgaW50ZXJhY3Rpb24gbGlrZSBkYXRhWm9vbSwgZGF0YVZpZXcgY2hhbmdpbmcuXG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgXG4gICAgICogVGhlbiB1c2VyIHByZXNzICdyZXNldCBidXR0b24nIGluIHRvb2xib3guXG4gICAgICpcbiAgICAgKiBBZnRlciBkb2luZyB0aGF0IGFsbCBvZiB0aGUgaW50ZXJhY3Rpb24gZWZmZWN0cyBzaG91bGQgYmUgcmVzZXQsIHRoZVxuICAgICAqIGNoYXJ0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgcmVzdWx0IG9mIGludm9rZVxuICAgICAqIGBjaGFydC5zZXRPcHRpb24ob3B0MSk7IGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgLlxuICAgICAqXG4gICAgICogQWx0aG91Z2ggaXQgaXMgbm90IGFibGUgZW5zdXJlIHRoYXRcbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpOyBjaGFydC5zZXRPcHRpb24ob3B0Mik7YCBpcyBlcXVpdmFsZW50cyB0b1xuICAgICAqIGBjaGFydC5zZXRPcHRpb24obWVyZ2Uob3B0MSwgb3B0MikpO2AgZXhhY3RseSxcbiAgICAgKiB0aGlzIG1pZ2h0IGJlIHRoZSBvbmx5IHNpbXBsZSB3YXkgdG8gaW1wbGVtZW50IHRoYXQgZmVhdHVyZS5cbiAgICAgKlxuICAgICAqIE1FTU86IFdlJ3ZlIGNvbnNpZGVyZWQgc29tZSBvdGhlciBhcHByb2FjaGVzOlxuICAgICAqIDEuIEVhY2ggbW9kZWwgaGFuZGxlIGl0cyBzZWxmIHJlc3RvcmF0aW9uIGJ1dCBub3QgdW5pZm9ybSB0cmVhdG1lbnQuXG4gICAgICogICAgIChUb28gY29tcGxleCBpbiBsb2dpYyBhbmQgZXJyb3ItcHJvbmUpXG4gICAgICogMi4gVXNlIGEgc2hhZG93IGVjTW9kZWwuIChQZXJmb3JtYWNlIGV4cGVuc2l2ZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZU9wdGlvbihvbGRPcHRpb24sIG5ld09wdGlvbikge1xuICAgICAgICBuZXdPcHRpb24gPSBuZXdPcHRpb24gfHwge307XG5cbiAgICAgICAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChuZXdDcHRPcHQsIG1haW5UeXBlKSB7XG4gICAgICAgICAgICBpZiAobmV3Q3B0T3B0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvbGRDcHRPcHQgPSBvbGRPcHRpb25bbWFpblR5cGVdO1xuXG4gICAgICAgICAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIG9sZE9wdGlvblttYWluVHlwZV0gPSBtZXJnZShvbGRDcHRPcHQsIG5ld0NwdE9wdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdDcHRPcHQgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShuZXdDcHRPcHQpO1xuICAgICAgICAgICAgICAgIG9sZENwdE9wdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9sZENwdE9wdCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWFwUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhvbGRDcHRPcHQsIG5ld0NwdE9wdCk7XG5cbiAgICAgICAgICAgICAgICBvbGRPcHRpb25bbWFpblR5cGVdID0gbWFwKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpdGVtLm9wdGlvbiAmJiBpdGVtLmV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtZXJnZShpdGVtLmV4aXN0LCBpdGVtLm9wdGlvbiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGl0ZW0uZXhpc3QgfHwgaXRlbS5vcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9wdGlvbk1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvbW9kZWwvT3B0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 169 */
/***/ (function(module, exports) {

eval("\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // 全图默认背景\n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // 浅色\n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // 深色\n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        // 默认需要 Grid 配置项\n        // grid: {},\n        // 主题，主题\n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanM/YmE4ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE2OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBwbGF0Zm9ybSA9ICcnO1xuICAgIC8vIE5hdmlnYXRvciBub3QgZXhpc3RzIGluIG5vZGVcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0gfHwgJyc7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvLyDlhajlm77pu5jorqTog4zmma9cbiAgICAgICAgLy8gYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9kcmliYmJsZS5jb20vc2hvdHMvMTA2NTk2MC1JbmZvZ3JhcGhpYy1QaWUtY2hhcnQtdmlzdWFsaXphdGlvblxuICAgICAgICAvLyBjb2xvcjogWycjNTc5M2YzJywgJyNkMTRhNjEnLCAnI2ZkOWMzNScsICcjNjc1YmJhJywgJyNmZWM0MmMnLCAnI2RkNDQ0NCcsICcjZDRkZjVhJywgJyNjZDQ4NzAnXSxcbiAgICAgICAgLy8g5rWF6ImyXG4gICAgICAgIC8vIGNvbG9yOiBbJyNiY2QzYmInLCAnI2U4OGY3MCcsICcjZWRjMWE1JywgJyM5ZGM1YzgnLCAnI2UxZThjOCcsICcjN2I3YzY4JywgJyNlNWI1YjUnLCAnI2YwYjQ4OScsICcjOTI4ZWE4JywgJyNiZGEyOWEnXSxcbiAgICAgICAgLy8gY29sb3I6IFsnI2NjNTY2NCcsICcjOWJkNmVjJywgJyNlYTk0NmUnLCAnIzhhY2FhYScsICcjZjFlYzY0JywgJyNlZTg2ODYnLCAnI2E0OGRjMScsICcjNWRhNmJjJywgJyNiOWRjYWUnXSxcbiAgICAgICAgLy8g5rex6ImyXG4gICAgICAgIGNvbG9yOiBbJyNjMjM1MzEnLCcjMmY0NTU0JywgJyM2MWEwYTgnLCAnI2Q0ODI2NScsICcjOTFjN2FlJywnIzc0OWY4MycsICAnI2NhODYyMicsICcjYmRhMjlhJywnIzZlNzA3NCcsICcjNTQ2NTcwJywgJyNjNGNjZDMnXSxcblxuICAgICAgICAvLyDpu5jorqTpnIDopoEgR3JpZCDphY3nva7poblcbiAgICAgICAgLy8gZ3JpZDoge30sXG4gICAgICAgIC8vIOS4u+mimO+8jOS4u+mimFxuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgIC8vIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICAvLyBkZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICBmb250RmFtaWx5OiBwbGF0Zm9ybS5tYXRjaCgvXldpbi8pID8gJ01pY3Jvc29mdCBZYUhlaScgOiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICAvLyBmb250RmFtaWx5OiAnQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLFxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL2Jsb2dzLmFkb2JlLmNvbS93ZWJwbGF0Zm9ybS8yMDE0LzAyLzI0L3VzaW5nLWJsZW5kLW1vZGVzLWluLWh0bWwtY2FudmFzL1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICAvLyBEZWZhdWx0IGlzIHNvdXJjZS1vdmVyXG4gICAgICAgIGJsZW5kTW9kZTogbnVsbCxcblxuICAgICAgICBhbmltYXRpb246ICdhdXRvJyxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDAsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAzMDAsXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogJ2V4cG9uZW50aWFsT3V0JyxcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nVXBkYXRlOiAnY3ViaWNPdXQnLFxuXG4gICAgICAgIGFuaW1hdGlvblRocmVzaG9sZDogMjAwMCxcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBmb3IgcHJvZ3Jlc3NpdmUvaW5jcmVtZW50YWwgcmVuZGVyaW5nXG4gICAgICAgIHByb2dyZXNzaXZlVGhyZXNob2xkOiAzMDAwLFxuICAgICAgICBwcm9ncmVzc2l2ZTogNDAwLFxuXG4gICAgICAgIC8vIFRocmVzaG9sZCBvZiBpZiB1c2Ugc2luZ2xlIGhvdmVyIGxheWVyIHRvIG9wdGltaXplLlxuICAgICAgICAvLyBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IGBob3ZlckxheWVyVGhyZXNob2xkYCBpcyBlcXVpdmFsZW50IHRvIG9yIGxlc3MgdGhhblxuICAgICAgICAvLyBgcHJvZ3Jlc3NpdmVUaHJlc2hvbGRgLCBvdGhlcndpc2UgaG92ZXIgd2lsbCBjYXVzZSByZXN0YXJ0IG9mIHByb2dyZXNzaXZlLFxuICAgICAgICAvLyB3aGljaCBpcyB1bmV4cGVjdGVkLlxuICAgICAgICAvLyBzZWUgZXhhbXBsZSA8ZWNoYXJ0cy90ZXN0L2hlYXRtYXAtbGFyZ2UuaHRtbD4uXG4gICAgICAgIGhvdmVyTGF5ZXJUaHJlc2hvbGQ6IDMwMDAsXG5cbiAgICAgICAgLy8gU2VlOiBtb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lXG4gICAgICAgIHVzZVVUQzogZmFsc2VcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n    module.exports = {\n        getAreaStyle: __webpack_require__(24)(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qcz9jNTEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGdldEFyZWFTdHlsZTogcmVxdWlyZSgnLi9tYWtlU3R5bGVNYXBwZXInKShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd0JsdXInXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd09mZnNldFgnXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd0NvbG9yJ11cbiAgICAgICAgICAgIF1cbiAgICAgICAgKVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vYXJlYVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 171 */
/***/ (function(module, exports) {

eval("\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL2JveExheW91dC5qcz8yMjBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE3MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGdldEJveExheW91dFBhcmFtczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmdldCgnbGVmdCcpLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5nZXQoJ3RvcCcpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmdldCgncmlnaHQnKSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuZ2V0KCdib3R0b20nKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5nZXQoJ3dpZHRoJyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldCgnaGVpZ2h0JylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL2JveExheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var getItemStyle = __webpack_require__(24)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qcz9iYmNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIGdldEl0ZW1TdHlsZSA9IHJlcXVpcmUoJy4vbWFrZVN0eWxlTWFwcGVyJykoXG4gICAgICAgIFtcbiAgICAgICAgICAgIFsnZmlsbCcsICdjb2xvciddLFxuICAgICAgICAgICAgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSxcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ2JvcmRlcldpZHRoJ10sXG4gICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXSxcbiAgICAgICAgICAgIFsndGV4dFBvc2l0aW9uJ10sXG4gICAgICAgICAgICBbJ3RleHRBbGlnbiddXG4gICAgICAgIF1cbiAgICApO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBnZXRJdGVtU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldEl0ZW1TdHlsZS5jYWxsKHRoaXMsIGV4Y2x1ZGVzLCBpbmNsdWRlcyk7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldEJvcmRlckxpbmVEYXNoKCk7XG4gICAgICAgICAgICBsaW5lRGFzaCAmJiAoc3R5bGUubGluZURhc2ggPSBsaW5lRGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm9yZGVyTGluZURhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lVHlwZSA9IHRoaXMuZ2V0KCdib3JkZXJUeXBlJyk7XG4gICAgICAgICAgICByZXR1cm4gKGxpbmVUeXBlID09PSAnc29saWQnIHx8IGxpbmVUeXBlID09IG51bGwpID8gbnVsbFxuICAgICAgICAgICAgICAgIDogKGxpbmVUeXBlID09PSAnZGFzaGVkJyA/IFs1LCA1XSA6IFsxLCAxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var getLineStyle = __webpack_require__(24)(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL2xpbmVTdHlsZS5qcz9lNzNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBnZXRMaW5lU3R5bGUgPSByZXF1aXJlKCcuL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICd3aWR0aCddLFxuICAgICAgICAgICAgWydzdHJva2UnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnb3BhY2l0eSddLFxuICAgICAgICAgICAgWydzaGFkb3dCbHVyJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFgnXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WSddLFxuICAgICAgICAgICAgWydzaGFkb3dDb2xvciddXG4gICAgICAgIF1cbiAgICApO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBnZXRMaW5lU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0TGluZVN0eWxlLmNhbGwodGhpcywgZXhjbHVkZXMpO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRMaW5lRGFzaChzdHlsZS5saW5lV2lkdGgpO1xuICAgICAgICAgICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExpbmVEYXNoOiBmdW5jdGlvbiAobGluZVdpZHRoKSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmVUeXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBkb3RTaXplID0gTWF0aC5tYXgobGluZVdpZHRoLCAyKTtcbiAgICAgICAgICAgIHZhciBkYXNoU2l6ZSA9IGxpbmVXaWR0aCAqIDQ7XG4gICAgICAgICAgICByZXR1cm4gKGxpbmVUeXBlID09PSAnc29saWQnIHx8IGxpbmVUeXBlID09IG51bGwpID8gbnVsbFxuICAgICAgICAgICAgICAgIDogKGxpbmVUeXBlID09PSAnZGFzaGVkJyA/IFtkYXNoU2l6ZSwgZGFzaFNpemVdIDogW2RvdFNpemUsIGRvdFNpemVdKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vbGluZVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var textContain = __webpack_require__(16);\n    var graphicUtil = __webpack_require__(2);\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL21vZGVsL21peGluL3RleHRTdHlsZS5qcz84MGM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTc0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcbiAgICB2YXIgZ3JhcGhpY1V0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbG9yIHByb3BlcnR5IG9yIGdldCBjb2xvciBmcm9tIG9wdGlvbi50ZXh0U3R5bGUuY29sb3JcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dENvbG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNoYWxsb3coJ2NvbG9yJylcbiAgICAgICAgICAgICAgICB8fCAoZWNNb2RlbCAmJiBlY01vZGVsLmdldCgndGV4dFN0eWxlLmNvbG9yJykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgZm9udCBzdHJpbmcgZnJvbSBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5XG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFwaGljVXRpbC5nZXRGb250KHtcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFN0eWxlJyksXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogdGhpcy5nZXRTaGFsbG93KCdmb250V2VpZ2h0JyksXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFNpemUnKSxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB0aGlzLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKVxuICAgICAgICAgICAgfSwgdGhpcy5lY01vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUZXh0UmVjdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2FsaWduJyksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTaGFsbG93KCdiYXNlbGluZScpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRydW5jYXRlVGV4dDogZnVuY3Rpb24gKHRleHQsIGNvbnRhaW5lcldpZHRoLCBlbGxpcHNpcywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRDb250YWluLnRydW5jYXRlVGV4dChcbiAgICAgICAgICAgICAgICB0ZXh0LCBjb250YWluZXJXaWR0aCwgdGhpcy5nZXRGb250KCksIGVsbGlwc2lzLCBvcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fZWNoYXJ0c0AzLjYuMkBlY2hhcnRzL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

eval("// Compatitable with 2.0\n\n\n    var zrUtil = __webpack_require__(0);\n    var compatStyle = __webpack_require__(176);\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qcz83OWNjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUIiwiZmlsZSI6IjE3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvbXBhdGl0YWJsZSB3aXRoIDIuMFxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbXBhdFN0eWxlID0gcmVxdWlyZSgnLi9oZWxwZXIvY29tcGF0U3R5bGUnKTtcblxuICAgIGZ1bmN0aW9uIGdldChvcHQsIHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIG9iaiA9IG9wdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogJiYgb2JqW3BhdGhbaV1dO1xuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQob3B0LCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSkge1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgb2JqID0gb3B0O1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBwYXRoW2ldO1xuICAgICAgICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJ3cml0ZSB8fCBvYmpbcGF0aFtpXV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW3BhdGhbaV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pIHtcbiAgICAgICAgZWFjaChMQVlPVVRfUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChwcm9wWzBdIGluIG9wdGlvbiAmJiAhKHByb3BbMV0gaW4gb3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbltwcm9wWzFdXSA9IG9wdGlvbltwcm9wWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIExBWU9VVF9QUk9QRVJUSUVTID0gW1xuICAgICAgICBbJ3gnLCAnbGVmdCddLCBbJ3knLCAndG9wJ10sIFsneDInLCAncmlnaHQnXSwgWyd5MicsICdib3R0b20nXVxuICAgIF07XG5cbiAgICB2YXIgQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMgPSBbXG4gICAgICAgICdncmlkJywgJ2dlbycsICdwYXJhbGxlbCcsICdsZWdlbmQnLCAndG9vbGJveCcsICd0aXRsZScsICd2aXN1YWxNYXAnLCAnZGF0YVpvb20nLCAndGltZWxpbmUnXG4gICAgXTtcblxuICAgIHZhciBDT01QQVRJVEFCTEVfU0VSSUVTID0gW1xuICAgICAgICAnYmFyJywgJ2JveHBsb3QnLCAnY2FuZGxlc3RpY2snLCAnY2hvcmQnLCAnZWZmZWN0U2NhdHRlcicsXG4gICAgICAgICdmdW5uZWwnLCAnZ2F1Z2UnLCAnbGluZXMnLCAnZ3JhcGgnLCAnaGVhdG1hcCcsICdsaW5lJywgJ21hcCcsICdwYXJhbGxlbCcsXG4gICAgICAgICdwaWUnLCAncmFkYXInLCAnc2Fua2V5JywgJ3NjYXR0ZXInLCAndHJlZW1hcCdcbiAgICBdO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBlYWNoKG9wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNUeXBlID0gc2VyaWVzT3B0LnR5cGU7XG5cbiAgICAgICAgICAgIGNvbXBhdFN0eWxlKHNlcmllc09wdCk7XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXNUeXBlID09PSAncGllJyB8fCBzZXJpZXNUeXBlID09PSAnZ2F1Z2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc09wdC5jbG9ja1dpc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNPcHQuY2xvY2t3aXNlID0gc2VyaWVzT3B0LmNsb2NrV2lzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2dhdWdlJykge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyQ29sb3IgPSBnZXQoc2VyaWVzT3B0LCAncG9pbnRlci5jb2xvcicpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJDb2xvciAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmIHNldChzZXJpZXNPcHQsICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJywgcG9pbnRlckNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDT01QQVRJVEFCTEVfU0VSSUVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKENPTVBBVElUQUJMRV9TRVJJRVNbaV0gPT09IHNlcmllc09wdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMoc2VyaWVzT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkYXRhUmFuZ2UgaGFzIGNoYW5nZWQgdG8gdmlzdWFsTWFwXG4gICAgICAgIGlmIChvcHRpb24uZGF0YVJhbmdlKSB7XG4gICAgICAgICAgICBvcHRpb24udmlzdWFsTWFwID0gb3B0aW9uLmRhdGFSYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMsIGZ1bmN0aW9uIChjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbltjb21wb25lbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gW29wdGlvbnNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(0);\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanM/ODQ0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTc2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgUE9TU0lCTEVfU1RZTEVTID0gW1xuICAgICAgICAnYXJlYVN0eWxlJywgJ2xpbmVTdHlsZScsICdub2RlU3R5bGUnLCAnbGlua1N0eWxlJyxcbiAgICAgICAgJ2Nob3JkU3R5bGUnLCAnbGFiZWwnLCAnbGFiZWxMaW5lJ1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBjb21wYXRJdGVtU3R5bGUob3B0KSB7XG4gICAgICAgIHZhciBpdGVtU3R5bGVPcHQgPSBvcHQgJiYgb3B0Lml0ZW1TdHlsZTtcbiAgICAgICAgaWYgKGl0ZW1TdHlsZU9wdCkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goUE9TU0lCTEVfU1RZTEVTLCBmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEl0ZW1TdHlsZU9wdCA9IGl0ZW1TdHlsZU9wdC5ub3JtYWw7XG4gICAgICAgICAgICAgICAgdmFyIGVtcGhhc2lzSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0LmVtcGhhc2lzO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxJdGVtU3R5bGVPcHQgJiYgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0gPSBvcHRbc3R5bGVOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRbc3R5bGVOYW1lXS5ub3JtYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdFtzdHlsZU5hbWVdLm5vcm1hbCA9IG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLm5vcm1hbCwgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVtcGhhc2lzSXRlbVN0eWxlT3B0ICYmIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0gPSBvcHRbc3R5bGVOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0uZW1waGFzaXMgPSBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzLCBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgICAgICBpZiAoIXNlcmllc09wdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShzZXJpZXNPcHQpO1xuICAgICAgICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0Lm1hcmtQb2ludCk7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShzZXJpZXNPcHQubWFya0xpbmUpO1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc09wdC5kYXRhO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFyayBwb2ludCBkYXRhXG4gICAgICAgICAgICB2YXIgbWFya1BvaW50ID0gc2VyaWVzT3B0Lm1hcmtQb2ludDtcbiAgICAgICAgICAgIGlmIChtYXJrUG9pbnQgJiYgbWFya1BvaW50LmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXBEYXRhID0gbWFya1BvaW50LmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtcERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1wRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFyayBsaW5lIGRhdGFcbiAgICAgICAgICAgIHZhciBtYXJrTGluZSA9IHNlcmllc09wdC5tYXJrTGluZTtcbiAgICAgICAgICAgIGlmIChtYXJrTGluZSAmJiBtYXJrTGluZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1sRGF0YSA9IG1hcmtMaW5lLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KG1sRGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV1bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUobWxEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2hlbHBlci9jb21wYXRTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 177 */
/***/ (function(module, exports) {

eval("\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzP2QzZWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUIiwiZmlsZSI6IjE3Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBzYW1wbGVycyA9IHtcbiAgICAgICAgYXZlcmFnZTogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihmcmFtZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGZyYW1lW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgY291bnQgaXMgMFxuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09PSAwID8gTmFOIDogc3VtIC8gY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHN1bTogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgTmFOXG4gICAgICAgICAgICAgICAgc3VtICs9IGZyYW1lW2ldIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9LFxuICAgICAgICBtYXg6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFtZVtpXSA+IG1heCAmJiAobWF4ID0gZnJhbWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfSxcbiAgICAgICAgbWluOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFtZVtpXSA8IG1pbiAmJiAobWluID0gZnJhbWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBNZWRpYW5cbiAgICAgICAgbmVhcmVzdDogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGluZGV4U2FtcGxlciA9IGZ1bmN0aW9uIChmcmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZnJhbWUubGVuZ3RoIC8gMik7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgc2FtcGxpbmcgPSBzZXJpZXNNb2RlbC5nZXQoJ3NhbXBsaW5nJyk7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGRvd24gc2FtcGxpbmdcbiAgICAgICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnICYmIHNhbXBsaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICAgICAgLy8gQ29vcmRpbnN0ZSBzeXN0ZW0gaGFzIGJlZW4gcmVzaXplZFxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgIHZhciByYXRlID0gTWF0aC5yb3VuZChkYXRhLmNvdW50KCkgLyBzaXplKTtcbiAgICAgICAgICAgICAgICBpZiAocmF0ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbXBsZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2FtcGxpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVyID0gc2FtcGxlcnNbc2FtcGxpbmddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzYW1wbGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1wbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5kb3duU2FtcGxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXhpcy5kaW0sIDEgLyByYXRlLCBzYW1wbGVyLCBpbmRleFNhbXBsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5zZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var Scale = __webpack_require__(25);\n    var numberUtil = __webpack_require__(5);\n\n    // Use some method of IntervalScale\n    var IntervalScale = __webpack_require__(36);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL0xvZy5qcz85ZmRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTc4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2cgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9Mb2dcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcblxuICAgIC8vIFVzZSBzb21lIG1ldGhvZCBvZiBJbnRlcnZhbFNjYWxlXG4gICAgdmFyIEludGVydmFsU2NhbGUgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcbiAgICB2YXIgaW50ZXJ2YWxTY2FsZVByb3RvID0gSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0UHJlY2lzaW9uU2FmZSA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZTtcbiAgICB2YXIgcm91bmRpbmdFcnJvckZpeCA9IG51bWJlclV0aWwucm91bmQ7XG5cbiAgICB2YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcblxuICAgIHZhciBtYXRoTG9nID0gTWF0aC5sb2c7XG5cbiAgICB2YXIgTG9nU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsb2cnLFxuXG4gICAgICAgIGJhc2U6IDEwLFxuXG4gICAgICAgICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgU2NhbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsU2NhbGUgPSBuZXcgSW50ZXJ2YWxTY2FsZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAoaW50ZXJ2YWxTY2FsZVByb3RvLmdldFRpY2tzLmNhbGwodGhpcyksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG93VmFsID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoUG93KHRoaXMuYmFzZSwgdmFsKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXggIzQxNThcbiAgICAgICAgICAgICAgICBwb3dWYWwgPSAodmFsID09PSBleHRlbnRbMF0gJiYgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbilcbiAgICAgICAgICAgICAgICAgICAgPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMF0pXG4gICAgICAgICAgICAgICAgICAgIDogcG93VmFsO1xuICAgICAgICAgICAgICAgIHBvd1ZhbCA9ICh2YWwgPT09IGV4dGVudFsxXSAmJiBvcmlnaW5hbFNjYWxlLl9fZml4TWF4KVxuICAgICAgICAgICAgICAgICAgICA/IGZpeFJvdW5kaW5nRXJyb3IocG93VmFsLCBvcmlnaW5hbEV4dGVudFsxXSlcbiAgICAgICAgICAgICAgICAgICAgOiBwb3dWYWw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcG93VmFsO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWw6IGludGVydmFsU2NhbGVQcm90by5nZXRMYWJlbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhbCA9IHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhQb3codGhpcy5iYXNlLCB2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgICAgICAgICBzdGFydCA9IG1hdGhMb2coc3RhcnQpIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIGVuZCA9IG1hdGhMb2coZW5kKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBpbnRlcnZhbFNjYWxlUHJvdG8uc2V0RXh0ZW50LmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gZW5kXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHNjYWxlUHJvdG8uZ2V0RXh0ZW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFswXSk7XG4gICAgICAgICAgICBleHRlbnRbMV0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFsxXSk7XG5cbiAgICAgICAgICAgIC8vIEZpeCAjNDE1OFxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gJiYgKGV4dGVudFswXSA9IGZpeFJvdW5kaW5nRXJyb3IoZXh0ZW50WzBdLCBvcmlnaW5hbEV4dGVudFswXSkpO1xuICAgICAgICAgICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCAmJiAoZXh0ZW50WzFdID0gZml4Um91bmRpbmdFcnJvcihleHRlbnRbMV0sIG9yaWdpbmFsRXh0ZW50WzFdKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRlbnRcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAoZXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFNjYWxlLnVuaW9uRXh0ZW50KGV4dGVudCk7XG5cbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgZXh0ZW50WzBdID0gbWF0aExvZyhleHRlbnRbMF0pIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIGV4dGVudFsxXSA9IG1hdGhMb2coZXh0ZW50WzFdKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBzY2FsZVByb3RvLnVuaW9uRXh0ZW50LmNhbGwodGhpcywgZXh0ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbkV4dGVudEZyb21EYXRhOiBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgICAgICAgICB0aGlzLnVuaW9uRXh0ZW50KGRhdGEuZ2V0RGF0YUV4dGVudChkaW0sIHRydWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID4gMDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW2FwcHJveFRpY2tOdW0gPSAxMF0gR2l2ZW4gYXBwcm94IHRpY2sgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtKSB7XG4gICAgICAgICAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIGlmIChzcGFuID09PSBJbmZpbml0eSB8fCBzcGFuIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IG51bWJlclV0aWwucXVhbnRpdHkoc3Bhbik7XG4gICAgICAgICAgICB2YXIgZXJyID0gYXBwcm94VGlja051bSAvIHNwYW4gKiBpbnRlcnZhbDtcblxuICAgICAgICAgICAgLy8gRmlsdGVyIHRpY2tzIHRvIGdldCBjbG9zZXIgdG8gdGhlIGRlc2lyZWQgY291bnQuXG4gICAgICAgICAgICBpZiAoZXJyIDw9IDAuNSkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICo9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnRlcnZhbCBzaG91bGQgYmUgaW50ZWdlclxuICAgICAgICAgICAgd2hpbGUgKCFpc05hTihpbnRlcnZhbCkgJiYgTWF0aC5hYnMoaW50ZXJ2YWwpIDwgMSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuaWNlRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpLFxuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOaWNlIGV4dGVudC5cbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICBpbnRlcnZhbFNjYWxlUHJvdG8ubmljZUV4dGVudC5jYWxsKHRoaXMsIG9wdCk7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gPSBvcHQuZml4TWluO1xuICAgICAgICAgICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCA9IG9wdC5maXhNYXg7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgenJVdGlsLmVhY2goWydjb250YWluJywgJ25vcm1hbGl6ZSddLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICBMb2dTY2FsZS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YWwgPSBtYXRoTG9nKHZhbCkgLyBtYXRoTG9nKHRoaXMuYmFzZSk7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVQcm90b1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMb2dTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nU2NhbGUoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZml4Um91bmRpbmdFcnJvcih2YWwsIG9yaWdpbmFsVmFsKSB7XG4gICAgICAgIHJldHVybiByb3VuZGluZ0Vycm9yRml4KHZhbCwgZ2V0UHJlY2lzaW9uU2FmZShvcmlnaW5hbFZhbCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gTG9nU2NhbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvc2NhbGUvTG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = __webpack_require__(0);\n    var Scale = __webpack_require__(25);\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanM/NzU1NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE3OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGluZWFyIGNvbnRpbnVvdXMgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb29yZC9zY2FsZS9PcmRpbmFsXG4gKlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbF9vZl9tZWFzdXJlbWVudFxuICovXG5cbi8vIEZJWE1FIG9ubHkgb25lIGRhdGFcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKTtcblxuICAgIHZhciBzY2FsZVByb3RvID0gU2NhbGUucHJvdG90eXBlO1xuXG4gICAgdmFyIE9yZGluYWxTY2FsZSA9IFNjYWxlLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ29yZGluYWwnLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChkYXRhLCBleHRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5fZXh0ZW50ID0gZXh0ZW50IHx8IFswLCBkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHpyVXRpbC5pbmRleE9mKHRoaXMuX2RhdGEsIHZhbClcbiAgICAgICAgICAgICAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHJhbmspIHtcbiAgICAgICAgICAgIHJhbmsgPSB0aGlzLnBhcnNlKHJhbmspO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlUHJvdG8uY29udGFpbi5jYWxsKHRoaXMsIHJhbmspXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fZGF0YVtyYW5rXSAhPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3JtYWxpemUgZ2l2ZW4gcmFuayBvciBuYW1lIHRvIGxpbmVhciBbMCwgMV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbdmFsXVxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZVByb3RvLm5vcm1hbGl6ZS5jYWxsKHRoaXMsIHRoaXMucGFyc2UodmFsKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gW107XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHJhbmsgPSBleHRlbnRbMF07XG5cbiAgICAgICAgICAgIHdoaWxlIChyYW5rIDw9IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIHRpY2tzLnB1c2gocmFuayk7XG4gICAgICAgICAgICAgICAgcmFuaysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBpdGVtIG9uIHJhbmsgblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25dO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4dGVudFsxXSAtIHRoaXMuX2V4dGVudFswXSArIDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdW5pb25FeHRlbnRGcm9tRGF0YTogZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgICAgICAgICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldERhdGFFeHRlbnQoZGltLCBmYWxzZSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5pY2VUaWNrczogenJVdGlsLm5vb3AsXG4gICAgICAgIG5pY2VFeHRlbnQ6IHpyVXRpbC5ub29wXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICAgICAqL1xuICAgIE9yZGluYWxTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gT3JkaW5hbFNjYWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = __webpack_require__(0);\n    var numberUtil = __webpack_require__(5);\n    var formatUtil = __webpack_require__(10);\n    var scaleHelper = __webpack_require__(64);\n\n    var IntervalScale = __webpack_require__(36);\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME 公用？\n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum) {\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : numberUtil.getTimezoneOffset() * 60 * 1000;\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset)/ interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3NjYWxlL1RpbWUuanM/N2YyYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFOztBQUVBIiwiZmlsZSI6IjE4MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJ2YWwgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb29yZC9zY2FsZS9UaW1lXG4gKi9cblxuXG5cbiAgICAvLyBbQWJvdXQgVVRDIGFuZCBsb2NhbCB0aW1lIHpvbmVdOlxuICAgIC8vIEluIG1vc3QgY2FzZXMsIGBudW1iZXIucGFyc2VEYXRlYCB3aWxsIHRyZWF0IGlucHV0IGRhdGEgc3RyaW5nIGFzIGxvY2FsIHRpbWVcbiAgICAvLyAoZXhjZXB0IHRpbWUgem9uZSBpcyBzcGVjaWZpZWQgaW4gdGltZSBzdHJpbmcpLiBBbmQgYGZvcm1hdC5mb3JtYXRlVGltZWAgcmV0dXJuc1xuICAgIC8vIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC4gb3B0aW9uLnVzZVVUQyBpcyBmYWxzZSBieSBkZWZhdWx0LiBUaGlzIGRlc2lnbiBoYXZlXG4gICAgLy8gY29uY2lkZXJlZCB0aGVzZSBjb21tb24gY2FzZTpcbiAgICAvLyAoMSkgVGltZSB0aGF0IGlzIHBlcnNpc3RlbnQgaW4gc2VydmVyIGlzIGluIFVUQywgYnV0IGl0IGlzIG5lZWRlZCB0byBiZSBkaXBsYXllZFxuICAgIC8vIGluIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC5cbiAgICAvLyAoMikgQnkgZGVmYXVsdCwgdGhlIGlucHV0IGRhdGEgc3RyaW5nIChlLmcuLCAnMjAxMS0wMS0wMicpIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICAvLyBhcyBpdHMgb3JpZ2luYWwgdGltZSwgd2l0aG91dCBhbnkgdGltZSBkaWZmZXJlbmNlLlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIHNjYWxlSGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcblxuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuXG4gICAgdmFyIGludGVydmFsU2NhbGVQcm90byA9IEludGVydmFsU2NhbGUucHJvdG90eXBlO1xuXG4gICAgdmFyIG1hdGhDZWlsID0gTWF0aC5jZWlsO1xuICAgIHZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBPTkVfU0VDT05EID0gMTAwMDtcbiAgICB2YXIgT05FX01JTlVURSA9IE9ORV9TRUNPTkQgKiA2MDtcbiAgICB2YXIgT05FX0hPVVIgPSBPTkVfTUlOVVRFICogNjA7XG4gICAgdmFyIE9ORV9EQVkgPSBPTkVfSE9VUiAqIDI0O1xuXG4gICAgLy8gRklYTUUg5YWs55So77yfXG4gICAgdmFyIGJpc2VjdCA9IGZ1bmN0aW9uIChhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgICAgaWYgKGFbbWlkXVsyXSA8IHgpIHtcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaSAgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvVGltZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUaW1lU2NhbGUgPSBJbnRlcnZhbFNjYWxlLmV4dGVuZCh7XG4gICAgICAgIHR5cGU6ICd0aW1lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFyIHN0ZXBMdmwgPSB0aGlzLl9zdGVwTHZsO1xuXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHZhbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRVdGlsLmZvcm1hdFRpbWUoc3RlcEx2bFswXSwgZGF0ZSwgdGhpcy5nZXRTZXR0aW5nKCd1c2VVVEMnKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZUV4dGVudDogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIC8vIElmIGV4dGVudCBzdGFydCBhbmQgZW5kIGFyZSBzYW1lLCBleHBhbmQgdGhlbVxuICAgICAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgICAgICAgICAgIGV4dGVudFswXSAtPSBPTkVfREFZO1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSArPSBPTkVfREFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRhdGEgYW5kIGV4dGVudCBhcmUgW0luZmluaXR5LCAtSW5maW5pdHldXG4gICAgICAgICAgICBpZiAoZXh0ZW50WzFdID09PSAtSW5maW5pdHkgJiYgZXh0ZW50WzBdID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBleHRlbnRbMV0gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IGV4dGVudFsxXSAtIE9ORV9EQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlcik7XG5cbiAgICAgICAgICAgIC8vIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcblxuICAgICAgICAgICAgaWYgKCFvcHQuZml4TWluKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoRmxvb3IoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHQuZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoQ2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZVRpY2tzOiBmdW5jdGlvbiAoYXBwcm94VGlja051bSkge1xuICAgICAgICAgICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGhpcy5nZXRTZXR0aW5nKCd1c2VVVEMnKVxuICAgICAgICAgICAgICAgID8gMCA6IG51bWJlclV0aWwuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgIGFwcHJveFRpY2tOdW0gPSBhcHByb3hUaWNrTnVtIHx8IDEwO1xuXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICB2YXIgYXBwcm94SW50ZXJ2YWwgPSBzcGFuIC8gYXBwcm94VGlja051bTtcbiAgICAgICAgICAgIHZhciBzY2FsZUxldmVsc0xlbiA9IHNjYWxlTGV2ZWxzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpZHggPSBiaXNlY3Qoc2NhbGVMZXZlbHMsIGFwcHJveEludGVydmFsLCAwLCBzY2FsZUxldmVsc0xlbik7XG5cbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHNjYWxlTGV2ZWxzW01hdGgubWluKGlkeCwgc2NhbGVMZXZlbHNMZW4gLSAxKV07XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBsZXZlbFsyXTtcbiAgICAgICAgICAgIC8vIFNhbWUgd2l0aCBpbnRlcnZhbCBzY2FsZSBpZiBzcGFuIGlzIG11Y2ggbGFyZ2VyIHRoYW4gMSB5ZWFyXG4gICAgICAgICAgICBpZiAobGV2ZWxbMF0gPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyU3BhbiA9IHNwYW4gLyBpbnRlcnZhbDtcblxuICAgICAgICAgICAgICAgIC8vIEZyb20gXCJOaWNlIE51bWJlcnMgZm9yIEdyYXBoIExhYmVsc1wiIG9mIEdyYXBoaWMgR2Vtc1xuICAgICAgICAgICAgICAgIC8vIHZhciBuaWNlWWVhclNwYW4gPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgeWVhclN0ZXAgPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4gLyBhcHByb3hUaWNrTnVtLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGludGVydmFsICo9IHllYXJTdGVwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmljZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKG1hdGhDZWlsKChleHRlbnRbMF0gLSB0aW1lem9uZU9mZnNldCkgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKG1hdGhGbG9vcigoZXh0ZW50WzFdIC0gdGltZXpvbmVPZmZzZXQpLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgc2NhbGVIZWxwZXIuZml4RXh0ZW50KG5pY2VFeHRlbnQsIGV4dGVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0ZXBMdmwgPSBsZXZlbDtcbiAgICAgICAgICAgIC8vIEludGVydmFsIHdpbGwgYmUgdXNlZCBpbiBnZXRUaWNrc1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgICAgICAgICByZXR1cm4gK251bWJlclV0aWwucGFyc2VEYXRlKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgVGltZVNjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnZhbFNjYWxlUHJvdG9bbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCB0aGlzLnBhcnNlKHZhbCkpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gU3RlcHMgZnJvbSBkM1xuICAgIHZhciBzY2FsZUxldmVscyA9IFtcbiAgICAgICAgLy8gRm9ybWF0ICAgICAgIHN0ZXAgICAgaW50ZXJ2YWxcbiAgICAgICAgWydoaDptbTpzcycsICAgIDEsICAgICAgT05FX1NFQ09ORF0sICAgICAgICAgICAvLyAxc1xuICAgICAgICBbJ2hoOm1tOnNzJywgICAgNSwgICAgICBPTkVfU0VDT05EICogNV0sICAgICAgIC8vIDVzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAxMCwgICAgIE9ORV9TRUNPTkQgKiAxMF0sICAgICAgLy8gMTBzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAxNSwgICAgIE9ORV9TRUNPTkQgKiAxNV0sICAgICAgLy8gMTVzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAzMCwgICAgIE9ORV9TRUNPTkQgKiAzMF0sICAgICAgLy8gMzBzXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMSwgICAgICBPTkVfTUlOVVRFXSwgICAgICAgICAgLy8gMW1cbiAgICAgICAgWydoaDptbVxcbk1NLWRkJyw1LCAgICAgIE9ORV9NSU5VVEUgKiA1XSwgICAgICAvLyA1bVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEwLCAgICAgT05FX01JTlVURSAqIDEwXSwgICAgIC8vIDEwbVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDE1LCAgICAgT05FX01JTlVURSAqIDE1XSwgICAgIC8vIDE1bVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDMwLCAgICAgT05FX01JTlVURSAqIDMwXSwgICAgIC8vIDMwbVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEsICAgICAgT05FX0hPVVJdLCAgICAgICAgLy8gMWhcbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywyLCAgICAgIE9ORV9IT1VSICogMl0sICAgIC8vIDJoXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsNiwgICAgICBPTkVfSE9VUiAqIDZdLCAgICAvLyA2aFxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEyLCAgICAgT05FX0hPVVIgKiAxMl0sICAgLy8gMTJoXG4gICAgICAgIFsnTU0tZGRcXG55eXl5JywgMSwgICAgICBPTkVfREFZXSwgICAvLyAxZFxuICAgICAgICBbJ3dlZWsnLCAgICAgICAgNywgICAgICBPTkVfREFZICogN10sICAgICAgICAvLyA3ZFxuICAgICAgICBbJ21vbnRoJywgICAgICAgMSwgICAgICBPTkVfREFZICogMzFdLCAgICAgICAvLyAxTVxuICAgICAgICBbJ3F1YXJ0ZXInLCAgICAgMywgICAgICBPTkVfREFZICogMzgwIC8gNF0sICAvLyAzTVxuICAgICAgICBbJ2hhbGYteWVhcicsICAgNiwgICAgICBPTkVfREFZICogMzgwIC8gMl0sICAvLyA2TVxuICAgICAgICBbJ3llYXInLCAgICAgICAgMSwgICAgICBPTkVfREFZICogMzgwXSAgICAgICAvLyAxWVxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gICAgICovXG4gICAgVGltZVNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVTY2FsZSh7dXNlVVRDOiBtb2RlbC5lY01vZGVsLmdldCgndXNlVVRDJyl9KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUaW1lU2NhbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvc2NhbGUvVGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var Gradient = __webpack_require__(41);\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3Zpc3VhbC9zZXJpZXNDb2xvci5qcz83ZGY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTgxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudCcpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlQ29sb3Ioc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBjb2xvckFjY2Vzc1BhdGggPSAoc2VyaWVzTW9kZWwudmlzdWFsQ29sb3JBY2Nlc3NQYXRoIHx8ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gc2VyaWVzTW9kZWwuZ2V0KGNvbG9yQWNjZXNzUGF0aCkgLy8gU2V0IGluIGl0ZW1TdHlsZVxuICAgICAgICAgICAgICAgIHx8IHNlcmllc01vZGVsLmdldENvbG9yRnJvbVBhbGV0dGUoc2VyaWVzTW9kZWwuZ2V0KCduYW1lJykpOyAgLy8gRGVmYXVsdCBjb2xvclxuXG4gICAgICAgICAgICAvLyBGSVhNRSBTZXQgY29sb3IgZnVuY3Rpb24gb3IgdXNlIHRoZSBwbGF0dGUgY29sb3JcbiAgICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTtcblxuICAgICAgICAgICAgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnZnVuY3Rpb24nICYmICEoY29sb3IgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgsICdjb2xvcicsIGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGl0ZW1TdHlsZSBpbiBlYWNoIGRhdGEgaXRlbVxuICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtTW9kZWwuZ2V0KGNvbG9yQWNjZXNzUGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZW5jb2RlQ29sb3IpO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvdmlzdWFsL3Nlcmllc0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 182 */
/***/ (function(module, exports) {

eval("\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L19lY2hhcnRzQDMuNi4yQGVjaGFydHMvbGliL3Zpc3VhbC9zeW1ib2wuanM/YTUyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUIiwiZmlsZSI6IjE4Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZGVmYXVsdFN5bWJvbFR5cGUsIGxlZ2VuZFN5bWJvbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgLy8gRW5jb2RpbmcgdmlzdWFsIGZvciBhbGwgc2VyaWVzIGluY2x1ZGUgd2hpY2ggaXMgZmlsdGVyZWQgZm9yIGxlZ2VuZCBkcmF3aW5nXG4gICAgICAgIGVjTW9kZWwuZWFjaFJhd1Nlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sJykgfHwgZGVmYXVsdFN5bWJvbFR5cGU7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuXG4gICAgICAgICAgICBkYXRhLnNldFZpc3VhbCh7XG4gICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sOiBsZWdlbmRTeW1ib2wgfHwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgICAgICAgICAgICAgc3ltYm9sU2l6ZTogc3ltYm9sU2l6ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuICAgICAgICAgICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzeW1ib2xTaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIHN5bWJvbFNpemUocmF3VmFsdWUsIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtU3ltYm9sVHlwZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1TeW1ib2xTaXplID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIGl0ZW0gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJywgaXRlbVN5bWJvbFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIFRyYW5zZm9ybSBzeW1ib2xTaXplID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJywgaXRlbVN5bWJvbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX2VjaGFydHNAMy42LjJAZWNoYXJ0cy9saWIvdmlzdWFsL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = __webpack_require__(0);\n    var Draggable = __webpack_require__(217);\n\n    var Eventful = __webpack_require__(21);\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var lastHoveredTarget = lastHovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget && lastHoveredTarget.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            var el = targetInfo.target;\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downel = hoveredTarget;\n                // In case click triggered before mouseup\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL0hhbmRsZXIuanM/ZDk5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELGFBQWE7QUFDakUsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPLGFBQWEsa0JBQWtCO0FBQ3pELG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLG1DQUFtQztBQUN0RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTgzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBIYW5kbGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvSGFuZGxlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKHNoZW55aS45MTRAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRHJhZ2dhYmxlID0gcmVxdWlyZSgnLi9taXhpbi9EcmFnZ2FibGUnKTtcblxuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vRXZlbnRmdWwnKTtcblxuICAgIHZhciBTSUxFTlQgPSAnc2lsZW50JztcblxuICAgIGZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXRJbmZvLCBldmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZXZlVHlwZSxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIC8vIHRhcmdldCBjYW4gb25seSBiZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHNpbGVudC5cbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0SW5mby50YXJnZXQsXG4gICAgICAgICAgICAvLyB0b3BUYXJnZXQgY2FuIGJlIGEgc2lsZW50IGVsZW1lbnQuXG4gICAgICAgICAgICB0b3BUYXJnZXQ6IHRhcmdldEluZm8udG9wVGFyZ2V0LFxuICAgICAgICAgICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG9mZnNldFg6IGV2ZW50LnpyWCxcbiAgICAgICAgICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICAgICAgICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgICAgICAgICAgcGluY2hYOiBldmVudC5waW5jaFgsXG4gICAgICAgICAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICAgICAgICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgICAgICAgICB3aGVlbERlbHRhOiBldmVudC56ckRlbHRhLFxuICAgICAgICAgICAgenJCeVRvdWNoOiBldmVudC56ckJ5VG91Y2hcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBFbXB0eVByb3h5ICgpIHt9XG4gICAgRW1wdHlQcm94eS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdmFyIGhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuICAgIF07XG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0hhbmRsZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZSBTdG9yYWdlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlciBQYWludGVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eX0gcHJveHkgSGFuZGxlclByb3h5IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhaW50ZXJSb290IHBhaW50ZXIucm9vdCAobm90IHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkpLlxuICAgICAqL1xuICAgIHZhciBIYW5kbGVyID0gZnVuY3Rpb24oc3RvcmFnZSwgcGFpbnRlciwgcHJveHksIHBhaW50ZXJSb290KSB7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHRoaXMucGFpbnRlclJvb3QgPSBwYWludGVyUm9vdDtcblxuICAgICAgICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3h5IG9mIGV2ZW50LiBjYW4gYmUgRG9tLCBXZWJHTFN1cmZhY2UsIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJveHkgPSBwcm94eTtcblxuICAgICAgICAvLyBBdHRhY2ggaGFuZGxlclxuICAgICAgICBwcm94eS5oYW5kbGVyID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICoge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJlZCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RYO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFk7XG5cblxuICAgICAgICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcblxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHggPSBldmVudC56clg7XG4gICAgICAgICAgICB2YXIgeSA9IGV2ZW50LnpyWTtcblxuICAgICAgICAgICAgdmFyIGxhc3RIb3ZlcmVkID0gdGhpcy5faG92ZXJlZDtcbiAgICAgICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5faG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKHgsIHkpO1xuICAgICAgICAgICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcblxuICAgICAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICAgICAgICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZFRhcmdldCA/IGhvdmVyZWRUYXJnZXQuY3Vyc29yIDogJ2RlZmF1bHQnKTtcblxuICAgICAgICAgICAgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0ICYmIGxhc3RIb3ZlcmVkVGFyZ2V0Ll9fenIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5faG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBzb21lIGRvbXMgY3JlYXRlZCBieSB1cHBlciBsYXllciBhcHBsaWNhdGlvblxuICAgICAgICAgICAgLy8gYXQgdGhlIHNhbWUgbGV2ZWwgb2YgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSAoZS5nLiwgdG9vbHRpcFxuICAgICAgICAgICAgLy8gZG9tIGNyZWF0ZWQgYnkgZWNoYXJ0cyksIHdoZXJlICdnbG9iYWxvdXQnIGV2ZW50IHNob3VsZCBub3RcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCB3aGVuIG1vdXNlIGVudGVycyB0aGVzZSBkb21zLiAoQnV0ICdtb3VzZW91dCdcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQgdGhlIG9yaWdpbmFsIGhvdmVyZWQgZWxlbWVudCBhcyB1c3VhbCkuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGlubmVyRG9tO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSAmJiAhKFxuICAgICAgICAgICAgICAgIGlubmVyRG9tID0gZWxlbWVudCA9PT0gdGhpcy5wYWludGVyUm9vdFxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICFpbm5lckRvbSAmJiB0aGlzLnRyaWdnZXIoJ2dsb2JhbG91dCcsIHtldmVudDogZXZlbnR9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzaXplXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucHJveHkgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0SW5mbyB7dGFyZ2V0LCB0b3BUYXJnZXR9IOebruagh+WbvuW9ouWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaFRvRWxlbWVudDogZnVuY3Rpb24gKHRhcmdldEluZm8sIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgICAgICAgICB2YXIgZXZlbnRQYWNrZXQgPSBtYWtlRXZlbnRQYWNrZXQoZXZlbnROYW1lLCB0YXJnZXRJbmZvLCBldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBlbCA9IHRhcmdldEluZm8udGFyZ2V0O1xuICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgICAgZWxbZXZlbnRIYW5kbGVyXVxuICAgICAgICAgICAgICAgICAgICAmJiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlID0gZWxbZXZlbnRIYW5kbGVyXS5jYWxsKGVsLCBldmVudFBhY2tldCkpO1xuXG4gICAgICAgICAgICAgICAgZWwudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcblxuICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8g5YaS5rOh5Yiw6aG257qnIHpyZW5kZXIg5a+56LGhXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgIC8vIOWIhuWPkeS6i+S7tuWIsOeUqOaIt+iHquWumuS5ieWxglxuICAgICAgICAgICAgICAgIC8vIOeUqOaIt+acieWPr+iDveWcqOWFqOWxgCBjbGljayDkuovku7bkuK0gZGlzcG9zZe+8jOaJgOS7pemcgOimgeWIpOaWreS4iyBwYWludGVyIOaYr+WQpuWtmOWcqFxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlciAmJiB0aGlzLnBhaW50ZXIuZWFjaE90aGVyTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YobGF5ZXJbZXZlbnRIYW5kbGVyXSkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJbZXZlbnRIYW5kbGVyXS5jYWxsKGxheWVyLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfSBleGNsdWRlXG4gICAgICAgICAqIEByZXR1cm4ge21vZGVsOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEhvdmVyOiBmdW5jdGlvbih4LCB5LCBleGNsdWRlKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaG92ZXJDaGVja1Jlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAobGlzdFtpXSAhPT0gZXhjbHVkZVxuICAgICAgICAgICAgICAgICAgICAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgJiYgIWxpc3RbaV0uaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICYmIChob3ZlckNoZWNrUmVzdWx0ID0gaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgIW91dC50b3BUYXJnZXQgJiYgKG91dC50b3BUYXJnZXQgPSBsaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdmVyQ2hlY2tSZXN1bHQgIT09IFNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnRhcmdldCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDb21tb24gaGFuZGxlcnNcbiAgICB1dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSk7XG4gICAgICAgICAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb3duZWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgY2xpY2sgdHJpZ2dlcmVkIGJlZm9yZSBtb3VzZXVwXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBlbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnbW9zdWV1cCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZG93bmVsICE9PSB0aGlzLl91cGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgbmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaXNIb3ZlcihkaXNwbGF5YWJsZSwgeCwgeSkge1xuICAgICAgICBpZiAoZGlzcGxheWFibGVbZGlzcGxheWFibGUucmVjdEhvdmVyID8gJ3JlY3RDb250YWluJyA6ICdjb250YWluJ10oeCwgeSkpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgICAgICAgICAgdmFyIGlzU2lsZW50O1xuICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2xpcHBlZCBieSBhbmNlc3Rvci5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogSWYgY2xpcFBhdGggaGFzIG5laXRoZXIgc3Ryb2tlIG5vciBmaWxsLFxuICAgICAgICAgICAgICAgIC8vIGVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgICAgIGlmIChlbC5jbGlwUGF0aCAmJiAhZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWwuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTaWxlbnQgPyBTSUxFTlQgOiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = __webpack_require__(0);\n    var config = __webpack_require__(26);\n    var Style = __webpack_require__(77);\n    var Pattern = __webpack_require__(76);\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL0xheWVyLmpzPzA3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxODQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9MYXllclxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9ncmFwaGljL1N0eWxlJyk7XG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL2dyYXBoaWMvUGF0dGVybicpO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7pkb21cbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZG9tIHR5cGXvvIxzdWNoIGFzIGNhbnZhcywgZGl2IGV0Yy5cbiAgICAgKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb20oaWQsIHR5cGUsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgbmV3RG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcblxuICAgICAgICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7XG4gICAgICAgIC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cbiAgICAgICAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgIC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG4gICAgICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAgICAgKi9cbiAgICB2YXIgTGF5ZXIgPSBmdW5jdGlvbihpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBkb207XG4gICAgICAgIGRwciA9IGRwciB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgJ2NhbnZhcycsIHBhaW50ZXIsIGRwcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICAgICAgICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRvbS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7IC8vIE5vdCBpbiBub2RlXG4gICAgICAgICAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ21hcmdpbiddID0gMDtcbiAgICAgICAgICAgIGRvbVN0eWxlWydib3JkZXItd2lkdGgnXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuXG4gICAgICAgIC8vIENvbmZpZ3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIGRwclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgfTtcblxuICAgIExheWVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG5cbiAgICAgICAgZWxDb3VudDogMCxcblxuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66K+l5bGC55S75biDXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgLy8gR3JhZGllbnRcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL0xheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = __webpack_require__(26);\n    var util = __webpack_require__(0);\n    var log = __webpack_require__(74);\n    var BoundingRect = __webpack_require__(11);\n    var timsort = __webpack_require__(39);\n\n    var Layer = __webpack_require__(184);\n\n    var requestAnimationFrame = __webpack_require__(70);\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = __webpack_require__(75);\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL1BhaW50ZXIuanM/MGU1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxZQUFZOztBQUV0RDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE4NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbiBcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi9jb3JlL2xvZycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCcuL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpO1xuXG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgLy8gUEVORElHTlxuICAgIC8vIExheWVyIGV4Y2VlZHMgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiBtYXkgaGF2ZSBzb21lIHByb2JsZW0gd2hlbiBmbHVzaCBkaXJlY3RseSBzZWNvbmQgdGltZS5cbiAgICAvL1xuICAgIC8vIE1heGltdW0gcHJvZ3Jlc3NpdmUgbGF5ZXIuIFdoZW4gZXhjZWVkaW5nIHRoaXMgbnVtYmVyLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBkcmF3ZWQgaW4gdGhlIGxhc3QgbGF5ZXIuXG4gICAgdmFyIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgPSA1O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGF5ZXJWYWxpZChsYXllcikge1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFja1xuICAgICAgICAgICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21Sb290LnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICAncG9zaXRpb246cmVsYXRpdmUnLFxuICAgICAgICAgICAgJ292ZXJmbG93OmhpZGRlbicsXG4gICAgICAgICAgICAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQ6JyArIGhlaWdodCArICdweCcsXG4gICAgICAgICAgICAncGFkZGluZzowJyxcbiAgICAgICAgICAgICdtYXJnaW46MCcsXG4gICAgICAgICAgICAnYm9yZGVyLXdpZHRoOjAnXG4gICAgICAgIF0uam9pbignOycpICsgJzsnO1xuXG4gICAgICAgIHJldHVybiBkb21Sb290O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0ge09qYmVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMpIHtcbiAgICAgICAgLy8gSW4gbm9kZSBlbnZpcm9ubWVudCB1c2luZyBub2RlLWNhbnZhc1xuICAgICAgICB2YXIgc2luZ2xlQ2FudmFzID0gIXJvb3Qubm9kZU5hbWUgLy8gSW4gbm9kZSA/XG4gICAgICAgICAgICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuXG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzID0gdXRpbC5leHRlbmQoe30sIG9wdHMgfHwge30pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBvcHRzLmRldmljZVBpeGVsUmF0aW8gfHwgY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NpbmdsZUNhbnZhcyA9IHNpbmdsZUNhbnZhcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7mOWbvuWuueWZqFxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIHZhciByb290U3R5bGUgPSByb290LnN0eWxlO1xuXG4gICAgICAgIGlmIChyb290U3R5bGUpIHtcbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID1cbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIHJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9MYXllcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn1cbiAgICAgICAgICogQHR5cGUge3ByaXZhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gICAgICAgIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuXG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KFxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgICAgICAgICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGF5ZXJzWzBdID0gbWFpbkxheWVyO1xuICAgICAgICAgICAgemxldmVsTGlzdC5wdXNoKDApO1xuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID0gcm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExheWVycyBmb3IgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvdmVybGF5ZXI7XG5cbiAgICAgICAgdGhpcy5faG92ZXJFbGVtZW50cyA9IFtdO1xuICAgIH07XG5cbiAgICBQYWludGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllci5yZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogZWwuc2hhcGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxNaXJyb3IuX19mcm9tID0gZWw7XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gZWxNaXJyb3I7XG4gICAgICAgICAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgICAgICAgICAgLy8gRklYTUU/XG4gICAgICAgICAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEVsID0gZWwuX19mcm9tO1xuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwudHJhbnNmb3JtID0gb3JpZ2luYWxFbC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IG9yaWdpbmFsRWwuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0UHJvZ2Vzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHpyLnJlZnJlc2ggY2FsbGluZy5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiAmJiBzZWxmLnN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgaWYgKHBhaW50QWxsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXllclN0YXR1cyhsaXN0KTtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocHJlUHJvY2Vzc0xheWVyKTtcblxuICAgICAgICAgICAgdGhpcy5fZG9QYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICAgICAgICAgIHZhciBjdHg7XG5cbiAgICAgICAgICAgIC8vIHZhciBpbnZUcmFuc2Zvcm0gPSBbXTtcbiAgICAgICAgICAgIHZhciBzY29wZTtcblxuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5ZXJQcm9ncmVzcztcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcbiAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGVsWkxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcblxuICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBkcmF3IGxheWVyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRaTGV2ZWwgIT09IGVsWkxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzY29wZVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgMCB6bGV2ZWwgaWYgb25seSBoYXMgb25lIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WkxldmVsID0gZWxaTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllciA9IHRoaXMuZ2V0TGF5ZXIoY3VycmVudFpMZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWkxldmVsICcgKyBjdXJyZW50WkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX191bnVzZWRDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2dyZXNzaXZlIGxheWVyIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVyc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVySWR4KyssIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID4gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVpY2sganVtcCBhbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudCBhcmUgbm90IGRpcnR5LCBqdW1wIG92ZXIgYW5kIGZsdXNoIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJQcm9ncmVzcyA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID0gZnJhbWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPT09IGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuICAgICAgICAgICAgY3R4ICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyBJZiBzdGlsbCBoYXMgY2xpcHBpbmcgc3RhdGVcbiAgICAgICAgICAgIC8vIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gbGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICB2YXIgbSA9IGVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoY3VycmVudExheWVyLl9fZGlydHkgfHwgZm9yY2VQYWludClcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhZWwuaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHRyYW5zcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiBlbC5zdHlsZS5vcGFjaXR5ICE9PSAwXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIHNjYWxlIDAgZWxlbWVudCBjYW4gY2F1c2UgYWxsIGZvbGxvd2luZyBkcmF3IHdyb25nXG4gICAgICAgICAgICAgICAgLy8gQW5kIHNldFRyYW5zZm9ybSB3aXRoIHNjYWxlIDAgd2lsbCBjYXVzZSBzZXQgYmFjayB0cmFuc2Zvcm0gZmFpbGVkLlxuICAgICAgICAgICAgICAgICYmICEobSAmJiAhbVswXSAmJiAhbVszXSlcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZDbGlwTGF5ZXIgIT09IGN1cnJlbnRMYXllclxuICAgICAgICAgICAgICAgICAgICB8fCBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHNjb3BlLnByZXZFbENsaXBQYXRocylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcblxuICAgICAgICAgICAgICAgIGVsLmJydXNoKGN0eCwgc2NvcGUucHJldkVsIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IGVsO1xuXG4gICAgICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPliB6bGV2ZWwg5omA5Zyo5bGC77yM5aaC5p6c5LiN5a2Y5Zyo5YiZ5Lya5Yib5bu65LiA5Liq5paw55qE5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICAgICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuICAgICAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB6bGV2ZWxMaXN0W2ldIDwgemxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgICAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyO1xuXG4gICAgICAgICAgICAvLyBWaXR1YWwgbGF5ZXIgd2lsbCBub3QgZGlyZWN0bHkgc2hvdyBvbiB0aGUgc2NyZWVuLlxuICAgICAgICAgICAgLy8gKEl0IGNhbiBiZSBhIFdlYkdMIGxheWVyIGFuZCBhc3NpZ25lZCB0byBhIFpJbWFnZSBlbGVtZW50KVxuICAgICAgICAgICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cbiAgICAgICAgICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkRvbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEb20ubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgICAgICAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoQnVpbHRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGlucHV0IHcvaFxuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgd2lkdGggIT0gbnVsbCAmJiAob3B0cy53aWR0aCA9IHdpZHRoKTtcbiAgICAgICAgICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG5cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmHiuaUvlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICB0aGlzLnJvb3QgPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cblxuICAgICAgICAgICAgdGhpcy5fZG9tUm9vdCA9XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbWFnZUxheWVyID0gbmV3IExheWVyKCdpbWFnZScsIHRoaXMsIG9wdHMucGl4ZWxSYXRpbyB8fCB0aGlzLmRwcik7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGltYWdlTGF5ZXIuY2xlYXJDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICAgICAgdmFyIHpsZXZlbDtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEFuZERyYXdPdGhlckxheWVyKHNtYWxsZXIsIGxhcmdlcikge1xuICAgICAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoc21hbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXIgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGVMYXllcjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgeiA+IHNtYWxsZXIgJiYgeiA8IGxhcmdlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlTGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIGlmIChlbC56bGV2ZWwgIT09IHpsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBlbC56bGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB6bGV2ZWwgPSBlbC56bGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaW1hZ2VMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFNpemU6IGZ1bmN0aW9uICh3aElkeCkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgY3doID0gWydjbGllbnRXaWR0aCcsICdjbGllbnRIZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgcGx0ID0gWydwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJ11bd2hJZHhdO1xuICAgICAgICAgICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICAgICAgICAgIGlmIChvcHRzW3doXSAhPSBudWxsICYmIG9wdHNbd2hdICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHJvb3RbY3doXSB8fCBwYXJzZUludDEwKHN0bFt3aF0pIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZVt3aF0pKVxuICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsW3BsdF0pIHx8IDApXG4gICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMClcbiAgICAgICAgICAgICkgfCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAocGF0aCwgZHByKSB7XG4gICAgICAgICAgICBkcHIgPSBkcHIgfHwgdGhpcy5kcHI7XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHBhdGguc3R5bGU7XG4gICAgICAgICAgICB2YXIgc2hhZG93Qmx1clNpemUgPSBzdHlsZS5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZS5zaGFkb3dPZmZzZXRZO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUubGluZVdpZHRoIDogMDtcblxuICAgICAgICAgICAgdmFyIGxlZnRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciByaWdodE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgYm90dG9tTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggKyBsZWZ0TWFyZ2luICsgcmlnaHRNYXJnaW47XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgY3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjdHguZHByID0gZHByO1xuXG4gICAgICAgICAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF0aC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcGF0aC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhdGgucG9zaXRpb24gPSBbbGVmdE1hcmdpbiAtIHJlY3QueCwgdG9wTWFyZ2luIC0gcmVjdC55XTtcbiAgICAgICAgICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgcGF0aC5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgICAgIHBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGguYnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIEltYWdlU2hhcGUgPSByZXF1aXJlKCcuL2dyYXBoaWMvSW1hZ2UnKTtcbiAgICAgICAgICAgIHZhciBpbWdTaGFwZSA9IG5ldyBJbWFnZVNoYXBlKHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUucm90YXRpb24gPSBwYXRoLnJvdGF0aW9uID0gcGF0aFRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnNjYWxlID0gcGF0aC5zY2FsZSA9IHBhdGhUcmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWdTaGFwZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhaW50ZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = __webpack_require__(0);\n    var env = __webpack_require__(6);\n\n    var Group = __webpack_require__(27);\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = __webpack_require__(39);\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath 的变换是基于使用这个 clipPath 的元素\n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // 不指定el清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL1N0b3JhZ2UuanM/YzRjZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELFNBQVM7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixxQkFBcUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSIsImZpbGUiOiIxODYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIFN0b3JhZ2XlhoXlrrnku5PlupPmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9TdG9yYWdlXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcvKVxuICovXG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuXG4gICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnLi9jb250YWluZXIvR3JvdXAnKTtcblxuICAgIC8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4gICAgLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuICAgIHZhciB0aW1zb3J0ID0gcmVxdWlyZSgnLi9jb3JlL3RpbXNvcnQnKTtcblxuICAgIGZ1bmN0aW9uIHNoYXBlQ29tcGFyZUZ1bmMoYSwgYikge1xuICAgICAgICBpZiAoYS56bGV2ZWwgPT09IGIuemxldmVsKSB7XG4gICAgICAgICAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYS56MiA9PT0gYi56Mikge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ3Y2NlNTQ0YTMxZWQ1NTc3ZmZlMjk2M2Y2N2FjYjQxNDRlZTAyMzIvc3JjL2pzL2FycmF5LmpzI0wxMDEyXG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5YaF5a655LuT5bqTIChNKVxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgfTtcblxuICAgIFN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgICAgICpcbiAgICAgICAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAgICAgICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgICAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcblxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICAgICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG5cbiAgICAgICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuXG4gICAgICAgICAgICAgICAgZWwudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYWZ0ZXJVcGRhdGUoKTtcblxuICAgICAgICAgICAgdmFyIHVzZXJTZXRDbGlwUGF0aCA9IGVsLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5pWI546H5b2x5ZONXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBjbGlwUGF0aHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2xpcFBhdGggPSB1c2VyU2V0Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENsaXBQYXRoID0gZWw7XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgYWRkIGNsaXAgcGF0aFxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpcFBhdGgg55qE5Y+Y5o2i5piv5Z+65LqO5L2/55So6L+Z5LiqIGNsaXBQYXRoIOeahOWFg+e0oFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGgucGFyZW50ID0gcGFyZW50Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMucHVzaChjdXJyZW50Q2xpcFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguY2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBfX2RpcnR5UGF0aCA/XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGNoaWxkLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hcmsgZ3JvdXAgY2xlYW4gaGVyZVxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdFt0aGlzLl9kaXNwbGF5TGlzdExlbisrXSA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKeWIsOagueiKgueCuVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGRSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5fX3N0b3JhZ2UgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRkVG9TdG9yYWdlKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsXSDlpoLmnpzkuLrnqbrmuIXnqbrmlbTkuKpTdG9yYWdlXG4gICAgICAgICAqL1xuICAgICAgICBkZWxSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5oyH5a6aZWzmuIXnqbpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxSb290KGVsW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsRnJvbVN0b3JhZ2UoZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFRvU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICAgICAgZWwuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxGcm9tU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGlzdCA9XG4gICAgICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2U7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = __webpack_require__(0);\n    var Dispatcher = __webpack_require__(19).Dispatcher;\n\n    var requestAnimationFrame = __webpack_require__(70);\n\n    var Animator = __webpack_require__(69);\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanM/YjNlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIxODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpLkRpc3BhdGNoZXI7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4vQW5pbWF0b3InKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICAgICAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICAgKiAgICAgdmFyIG9iaiA9IHtcbiAgICAgKiAgICAgICAgIHg6IDEwMCxcbiAgICAgKiAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICB9O1xuICAgICAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAqICAgICAgICAgICAgIHg6IDUwMCxcbiAgICAgKiAgICAgICAgICAgICB5OiA1MDBcbiAgICAgKiAgICAgICAgIH0pXG4gICAgICogICAgICAgICAud2hlbigyMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG9wdGlvbnMuc3RhZ2UgfHwge307XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX2NsaXBzID0gW107XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RpbWU7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgIGNsaXBcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAgICAgICAqL1xuICAgICAgICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXA6IGZ1bmN0aW9uKGNsaXApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICAgICAgICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBlID0gY2xpcC5zdGVwKHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHN0YWdlLnVwZGF0ZSwgbGlrZSBkZXN0cm95XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbiA9IGRlZmVycmVkRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgICAgICAgdGhpcy5vbmZyYW1lKGRlbHRhKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhZ2UudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLl9wYXVzZWQgJiYgc2VsZi5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i6L+Q6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdXNlXG4gICAgICAgICAqL1xuICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdW1lXG4gICAgICAgICAqL1xuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTmiYDmnInliqjnlLvniYfmrrVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5a+55LiA5Liq55uu5qCH5Yib5bu65LiA5LiqYW5pbWF0b3Llr7nosaHvvIzlj6/ku6XmjIflrprnm67moIfkuK3nmoTlsZ7mgKfkvb/nlKjliqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmxvb3A9ZmFsc2VdIOaYr+WQpuW+queOr+aSreaUvuWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2V0dGVyPW51bGxdXG4gICAgICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6aZ2V0dGVy5Ye95pWw77yM5Lya6YCa6L+HZ2V0dGVy5Ye95pWw5Y+W5bGe5oCn5YC8XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5zZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppzZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dzZXR0ZXLlh73mlbDorr7nva7lsZ7mgKflgLxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn5BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gR2FwXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldHRlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBbmltYXRvcihhbmltYXRvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB1dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = __webpack_require__(189);\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzPzQ2ZDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxODguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cblxuXG4gICAgdmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZSgnLi9lYXNpbmcnKTtcblxuICAgIGZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gICAgICAgIC8vIOeUn+WRveWRqOacn1xuICAgICAgICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7XG4gICAgICAgIC8vIOW7tuaXtlxuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgICAgICAgLy8g5byA5aeL5pe26Ze0XG4gICAgICAgIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8g5piv5ZCm5b6q546vXG4gICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG5cbiAgICAgICAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICAgICAgICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICAgICAgICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBDbGlwLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2xpcCxcblxuICAgICAgICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgLyB0aGlzLl9saWZlO1xuXG4gICAgICAgICAgICAvLyDov5jmsqHlvIDlp4tcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuXG4gICAgICAgICAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgICAgICAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGVhc2luZ0Z1bmMocGVyY2VudClcbiAgICAgICAgICAgICAgICA6IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7XG5cbiAgICAgICAgICAgIC8vIOe7k+adn1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0IChnbG9iYWxUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5byA5aeL5ZGo5pyfXG4gICAgICAgICAgICAgICAgICAgIC8vIOaKm+WHuuiAjOS4jeaYr+ebtOaOpeiwg+eUqOS6i+S7tuebtOWIsCBzdGFnZS51cGRhdGUg5ZCO5YaN57uf5LiA6LCD55So6L+Z5Lqb5LqL5Lu2XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g5Yqo55S75a6M5oiQ5bCG6L+Z5Liq5o6n5Yi25Zmo5qCH6K+G5Li65b6F5Yig6ZmkXG4gICAgICAgICAgICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsaXA7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 189 */
/***/ (function(module, exports) {

eval("/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanM/ODU5OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog57yT5Yqo5Luj56CB5p2l6IeqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzL2Jsb2IvbWFzdGVyL3NyYy9Ud2Vlbi5qc1xuICogQHNlZSBodHRwOi8vc29sZS5naXRodWIuaW8vdHdlZW4uanMvZXhhbXBsZXMvMDNfZ3JhcGhzLmh0bWxcbiAqIEBleHBvcnRzIHpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ1xuICovXG5cbiAgICB2YXIgZWFzaW5nID0ge1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS6lOasoeaWueeahOe8k+WKqO+8iHReNe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnIblvaLmm7Lnur/nmoTnvJPliqjvvIhzcXJ0KDEtdF4yKe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhICogTWF0aC5wb3coMiwgLTEwICogaykgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuW8uei3s+aViOaenFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAoMSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVhc2luZztcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var normalizeRadian = __webpack_require__(71).normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzPzBkY2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE5MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICkge1xuXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuXG4gICAgICAgICAgICB4IC09IGN4O1xuICAgICAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgICAgICAgICBpZiAoKGQgLSBfbCA+IHIpIHx8IChkICsgX2wgPCByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgfHwgKGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9jb250YWluL2FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var curve = __webpack_require__(18);\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanM/ZjIwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sICYmIHkgPiB5MyArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sICYmIHggPCB4MyAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5jdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 192 */
/***/ (function(module, exports) {

eval("\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcz9iYjJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnur/mrrXljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICB2YXIgX2EgPSAwO1xuICAgICAgICAgICAgdmFyIF9iID0geDA7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4MCAhPT0geDEpIHtcbiAgICAgICAgICAgICAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICAgICAgICAgICAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSkgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcCA9IF9hICogeCAtIHkgKyBfYjtcbiAgICAgICAgICAgIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var CMD = __webpack_require__(28).CMD;\n    var line = __webpack_require__(192);\n    var cubic = __webpack_require__(191);\n    var quadratic = __webpack_require__(194);\n    var arc = __webpack_require__(190);\n    var normalizeRadian = __webpack_require__(71).normalizeRadian;\n    var curve = __webpack_require__(18);\n\n    var windingLine = __webpack_require__(195);\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qcz81NTQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIGxpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbiAgICB2YXIgY3ViaWMgPSByZXF1aXJlKCcuL2N1YmljJyk7XG4gICAgdmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoJy4vcXVhZHJhdGljJyk7XG4gICAgdmFyIGFyYyA9IHJlcXVpcmUoJy4vYXJjJyk7XG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICB2YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKCcuL3dpbmRpbmdMaW5lJyk7XG5cbiAgICB2YXIgY29udGFpblN0cm9rZSA9IGxpbmUuY29udGFpblN0cm9rZTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuICAgIHZhciBFUFNJTE9OID0gMWUtNDtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvLyDkuLTml7bmlbDnu4RcbiAgICB2YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG4gICAgdmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuICAgIGZ1bmN0aW9uIHN3YXBFeHRyZW1hKCkge1xuICAgICAgICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgICAgICAgZXh0cmVtYVswXSA9IGV4dHJlbWFbMV07XG4gICAgICAgIGV4dHJlbWFbMV0gPSB0bXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MylcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG4gICAgICAgIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgICAgICAgICB2YXIgeTBfLCB5MV87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByb290c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbkV4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwRXh0cmVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPCBleHRyZW1hWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkxXyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkzIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MilcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUucXVhZHJhdGljUm9vdEF0KHkwLCB5MSwgeTIsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdCA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MiA8IHlfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1swXSA9PT0gMCB8fCByb290c1swXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuICAgICAgICAgICAgICAgIGlmICh4XyA8IHgpIHsgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5MiA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ET1xuICAgIC8vIEFyYyDml4vovaxcbiAgICBmdW5jdGlvbiB3aW5kaW5nQXJjKFxuICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCB4LCB5XG4gICAgKSB7XG4gICAgICAgIHkgLT0gY3k7XG4gICAgICAgIGlmICh5ID4gciB8fCB5IDwgLXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0bXAgPSBNYXRoLnNxcnQociAqIHIgLSB5ICogeSk7XG4gICAgICAgIHJvb3RzWzBdID0gLXRtcDtcbiAgICAgICAgcm9vdHNbMV0gPSB0bXA7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuICAgICAgICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmICh4ID49IHJvb3RzWzBdICsgY3ggJiYgeCA8PSByb290c1sxXSArIGN4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4XyA9IHJvb3RzW2ldO1xuICAgICAgICAgICAgaWYgKHhfICsgY3ggPiB4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICAgICB8fCAoYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSAtZGlyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgdmFyIHgwID0gMDtcbiAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIC8vIEJlZ2luIGEgbmV3IHN1YnBhdGhcbiAgICAgICAgICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSDlnKjnrKzkuIDkuKrlkb3ku6TkuLogTCwgQywgUSDnmoTml7blgJnkvJrorqHnrpflh7ogTmFOXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nQ3ViaWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5peL6L2sXG4gICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF94ID0gKHggLSBjeCkgKiByeSAvIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyYy5jb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gTWF0aC5jb3ModGhldGEgKyBkVGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDEsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgwLCB5MSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIENsb2Nrd2lzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgYSBzdWJwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ICE9PSAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAocGF0aERhdGEsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgMCwgZmFsc2UsIHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uIChwYXRoRGF0YSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var curve = __webpack_require__(18);\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzPzMyOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTk0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6jOasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5xdWFkcmF0aWNQcm9qZWN0UG9pbnQoXG4gICAgICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 195 */
/***/ (function(module, exports) {

eval("\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanM/N2Y4YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiIxOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdpbmRpbmdMaW5lKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gICAgICAgIGlmICgoeSA+IHkwICYmIHkgPiB5MSkgfHwgKHkgPCB5MCAmJiB5IDwgeTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgaG9yaXpvbnRhbCBsaW5lXG4gICAgICAgIGlmICh5MSA9PT0geTApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICAgICAgICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApO1xuXG4gICAgICAgIC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuICAgICAgICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgICAgICAgICBkaXIgPSB5MSA8IHkwID8gMC41IDogLTAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4XyA9IHQgKiAoeDEgLSB4MCkgKyB4MDtcblxuICAgICAgICByZXR1cm4geF8gPiB4ID8gZGlyIDogMDtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = __webpack_require__(19);\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvR2VzdHVyZU1nci5qcz9iNGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JELHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTk2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cblxuXG4gICAgdmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcblxuICAgIHZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90cmFjayA9IFtdO1xuICAgIH07XG5cbiAgICBHZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcblxuICAgICAgICByZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblxuICAgICAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgdG91Y2hlczogW10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoLCB7fSk7XG4gICAgICAgICAgICAgICAgdHJhY2tJdGVtLnBvaW50cy5wdXNoKFtwb3MuenJYLCBwb3MuenJZXSk7XG4gICAgICAgICAgICAgICAgdHJhY2tJdGVtLnRvdWNoZXMucHVzaCh0b3VjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByZWNvZ25pemVycykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvZ25pemVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IHJlY29nbml6ZXJzW2V2ZW50TmFtZV0odGhpcy5fdHJhY2ssIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VzdHVyZUluZm87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGlzdChwb2ludFBhaXIpIHtcbiAgICAgICAgdmFyIGR4ID0gcG9pbnRQYWlyWzFdWzBdIC0gcG9pbnRQYWlyWzBdWzBdO1xuICAgICAgICB2YXIgZHkgPSBwb2ludFBhaXJbMV1bMV0gLSBwb2ludFBhaXJbMF1bMV07XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKHBvaW50UGFpclswXVswXSArIHBvaW50UGFpclsxXVswXSkgLyAyLFxuICAgICAgICAgICAgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIHJlY29nbml6ZXJzID0ge1xuXG4gICAgICAgIHBpbmNoOiBmdW5jdGlvbiAodHJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tMZW4gPSB0cmFjay5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwaW5jaEVuZCA9ICh0cmFja1t0cmFja0xlbiAtIDFdIHx8IHt9KS5wb2ludHM7XG4gICAgICAgICAgICB2YXIgcGluY2hQcmUgPSAodHJhY2tbdHJhY2tMZW4gLSAyXSB8fCB7fSkucG9pbnRzIHx8IHBpbmNoRW5kO1xuXG4gICAgICAgICAgICBpZiAocGluY2hQcmVcbiAgICAgICAgICAgICAgICAmJiBwaW5jaFByZS5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmRcbiAgICAgICAgICAgICAgICAmJiBwaW5jaEVuZC5sZW5ndGggPiAxXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGluY2hTY2FsZSA9IGRpc3QocGluY2hFbmQpIC8gZGlzdChwaW5jaFByZSk7XG4gICAgICAgICAgICAgICAgIWlzRmluaXRlKHBpbmNoU2NhbGUpICYmIChwaW5jaFNjYWxlID0gMSk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcblxuICAgICAgICAgICAgICAgIHZhciBwaW5jaENlbnRlciA9IGNlbnRlcihwaW5jaEVuZCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hYID0gcGluY2hDZW50ZXJbMF07XG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGluY2gnLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgcGluY2ggY3VycmVudGx5LlxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdlc3R1cmVNZ3I7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(7);\n    var curve = __webpack_require__(18);\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvYmJveC5qcz8zYzZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAYXV0aG9yIFlpIFNoZW4oaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKTtcblxuICAgIHZhciBiYm94ID0ge307XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcblxuICAgIHZhciBzdGFydCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIGVuZCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIGV4dHJlbWl0eSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgLyoqXG4gICAgICog5LuO6aG254K55pWw57uE5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvaW50cyDpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cywgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBvaW50c1swXTtcbiAgICAgICAgdmFyIGxlZnQgPSBwWzBdO1xuICAgICAgICB2YXIgcmlnaHQgPSBwWzBdO1xuICAgICAgICB2YXIgdG9wID0gcFsxXTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IHBbMV07XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBsZWZ0ID0gbWF0aE1pbihsZWZ0LCBwWzBdKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWF0aE1heChyaWdodCwgcFswXSk7XG4gICAgICAgICAgICB0b3AgPSBtYXRoTWluKHRvcCwgcFsxXSk7XG4gICAgICAgICAgICBib3R0b20gPSBtYXRoTWF4KGJvdHRvbSwgcFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5bMF0gPSBsZWZ0O1xuICAgICAgICBtaW5bMV0gPSB0b3A7XG4gICAgICAgIG1heFswXSA9IHJpZ2h0O1xuICAgICAgICBtYXhbMV0gPSBib3R0b207XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21MaW5lID0gZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCBtaW4sIG1heCkge1xuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MSk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkxKTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDEpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MSk7XG4gICAgfTtcblxuICAgIHZhciB4RGltID0gW107XG4gICAgdmFyIHlEaW0gPSBbXTtcbiAgICAvKipcbiAgICAgKiDku47kuInpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMiwgcDMp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21DdWJpYyA9IGZ1bmN0aW9uKFxuICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbiwgbWF4XG4gICAgKSB7XG4gICAgICAgIHZhciBjdWJpY0V4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWE7XG4gICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBuID0gY3ViaWNFeHRyZW1hKHgwLCB4MSwgeDIsIHgzLCB4RGltKTtcbiAgICAgICAgbWluWzBdID0gSW5maW5pdHk7XG4gICAgICAgIG1pblsxXSA9IEluZmluaXR5O1xuICAgICAgICBtYXhbMF0gPSAtSW5maW5pdHk7XG4gICAgICAgIG1heFsxXSA9IC1JbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHhEaW1baV0pO1xuICAgICAgICAgICAgbWluWzBdID0gbWF0aE1pbih4LCBtaW5bMF0pO1xuICAgICAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4LCBtYXhbMF0pO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHlEaW1baV0pO1xuICAgICAgICAgICAgbWluWzFdID0gbWF0aE1pbih5LCBtaW5bMV0pO1xuICAgICAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5LCBtYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MCwgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgbWF4WzBdKTtcbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MywgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MywgbWF4WzBdKTtcblxuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCBtYXhbMV0pO1xuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkzLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkzLCBtYXhbMV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDku47kuozpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMinkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbVF1YWRyYXRpYyA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBxdWFkcmF0aWNFeHRyZW11bSA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtO1xuICAgICAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZS5xdWFkcmF0aWNBdDtcbiAgICAgICAgLy8gRmluZCBleHRyZW1pdGllcywgd2hlcmUgZGVyaXZhdGl2ZSBpbiB4IGRpbSBvciB5IGRpbSBpcyB6ZXJvXG4gICAgICAgIHZhciB0eCA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeDAsIHgxLCB4MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB2YXIgdHkgPVxuICAgICAgICAgICAgbWF0aE1heChcbiAgICAgICAgICAgICAgICBtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpLCAxKSwgMFxuICAgICAgICAgICAgKTtcblxuICAgICAgICB2YXIgeCA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHR4KTtcbiAgICAgICAgdmFyIHkgPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0eSk7XG5cbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MCwgeDIsIHgpO1xuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MiwgeSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIHgyLCB4KTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTIsIHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDku47lnIblvKfkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJ4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW50aWNsb2Nrd2lzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUFyYyA9IGZ1bmN0aW9uIChcbiAgICAgICAgeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbWluLCBtYXhcbiAgICApIHtcbiAgICAgICAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgICAgICAgdmFyIHZlYzJNYXggPSB2ZWMyLm1heDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cblxuICAgICAgICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQgJiYgZGlmZiA+IDFlLTQpIHtcbiAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICBtaW5bMF0gPSB4IC0gcng7XG4gICAgICAgICAgICBtaW5bMV0gPSB5IC0gcnk7XG4gICAgICAgICAgICBtYXhbMF0gPSB4ICsgcng7XG4gICAgICAgICAgICBtYXhbMV0gPSB5ICsgcnk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFswXSA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIHg7XG4gICAgICAgIHN0YXJ0WzFdID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICBlbmRbMF0gPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgZW5kWzFdID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgdmVjMk1pbihtaW4sIHN0YXJ0LCBlbmQpO1xuICAgICAgICB2ZWMyTWF4KG1heCwgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgLy8gVGhyZXNoIHRvIFswLCBNYXRoLlBJICogMl1cbiAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICUgKFBJMik7XG4gICAgICAgIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgKyBQSTI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlICYmICFhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnRBbmdsZSA8IGVuZEFuZ2xlICYmIGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gZW5kQW5nbGU7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFyIG51bWJlciA9IDA7XG4gICAgICAgIC8vIHZhciBzdGVwID0gKGFudGljbG9ja3dpc2UgPyAtTWF0aC5QSSA6IE1hdGguUEkpIC8gMjtcbiAgICAgICAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgaWYgKGFuZ2xlID4gc3RhcnRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWl0eVswXSA9IG1hdGhDb3MoYW5nbGUpICogcnggKyB4O1xuICAgICAgICAgICAgICAgIGV4dHJlbWl0eVsxXSA9IG1hdGhTaW4oYW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgICAgICAgICAgdmVjMk1pbihtaW4sIGV4dHJlbWl0eSwgbWluKTtcbiAgICAgICAgICAgICAgICB2ZWMyTWF4KG1heCwgZXh0cmVtaXR5LCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmJveDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var eventTool = __webpack_require__(19);\n    var zrUtil = __webpack_require__(0);\n    var Eventful = __webpack_require__(21);\n    var env = __webpack_require__(6);\n    var GestureMgr = __webpack_require__(196);\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanM/NjEzOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QywyQkFBMkI7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjE5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgdmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICAgICAgICBwb2ludGVyZG93bjogMSwgcG9pbnRlcnVwOiAxLCBwb2ludGVybW92ZTogMSwgcG9pbnRlcm91dDogMVxuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICAgICAgICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LFxuICAgICAgICAgICAgcHJveHkuZG9tXG4gICAgICAgICk7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdlbmQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcblxuICAgICAgICAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICAgICAgICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG5cbiAgICAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoe3RhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0fSwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4gICAgLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbiAgICAvLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuICAgIC8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbiAgICAvLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4gICAgLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4gICAgLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICAgICAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gICAgICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAgICAgKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gICAgICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCA3MDApO1xuICAgIH1cblxuXG4gICAgdmFyIGRvbUhhbmRsZXJzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgICAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgICAgICAgICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgICAgICAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAgICAgICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAgICAgICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAgICAgICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAgICAgICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgICAgICAgICAgLy8gZGV2aWNlIHlldC5cbiAgICAgICAgICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgICAgICAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAgICAgICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4gICAgLy8gfVxuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hUaW1lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7IC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgICAgICAgICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgICAgICAgICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAgICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgICAgICAgICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgICAgICAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgICAgICAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cblxuICAgICAgICAgICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgICAgICAgICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgICAgICAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAgICAgICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

eval("// CompoundPath to improve performance\n\n\n    var Path = __webpack_require__(8);\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvQ29tcG91bmRQYXRoLmpzP2JhMmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiIxOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21wb3VuZFBhdGggdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuXG5cbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NvbXBvdW5kJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBwYXRoczogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVQYXRoRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkaXJ0eVBhdGggPSB0aGlzLl9fZGlydHlQYXRoO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFzIGRpcnR5IGlmIGFueSBzdWJwYXRoIGlzIGRpcnR5XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoIHx8IHBhdGhzW2ldLl9fZGlydHlQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRoaXMuX19kaXJ0eSB8fCBkaXJ0eVBhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwYXRoIHNjYWxlXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoc1tpXS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzW2ldLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoc1tpXS5wYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHMgfHwgW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbaV0uYnVpbGRQYXRoKGN0eCwgcGF0aHNbaV0uc2hhcGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbaV0uX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var Gradient = __webpack_require__(41);\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanM/OWMxMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIyMDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4vR3JhZGllbnQnKTtcblxuICAgIC8qKlxuICAgICAqIHgsIHksIHgyLCB5MiBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3gyPTFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5Mj0wXVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAgICAgICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gICAgICAgIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ2xpbmVhcicsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAgICAgICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cblxuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcblxuICAgICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcblxuICAgICAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdsaW5lYXInO1xuXG4gICAgICAgIC8vIElmIHVzZSBnbG9iYWwgY29vcmRcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJHcmFkaWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var Gradient = __webpack_require__(41);\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanM/MDc0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjIwMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi9HcmFkaWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogeCwgeSwgciBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyPTAuNV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgICAgICAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAgICAgICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdyYWRpYWwnLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgICAgICAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG5cbiAgICAgICAgdGhpcy54ID0geCA9PSBudWxsID8gMC41IDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwLjUgOiB5O1xuXG4gICAgICAgIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAncmFkaWFsJztcblxuICAgICAgICAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG5cbiAgICAgICAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbiAgICB9O1xuXG4gICAgUmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoUmFkaWFsR3JhZGllbnQsIEdyYWRpZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmFkaWFsR3JhZGllbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = __webpack_require__(40);\n    var zrUtil = __webpack_require__(0);\n    var textContain = __webpack_require__(16);\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcz9mYTgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMjAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXh0IGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1RleHRcbiAqXG4gKiBUT0RPIFdyYXBwaW5nXG4gKlxuICogVGV4dCBub3Qgc3VwcG9ydCBncmFkaWVudFxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3RleHQnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFRleHQsXG5cbiAgICAgICAgdHlwZTogJ3RleHQnLFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICAgICAgICAgIC8vIEFsd2F5cyBiaW5kIHN0eWxlXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgICAgICAgICAgaWYgKHRleHQpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsIGZvbnQsIHN0eWxlLnRleHRBbGlnbiwgJ3RvcCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRleHRCYXNlbGluZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdHlsZS50ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHJlY3QuaGVpZ2h0IC8gMiAtIHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gcmVjdC5oZWlnaHQgLSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIEludmFsaWQgZm9udFxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGV4dEFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgbGVmdCB0ZXh0QWxpZ24uIEdpdmluZyBpbnZhbGlkIHZhbHVlIHdpbGwgY2F1c2Ugc3RhdGUgbm90IGNoYW5nZVxuICAgICAgICAgICAgICAgIGlmIChjdHgudGV4dEFsaWduICE9PSB0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgaW4gdGV4dCBjb250YWluIGRlZmF1bHQgaXMgdG9wXG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZSB8fCAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGFscGhhYmV0aWMgYmFzZWxpbmVcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnRleHRCYXNlbGluZSAhPT0gdGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCgn5Zu9JywgY3R4LmZvbnQpLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRMaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhhc1N0cm9rZSgpICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhhc0ZpbGwoKSAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICBzdHlsZS50ZXh0ICsgJycsIHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPyAndG9wJyA6IHN0eWxlLnRleHRCYXNlbGluZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC55IC09IHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC55IC09IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgcmVjdC55ICs9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QueCAtPSB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC55IC09IHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0LndpZHRoICs9IHc7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICs9IHc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 203 */
/***/ (function(module, exports) {

eval("\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcz8zOWNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByID0gc2hhcGUucjtcbiAgICAgICAgICAgIHZhciByMTtcbiAgICAgICAgICAgIHZhciByMjtcbiAgICAgICAgICAgIHZhciByMztcbiAgICAgICAgICAgIHZhciByNDtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgeCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjMgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICAgICAgcjQgPSByWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdGFsO1xuICAgICAgICAgICAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICAgICAgICAgICAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMyArIHI0O1xuICAgICAgICAgICAgICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMiArIHIzO1xuICAgICAgICAgICAgICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgICAgICAgICAgICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgICAgICAgICAgIHIyICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcjJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgICAgICAgICAgIHIzICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcjRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gICAgICAgICAgICByMSAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcjEsIHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = __webpack_require__(7);\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qcz8zNmE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMjA0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyTWluID0gdmVjMi5taW47XG4gICAgdmFyIHYyTWF4ID0gdmVjMi5tYXg7XG4gICAgdmFyIHYyU2NhbGUgPSB2ZWMyLnNjYWxlO1xuICAgIHZhciB2MkRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZTtcbiAgICB2YXIgdjJBZGQgPSB2ZWMyLmFkZDtcblxuICAgIC8qKlxuICAgICAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIGNwcyA9IFtdO1xuXG4gICAgICAgIHZhciB2ID0gW107XG4gICAgICAgIHZhciB2MSA9IFtdO1xuICAgICAgICB2YXIgdjIgPSBbXTtcbiAgICAgICAgdmFyIHByZXZQb2ludDtcbiAgICAgICAgdmFyIG5leHRQb2ludDtcblxuICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBtaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICAgICAgICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIHBvaW50c1tpXSk7XG4gICAgICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcbiAgICAgICAgICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICAgICAgICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpID8gaSAtIDEgOiBsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNwcy5wdXNoKHZlYzIuY2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTtcblxuICAgICAgICAgICAgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuICAgICAgICAgICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuXG4gICAgICAgICAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgICAgICAgICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBkMCArIGQxO1xuICAgICAgICAgICAgaWYgKHN1bSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGQwIC89IHN1bTtcbiAgICAgICAgICAgICAgICBkMSAvPSBzdW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYyU2NhbGUodjEsIHYsIC1kMCk7XG4gICAgICAgICAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgICAgICAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgICAgICAgICB2YXIgY3AxID0gdjJBZGQoW10sIHBvaW50LCB2Mik7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMSwgY3AxLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3BzLnB1c2goY3AwKTtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3BzO1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = __webpack_require__(7);\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qcz8wNzkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2F0bXVsbC1Sb20gc3BsaW5lIOaPkuWAvOaKmOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBpc0xvb3ApIHtcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSArPSB2ZWMyLmRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgICAgICAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IocG9zKTtcblxuICAgICAgICAgICAgdmFyIHcgPSBwb3MgLSBpZHg7XG5cbiAgICAgICAgICAgIHZhciBwMDtcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgICAgICAgICAgdmFyIHAyO1xuICAgICAgICAgICAgdmFyIHAzO1xuICAgICAgICAgICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1tpZHggPT09IDAgPyBpZHggOiBpZHggLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzW2lkeCA+IGxlbiAtIDMgPyBsZW4gLSAxIDogaWR4ICsgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1soaWR4IC0gMSArIGxlbikgJSBsZW5dO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbKGlkeCArIDIpICUgbGVuXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHcyID0gdyAqIHc7XG4gICAgICAgICAgICB2YXIgdzMgPSB3ICogdzI7XG5cbiAgICAgICAgICAgIHJldC5wdXNoKFtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdywgdzIsIHczKSxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgdywgdzIsIHczKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = __webpack_require__(16);\n    var BoundingRect = __webpack_require__(11);\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n            rect = style.textPositionRect || rect;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanM/YmY4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xuXG5cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uLy4uL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgICB2YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgUmVjdFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGV4dFJlY3QgQWx0ZXJuYXRpdmUgcHJlY2FsY3VsYXRlZCB0ZXh0IGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCwgdGV4dFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRPZmZzZXQgPSBzdHlsZS50ZXh0T2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcbiAgICAgICAgICAgIHJlY3QgPSBzdHlsZS50ZXh0UG9zaXRpb25SZWN0IHx8IHJlY3Q7XG5cbiAgICAgICAgICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCBiYXNlbGluZSk7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmICghc3R5bGUudGV4dFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcbiAgICAgICAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFBlcmNlbnRcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8ICd0b3AnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC8gMiAtIHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodCAtIHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGJzZWxpbmUgdG8gYmUgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdChcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uLCByZWN0LCB0ZXh0UmVjdCwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSByZXMueDtcbiAgICAgICAgICAgICAgICB5ID0gcmVzLnk7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgcmVzLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB4ICs9IHRleHRPZmZzZXRbMF07XG4gICAgICAgICAgICAgICAgeSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgbGVmdCB0ZXh0QWxpZ24uIEdpdmluZyBpbnZhbGlkIHZhbHVlIHdpbGwgY2F1c2Ugc3RhdGUgbm90IGNoYW5nZVxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBhbHBoYWJldGljIGJhc2VsaW5lXG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEZpbGwgPSBzdHlsZS50ZXh0RmlsbDtcbiAgICAgICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gc3R5bGUudGV4dFN0cm9rZTtcbiAgICAgICAgICAgIHRleHRGaWxsICYmIChjdHguZmlsbFN0eWxlID0gdGV4dEZpbGwpO1xuICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiAoY3R4LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2hhZG93XG4gICAgICAgICAgICAvLyBBbHdheXMgc2V0IHNoYWRvd0JsdXIgYW5kIHNoYWRvd09mZnNldCB0byBhdm9pZCBsZWFrIGZyb20gZGlzcGxheWFibGVcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gc3R5bGUudGV4dFNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZO1xuXG4gICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0Um90YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gJiYgY3R4LnRyYW5zbGF0ZSh0cmFuc2Zvcm1bNF0sIHRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShzdHlsZS50ZXh0Um90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKC10cmFuc2Zvcm1bNF0sIC10cmFuc2Zvcm1bNV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlY3RUZXh0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = __webpack_require__(8).extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzPzNjYjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiIyMDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbiBcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2FyYycsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG5cbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG5cbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = __webpack_require__(18);\n    var vec2 = __webpack_require__(7);\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = __webpack_require__(8).extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanM/MDI4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMjA4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDotJ3loZ7lsJTmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9CZXppZXJDdXJ2ZVxuICovXG5cblxuICAgIHZhciBjdXJ2ZVRvb2wgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wucXVhZHJhdGljU3ViZGl2aWRlO1xuICAgIHZhciBjdWJpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5jdWJpY1N1YmRpdmlkZTtcbiAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljQXQ7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZVRvb2wuY3ViaWNBdDtcbiAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbiAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLFxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS5jcHkyLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSxcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYmV6aWVyLWN1cnZlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG4gICAgICAgICAgICBjcHgxOiAwLFxuICAgICAgICAgICAgY3B5MTogMCxcbiAgICAgICAgICAgIC8vIGNweDI6IDAsXG4gICAgICAgICAgICAvLyBjcHkyOiAwXG5cbiAgICAgICAgICAgIC8vIEN1cnZlIHNob3cgcGVyY2VudCwgZm9yIGFuaW1hdGluZ1xuICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICAgICAgICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcbiAgICAgICAgICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICAgICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICAgICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICAgICAgICAgIGlmIChjcHgyID09IG51bGwgfHwgY3B5MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgY3B4MiwgY3B5MixcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGFuZ2VudCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRhbmdlbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBwID0gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = __webpack_require__(8).extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzPzNlMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiIyMDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWchuW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0NpcmNsZVxuICovXG5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDBcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGJ1aWxkUGF0aCA6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICAvLyBBbHdheXMgZG8gaXQgbWF5IGhhdmUgcGVyZm9ybWVuY2UgaXNzdWUgKCBmaWxsIG1heSBiZSAyeCBtb3JlIGNvc3QpXG4gICAgICAgICAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGN0eC5hbGxvY2F0ZShjdHguQ01EX01FTV9TSVpFLkEpO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = __webpack_require__(8).extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcz8xYTYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsImZpbGUiOiIyMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8gU3RhcnQgcG9pbnRcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICAvLyBFbmQgcG9pbnRcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG5cbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgICAgICAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc2hhcGUueDEgKiAoMSAtIHApICsgc2hhcGUueDIgKiBwLFxuICAgICAgICAgICAgICAgIHNoYXBlLnkxICogKDEgLSBwKSArIHNoYXBlLnkyICogcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = __webpack_require__(78);\n\n    module.exports = __webpack_require__(8).extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcz9iMWYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5aSa6L655b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvUG9seWdvblxuICovXG5cblxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3BvbHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAncG9seWdvbicsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcblxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcblxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = __webpack_require__(78);\n\n    module.exports = __webpack_require__(8).extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanM/YjUyOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVxuICovXG5cblxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3BvbHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXG5cbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG5cbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = __webpack_require__(203);\n\n    module.exports = __webpack_require__(8).extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcz9mZTdlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJmaWxlIjoiMjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xuXG5cbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3JvdW5kUmVjdCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = __webpack_require__(8).extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcz8yZmU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5ZyG546vXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SaW5nXG4gKi9cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmluZycsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcjA6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIwLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUucjAsIDAsIFBJMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = __webpack_require__(6);\n    var Path = __webpack_require__(8);\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzPzc1NzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLIiwiZmlsZSI6IjIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xuXG5cblxuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2VudicpO1xuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vUGF0aCcpO1xuXG4gICAgdmFyIHNoYWRvd1RlbXAgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLFxuICAgICAgICBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSxcbiAgICAgICAgWydzaGFkb3dPZmZzZXRYJywgMF0sXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WScsIDBdXG4gICAgXTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0aC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZWN0b3InLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIGN4OiAwLFxuXG4gICAgICAgICAgICBjeTogMCxcblxuICAgICAgICAgICAgcjA6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnJ1c2g6IChlbnYuYnJvd3Nlci5pZSAmJiBlbnYuYnJvd3Nlci52ZXJzaW9uID49IDExKSAvLyB2ZXJzaW9uOiAnMTEuMCdcbiAgICAgICAgICAgIC8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3ODAxKSxcbiAgICAgICAgICAgIC8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbiAgICAgICAgICAgIC8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgYWZ0ZXIgYSBwYXRoIHdob3NlIGFyZWEgc2l6ZVxuICAgICAgICAgICAgLy8gaXMgemVybyBpcyBkcmF3biBhbmQgY3R4LmNsaXAoKSBpcyBjYWxsZWQgYW5kIHNoYWRvd0JsdXIgaXMgc2V0LlxuICAgICAgICAgICAgLy8gKGUuZy4sXG4gICAgICAgICAgICAvLyAgY3R4Lm1vdmVUbygxMCwgMTApO1xuICAgICAgICAgICAgLy8gIGN0eC5saW5lVG8oMjAsIDEwKTtcbiAgICAgICAgICAgIC8vICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAvLyAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIC8vICBjdHguc2hhZG93Qmx1ciA9IDEwO1xuICAgICAgICAgICAgLy8gIC4uLlxuICAgICAgICAgICAgLy8gIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAvLyApXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcFBhdGhzID0gdGhpcy5fX2NsaXBQYXRocztcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZDtcblxuICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoc1tpXSAmJiBjbGlwUGF0aHNbaV0uc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuc3RhcnRBbmdsZSA9PT0gc2hhcGUuZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93VGVtcFtqXVsyXSA9IHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFBhdGgucHJvdG90eXBlLmJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IFBhdGgucHJvdG90eXBlLmJydXNoLFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LFxuICAgICAgICAgICAgICAgIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = __webpack_require__(69);\n    var util = __webpack_require__(0);\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = __webpack_require__(74);\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanM/YjY1NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QyxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQyxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqL1xuXG5cbiAgICB2YXIgQW5pbWF0b3IgPSByZXF1aXJlKCcuLi9hbmltYXRpb24vQW5pbWF0b3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc1N0cmluZyA9IHV0aWwuaXNTdHJpbmc7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB1dGlsLmlzRnVuY3Rpb247XG4gICAgdmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi4vY29yZS9sb2cnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1ZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3I+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0b3JzID0gW107XG4gICAgfTtcblxuICAgIEFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliqjnlLtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGgg6ZyA6KaB5re75Yqg5Yqo55S755qE5bGe5oCn6I635Y+W6Lev5b6E77yM5Y+v5Lul6YCa6L+HYS5iLmPmnaXojrflj5bmt7HlsYLnmoTlsZ7mgKdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0g5Yqo55S75piv5ZCm5b6q546vXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICogQGV4YW1wbGU6XG4gICAgICAgICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgICAgICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgICAgICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAgICAgICAqICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZWw7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAgICdQcm9wZXJ0eSBcIidcbiAgICAgICAgICAgICAgICAgICAgKyBwYXRoXG4gICAgICAgICAgICAgICAgICAgICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJ1xuICAgICAgICAgICAgICAgICAgICArIGVsLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuXG4gICAgICAgICAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzLnNwbGljZSh1dGlsLmluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTtcblxuICAgICAgICAgICAgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBzaGFwZToge1xuICAgICAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICBzdHlsZToge1xuICAgICAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICovXG4gICAgICAgICAvLyBUT0RPIFJldHVybiBhbmltYXRpb24ga2V5XG4gICAgICAgIGFuaW1hdGVUbzogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgICAgICAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXVxuICAgICAgICAgICAgICAgICAgICAuZG9uZShkb25lKVxuICAgICAgICAgICAgICAgICAgICAuc3RhcnQoZWFzaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGg9JydcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICAgICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICAgICAgICogICAgICB9LFxuICAgICAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICAgICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgMTAwLCAxMDApXG4gICAgICAgICAqL1xuICAgICAgICBfYW5pbWF0ZVRvU2hhbGxvdzogZnVuY3Rpb24gKHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSkge1xuICAgICAgICAgICAgdmFyIG9ialNoYWxsb3cgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICF1dGlsLmlzQXJyYXlMaWtlKHRhcmdldFtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA/IHBhdGggKyAnLicgKyBuYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dHIgZGlyZWN0bHkgaWYgbm90IGhhcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgIC8vIFNoYXBlIG9yIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twYXRoXVtuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShwYXRoLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLndoZW4odGltZSA9PSBudWxsID8gNTAwIDogdGltZSwgb2JqU2hhbGxvdylcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 217 */
/***/ (function(module, exports) {

eval("// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qcz81ZTEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEiLCJmaWxlIjoiMjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5cbiAgICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5feCA9IDA7XG4gICAgICAgIC8vIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIERyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcblxuICAgICAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWcnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0odGhpcy5fZHJvcFRhcmdldCwgZSksICdkcm9wJywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gICAgICAgIHJldHVybiB7dGFyZ2V0OiB0YXJnZXQsIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vX3pyZW5kZXJAMy41LjJAenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var Path = __webpack_require__(8);\n    var PathProxy = __webpack_require__(28);\n    var transformPath = __webpack_require__(219);\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcz9mZWZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5Jyk7XG4gICAgdmFyIHRyYW5zZm9ybVBhdGggPSByZXF1aXJlKCcuL3RyYW5zZm9ybVBhdGgnKTtcblxuICAgIC8vIGNvbW1hbmQgY2hhcnNcbiAgICB2YXIgY2MgPSBbXG4gICAgICAgICdtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJyxcbiAgICAgICAgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXG4gICAgXTtcblxuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcblxuICAgIHZhciB2TWFnID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgIH07XG4gICAgdmFyIHZSYXRpbyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2TWFnKHUpICogdk1hZyh2KSk7XG4gICAgfTtcbiAgICB2YXIgdkFuZ2xlID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpXG4gICAgICAgICAgICAgICAgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FyYyh4MSwgeTEsIHgyLCB5MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZywgY21kLCBwYXRoKSB7XG4gICAgICAgIHZhciBwc2kgPSBwc2lEZWcgKiAoUEkgLyAxODAuMCk7XG4gICAgICAgIHZhciB4cCA9IG1hdGhDb3MocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhTaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgICAgICAgdmFyIHlwID0gLTEgKiBtYXRoU2luKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9ICh4cCAqIHhwKSAvIChyeCAqIHJ4KSArICh5cCAqIHlwKSAvIChyeSAqIHJ5KTtcblxuICAgICAgICBpZiAobGFtYmRhID4gMSkge1xuICAgICAgICAgICAgcnggKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpXG4gICAgICAgICAgICAqIG1hdGhTcXJ0KCgoKHJ4ICogcngpICogKHJ5ICogcnkpKVxuICAgICAgICAgICAgICAgICAgICAtICgocnggKiByeCkgKiAoeXAgKiB5cCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeSAqIHJ5KSAqICh4cCAqIHhwKSkpIC8gKChyeCAqIHJ4KSAqICh5cCAqIHlwKVxuICAgICAgICAgICAgICAgICAgICArIChyeSAqIHJ5KSAqICh4cCAqIHhwKSlcbiAgICAgICAgICAgICAgICApIHx8IDA7XG5cbiAgICAgICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gICAgICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgICAgICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gICAgICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMFxuICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogY3hwXG4gICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeXA7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gdkFuZ2xlKFsgMSwgMCBdLCBbICh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5IF0pO1xuICAgICAgICB2YXIgdSA9IFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXTtcbiAgICAgICAgdmFyIHYgPSBbICgtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgZFRoZXRhID0gdkFuZ2xlKHUsIHYpO1xuXG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnMgPT09IDAgJiYgZFRoZXRhID4gMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMSAmJiBkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgKyAyICogUEk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tbWFuZCBzdHJpbmdcbiAgICAgICAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAvZywgJywnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLywsL2csICcsJyk7XG5cbiAgICAgICAgdmFyIG47XG4gICAgICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYXJyYXlcbiAgICAgICAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7XG4gICAgICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxuICAgICAgICB2YXIgY3B4ID0gMDtcbiAgICAgICAgdmFyIGNweSA9IDA7XG5cbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgICAgIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuXG4gICAgICAgIHZhciBwcmV2Q21kO1xuICAgICAgICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gYXJyW25dO1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgICAgICB2YXIgcCA9IHN0ci5zbGljZSgxKS5yZXBsYWNlKC9lLC0vZywgJ2UtJykuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBjbWQ7XG5cbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG9mZiA8IHAubGVuZ3RoICYmICFpc05hTihwW29mZl0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR4O1xuICAgICAgICAgICAgICAgIHZhciBjdGxQdHk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcng7XG4gICAgICAgICAgICAgICAgdmFyIHJ5O1xuICAgICAgICAgICAgICAgIHZhciBwc2k7XG4gICAgICAgICAgICAgICAgdmFyIGZhO1xuICAgICAgICAgICAgICAgIHZhciBmcztcblxuICAgICAgICAgICAgICAgIHZhciB4MSA9IGNweDtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSBjcHk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQsIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHggKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gY3B5ICsgcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK10gKyBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcFtvZmYrK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY21kID0gQ01ELlo7XG4gICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZDbWQgPSBjbWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICAgICAgICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGguc2V0RGF0YSkge1xuICAgICAgICAgICAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoO1xuICAgICAgICAgICAgICAgIHBhdGhQcm94eS5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtUGF0aChwYXRoUHJveHksIG0pO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGgoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggY2xhc3MgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmRGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuICAgICAgICAvLyBUT0RPIHN0cm9rZSBkYXNoXG4gICAgICAgIC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cbiAgICAgICAgbWVyZ2VQYXRoOiBmdW5jdGlvbiAocGF0aEVscywgb3B0cykge1xuICAgICAgICAgICAgdmFyIHBhdGhMaXN0ID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoRWwucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoRWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXRoRWwuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7XG4gICAgICAgICAgICAvLyBOZWVkIHBhdGggcHJveHkuXG4gICAgICAgICAgICBwYXRoQnVuZGxlLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgICAgICAgICAgcGF0aEJ1bmRsZS5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kUGF0aChwYXRoTGlzdCk7XG4gICAgICAgICAgICAgICAgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBwYXRoQnVuZGxlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi90b29sL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var CMD = __webpack_require__(28).CMD;\n    var vec2 = __webpack_require__(7);\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qcz9mY2NkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG5cbiAgICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKHBhdGgsIG0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgIHZhciBjbWQ7XG4gICAgICAgIHZhciBuUG9pbnQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHZhciBwO1xuXG4gICAgICAgIHZhciBNID0gQ01ELk07XG4gICAgICAgIHZhciBDID0gQ01ELkM7XG4gICAgICAgIHZhciBMID0gQ01ELkw7XG4gICAgICAgIHZhciBSID0gQ01ELlI7XG4gICAgICAgIHZhciBBID0gQ01ELkE7XG4gICAgICAgIHZhciBRID0gQ01ELlE7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgblBvaW50ID0gMDtcblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTDpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFE6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG1bNV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IG1hdGhTcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gbWF0aEF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN4XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gKj0gc3g7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB4O1xuICAgICAgICAgICAgICAgICAgICAvLyBjeVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldICo9IHN5O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0geTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgcHNpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgICAgICAgICAgLy8geDAsIHkwXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgYmFja1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9fenJlbmRlckAzLjUuMkB6cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDIxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = __webpack_require__(73);\n    var env = __webpack_require__(6);\n    var zrUtil = __webpack_require__(0);\n\n    var Handler = __webpack_require__(183);\n    var Storage = __webpack_require__(186);\n    var Animation = __webpack_require__(187);\n    var HandlerProxy = __webpack_require__(198);\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: __webpack_require__(185)\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.5.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL3pyZW5kZXIuanM/YzBkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLE9BQU8sRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFpSZW5kZXIsIGEgaGlnaCBwZXJmb3JtYW5jZSAyZCBkcmF3aW5nIGxpYnJhcnkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuICovXG4vLyBHbG9iYWwgZGVmaW5lc1xuXG4gICAgdmFyIGd1aWQgPSByZXF1aXJlKCcuL2NvcmUvZ3VpZCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuL2NvcmUvZW52Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgSGFuZGxlciA9IHJlcXVpcmUoJy4vSGFuZGxlcicpO1xuICAgIHZhciBTdG9yYWdlID0gcmVxdWlyZSgnLi9TdG9yYWdlJyk7XG4gICAgdmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL0FuaW1hdGlvbicpO1xuICAgIHZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKCcuL2RvbS9IYW5kbGVyUHJveHknKTtcblxuICAgIHZhciB1c2VWTUwgPSAhZW52LmNhbnZhc1N1cHBvcnRlZDtcblxuICAgIHZhciBwYWludGVyQ3RvcnMgPSB7XG4gICAgICAgIGNhbnZhczogcmVxdWlyZSgnLi9QYWludGVyJylcbiAgICB9O1xuXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9OyAgICAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbiAgICB2YXIgenJlbmRlciA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6cmVuZGVyLnZlcnNpb24gPSAnMy41LjInO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6aW5nIGEgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAqL1xuICAgIHpyZW5kZXIuaW5pdCA9IGZ1bmN0aW9uKGRvbSwgb3B0cykge1xuICAgICAgICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gICAgICAgIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgICAgICAgcmV0dXJuIHpyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICovXG4gICAgenJlbmRlci5kaXNwb3NlID0gZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgenIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4genJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbiAgICB9O1xuXG4gICAgenJlbmRlci5yZWdpc3RlclBhaW50ZXIgPSBmdW5jdGlvbiAobmFtZSwgQ3Rvcikge1xuICAgICAgICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtIVE1MRG9tRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKi9cbiAgICB2YXIgWlJlbmRlciA9IGZ1bmN0aW9uKGlkLCBkb20sIG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hUTUxEb21FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb20gPSBkb207XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCk7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXI7XG4gICAgICAgIC8vIFRPRE8gV2ViR0xcbiAgICAgICAgaWYgKHVzZVZNTCkge1xuICAgICAgICAgICAgaWYgKCFwYWludGVyQ3RvcnMudm1sKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byByZXF1aXJlIFxcJ3pyZW5kZXIvdm1sL3ZtbFxcJyB0byBzdXBwb3J0IElFOCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gJ3ZtbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJlbmRlcmVyVHlwZSB8fCAhcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWludGVyID0gbmV3IHBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKGRvbSwgc3RvcmFnZSwgb3B0cyk7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICB2YXIgaGFuZGVyUHJveHkgPSAhZW52Lm5vZGUgPyBuZXcgSGFuZGxlclByb3h5KHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkpIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbmV3IEhhbmRsZXIoc3RvcmFnZSwgcGFpbnRlciwgaGFuZGVyUHJveHksIHBhaW50ZXIucm9vdCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHN0YWdlOiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiB6clV0aWwuYmluZCh0aGlzLmZsdXNoLCB0aGlzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2g7XG5cbiAgICAgICAgLy8g5L+u5pS5IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAgICAgICAvLyBGSVhNRSDmnInngrl1Z2x5XG4gICAgICAgIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gICAgICAgIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcblxuICAgICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgICAgICAgICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgICAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgWlJlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFpSZW5kZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAgICAgICAqL1xuICAgICAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwYWludCB0aGUgY2FudmFzIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIG5lZWRzUmVmcmVzaCBhaGVhZCB0byBhdm9pZCBzb21ldGhpbmcgd3JvbmcgaGFwcGVucyBpbiByZWZyZXNoXG4gICAgICAgICAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgYW5kIHJlcGFpbnQgdGhlIGNhbnZhcyBpbiB0aGUgbmV4dCBmcmFtZSBvZiBicm93c2VyXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gYWxsIHJlZnJlc2hcbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgdG8gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5hZGRIb3ZlcihlbCwgc3R5bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCBob3ZlciBlbGVtZW50cyBpbiBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoIGhvdmVyIGluIG5leHQgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICAgICAgICogU2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250YWluZXIgc2l6ZSBpcyBjaGFuZ2VkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAgICAgICAqL1xuICAgICAgICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gICAgICAgIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgICAgICAgLy8gfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAgICAgICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbihlLCBkcHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIucGF0aFRvSW1hZ2UoZSwgZHByKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRlZmF1bHQgY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIGhvdmVyZWQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0YXJnZXQsIHRvcFRhcmdldH1cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9mZihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdCgpO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2Ugc2VsZi5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0genJlbmRlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L196cmVuZGVyQDMuNS4yQHpyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_resource__ = __webpack_require__(103);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_Components_Samples_demo_vue__ = __webpack_require__(102);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_Components_Samples_demo_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__src_Components_Samples_demo_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Src_Components_DataRender_pks_histogram_vue__ = __webpack_require__(83);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Src_Components_DataRender_pks_histogram_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__Src_Components_DataRender_pks_histogram_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_Components_DataRender_pks_image_vue__ = __webpack_require__(101);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_Components_DataRender_pks_image_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__src_Components_DataRender_pks_image_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Src_Components_Layout_pks_header_vue__ = __webpack_require__(84);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Src_Components_Layout_pks_header_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__Src_Components_Layout_pks_header_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Src_Components_Layout_pks_menu_vue__ = __webpack_require__(85);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Src_Components_Layout_pks_menu_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__Src_Components_Layout_pks_menu_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Src_Components_SZXT_pks_tabs_vue__ = __webpack_require__(100);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Src_Components_SZXT_pks_tabs_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__Src_Components_SZXT_pks_tabs_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Src_Components_SZXT_pks_ctabs_vue__ = __webpack_require__(87);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Src_Components_SZXT_pks_ctabs_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__Src_Components_SZXT_pks_ctabs_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Src_Components_SZXT_pks_list_vue__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Src_Components_SZXT_pks_list_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__Src_Components_SZXT_pks_list_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Src_Components_SZXT_pks_listm_vue__ = __webpack_require__(91);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Src_Components_SZXT_pks_listm_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__Src_Components_SZXT_pks_listm_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Src_Components_SZXT_pks_multipleTitle_vue__ = __webpack_require__(93);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Src_Components_SZXT_pks_multipleTitle_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__Src_Components_SZXT_pks_multipleTitle_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__Src_Components_SZXT_pks_panel_vue__ = __webpack_require__(43);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__Src_Components_SZXT_pks_panel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__Src_Components_SZXT_pks_panel_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__Src_Components_SZXT_pks_panel2_vue__ = __webpack_require__(96);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__Src_Components_SZXT_pks_panel2_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13__Src_Components_SZXT_pks_panel2_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__Src_Components_SZXT_pks_panelList_vue__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__Src_Components_SZXT_pks_panelList_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14__Src_Components_SZXT_pks_panelList_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__Src_Components_SZXT_pks_singleTitle_vue__ = __webpack_require__(97);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__Src_Components_SZXT_pks_singleTitle_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15__Src_Components_SZXT_pks_singleTitle_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__Src_Components_SZXT_pks_filterlist_vue__ = __webpack_require__(88);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__Src_Components_SZXT_pks_filterlist_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16__Src_Components_SZXT_pks_filterlist_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__Src_Components_SZXT_pks_imglist_vue__ = __webpack_require__(89);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__Src_Components_SZXT_pks_imglist_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17__Src_Components_SZXT_pks_imglist_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__Src_Components_SZXT_pks_sort_vue__ = __webpack_require__(99);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__Src_Components_SZXT_pks_sort_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18__Src_Components_SZXT_pks_sort_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__Src_Components_SZXT_pks_listtable_vue__ = __webpack_require__(92);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__Src_Components_SZXT_pks_listtable_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19__Src_Components_SZXT_pks_listtable_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__Src_Components_SZXT_pks_pager_vue__ = __webpack_require__(95);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__Src_Components_SZXT_pks_pager_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20__Src_Components_SZXT_pks_pager_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__Src_Components_SZXT_pks_nostructtable_vue__ = __webpack_require__(94);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__Src_Components_SZXT_pks_nostructtable_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21__Src_Components_SZXT_pks_nostructtable_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__Src_Components_SZXT_pks_complexFiltration_vue__ = __webpack_require__(86);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__Src_Components_SZXT_pks_complexFiltration_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22__Src_Components_SZXT_pks_complexFiltration_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__Src_Components_SZXT_pks_imgviewer_vue__ = __webpack_require__(90);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__Src_Components_SZXT_pks_imgviewer_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23__Src_Components_SZXT_pks_imgviewer_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__Src_Components_SZXT_pks_singleimg_vue__ = __webpack_require__(98);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__Src_Components_SZXT_pks_singleimg_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24__Src_Components_SZXT_pks_singleimg_vue__);\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n//require('./Assets/Js/lib/vue.min.js?r=1')\n//import Vue from './Assets/Js/lib/vue.min.js'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"].use(__WEBPACK_IMPORTED_MODULE_1_vue_resource__[\"a\" /* default */]);\nvar models = {\n    \"pks:demo\": __WEBPACK_IMPORTED_MODULE_2__src_Components_Samples_demo_vue___default.a,\n    \"pks:histogram\": __WEBPACK_IMPORTED_MODULE_3__Src_Components_DataRender_pks_histogram_vue___default.a,\n    \"pks:header\": __WEBPACK_IMPORTED_MODULE_5__Src_Components_Layout_pks_header_vue___default.a,\n    \"pks:menu\": __WEBPACK_IMPORTED_MODULE_6__Src_Components_Layout_pks_menu_vue___default.a,\n    \"pks:tabs\": __WEBPACK_IMPORTED_MODULE_7__Src_Components_SZXT_pks_tabs_vue___default.a,\n    \"pks:ctabs\": __WEBPACK_IMPORTED_MODULE_8__Src_Components_SZXT_pks_ctabs_vue___default.a,\n    \"pks:list\": __WEBPACK_IMPORTED_MODULE_9__Src_Components_SZXT_pks_list_vue___default.a,\n    \"pks:listm\": __WEBPACK_IMPORTED_MODULE_10__Src_Components_SZXT_pks_listm_vue___default.a,\n    \"pks:multipletitle\": __WEBPACK_IMPORTED_MODULE_11__Src_Components_SZXT_pks_multipleTitle_vue___default.a,\n    \"pks:panel\": __WEBPACK_IMPORTED_MODULE_12__Src_Components_SZXT_pks_panel_vue___default.a,\n    \"pks:panel2\": __WEBPACK_IMPORTED_MODULE_13__Src_Components_SZXT_pks_panel2_vue___default.a,\n    \"pks:panellist\": __WEBPACK_IMPORTED_MODULE_14__Src_Components_SZXT_pks_panelList_vue___default.a,\n    \"pks:singletitle\": __WEBPACK_IMPORTED_MODULE_15__Src_Components_SZXT_pks_singleTitle_vue___default.a,\n    \"pks:filterlist\": __WEBPACK_IMPORTED_MODULE_16__Src_Components_SZXT_pks_filterlist_vue___default.a,\n    \"pks:imglist\": __WEBPACK_IMPORTED_MODULE_17__Src_Components_SZXT_pks_imglist_vue___default.a,\n    \"pks:listtable\": __WEBPACK_IMPORTED_MODULE_19__Src_Components_SZXT_pks_listtable_vue___default.a,\n    \"pks:sort\": __WEBPACK_IMPORTED_MODULE_18__Src_Components_SZXT_pks_sort_vue___default.a,\n    \"pks:pager\": __WEBPACK_IMPORTED_MODULE_20__Src_Components_SZXT_pks_pager_vue___default.a,\n    \"pks:nostructtable\": __WEBPACK_IMPORTED_MODULE_21__Src_Components_SZXT_pks_nostructtable_vue___default.a,\n    \"pks:complex\": __WEBPACK_IMPORTED_MODULE_22__Src_Components_SZXT_pks_complexFiltration_vue___default.a,\n    \"pks:imgviewer\": __WEBPACK_IMPORTED_MODULE_23__Src_Components_SZXT_pks_imgviewer_vue___default.a,\n    \"pks:image\": __WEBPACK_IMPORTED_MODULE_4__src_Components_DataRender_pks_image_vue___default.a,\n    \"pks:singleimg\": __WEBPACK_IMPORTED_MODULE_24__Src_Components_SZXT_pks_singleimg_vue___default.a\n};\nvar PKSUI = {\n    isAutoLoadUI: true,\n    bind: function bind(com) {\n        var model = {};\n        if (com.model) {\n            if (typeof com.model == \"string\") {\n                model = _defineProperty({}, com.model, models[com.model]);\n            } else {\n                for (var i = 0; i < com.model.length; i++) {\n                    model[com.model[i]] = models[com.model[i]];\n                }\n            }\n        } else {\n            //出于性能的考虑，目前必须手动注册使用到的模块。\n            model = models;\n        }\n\n        var vm = new __WEBPACK_IMPORTED_MODULE_0_vue__[\"default\"]({\n            el: com.el,\n            data: com.data,\n            methods: com.methods,\n            components: model\n        });\n        return vm;\n    },\n\n    getDataByVm: function getDataByVm(vm, name) {\n        // return vm.$get(name);\n        return vm.$data[name];\n    },\n    setDataByVm: function setDataByVm(vm, name, data) {\n        //vm.$set(name, data);\n        vm.$data[name] = data;\n    },\n    getDataById: function getDataById(id, name) {\n        var vm = PKSUI.getViewModel(id);\n        //return vm.$get(name);\n        return vm.$data[name];\n    },\n    setDataById: function setDataById(id, name, data) {\n        var vm = PKSUI.getViewModel(id);\n        //vm.$set(name, data);\n        vm.$data[name] = data;\n    },\n    bindViewModel: function bindViewModel(vm, scope) {\n        vm.$mount(\"#\" + scope);\n    },\n    getViewModel: function getViewModel(id) {\n        //按id获取自动加载UI是的vm\n        var r = null;\n        if (!PKSUI.isAutoLoadUI) return r;\n        if (soModels.viewModels[id]) r = soModels.viewModels[id].vm;\n        return r;\n    }\n};\nwindow.PKSUI = PKSUI;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZW1vLmpzPzE2ZGQiXSwibmFtZXMiOlsiVnVlIiwidXNlIiwibW9kZWxzIiwic2luZ2xlaW1nIiwiUEtTVUkiLCJpc0F1dG9Mb2FkVUkiLCJiaW5kIiwiY29tIiwibW9kZWwiLCJpIiwibGVuZ3RoIiwidm0iLCJlbCIsImRhdGEiLCJtZXRob2RzIiwiY29tcG9uZW50cyIsImdldERhdGFCeVZtIiwibmFtZSIsIiRkYXRhIiwic2V0RGF0YUJ5Vm0iLCJnZXREYXRhQnlJZCIsImlkIiwiZ2V0Vmlld01vZGVsIiwic2V0RGF0YUJ5SWQiLCJiaW5kVmlld01vZGVsIiwic2NvcGUiLCIkbW91bnQiLCJyIiwic29Nb2RlbHMiLCJ2aWV3TW9kZWxzIiwid2luZG93Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQUFBLENBQUlDLEdBQUosQ0FBUSw2REFBUjtBQUNBLElBQU1DLFNBQU87QUFDVCxnQkFBVyx3RUFERjtBQUVULHFCQUFnQixvRkFGUDtBQUdULGtCQUFhLDZFQUhKO0FBSVQsZ0JBQVcsMkVBSkY7QUFLVCxnQkFBVyx5RUFMRjtBQU1ULGlCQUFZLDBFQU5IO0FBT1QsZ0JBQVcseUVBUEY7QUFRVCxpQkFBWSwyRUFSSDtBQVNULHlCQUFvQixtRkFUWDtBQVVULGlCQUFZLDJFQVZIO0FBV1Qsa0JBQWEsNEVBWEo7QUFZVCxxQkFBZ0IsK0VBWlA7QUFhVCx1QkFBa0IsaUZBYlQ7QUFjVCxzQkFBaUIsZ0ZBZFI7QUFlVCxtQkFBYyw2RUFmTDtBQWdCVCxxQkFBZ0IsK0VBaEJQO0FBaUJaLGdCQUFXLDBFQWpCQztBQWtCWixpQkFBWSwyRUFsQkE7QUFtQloseUJBQW9CLG1GQW5CUjtBQW9CVCxtQkFBYyx1RkFwQkw7QUFxQlQscUJBQWdCLCtFQXJCUDtBQXNCVCxpQkFBWSxnRkF0Qkg7QUF1QlQscUJBQWdCLCtFQUFBQztBQXZCUCxDQUFiO0FBeUJBLElBQU1DLFFBQVE7QUFDVkMsa0JBQWMsSUFESjtBQUVWQyxVQUFNLGNBQVNDLEdBQVQsRUFBYztBQUNoQixZQUFJQyxRQUFRLEVBQVo7QUFDQSxZQUFJRCxJQUFJQyxLQUFSLEVBQWU7QUFDWCxnQkFBSSxPQUFPRCxJQUFJQyxLQUFYLElBQXFCLFFBQXpCLEVBQW1DO0FBQy9CQSw0Q0FDS0QsSUFBSUMsS0FEVCxFQUNpQk4sT0FBT0ssSUFBSUMsS0FBWCxDQURqQjtBQUdILGFBSkQsTUFJTztBQUNILHFCQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsSUFBSUMsS0FBSixDQUFVRSxNQUE5QixFQUFzQ0QsR0FBdEMsRUFBMkM7QUFDdkNELDBCQUFNRCxJQUFJQyxLQUFKLENBQVVDLENBQVYsQ0FBTixJQUFzQlAsT0FBT0ssSUFBSUMsS0FBSixDQUFVQyxDQUFWLENBQVAsQ0FBdEI7QUFDSDtBQUNKO0FBQ0osU0FWRCxNQVVPO0FBQ0g7QUFDQUQsb0JBQU1OLE1BQU47QUFDSDs7QUFHRCxZQUFJUyxLQUFLLElBQUksNENBQUosQ0FBUTtBQUNiQyxnQkFBSUwsSUFBSUssRUFESztBQUViQyxrQkFBTU4sSUFBSU0sSUFGRztBQUdiQyxxQkFBU1AsSUFBSU8sT0FIQTtBQUliQyx3QkFBWVA7QUFKQyxTQUFSLENBQVQ7QUFNQSxlQUFPRyxFQUFQO0FBQ0gsS0EzQlM7O0FBNkJWSyxpQkFBYSxxQkFBU0wsRUFBVCxFQUFhTSxJQUFiLEVBQW1CO0FBQzVCO0FBQ0EsZUFBT04sR0FBR08sS0FBSCxDQUFTRCxJQUFULENBQVA7QUFDSCxLQWhDUztBQWlDVkUsaUJBQWEscUJBQVNSLEVBQVQsRUFBYU0sSUFBYixFQUFtQkosSUFBbkIsRUFBeUI7QUFDbEM7QUFDQUYsV0FBR08sS0FBSCxDQUFTRCxJQUFULElBQWlCSixJQUFqQjtBQUNILEtBcENTO0FBcUNWTyxpQkFBYSxxQkFBU0MsRUFBVCxFQUFhSixJQUFiLEVBQW1CO0FBQzVCLFlBQUlOLEtBQUtQLE1BQU1rQixZQUFOLENBQW1CRCxFQUFuQixDQUFUO0FBQ0E7QUFDQSxlQUFPVixHQUFHTyxLQUFILENBQVNELElBQVQsQ0FBUDtBQUNILEtBekNTO0FBMENWTSxpQkFBYSxxQkFBU0YsRUFBVCxFQUFhSixJQUFiLEVBQW1CSixJQUFuQixFQUF5QjtBQUNsQyxZQUFJRixLQUFLUCxNQUFNa0IsWUFBTixDQUFtQkQsRUFBbkIsQ0FBVDtBQUNBO0FBQ0FWLFdBQUdPLEtBQUgsQ0FBU0QsSUFBVCxJQUFpQkosSUFBakI7QUFDSCxLQTlDUztBQStDVlcsbUJBQWUsdUJBQVNiLEVBQVQsRUFBYWMsS0FBYixFQUFvQjtBQUMvQmQsV0FBR2UsTUFBSCxDQUFVLE1BQU1ELEtBQWhCO0FBQ0gsS0FqRFM7QUFrRFZILGtCQUFjLHNCQUFTRCxFQUFULEVBQWE7QUFDdkI7QUFDQSxZQUFJTSxJQUFJLElBQVI7QUFDQSxZQUFJLENBQUN2QixNQUFNQyxZQUFYLEVBQ0ksT0FBT3NCLENBQVA7QUFDSixZQUFJQyxTQUFTQyxVQUFULENBQW9CUixFQUFwQixDQUFKLEVBQ0lNLElBQUlDLFNBQVNDLFVBQVQsQ0FBb0JSLEVBQXBCLEVBQXdCVixFQUE1QjtBQUNKLGVBQU9nQixDQUFQO0FBQ0g7QUExRFMsQ0FBZDtBQTREQUcsT0FBTzFCLEtBQVAsR0FBZUEsS0FBZiIsImZpbGUiOiIyMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBWdWVSZXNvdXJjZSBmcm9tICd2dWUtcmVzb3VyY2UnOyBcbi8vcmVxdWlyZSgnLi9Bc3NldHMvSnMvbGliL3Z1ZS5taW4uanM/cj0xJylcbi8vaW1wb3J0IFZ1ZSBmcm9tICcuL0Fzc2V0cy9Kcy9saWIvdnVlLm1pbi5qcydcbmltcG9ydCBkZW1vIGZyb20gJy4vc3JjL0NvbXBvbmVudHMvU2FtcGxlcy9kZW1vLnZ1ZSdcbmltcG9ydCBoaXN0b2dyYW0gZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9EYXRhUmVuZGVyL3Brcy5oaXN0b2dyYW0udnVlJ1xuaW1wb3J0IGltYWdlIGZyb20gJy4vc3JjL0NvbXBvbmVudHMvRGF0YVJlbmRlci9wa3MuaW1hZ2UudnVlJ1xuaW1wb3J0IGhlYWRlciBmcm9tICcuL1NyYy9Db21wb25lbnRzL0xheW91dC9wa3MuaGVhZGVyLnZ1ZSdcbmltcG9ydCBtZW51IGZyb20gJy4vU3JjL0NvbXBvbmVudHMvTGF5b3V0L3Brcy5tZW51LnZ1ZSdcbmltcG9ydCB0YWJzIGZyb20gJy4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MudGFicy52dWUnXG5pbXBvcnQgY2xpY2t0YWJzIGZyb20gJy4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MuY3RhYnMudnVlJ1xuaW1wb3J0IGxpc3QgZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0LnZ1ZSdcbmltcG9ydCBsaXN0bSBmcm9tICcuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLmxpc3RtLnZ1ZSdcbmltcG9ydCBtdWx0aXBsZVRpdGxlIGZyb20gJy4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MubXVsdGlwbGVUaXRsZS52dWUnXG5pbXBvcnQgcGFuZWwgZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbC52dWUnXG5pbXBvcnQgcGFuZWwyIGZyb20gJy4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MucGFuZWwyLnZ1ZSdcbmltcG9ydCBwYW5lbExpc3QgZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbExpc3QudnVlJ1xuaW1wb3J0IHNpbmdsZVRpdGxlIGZyb20gJy4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3Muc2luZ2xlVGl0bGUudnVlJ1xuaW1wb3J0IGZpbHRlcmxpc3QgZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5maWx0ZXJsaXN0LnZ1ZSdcbmltcG9ydCBpbWdsaXN0IGZyb20gJy4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MuaW1nbGlzdC52dWUnXG5pbXBvcnQgc29ydCBmcm9tICcuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnNvcnQudnVlJ1xuaW1wb3J0IGxpc3R0YWJsZSBmcm9tICcuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLmxpc3R0YWJsZS52dWUnXG5pbXBvcnQgcGFnZXIgZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYWdlci52dWUnXG5pbXBvcnQgbm9zdHJ1Y3R0YWJsZSBmcm9tICcuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLm5vc3RydWN0dGFibGUudnVlJ1xuaW1wb3J0IGNvbXBsZXggZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5jb21wbGV4RmlsdHJhdGlvbi52dWUnXG5pbXBvcnQgaW1ndmlld2VyIGZyb20gJy4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MuaW1ndmlld2VyLnZ1ZSdcbmltcG9ydCBzaW5nbGVpbWcgZnJvbSAnLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zaW5nbGVpbWcudnVlJ1xuXG5WdWUudXNlKFZ1ZVJlc291cmNlKTtcbmNvbnN0IG1vZGVscz17XG4gICAgXCJwa3M6ZGVtb1wiOmRlbW8sXG4gICAgXCJwa3M6aGlzdG9ncmFtXCI6aGlzdG9ncmFtLFxuICAgIFwicGtzOmhlYWRlclwiOmhlYWRlcixcbiAgICBcInBrczptZW51XCI6bWVudSxcbiAgICBcInBrczp0YWJzXCI6dGFicyxcbiAgICBcInBrczpjdGFic1wiOmNsaWNrdGFicyxcbiAgICBcInBrczpsaXN0XCI6bGlzdCxcbiAgICBcInBrczpsaXN0bVwiOmxpc3RtLFxuICAgIFwicGtzOm11bHRpcGxldGl0bGVcIjptdWx0aXBsZVRpdGxlLFxuICAgIFwicGtzOnBhbmVsXCI6cGFuZWwsXG4gICAgXCJwa3M6cGFuZWwyXCI6cGFuZWwyLFxuICAgIFwicGtzOnBhbmVsbGlzdFwiOnBhbmVsTGlzdCxcbiAgICBcInBrczpzaW5nbGV0aXRsZVwiOnNpbmdsZVRpdGxlLFxuICAgIFwicGtzOmZpbHRlcmxpc3RcIjpmaWx0ZXJsaXN0LFxuICAgIFwicGtzOmltZ2xpc3RcIjppbWdsaXN0LFxuICAgIFwicGtzOmxpc3R0YWJsZVwiOmxpc3R0YWJsZSxcblx0XCJwa3M6c29ydFwiOnNvcnQsXG5cdFwicGtzOnBhZ2VyXCI6cGFnZXIsXG5cdFwicGtzOm5vc3RydWN0dGFibGVcIjpub3N0cnVjdHRhYmxlLFxuICAgIFwicGtzOmNvbXBsZXhcIjpjb21wbGV4LFxuICAgIFwicGtzOmltZ3ZpZXdlclwiOmltZ3ZpZXdlcixcbiAgICBcInBrczppbWFnZVwiOmltYWdlLFxuICAgIFwicGtzOnNpbmdsZWltZ1wiOnNpbmdsZWltZ1xufVxuY29uc3QgUEtTVUkgPSB7XG4gICAgaXNBdXRvTG9hZFVJOiB0cnVlLFxuICAgIGJpbmQ6IGZ1bmN0aW9uKGNvbSkge1xuICAgICAgICBsZXQgbW9kZWwgPSB7fTtcbiAgICAgICAgaWYgKGNvbS5tb2RlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihjb20ubW9kZWwpID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2NvbS5tb2RlbF06IG1vZGVsc1tjb20ubW9kZWxdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbS5tb2RlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFtjb20ubW9kZWxbaV1dID0gbW9kZWxzW2NvbS5tb2RlbFtpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy/lh7rkuo7mgKfog73nmoTogIPomZHvvIznm67liY3lv4XpobvmiYvliqjms6jlhozkvb/nlKjliLDnmoTmqKHlnZfjgIJcbiAgICAgICAgICAgIG1vZGVsPW1vZGVscztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IHZtID0gbmV3IFZ1ZSh7XG4gICAgICAgICAgICBlbDogY29tLmVsLFxuICAgICAgICAgICAgZGF0YTogY29tLmRhdGEsXG4gICAgICAgICAgICBtZXRob2RzOiBjb20ubWV0aG9kcyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IG1vZGVsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdm07XG4gICAgfSxcbiAgIFxuICAgIGdldERhdGFCeVZtOiBmdW5jdGlvbih2bSwgbmFtZSkge1xuICAgICAgICAvLyByZXR1cm4gdm0uJGdldChuYW1lKTtcbiAgICAgICAgcmV0dXJuIHZtLiRkYXRhW25hbWVdO1xuICAgIH0sXG4gICAgc2V0RGF0YUJ5Vm06IGZ1bmN0aW9uKHZtLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgIC8vdm0uJHNldChuYW1lLCBkYXRhKTtcbiAgICAgICAgdm0uJGRhdGFbbmFtZV0gPSBkYXRhO1xuICAgIH0sXG4gICAgZ2V0RGF0YUJ5SWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgIGxldCB2bSA9IFBLU1VJLmdldFZpZXdNb2RlbChpZCk7XG4gICAgICAgIC8vcmV0dXJuIHZtLiRnZXQobmFtZSk7XG4gICAgICAgIHJldHVybiB2bS4kZGF0YVtuYW1lXTtcbiAgICB9LFxuICAgIHNldERhdGFCeUlkOiBmdW5jdGlvbihpZCwgbmFtZSwgZGF0YSkge1xuICAgICAgICBsZXQgdm0gPSBQS1NVSS5nZXRWaWV3TW9kZWwoaWQpO1xuICAgICAgICAvL3ZtLiRzZXQobmFtZSwgZGF0YSk7XG4gICAgICAgIHZtLiRkYXRhW25hbWVdID0gZGF0YTtcbiAgICB9LFxuICAgIGJpbmRWaWV3TW9kZWw6IGZ1bmN0aW9uKHZtLCBzY29wZSkge1xuICAgICAgICB2bS4kbW91bnQoXCIjXCIgKyBzY29wZSk7XG4gICAgfSxcbiAgICBnZXRWaWV3TW9kZWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIC8v5oyJaWTojrflj5boh6rliqjliqDovb1VSeaYr+eahHZtXG4gICAgICAgIGxldCByID0gbnVsbDtcbiAgICAgICAgaWYgKCFQS1NVSS5pc0F1dG9Mb2FkVUkpXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgaWYgKHNvTW9kZWxzLnZpZXdNb2RlbHNbaWRdKVxuICAgICAgICAgICAgciA9IHNvTW9kZWxzLnZpZXdNb2RlbHNbaWRdLnZtO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9LFxufTtcbndpbmRvdy5QS1NVSSA9IFBLU1VJO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RlbW8uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n\n//import echarts from 'echarts'\nvar echarts = __webpack_require__(1);\n// 引入折现图\n__webpack_require__(113);\n__webpack_require__(105);\n// 引入提示框和标题组件\n__webpack_require__(153);\n__webpack_require__(144);\n__webpack_require__(145);\n__webpack_require__(139);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        var types, x, y, maintitle, smooth, yAxisName, legend;\n        if (this.isEmptyObject(this.data)) {\n            types = \"bar\";\n            x = [];\n            y = [];\n            maintitle = \"\", smooth = true;\n            yAxisName = \"\";\n            legend = [];\n        } else {\n            types = this.gettypes(this.data);\n            x = this.getxdata(this.data);\n            y = this.getydata(this.data);\n            maintitle = this.data.setting.title === \"\" || !this.data.setting.title ? \"\" : this.data.setting.title, smooth = !this.data.setting.smooth ? true : this.data.setting.smooth;\n            yAxisName = !this.data.setting.yaxiscaption ? \"\" : this.data.setting.yaxiscaption;\n            legend = !this.data.setting.legend ? [] : this.data.setting.legend;\n        }\n        return {\n            maintitle: maintitle,\n            smooth: smooth,\n            type: types,\n            yAxisName: yAxisName,\n            legend: legend,\n            xAxis: x,\n            dataArea: y\n        };\n    },\n\n    props: {\n        //组件宽度\"200px\"|\"50%\"\n        width: {\n            type: String,\n            default: \"100%\"\n        },\n        //组件高度\"200px\"|\"50%\"\n        height: {\n            type: String,\n            default: \"100%\"\n        },\n        //后台传递的数据结构\n        data: Object,\n        //工具栏显示\n        showtool: {\n            type: Boolean,\n            default: false\n        },\n        //柱状图标签显示\n        showlabel: {\n            type: Boolean,\n            default: false\n        },\n        //标题所在位置\n        titlelocation: {\n            type: Array,\n            default: function _default() {\n                return [\"center\", \"bottom\"];\n            }\n        },\n        barwidth: {\n            type: Number,\n            default: 15\n        },\n        //标题尺寸\n        fontsize: {\n            type: String,\n            default: \"14\"\n        },\n        //图例位置及样式\n        legendstyle: {\n            type: Array,\n            default: function _default() {\n                return [\"center\", \"top\", \"horizontal\"];\n            }\n        }\n    },\n    methods: {\n        isEmptyObject: function isEmptyObject(e) {\n            var t;\n            for (t in e) {\n                return !1;\n            }return !0;\n        },\n        gettypes: function gettypes(data) {\n            var defaultchart = data.setting.defaultchart ? data.setting.defaultchart : \"bar\";\n            var types;\n            if (!data.setting.chart || data.setting.chart.length == 0) {\n                types = [defaultchart];\n            } else {\n                types = data.setting.chart;\n            }\n            return types;\n        },\n        getkeywordindex: function getkeywordindex(data) {\n            var xfield = data.setting.xaxisfield;\n            var columns = data.columns;\n            var index = 0;\n            var i = 0;\n            $.map(columns, function (item) {\n                if (item.field == xfield) {\n                    index = i;\n                    return;\n                }\n                i++;\n            });\n            return index;\n        },\n        getxdata: function getxdata(data) {\n            var x = [];\n            var index = this.getkeywordindex(data);\n            var rows = this.data.rows;\n            if (rows.length != 0) {\n                for (var k = 0, j = rows[0].length; k < j; k++) {\n                    if (k == index) {\n                        for (var t = 0, h = rows.length; t < h; t++) {\n                            x.push(rows[t][k]);\n                        }\n                    }\n                }\n            }\n            return x;\n        },\n        getydata: function getydata(data) {\n            var rows = this.data.rows;\n            var index = this.getkeywordindex(data);\n            var y = [];\n            if (rows.length != 0) {\n                for (var k = 0, j = rows[0].length; k < j; k++) {\n                    var list0 = [];\n                    if (k != index) {\n                        for (var m = 0, n = rows.length; m < n; m++) {\n                            list0.push(rows[m][k]);\n                        }\n                        y.push(list0);\n                    }\n                }\n            }\n            return y;\n        },\n        getoption: function getoption() {\n            var self = this;\n            var option = {\n                title: {\n                    x: self.titlelocation[0],\n                    y: self.titlelocation[1],\n                    text: self.maintitle,\n                    textStyle: {\n                        fontSize: self.fontsize\n                    }\n                },\n                tooltip: {\n                    trigger: 'axis'\n                },\n                legend: {\n                    data: self.legend,\n                    x: self.legendstyle[0],\n                    y: self.legendstyle[1],\n                    orient: self.legendstyle[2]\n                },\n                xAxis: {\n                    type: \"category\",\n                    data: self.xAxis\n                },\n                yAxis: {\n                    type: \"value\",\n                    name: self.yAxisName\n                },\n                toolbox: {\n                    show: self.showtool,\n                    feature: {\n                        mark: { show: true },\n                        dataView: { show: true, readOnly: false },\n                        saveAsImage: { show: true }\n                    }\n                },\n                series: function () {\n                    var list = [];\n                    var _bool = self.type.length < 2 ? true : false;\n                    for (var i = 0; i < self.dataArea.length; i++) {\n                        var bardata = {};\n                        bardata.name = self.legend[i];\n                        bardata.type = _bool ? self.type[0] : self.type[i];\n                        bardata.smooth = self.smooth;\n                        bardata.barWidth = self.barwidth;\n                        bardata.itemStyle = {\n                            normal: {\n                                label: {\n                                    show: self.showlabel, position: 'top'\n                                }\n                            }\n                        };\n                        bardata.data = self.dataArea[i];\n                        list.push(bardata);\n                    }\n                    return list;\n                }()\n            };\n            return option;\n        },\n        getchartobj: function getchartobj() {\n            return echarts.init(this.$el);\n        }\n    },\n    watch: {\n        'data': function data() {\n            if (this.isEmptyObject(this.data)) {\n                this.getchartobj().dispose();\n            } else {\n                this.maintitle = this.data.setting.title === \"\" || !this.data.setting.title ? \"\" : this.data.setting.title;\n                this.smooth = !this.data.setting.smooth ? true : this.data.setting.smooth;\n                this.yAxisName = !this.data.setting.yaxiscaption ? \"\" : this.data.setting.yaxiscaption;\n                this.legend = !this.data.setting.legend ? [] : this.data.setting.legend;\n                this.type = this.gettypes(this.data);\n                this.xAxis = this.getxdata(this.data);\n                this.dataArea = this.getydata(this.data);\n                var option = this.getoption();\n                this.getchartobj().setOption(option);\n            }\n            // mychart.clear();\n        }\n    },\n    mounted: function mounted() {\n        if (this.isEmptyObject(this.data)) return;\n        var option = this.getoption();\n        this.getchartobj().setOption(option);\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmhpc3RvZ3JhbS52dWU/MTkzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzBCQUVBO3VEQUNBOzJDQUNBO29CQUNBO2dCQUNBO2dCQUNBO3dCQUNBLGFBQ0E7d0JBQ0E7cUJBQ0E7ZUFDQTt1Q0FDQTttQ0FDQTttQ0FDQTs0R0FDQSxxRUFDQTtpRkFDQTt3RUFDQTtBQUNBOzt1QkFFQTtvQkFDQTtrQkFDQTt1QkFDQTtvQkFDQTttQkFDQTtzQkFFQTtBQVJBO0FBU0E7OztBQUVBOztrQkFFQTtxQkFFQTtBQUhBO0FBSUE7O2tCQUVBO3FCQUVBO0FBSEE7QUFJQTtjQUNBO0FBQ0E7O2tCQUVBO3FCQUVBO0FBSEE7QUFJQTs7a0JBRUE7cUJBRUE7QUFIQTtBQUlBOztrQkFFQTt5Q0FDQTtrQ0FDQTtBQUVBO0FBTEE7O2tCQU9BO3FCQUVBO0FBSEE7QUFJQTs7a0JBRUE7cUJBRUE7QUFIQTtBQUlBOztrQkFFQTt5Q0FDQTt5Q0FDQTtBQUdBO0FBTkE7QUF4Q0E7O2lEQWdEQTtnQkFDQTtzQkFDQTt3QkFDQTtxQkFDQTtBQUNBOzBDQUNBO3VGQUNBO2dCQUNBO3VFQUNBO3lCQUNBO21CQUNBO3FDQUNBO0FBQ0E7bUJBQ0E7QUFDQTt3REFDQTtzQ0FDQTsrQkFDQTt3QkFDQTtvQkFDQTsyQ0FDQTswQ0FDQTs0QkFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO21CQUNBO0FBQ0E7MENBQ0E7b0JBQ0E7NkNBQ0E7aUNBQ0E7a0NBQ0E7Z0VBQ0E7b0NBQ0E7cUVBQ0E7MkNBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTttQkFDQTtBQUNBOzBDQUNBO2lDQUNBOzZDQUNBO29CQUNBO2tDQUNBO2dFQUNBO2dDQUNBO29DQUNBO3FFQUNBOytDQUNBO0FBQ0E7K0JBQ0E7QUFDQTtBQUNBO0FBQ0E7bUJBQ0E7QUFDQTt3Q0FDQTt1QkFDQTs7OzBDQUdBOzBDQUNBOytCQUNBOzt1Q0FJQTtBQUhBO0FBSkE7OzZCQVVBO0FBRkE7OytCQUlBO3dDQUNBO3dDQUNBOzZDQUVBO0FBTEE7OzBCQU9BOytCQUVBO0FBSEE7OzBCQUtBOytCQUVBO0FBSEE7OytCQUtBOztzQ0FFQTswREFDQTs2Q0FHQTtBQUxBO0FBRkE7b0NBUUE7K0JBQ0E7OERBQ0E7bUVBQ0E7c0NBQ0E7bURBQ0E7d0VBQ0E7OENBQ0E7Z0RBQ0E7Ozs7b0VBT0E7QUFKQTtBQURBO0FBREE7cURBT0E7a0NBQ0E7QUFDQTsyQkFDQTtBQUVBO0FBdkRBO21CQXdEQTtBQUNBOzRDQUNBO3FDQUNBO0FBRUE7QUE5SEE7O2dDQWdJQTsrQ0FDQTttQ0FDQTttQkFDQTtxSEFDQTttRkFDQTswRkFDQTtpRkFDQTsrQ0FDQTtnREFDQTttREFDQTtrQ0FDQTs2Q0FDQTtBQUNBO0FBQ0E7QUFFQTtBQWpCQTtnQ0FrQkE7MkNBQ0E7MEJBQ0E7cUNBQ0E7QUFDQTtBQWxPQSIsImZpbGUiOiIyMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IG5hbWU9XCJlY2hhcnRzXCIgOnN0eWxlPVwie2hlaWdodDpoZWlnaHQsd2lkdGg6d2lkdGh9XCI+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuLy9pbXBvcnQgZWNoYXJ0cyBmcm9tICdlY2hhcnRzJ1xyXG5sZXQgZWNoYXJ0cyA9IHJlcXVpcmUoJ2VjaGFydHMvbGliL2VjaGFydHMnKTtcclxuLy8g5byV5YWl5oqY546w5Zu+XHJcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NoYXJ0L2xpbmUnKTtcclxucmVxdWlyZShcImVjaGFydHMvbGliL2NoYXJ0L2JhclwiKVxyXG4vLyDlvJXlhaXmj5DnpLrmoYblkozmoIfpopjnu4Tku7ZcclxucmVxdWlyZSgnZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAnKTtcclxucmVxdWlyZSgnZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlJyk7XHJcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94Jyk7XHJcbnJlcXVpcmUoXCJlY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kXCIpO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHZhciB0eXBlcywgeCwgeSxtYWludGl0bGUsc21vb3RoLHlBeGlzTmFtZSxsZWdlbmQ7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eU9iamVjdCh0aGlzLmRhdGEpKSB7XHJcbiAgICAgICAgICAgIHR5cGVzID0gXCJiYXJcIjtcclxuICAgICAgICAgICAgeCA9IFtdO1xyXG4gICAgICAgICAgICB5ID0gW107XHJcbiAgICAgICAgICAgIG1haW50aXRsZT1cIlwiLFxyXG4gICAgICAgICAgICBzbW9vdGg9dHJ1ZTtcclxuICAgICAgICAgICAgeUF4aXNOYW1lPVwiXCI7XHJcbiAgICAgICAgICAgIGxlZ2VuZD1bXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlcyA9IHRoaXMuZ2V0dHlwZXModGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgeCA9IHRoaXMuZ2V0eGRhdGEodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgeSA9IHRoaXMuZ2V0eWRhdGEodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgbWFpbnRpdGxlPXRoaXMuZGF0YS5zZXR0aW5nLnRpdGxlID09PSBcIlwiIHx8ICF0aGlzLmRhdGEuc2V0dGluZy50aXRsZSA/IFwiXCIgOiB0aGlzLmRhdGEuc2V0dGluZy50aXRsZSxcclxuICAgICAgICAgICAgc21vb3RoPSF0aGlzLmRhdGEuc2V0dGluZy5zbW9vdGggPyB0cnVlIDogdGhpcy5kYXRhLnNldHRpbmcuc21vb3RoO1xyXG4gICAgICAgICAgICB5QXhpc05hbWU9IXRoaXMuZGF0YS5zZXR0aW5nLnlheGlzY2FwdGlvbiA/IFwiXCIgOiB0aGlzLmRhdGEuc2V0dGluZy55YXhpc2NhcHRpb247XHJcbiAgICAgICAgICAgIGxlZ2VuZD0hdGhpcy5kYXRhLnNldHRpbmcubGVnZW5kID8gW10gOiB0aGlzLmRhdGEuc2V0dGluZy5sZWdlbmQ7XHJcbiAgICAgICAgfSAgICAgICBcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYWludGl0bGU6IG1haW50aXRsZSxcclxuICAgICAgICAgICAgc21vb3RoOnNtb290aCxcclxuICAgICAgICAgICAgdHlwZTogdHlwZXMsXHJcbiAgICAgICAgICAgIHlBeGlzTmFtZTogeUF4aXNOYW1lLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZCxcclxuICAgICAgICAgICAgeEF4aXM6IHgsXHJcbiAgICAgICAgICAgIGRhdGFBcmVhOiB5XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgLy/nu4Tku7blrr3luqZcIjIwMHB4XCJ8XCI1MCVcIlxyXG4gICAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDogXCIxMDAlXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v57uE5Lu26auY5bqmXCIyMDBweFwifFwiNTAlXCJcclxuICAgICAgICBoZWlnaHQ6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBcIjEwMCVcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/lkI7lj7DkvKDpgJLnmoTmlbDmja7nu5PmnoRcclxuICAgICAgICBkYXRhOiBPYmplY3QsXHJcbiAgICAgICAgLy/lt6XlhbfmoI/mmL7npLpcclxuICAgICAgICBzaG93dG9vbDoge1xyXG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/mn7Hnirblm77moIfnrb7mmL7npLpcclxuICAgICAgICBzaG93bGFiZWw6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v5qCH6aKY5omA5Zyo5L2N572uXHJcbiAgICAgICAgdGl0bGVsb2NhdGlvbjoge1xyXG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcclxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImNlbnRlclwiLCBcImJvdHRvbVwiXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBiYXJ3aWR0aDoge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDE1XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL+agh+mimOWwuuWvuFxyXG4gICAgICAgIGZvbnRzaXplOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDogXCIxNFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL+WbvuS+i+S9jee9ruWPiuagt+W8j1xyXG4gICAgICAgIGxlZ2VuZHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiY2VudGVyXCIsIFwidG9wXCIsIFwiaG9yaXpvbnRhbFwiXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgdDtcclxuICAgICAgICAgICAgZm9yICh0IGluIGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XHJcbiAgICAgICAgICAgIHJldHVybiAhMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0dHlwZXM6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Y2hhcnQgPSBkYXRhLnNldHRpbmcuZGVmYXVsdGNoYXJ0ID8gZGF0YS5zZXR0aW5nLmRlZmF1bHRjaGFydCA6IFwiYmFyXCI7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcztcclxuICAgICAgICAgICAgaWYgKCFkYXRhLnNldHRpbmcuY2hhcnQgfHwgZGF0YS5zZXR0aW5nLmNoYXJ0Lmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcyA9IFtkZWZhdWx0Y2hhcnRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHlwZXMgPSBkYXRhLnNldHRpbmcuY2hhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0a2V5d29yZGluZGV4OiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgeGZpZWxkID0gZGF0YS5zZXR0aW5nLnhheGlzZmllbGQ7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gZGF0YS5jb2x1bW5zO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5maWVsZCA9PSB4ZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXR4ZGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBbXTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRrZXl3b3JkaW5kZXgoZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5kYXRhLnJvd3M7XHJcbiAgICAgICAgICAgIGlmIChyb3dzLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgaiA9IHJvd3NbMF0ubGVuZ3RoOyBrIDwgajsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDAsIGggPSByb3dzLmxlbmd0aDsgdCA8IGg7IHQrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5wdXNoKHJvd3NbdF1ba10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0eWRhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5kYXRhLnJvd3M7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0a2V5d29yZGluZGV4KGRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgeSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAocm93cy5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGogPSByb3dzWzBdLmxlbmd0aDsgayA8IGo7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0MCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrICE9IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwLCBuID0gcm93cy5sZW5ndGg7IG0gPCBuOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QwLnB1c2gocm93c1ttXVtrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgeS5wdXNoKGxpc3QwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRvcHRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnRpdGxlbG9jYXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogc2VsZi50aXRsZWxvY2F0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHNlbGYubWFpbnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogc2VsZi5mb250c2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogJ2F4aXMnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VsZi5sZWdlbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5sZWdlbmRzdHlsZVswXSxcclxuICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLmxlZ2VuZHN0eWxlWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudDogc2VsZi5sZWdlbmRzdHlsZVsyXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHhBeGlzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjYXRlZ29yeVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlbGYueEF4aXNcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB5QXhpczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidmFsdWVcIixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZWxmLnlBeGlzTmFtZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRvb2xib3g6IHtcclxuICAgICAgICAgICAgICAgICAgICBzaG93OiBzZWxmLnNob3d0b29sLFxyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyazogeyBzaG93OiB0cnVlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFWaWV3OiB7IHNob3c6IHRydWUsIHJlYWRPbmx5OiBmYWxzZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlQXNJbWFnZTogeyBzaG93OiB0cnVlIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9ib29sID0gc2VsZi50eXBlLmxlbmd0aCA8IDIgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmRhdGFBcmVhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXJkYXRhID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmRhdGEubmFtZSA9IHNlbGYubGVnZW5kW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJkYXRhLnR5cGUgPSBfYm9vbCA/IHNlbGYudHlwZVswXSA6IHNlbGYudHlwZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyZGF0YS5zbW9vdGggPSBzZWxmLnNtb290aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyZGF0YS5iYXJXaWR0aCA9IHNlbGYuYmFyd2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmRhdGEuaXRlbVN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogc2VsZi5zaG93bGFiZWwsIHBvc2l0aW9uOiAndG9wJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyZGF0YS5kYXRhID0gc2VsZi5kYXRhQXJlYVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGJhcmRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0XHJcbiAgICAgICAgICAgICAgICB9KCkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRjaGFydG9iajpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gZWNoYXJ0cy5pbml0KHRoaXMuJGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2F0Y2g6IHtcclxuICAgICAgICAnZGF0YSc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pc0VtcHR5T2JqZWN0KHRoaXMuZGF0YSkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRjaGFydG9iaigpLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW50aXRsZT10aGlzLmRhdGEuc2V0dGluZy50aXRsZSA9PT0gXCJcIiB8fCAhdGhpcy5kYXRhLnNldHRpbmcudGl0bGUgPyBcIlwiIDogdGhpcy5kYXRhLnNldHRpbmcudGl0bGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNtb290aD0hdGhpcy5kYXRhLnNldHRpbmcuc21vb3RoID8gdHJ1ZSA6IHRoaXMuZGF0YS5zZXR0aW5nLnNtb290aDtcclxuICAgICAgICAgICAgICAgIHRoaXMueUF4aXNOYW1lPSF0aGlzLmRhdGEuc2V0dGluZy55YXhpc2NhcHRpb24gPyBcIlwiIDogdGhpcy5kYXRhLnNldHRpbmcueWF4aXNjYXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWdlbmQ9IXRoaXMuZGF0YS5zZXR0aW5nLmxlZ2VuZCA/IFtdIDogdGhpcy5kYXRhLnNldHRpbmcubGVnZW5kO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gdGhpcy5nZXR0eXBlcyh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54QXhpcyA9IHRoaXMuZ2V0eGRhdGEodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUFyZWEgPSB0aGlzLmdldHlkYXRhKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID10aGlzLmdldG9wdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRjaGFydG9iaigpLnNldE9wdGlvbihvcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgLy8gbXljaGFydC5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkKCkge1xyXG4gICAgICAgIGlmKHRoaXMuaXNFbXB0eU9iamVjdCh0aGlzLmRhdGEpKSByZXR1cm47XHJcbiAgICAgICAgdmFyIG9wdGlvbiA9dGhpcy5nZXRvcHRpb24oKTtcclxuICAgICAgICB0aGlzLmdldGNoYXJ0b2JqKCkuc2V0T3B0aW9uKG9wdGlvbik7XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBrcy5oaXN0b2dyYW0udnVlPzU4ZTM2M2ZhIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 223 */
/***/ (function(module, exports) {

eval("//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nmodule.exports = {\n    data: function data() {\n        return {};\n    },\n    props: {\n        redirectgissys: Function,\n        redirectsysmgr: Function,\n        redirectmessage: Function,\n        settingfunsys: Function,\n        logout: Function,\n        searchknowledge: Function,\n        //messagecount: {\n        //    type: String,\n        //    default:\"0\"\n        //},\n        imgsource: {\n            type: String,\n            default: \"\"\n        },\n        currentuser: {\n            type: String,\n            default: \"admin\"\n        },\n        logosource: {\n            type: String,\n            default: \"\"\n        },\n        txtSearch: {\n            type: String,\n            default: \"\"\n        }\n    },\n    methods: {\n        //GIS 事件处理\n        redirectGisSys: function redirectGisSys(event) {\n            this.redirectgissys && this.redirectgissys();\n        }, //系统管理\n        redirectSysMgr: function redirectSysMgr(event) {\n            this.redirectsysmgr && this.redirectsysmgr();\n        },\n        redirectMessage: function redirectMessage(event) {\n            this.redirectmessage && this.redirectmessage();\n        },\n        //settingFunSys: function (event) {\n        //    this.settingfunsys && this.settingfunsys();\n        //},\n        logOut: function logOut(event) {\n            this.logout && this.logout();\n        }, //搜索\n        searchKnowledge: function searchKnowledge(event) {\n            this.searchknowledge && this.searchknowledge();\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmhlYWRlci52dWU/ZWUzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkRBOzBCQUVBO2VBQ0E7QUFDQTs7d0JBRUE7d0JBQ0E7eUJBQ0E7dUJBQ0E7Z0JBQ0E7eUJBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a0JBRUE7cUJBRUE7QUFIQTs7a0JBS0E7cUJBRUE7QUFIQTs7a0JBS0E7cUJBRUE7QUFIQTs7a0JBS0E7cUJBR0E7QUFKQTtBQXZCQTs7QUE2QkE7dURBQ0E7d0NBQ0E7V0FDQTt1REFDQTt3Q0FDQTtBQUNBO3lEQUNBO3lDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7dUNBQ0E7Z0NBQ0E7V0FDQTt5REFDQTt5Q0FDQTtBQUVBO0FBcEJBO0FBaENBIiwiZmlsZSI6IjIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlci10b3BcIj5cclxuICAgICAgICAgICAgPHVsIGNsYXNzPVwibmF2IG5hdmJhci1uYXYgbmF2YmFyLWxlZnRcIj5cclxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImFjdGl2ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgQGNsaWNrPVwicmVkaXJlY3RHaXNTeXNcIj48c3Bhbj48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbWFwLW1hcmtlclwiPjwvaT5HaXPns7vnu588L3NwYW4+PC9hPlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiI1wiIEBjbGljaz1cInJlZGlyZWN0U3lzTWdyXCI+PHNwYW4+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRoLWxhcmdlXCI+PC9pPuezu+e7n+euoeeQhjwvc3Bhbj48L2E+XHJcbiAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJuYXYgbmF2YmFyLW5hdiBuYXZiYXItcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgIDwhLS08bGkgY2xhc3M9XCJhY3RpdmVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiI1wiIEBjbGljaz1cInJlZGlyZWN0TWVzc2FnZVwiPjxzcGFuPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1iZWxsXCI+PC9pPua2iOaBrzwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJiYWRnZVwiPnt7bWVzc2FnZWNvdW50fX08L3NwYW4+PC9hPlxyXG4gICAgICAgICAgICAgICAgPC9saT4tLT5cclxuICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiI1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIDpzcmM9XCJpbWdzb3VyY2VcIiBjbGFzcz1cImltZy1jaXJjbGVcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57e2N1cnJlbnR1c2VyfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgIDwhLS08bGkgY2xhc3M9XCJhY3RpdmVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiI1wiIEBjbGljaz1cInNldHRpbmdGdW5TeXNcIj48c3Bhbj7orr7nva48L3NwYW4+PC9hPlxyXG4gICAgICAgICAgICAgICAgPC9saT4tLT5cclxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImFjdGl2ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgQGNsaWNrPVwibG9nT3V0XCI+PHNwYW4+6YCA5Ye6PC9zcGFuPjwvYT5cclxuICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlci1uYW1lIGhlYWRlci1zZWFyY2hcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvZ29cIj5cclxuICAgICAgICAgICAgICAgIDxpbWcgOnNyYz1cImxvZ29zb3VyY2VcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21wYW55bmFtZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwicDFcIj7kuK3lm73mtbfmsrnmt7HlnLPliIblhazlj7g8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJwMlwiPuaZuuiDveWLmOaOouWNj+WQjOW3peS9nOW5s+WPsDwvcD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2hcIiBzdHlsZT1cIndpZHRoOjUwMHB4XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuIGRyb3Bkb3duXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXdoaXRlIGRyb3Bkb3duLXRvZ2dsZVwiIGlkPVwic2VsZWN0LWFyZWFcIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwidHJ1ZVwiPuermeWGhSA8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCIgYXJpYS1sYWJlbGxlZGJ5PVwic2VsZWN0LWFyZWFcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiIyBcIj7nq5nlhoU8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIjIFwiPuaQnOayuTwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgXCIgYXJpYS1sYWJlbD1cIi4uLiBcIiBwbGFjZWhvbGRlcj1cIuaIkOaenOOAgeaVsOaNruOAgeefpeivhuOAgeeZvuenkeOAgeagh+WHhlwiIHJlZj1cInR4dFNlYXJjaFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1idG4gXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgXCIgdHlwZT1cImJ1dHRvblwiIEBjbGljaz1cInNlYXJjaEtub3dsZWRnZVwiPuaQnOe0ojwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgIHJlZGlyZWN0Z2lzc3lzOiBGdW5jdGlvbixcclxuICAgICAgICAgICAgcmVkaXJlY3RzeXNtZ3I6IEZ1bmN0aW9uLFxyXG4gICAgICAgICAgICByZWRpcmVjdG1lc3NhZ2U6IEZ1bmN0aW9uLFxyXG4gICAgICAgICAgICBzZXR0aW5nZnVuc3lzOiBGdW5jdGlvbixcclxuICAgICAgICAgICAgbG9nb3V0OiBGdW5jdGlvbixcclxuICAgICAgICAgICAgc2VhcmNoa25vd2xlZGdlOiBGdW5jdGlvbixcclxuICAgICAgICAgICAgLy9tZXNzYWdlY291bnQ6IHtcclxuICAgICAgICAgICAgLy8gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICAvLyAgICBkZWZhdWx0OlwiMFwiXHJcbiAgICAgICAgICAgIC8vfSxcclxuICAgICAgICAgICAgaW1nc291cmNlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIlwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGN1cnJlbnR1c2VyOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBcImFkbWluXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbG9nb3NvdXJjZTp7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCJcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0eHRTZWFyY2g6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWV0aG9kczoge1xyXG4gICAgICAgICAgICAvL0dJUyDkuovku7blpITnkIZcclxuICAgICAgICAgICAgcmVkaXJlY3RHaXNTeXM6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcmVjdGdpc3N5cyAmJiB0aGlzLnJlZGlyZWN0Z2lzc3lzKCk7XHJcbiAgICAgICAgICAgIH0sLy/ns7vnu5/nrqHnkIZcclxuICAgICAgICAgICAgcmVkaXJlY3RTeXNNZ3I6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcmVjdHN5c21nciAmJiB0aGlzLnJlZGlyZWN0c3lzbWdyKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlZGlyZWN0TWVzc2FnZTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZGlyZWN0bWVzc2FnZSAmJiB0aGlzLnJlZGlyZWN0bWVzc2FnZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL3NldHRpbmdGdW5TeXM6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAvLyAgICB0aGlzLnNldHRpbmdmdW5zeXMgJiYgdGhpcy5zZXR0aW5nZnVuc3lzKCk7XHJcbiAgICAgICAgICAgIC8vfSxcclxuICAgICAgICAgICAgbG9nT3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nb3V0ICYmIHRoaXMubG9nb3V0KCk7XHJcbiAgICAgICAgICAgIH0sLy/mkJzntKJcclxuICAgICAgICAgICAgc2VhcmNoS25vd2xlZGdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoa25vd2xlZGdlICYmIHRoaXMuc2VhcmNoa25vd2xlZGdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwa3MuaGVhZGVyLnZ1ZT8zNDllNjBiMiJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 224 */
/***/ (function(module, exports) {

eval("//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nmodule.exports = {\n    data: function data() {\n        return { items: null };\n    },\n    props: {\n        apipath: {\n            type: String,\n            default: \"\"\n        }\n    },\n    created: function created() {\n        this.getMenus();\n    },\n    updated: function updated() {\n        //var key = this.getUrlParam(\"key\");\n        var url = window.location.href;\n        if (url.indexOf(\"?\") > 0) {\n            url = url.substring(0, url.indexOf(\"?\"));\n        }\n        if (url != null) {\n            var obj = $(\"a[href ='\" + url + \"']\")[0];\n            $(\"a[href ='\" + url + \"']\").css(\"color\", \"#f79383\");\n            var liObj = $(obj).parents('.drop-menu-effect')[0];\n            $(liObj).addClass(\"active\");\n        }\n        $(\".drop-menu-effect\").each(function () {\n            var $this = $(this);\n            var theMenu = $this.find(\".dropdown-menus\");\n            var tarHeight = theMenu.height();\n            theMenu.css({ height: 0 });\n            $this.hover(function () {\n                var offsetLeft = $(this)[0].offsetLeft;\n                var divWidth = $($(this).find(\".dropdown-menus\")).width();\n                var totalWidth = offsetLeft + divWidth;\n                if (totalWidth > 1100) {\n                    var paddingWidth = 1100 - totalWidth;\n                    $($(this).find(\".dropdown-menus\")).css(\"left\", paddingWidth + 'px');\n                }\n                $(this).addClass(\"active\");\n                theMenu.stop().show().animate({ height: tarHeight }, 400);\n                //var url = window.location.href;\n                var obj = $(\"a[href ='\" + url + \"']\")[0];\n                var liObj = $(obj).parents('.drop-menu-effect')[0];\n                $(liObj).addClass(\"active\");\n            }, function () {\n                //如果当前dropdown-menus中未找到当前页面地址，则除去active\n                if ($(\"a[href ='\" + url + \"']\", $($(this).find(\".dropdown-menus\"))).length == 0) {\n                    //如果当前顶级菜单不等于当前页面地址\n                    if ($(\">a[href ='\" + url + \"']\", $(this)).length == 0) $(this).removeClass(\"active\");\n                }\n\n                theMenu.stop().animate({ height: 0 }, 400, function () {\n                    $(this).hide();\n                });\n            });\n        });\n    },\n    methods: {\n        getMenus: function getMenus() {\n            this.$http.get(this.apipath, { emulateJSON: true }).then(function (response) {\n                //response传参，可以是任何值\n                this.items = response.body.menus;\n            }).catch(function (response) {\n                console.log(response);\n            });\n        },\n        menuClick: function menuClick(url, key) {\n            if ($.trim(url) == \"\") {\n                return \"#\";\n            } else {\n                return url;\n            }\n        },\n        getUrlParam: function getUrlParam(name) {\n            var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\"); //构造一个含有目标参数的正则表达式对象\n            var r = window.location.search.substr(1).match(reg); //匹配目标参数\n            if (r != null) return unescape(r[2]);return null;\n        }\n\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLm1lbnUudnVlPzNmYTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7MEJBRUE7d0JBQ0E7QUFDQTs7O2tCQUdBO3FCQUdBO0FBSkE7QUFEQTtnQ0FNQTthQUNBO0FBQ0E7Z0NBQ0E7QUFDQTtrQ0FDQTtrQ0FDQTsrQ0FDQTtBQUNBO21CQUNBLE1BQ0E7a0RBQ0E7cURBQ0E7NERBQ0E7OEJBQ0E7QUFDQTtnREFDQTswQkFDQTtxQ0FDQTtvQ0FDQTtrQ0FDQTtrQkFDQSxrQkFDQTs0Q0FDQTtrRUFDQTs4Q0FDQTtpQ0FDQSxNQUNBOzhDQUNBO2tGQUNBO0FBQ0E7aUNBQ0E7cUVBQ0E7QUFDQTtzREFDQTtnRUFDQTtrQ0FDQTtBQUNBLDJCQUNBO0FBQ0E7OEZBQ0EsR0FDQTtBQUNBO3dFQUNBLHVCQUNBO0FBRUE7O3VFQUNBOzRCQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O3NDQUVBO3dEQUNBO0FBQ0E7MkNBQ0E7QUFDQSx5Q0FDQTs0QkFDQTtBQUNBO0FBQ0E7Z0RBQ0E7K0JBQ0EsSUFDQTt1QkFDQTtBQUVBLG1CQUNBO3VCQUNBO0FBRUE7QUFDQTtnREFDQTtvRUFDQTtpRUFDQTt3REFDQTtBQUdBOztBQTNCQTtBQWhFQSIsImZpbGUiOiIyMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8IS0taGVhZC1uYXYtLT5cclxuICAgIDxkaXYgY2xhc3M9XCJoZWFkZXItbmF2XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1uYXZvbmVcIj5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpIHYtZm9yPVwiaXRlbSBpbiBpdGVtc1wiIGNsYXNzPVwiZHJvcC1tZW51LWVmZmVjdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxhIDpocmVmPVwibWVudUNsaWNrKGl0ZW0udXJsLGl0ZW0ua2V5KVwiIDpkYXRhLWtleT1cIml0ZW0ua2V5XCIgdGFyZ2V0PVwiX3NlbGZcIj57e2l0ZW0ubmFtZX19PC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgdi1pZj1cIml0ZW0uY2hpbGRyZW4ubGVuZ3RoPjAgJiYgaXRlbS5oYXNUaGlyZD09dHJ1ZVwiIGNsYXNzPVwiZHJvcGRvd24tbWVudXNcIiA6c3R5bGU9XCJ7d2lkdGg6aXRlbS5jaGlsZHJlbi5sZW5ndGgqMTUwKydweCd9XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdi1mb3I9XCJzaXRlbSBpbiBpdGVtLmNoaWxkcmVuXCIgY2xhc3M9XCJkcm9wZG93bi1tZW51cy1saVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdi1zdWJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSA6aHJlZj1cIm1lbnVDbGljayhzaXRlbS51cmwsc2l0ZW0ua2V5KVwiIDpkYXRhLWtleT1cInNpdGVtLmtleVwiIHRhcmdldD1cIl9zZWxmXCI+e3tzaXRlbS5uYW1lfX08L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgdi1pZj1cInNpdGVtLmNoaWxkcmVuLmxlbmd0aD4wXCIgdi1mb3I9XCJ0aXRlbSBpbiBzaXRlbS5jaGlsZHJlblwiIGNsYXNzPVwibmF2LXN1Yi1zdWJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSA6aHJlZj1cIm1lbnVDbGljayh0aXRlbS51cmwsdGl0ZW0ua2V5KVwiIDpkYXRhLWtleT1cInRpdGVtLmtleVwiIHRhcmdldD1cIl9zZWxmXCI+e3t0aXRlbS5uYW1lfX08L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJjbGVhcjogYm90aDsgaGVpZ2h0OiAwcHg7IG92ZXJmbG93OiBoaWRkZW47XCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWVsc2U9XCJpdGVtLmNoaWxkcmVuLmxlbmd0aD4wICYmIGl0ZW0uaGFzVGhpcmQ9PWZhbHNlXCIgY2xhc3M9XCJkcm9wZG93bi1tZW51c1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtZm9yPVwic2l0ZW0gaW4gaXRlbS5jaGlsZHJlblwiIGNsYXNzPVwiZHJvcGRvd24tbWVudXMtbGlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXYtc3ViXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgOmhyZWY9XCJtZW51Q2xpY2soc2l0ZW0udXJsLHNpdGVtLmtleSlcIiA6ZGF0YS1rZXk9XCJzaXRlbS5rZXlcIiB0YXJnZXQ9XCJfc2VsZlwiPnt7c2l0ZW0ubmFtZX19PC9hPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwiY2xlYXI6IGJvdGg7IGhlaWdodDogMHB4OyBvdmVyZmxvdzogaGlkZGVuO1wiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBpdGVtczogbnVsbCB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgYXBpcGF0aDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogXCJcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TWVudXMoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL3ZhciBrZXkgPSB0aGlzLmdldFVybFBhcmFtKFwia2V5XCIpO1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihcIj9cIikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmluZGV4T2YoXCI/XCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXJsICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSAkKFwiYVtocmVmID0nXCIgKyB1cmwgKyBcIiddXCIpWzBdO1xyXG4gICAgICAgICAgICAgICAgJChcImFbaHJlZiA9J1wiICsgdXJsICsgXCInXVwiKS5jc3MoXCJjb2xvclwiLFwiI2Y3OTM4M1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBsaU9iaiA9ICQob2JqKS5wYXJlbnRzKCcuZHJvcC1tZW51LWVmZmVjdCcpWzBdO1xyXG4gICAgICAgICAgICAgICAgJChsaU9iaikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJChcIi5kcm9wLW1lbnUtZWZmZWN0XCIpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHZhciB0aGVNZW51ID0gJHRoaXMuZmluZChcIi5kcm9wZG93bi1tZW51c1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJIZWlnaHQgPSB0aGVNZW51LmhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgdGhlTWVudS5jc3MoeyBoZWlnaHQ6IDAgfSk7XHJcbiAgICAgICAgICAgICAgICAkdGhpcy5ob3ZlcihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gJCh0aGlzKVswXS5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGl2V2lkdGggPSAkKCQodGhpcykuZmluZChcIi5kcm9wZG93bi1tZW51c1wiKSkud2lkdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsV2lkdGggPSBvZmZzZXRMZWZ0K2RpdldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aCA+IDExMDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nV2lkdGggPSAxMTAwIC0gdG90YWxXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJCh0aGlzKS5maW5kKFwiLmRyb3Bkb3duLW1lbnVzXCIpKS5jc3MoXCJsZWZ0XCIscGFkZGluZ1dpZHRoKydweCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZU1lbnUuc3RvcCgpLnNob3coKS5hbmltYXRlKHsgaGVpZ2h0OiB0YXJIZWlnaHQgfSwgNDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSAkKFwiYVtocmVmID0nXCIgKyB1cmwgKyBcIiddXCIpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlPYmogPSAkKG9iaikucGFyZW50cygnLmRyb3AtbWVudS1lZmZlY3QnKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJChsaU9iaikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5b2T5YmNZHJvcGRvd24tbWVudXPkuK3mnKrmib7liLDlvZPliY3pobXpnaLlnLDlnYDvvIzliJnpmaTljrthY3RpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoJChcImFbaHJlZiA9J1wiICsgdXJsICsgXCInXVwiLCAkKCQodGhpcykuZmluZChcIi5kcm9wZG93bi1tZW51c1wiKSkpLmxlbmd0aD09MCkgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzlvZPliY3pobbnuqfoj5zljZXkuI3nrYnkuo7lvZPliY3pobXpnaLlnLDlnYBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCQoXCI+YVtocmVmID0nXCIgKyB1cmwgKyBcIiddXCIsICQodGhpcykpLmxlbmd0aD09MClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVNZW51LnN0b3AoKS5hbmltYXRlKHsgaGVpZ2h0OiAwIH0sIDQwMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWV0aG9kczoge1xyXG4gICAgICAgICAgICBnZXRNZW51czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kaHR0cC5nZXQodGhpcy5hcGlwYXRoLCAgeyBlbXVsYXRlSlNPTjogdHJ1ZX0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7IC8vcmVzcG9uc2XkvKDlj4LvvIzlj6/ku6XmmK/ku7vkvZXlgLxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcyA9IHJlc3BvbnNlLmJvZHkubWVudXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1lbnVDbGljazogZnVuY3Rpb24gKHVybCwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJC50cmltKHVybCkgPT0gXCJcIilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIjXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRVcmxQYXJhbTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiKF58JilcIiArIG5hbWUgKyBcIj0oW14mXSopKCZ8JClcIik7IC8v5p6E6YCg5LiA5Liq5ZCr5pyJ55uu5qCH5Y+C5pWw55qE5q2j5YiZ6KGo6L6+5byP5a+56LGhXHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLm1hdGNoKHJlZyk7ICAvL+WMuemFjeebruagh+WPguaVsFxyXG4gICAgICAgICAgICAgICAgaWYgKHIgIT0gbnVsbCkgcmV0dXJuIHVuZXNjYXBlKHJbMl0pOyByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc2NyaXB0PlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLm1lbnUudnVlPzBlNGFmNDIzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        return {\n            fiveYear: null,\n            start: 1996,\n            fiveYearsPlanName: [\"九五\", \"十五\", \"十一五\", \"十二五\", \"十三五\", \"十四五\", \"十五五\", \"十六五\", \"十七五\", \"十八五\", \"十九五\"],\n            fiveYears: null,\n            yearindex: 0,\n            index: 1,\n            total: 1,\n            selectdata: {},\n            bo: {},\n            showbo: [],\n            selectbo: \"\",\n            selectYear: \"\"\n        };\n    },\n\n    props: {\n        size: {\n            type: Number,\n            default: 3\n        },\n        bosize: {\n            type: Number,\n            default: 5\n        },\n        filters: Array,\n        onboclick: Function,\n        search: Function\n    },\n    created: function created() {\n        this.fiveYears = this.getShow5thName(this.size);\n        this.change5thYear(this.yearindex);\n        var list = [];\n        this.selectYear = this.fiveYear.years[0];\n        list.push(this.fiveYear.years[0]);\n        this.selectdata[\"year\"] = list;\n    },\n    mounted: function mounted() {\n        $(\".fiveYears>span:contains(\" + this.selectYear + \")\").addClass(\"active\");\n        $(\".filter span:contains('不限')\").addClass(\"active\").siblings(\"span\").removeClass(\"active\");\n        this.onsearch();\n        this.onboClick(this.bo.bos[0]);\n    },\n    updated: function updated() {\n        $(\".fiveYears>span:contains(\" + this.selectYear + \")\").addClass(\"active\");\n        if (this.selectbo != \"\") {\n            $(\".selectbo>span:contains(\" + this.selectbo + \")\").addClass(\"active\");\n        }\n    },\n\n    watch: {\n        \"filters\": function filters() {\n            var list = [];\n            this.selectYear = this.fiveYear.years[0];\n            list.push(this.fiveYear.years[0]);\n            this.selectdata = {};\n            this.selectdata[\"year\"] = list;\n            this.onsearch();\n            this.onboClick(this.bo.bos[0]);\n        }\n    },\n    methods: {\n        //分页方法\n        setPageData: function setPageData(size, index) {\n            this.total = Math.ceil(this.bo.bos.length / this.bosize);\n            this.showbo = [];\n            var bos = this.bo.bos;\n            if (index >= this.total) {\n                for (var i = size * (index - 1), j = bos.length; i < j; i++) {\n                    this.showbo.push(bos[i]);\n                }\n            } else {\n                for (var i = size * (index - 1), j = size * index; i < j; i++) {\n                    this.showbo.push(bos[i]);\n                }\n            }\n        },\n        //获取当前年\n        getCurrentYear: function getCurrentYear() {\n            return new Date().getFullYear();\n        },\n        //获取当前年是第几个五年计划\n        getFiveYear: function getFiveYear() {\n            var year = this.getCurrentYear();\n            return year - parseInt(this.start);\n        },\n        //获取过滤数据\n        getShow5thName: function getShow5thName(size) {\n            var index = Math.ceil(this.getFiveYear() / 5) - parseInt(size) - 1;\n            var showfiveYearName = [];\n            for (var i = parseInt(size) + index, j = index; i > j; i--) {\n                var item = {\n                    fiveplan: this.fiveYearsPlanName[i],\n                    year: this.getYearArray(i)\n                };\n                showfiveYearName.push(item);\n            }\n            return showfiveYearName;\n        },\n        //通过五年计划名称获取年数组\n        getYearArray: function getYearArray(index) {\n            var list = [];\n            this.start = parseInt(this.start);\n            var _start = this.start + 5 * parseInt(index);\n            for (var m = 0, n = 5; m < n; m++) {\n                var yearIndex = _start + parseInt(m);\n                if (yearIndex > parseInt(this.getCurrentYear())) break;\n                list.push(yearIndex);\n            }\n            return list;\n        },\n        change5thYear: function change5thYear(e) {\n            var fivethyear = this.fiveYears[e];\n            this.fiveYear = {\n                name: fivethyear.fiveplan,\n                years: fivethyear.year.sort().reverse()\n            };\n        },\n        onClick: function onClick(e, event) {\n            var $event = $(event.currentTarget);\n            $event.addClass(\"active\").siblings(\"span\").removeClass(\"active\");\n            var list = [];\n            list.push(e);\n            this.selectdata.year = list;\n            this.selectYear = e;\n        },\n        onleft: function onleft() {\n            this.yearindex = this.yearindex <= 0 ? this.yearindex : --this.yearindex;\n            this.change5thYear(this.yearindex);\n        },\n        onright: function onright() {\n            this.yearindex = this.yearindex >= this.size - 1 ? this.yearindex : ++this.yearindex;\n            this.change5thYear(this.yearindex);\n        },\n        onboleft: function onboleft() {\n            if (this.index <= 1) return;\n            this.showbo = [];\n            this.setPageData(this.bosize, --this.index);\n        },\n        onboright: function onboright() {\n            if (this.index >= this.total) return;\n            this.showbo = [];\n            this.setPageData(this.bosize, ++this.index);\n        },\n        onboClick: function onboClick(e) {\n            this.selectbo = e;\n            $(\".selectbo>span:contains(\" + this.selectbo + \")\").addClass(\"active\").siblings(\"span\").removeClass(\"active\");\n            this.onboclick && this.onboclick(e);\n        },\n        onfilterclick: function onfilterclick(option, name, e) {\n            var $e = $(e.currentTarget);\n            var res = this.selectdata;\n            if (res[name] == null) {\n                var list = [];\n                list.push(option);\n                res[name] = list;\n                $e.addClass(\"active\");\n            } else {\n                var bl = true;\n                var result = res[name].find(function (e) {\n                    return e == option;\n                });\n                if (result == null) bl = false;\n                if (bl) {\n                    if (res[name].length == 1) {\n                        delete res[name];\n                    } else {\n                        for (var i = res[name].length, j = 0; j < i; j++) {\n                            if (res[name][j] == option) res[name].splice(j, 1);\n                        }\n                    }\n                    $e.removeClass(\"active\");\n                } else {\n                    res[name].push(option);\n                    $e.addClass(\"active\");\n                }\n            }\n            if (res[name] == null) {\n                $e.siblings(\"span:contains('不限')\").addClass(\"active\");\n            } else {\n                $e.siblings(\"span:contains('不限')\").removeClass(\"active\");\n            }\n        },\n        unselect: function unselect(e, event) {\n            var $event = $(event.currentTarget);\n            var s = this.selectdata;\n            if (s[e] == null) return;\n            delete s[e];\n            $event.addClass(\"active\").siblings(\"span\").removeClass(\"active\");\n        },\n        onsearch: function onsearch() {\n            this.bo = this.search(this.selectdata);\n            debugger;\n            this.setPageData(this.bosize, 1);\n        }\n\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmNvbXBsZXhGaWx0cmF0aW9uLnZ1ZT8wYjI4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkRBOzBCQUVBOztzQkFFQTttQkFDQTtpRUFDQSxtQ0FDQTt1QkFDQTt1QkFDQTttQkFDQTttQkFDQTt3QkFDQTtnQkFDQTtvQkFDQTtzQkFDQTt3QkFFQTtBQWRBO0FBZUE7Ozs7a0JBR0E7cUJBRUE7QUFIQTs7a0JBS0E7cUJBRUE7QUFIQTtpQkFJQTttQkFDQTtnQkFFQTtBQVpBO2dDQWFBO2tEQUNBO2dDQUNBO21CQUNBOzhDQUNBO3NDQUNBO2tDQUNBO0FBQ0E7Z0NBQ0E7d0VBQ0E7eUZBQ0E7YUFDQTttQ0FDQTtBQUNBO2dDQUNBO3dFQUNBO2lDQUNBO3lFQUNBO0FBQ0E7QUFDQTs7O3NDQUVBO3VCQUNBO2tEQUNBOzBDQUNBOzhCQUNBO3NDQUNBO2lCQUNBO3VDQUNBO0FBRUE7QUFWQTs7QUFZQTt1REFDQTs2REFDQTswQkFDQTs4QkFDQTtxQ0FDQTs2RUFDQTt5Q0FDQTtBQUNBO21CQUNBOytFQUNBO3lDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7a0RBQ0E7OEJBQ0E7QUFDQTtBQUNBOzRDQUNBOzRCQUNBO3dDQUNBO0FBQ0E7QUFDQTtzREFDQTs2RUFDQTttQ0FDQTt3RUFDQTs7cURBRUE7NENBRUE7QUFIQTtzQ0FJQTtBQUNBO21CQUNBO0FBQ0E7QUFDQTttREFDQTt1QkFDQTt1Q0FDQTttREFDQTsrQ0FDQTtrREFDQTtpRUFDQTswQkFDQTtBQUNBO21CQUNBO0FBQ0E7aURBQ0E7NENBQ0E7O2lDQUVBOzhDQUVBO0FBSEE7QUFJQTs0Q0FDQTtpQ0FDQTttRUFDQTt1QkFDQTtzQkFDQTttQ0FDQTs4QkFDQTtBQUNBO2tDQUNBOzJFQUNBO29DQUNBO0FBQ0E7b0NBQ0E7dUZBQ0E7b0NBQ0E7QUFDQTtzQ0FDQTtpQ0FDQTswQkFDQTtpREFDQTtBQUNBO3dDQUNBOzBDQUNBOzBCQUNBO2lEQUNBO0FBQ0E7eUNBQ0E7NEJBQ0E7Z0hBQ0E7NkNBQ0E7QUFDQTsrREFDQTt5QkFDQTsyQkFDQTttQ0FDQTsyQkFDQTswQkFDQTs0QkFDQTs0QkFDQTttQkFDQTt5QkFDQTt5REFDQTtnQ0FDQTtBQUNBO3lDQUNBO3dCQUNBOytDQUNBO21DQUVBOzJCQUNBOzBFQUNBOzRFQUNBO0FBQ0E7QUFDQTttQ0FDQTt1QkFDQTttQ0FDQTtnQ0FDQTtBQUNBO0FBQ0E7bUNBQ0E7NERBQ0E7bUJBQ0E7K0RBQ0E7QUFDQTtBQUNBOzhDQUNBO2lDQUNBO3lCQUNBOzhCQUNBO3FCQUNBO21FQUVBO0FBQ0E7c0NBQ0E7dUNBQ0E7QUFDQTswQ0FDQTtBQUdBOztBQXpJQTtBQTlEQSIsImZpbGUiOiIyMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtZmlsdGVyLWNhcmRcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93IGp1cmFzc2ljLWZpbHRlcjV0aCBqdXJhc3NpYy1maWx0ZXItYm90dG9tXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1jb2wtMSBqdXJhc3NpYy1maWx0ZXItdGl0bGVcIj5cclxuICAgICAgICAgICAgICAgIOW5tOW6plxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xMSAganVyYXNzaWMtcG9pbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXJvdyBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTEgIGp1cmFzc2ljLWNsaWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1tZW51LWxlZnRcIiBAY2xpY2s9XCJvbmxlZnRcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC04IGZpdmVZZWFyIGZpdmVZZWFyc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB2LWZvcj1cInllYXIgaW4gZml2ZVllYXIueWVhcnNcIiA6a2V5PVwieWVhclwiIEBjbGljaz1cIm9uQ2xpY2soeWVhciwkZXZlbnQpXCI+e3t5ZWFyfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1jbGlja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1yaWdodFwiIEBjbGljaz1cIm9ucmlnaHRcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwianVyYXNzaWMtZmlsdGVyLXRpdGxlIGp1cmFzc2ljLWZpbHRlci1maXZlY29sb3JcIj57e2ZpdmVZZWFyLm5hbWV9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93IGZpbHRlciAganVyYXNzaWMtZmlsdGVyNXRoICBqdXJhc3NpYy1maWx0ZXItYm90dG9tXCIgdi1mb3I9XCIoZmlsdGVyLGluZGV4KSBpbiBmaWx0ZXJzXCIgOmtleT1cIidmaWx0ZXInK2luZGV4XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1jb2wtMSAganVyYXNzaWMtZmlsdGVyLXRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57e2ZpbHRlci5uYW1lfX08L3NwYW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTExICBmaXZlWWVhciAganVyYXNzaWMtcG9pbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gQGNsaWNrPVwidW5zZWxlY3QoZmlsdGVyLm5hbWUsJGV2ZW50KVwiPuS4jemZkDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDxzcGFuIHYtZm9yPVwib3B0aW9uIGluIGZpbHRlci5vcHRpb25zXCIgOmtleT1cIm9wdGlvblwiIEBjbGljaz1cIm9uZmlsdGVyY2xpY2sob3B0aW9uLGZpbHRlci5uYW1lLCRldmVudClcIj57e29wdGlvbn19PC9zcGFuPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93ICBqdXJhc3NpYy1maWx0ZXI1dGhcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1maWx0ZXItdGl0bGVcIj5cclxuICAgICAgICAgICAgICAgIDxzcGFuPnt7Ym8ubmFtZX19PC9zcGFuPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xMSBqdXJhc3NpYy1wb2ludGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1jbGlja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1sZWZ0XCIgQGNsaWNrPVwib25ib2xlZnRcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC04IGZpdmVZZWFyIHNlbGVjdGJvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtZm9yPVwiYm8gaW4gc2hvd2JvXCIgOmtleT1cImJvXCIgQGNsaWNrPVwib25ib0NsaWNrKGJvKVwiPnt7Ym99fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgJm5ic3A7XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1jbGlja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1yaWdodFwiIEBjbGljaz1cIm9uYm9yaWdodFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTFcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3tpbmRleH19L3t7dG90YWx9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTEgIGp1cmFzc2ljLWNsaWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2ggXCIgQGNsaWNrPVwib25zZWFyY2hcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZml2ZVllYXI6IG51bGwsXHJcbiAgICAgICAgICAgIHN0YXJ0OiAxOTk2LFxyXG4gICAgICAgICAgICBmaXZlWWVhcnNQbGFuTmFtZTogW1wi5Lmd5LqUXCIsIFwi5Y2B5LqUXCIsIFwi5Y2B5LiA5LqUXCIsIFwi5Y2B5LqM5LqUXCIsIFwi5Y2B5LiJ5LqUXCIsIFwi5Y2B5Zub5LqUXCIsXHJcbiAgICAgICAgICAgICAgICBcIuWNgeS6lOS6lFwiLCBcIuWNgeWFreS6lFwiLCBcIuWNgeS4g+S6lFwiLCBcIuWNgeWFq+S6lFwiLCBcIuWNgeS5neS6lFwiXSxcclxuICAgICAgICAgICAgZml2ZVllYXJzOiBudWxsLFxyXG4gICAgICAgICAgICB5ZWFyaW5kZXg6IDAsXHJcbiAgICAgICAgICAgIGluZGV4OiAxLFxyXG4gICAgICAgICAgICB0b3RhbDogMSxcclxuICAgICAgICAgICAgc2VsZWN0ZGF0YTp7fSxcclxuICAgICAgICAgICAgYm86e30sXHJcbiAgICAgICAgICAgIHNob3dibzpbXSxcclxuICAgICAgICAgICAgc2VsZWN0Ym86XCJcIixcclxuICAgICAgICAgICAgc2VsZWN0WWVhcjpcIlwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgc2l6ZToge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvc2l6ZTp7XHJcbiAgICAgICAgICAgIHR5cGU6TnVtYmVyLFxyXG4gICAgICAgICAgICBkZWZhdWx0OjVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbHRlcnM6IEFycmF5LFxyXG4gICAgICAgIG9uYm9jbGljazogRnVuY3Rpb24sXHJcbiAgICAgICAgc2VhcmNoOkZ1bmN0aW9uXHJcbiAgICB9LFxyXG4gICAgY3JlYXRlZCgpIHtcclxuICAgICAgICB0aGlzLmZpdmVZZWFycyA9IHRoaXMuZ2V0U2hvdzV0aE5hbWUodGhpcy5zaXplKTtcclxuICAgICAgICB0aGlzLmNoYW5nZTV0aFllYXIodGhpcy55ZWFyaW5kZXgpO1xyXG4gICAgICAgIHZhciBsaXN0PVtdO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0WWVhcj10aGlzLmZpdmVZZWFyLnllYXJzWzBdO1xyXG4gICAgICAgIGxpc3QucHVzaCh0aGlzLmZpdmVZZWFyLnllYXJzWzBdKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZGF0YVtcInllYXJcIl09bGlzdDtcclxuICAgIH0sXHJcbiAgICBtb3VudGVkKCl7XHJcbiAgICAgICAgJChcIi5maXZlWWVhcnM+c3Bhbjpjb250YWlucyhcIit0aGlzLnNlbGVjdFllYXIrXCIpXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICQoXCIuZmlsdGVyIHNwYW46Y29udGFpbnMoJ+S4jemZkCcpXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpLnNpYmxpbmdzKFwic3BhblwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICB0aGlzLm9uc2VhcmNoKCk7XHJcbiAgICAgICAgdGhpcy5vbmJvQ2xpY2sodGhpcy5iby5ib3NbMF0pO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoKXtcclxuICAgICAgICAkKFwiLmZpdmVZZWFycz5zcGFuOmNvbnRhaW5zKFwiK3RoaXMuc2VsZWN0WWVhcitcIilcIikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgaWYodGhpcy5zZWxlY3RibyE9XCJcIil7XHJcbiAgICAgICAgICAgICQoXCIuc2VsZWN0Ym8+c3Bhbjpjb250YWlucyhcIit0aGlzLnNlbGVjdGJvK1wiKVwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2F0Y2g6e1xyXG4gICAgICAgIFwiZmlsdGVyc1wiOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBsaXN0PVtdO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdFllYXI9dGhpcy5maXZlWWVhci55ZWFyc1swXTtcclxuICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMuZml2ZVllYXIueWVhcnNbMF0pXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZGF0YT17fTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RkYXRhW1wieWVhclwiXT1saXN0O1xyXG4gICAgICAgICAgICB0aGlzLm9uc2VhcmNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMub25ib0NsaWNrKHRoaXMuYm8uYm9zWzBdKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIC8v5YiG6aG15pa55rOVXHJcbiAgICAgICAgc2V0UGFnZURhdGE6ZnVuY3Rpb24oc2l6ZSxpbmRleCl7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWw9TWF0aC5jZWlsKHRoaXMuYm8uYm9zLmxlbmd0aC90aGlzLmJvc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd2JvPVtdO1xyXG4gICAgICAgICAgICB2YXIgYm9zPXRoaXMuYm8uYm9zO1xyXG4gICAgICAgICAgICBpZihpbmRleD49dGhpcy50b3RhbCl7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9c2l6ZSooaW5kZXgtMSksaj1ib3MubGVuZ3RoO2k8ajtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd2JvLnB1c2goYm9zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9c2l6ZSooaW5kZXgtMSksaj1zaXplKmluZGV4O2k8ajtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd2JvLnB1c2goYm9zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/ojrflj5blvZPliY3lubRcclxuICAgICAgICBnZXRDdXJyZW50WWVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/ojrflj5blvZPliY3lubTmmK/nrKzlh6DkuKrkupTlubTorqHliJJcclxuICAgICAgICBnZXRGaXZlWWVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgeWVhciA9IHRoaXMuZ2V0Q3VycmVudFllYXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHllYXIgLSBwYXJzZUludCh0aGlzLnN0YXJ0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v6I635Y+W6L+H5ruk5pWw5o2uXHJcbiAgICAgICAgZ2V0U2hvdzV0aE5hbWU6IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE1hdGguY2VpbCh0aGlzLmdldEZpdmVZZWFyKCkgLyA1KSAtIHBhcnNlSW50KHNpemUpIC0gMTtcclxuICAgICAgICAgICAgdmFyIHNob3dmaXZlWWVhck5hbWUgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBhcnNlSW50KHNpemUpICsgaW5kZXgsIGogPSBpbmRleDsgaSA+IGo7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZml2ZXBsYW46IHRoaXMuZml2ZVllYXJzUGxhbk5hbWVbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogdGhpcy5nZXRZZWFyQXJyYXkoaSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNob3dmaXZlWWVhck5hbWUucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2hvd2ZpdmVZZWFyTmFtZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/pgJrov4fkupTlubTorqHliJLlkI3np7Dojrflj5blubTmlbDnu4RcclxuICAgICAgICBnZXRZZWFyQXJyYXk6IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gcGFyc2VJbnQodGhpcy5zdGFydCk7XHJcbiAgICAgICAgICAgIHZhciBfc3RhcnQgPSB0aGlzLnN0YXJ0ICsgNSAqIHBhcnNlSW50KGluZGV4KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDAsIG4gPSA1OyBtIDwgbjsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeWVhckluZGV4ID0gX3N0YXJ0ICsgcGFyc2VJbnQobSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoeWVhckluZGV4ID4gcGFyc2VJbnQodGhpcy5nZXRDdXJyZW50WWVhcigpKSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goeWVhckluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoYW5nZTV0aFllYXI6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXZldGh5ZWFyID0gdGhpcy5maXZlWWVhcnNbZV07XHJcbiAgICAgICAgICAgIHRoaXMuZml2ZVllYXIgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBmaXZldGh5ZWFyLmZpdmVwbGFuLFxyXG4gICAgICAgICAgICAgICAgeWVhcnM6IGZpdmV0aHllYXIueWVhci5zb3J0KCkucmV2ZXJzZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIChlLGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciAkZXZlbnQ9JChldmVudC5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgJGV2ZW50LmFkZENsYXNzKFwiYWN0aXZlXCIpLnNpYmxpbmdzKFwic3BhblwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgdmFyIGxpc3Q9W107XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChlKTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RkYXRhLnllYXI9bGlzdDtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RZZWFyPWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbmxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMueWVhcmluZGV4PSB0aGlzLnllYXJpbmRleDw9MD90aGlzLnllYXJpbmRleDotLXRoaXMueWVhcmluZGV4XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlNXRoWWVhcih0aGlzLnllYXJpbmRleCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbnJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueWVhcmluZGV4PXRoaXMueWVhcmluZGV4Pj10aGlzLnNpemUtMT90aGlzLnllYXJpbmRleDorK3RoaXMueWVhcmluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZTV0aFllYXIodGhpcy55ZWFyaW5kZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25ib2xlZnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pbmRleDw9MSkgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLnNob3dibz1bXTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQYWdlRGF0YSh0aGlzLmJvc2l6ZSwtLXRoaXMuaW5kZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25ib3JpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaW5kZXg+PXRoaXMudG90YWwpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5zaG93Ym89W107XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnZURhdGEodGhpcy5ib3NpemUsKyt0aGlzLmluZGV4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uYm9DbGljazogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Ribz1lO1xyXG4gICAgICAgICAgICAkKFwiLnNlbGVjdGJvPnNwYW46Y29udGFpbnMoXCIrdGhpcy5zZWxlY3RibytcIilcIikuYWRkQ2xhc3MoXCJhY3RpdmVcIikuc2libGluZ3MoXCJzcGFuXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLm9uYm9jbGljayAmJiB0aGlzLm9uYm9jbGljayhlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uZmlsdGVyY2xpY2s6ZnVuY3Rpb24ob3B0aW9uLG5hbWUsZSl7XHJcbiAgICAgICAgICAgIHZhciAkZT0kKGUuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIHZhciByZXM9dGhpcy5zZWxlY3RkYXRhO1xyXG4gICAgICAgICAgICBpZihyZXNbbmFtZV09PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3Q9W107XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gob3B0aW9uKVxyXG4gICAgICAgICAgICAgICAgcmVzW25hbWVdPWxpc3Q7XHJcbiAgICAgICAgICAgICAgICAkZS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmw9dHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ9IHJlc1tuYW1lXS5maW5kKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlPT1vcHRpb247XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmKHJlc3VsdD09bnVsbCkgYmw9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZihibCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmVzW25hbWVdLmxlbmd0aD09MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9cmVzW25hbWVdLmxlbmd0aCxqPTA7ajxpO2orKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXNbbmFtZV1bal09PW9wdGlvbikgcmVzW25hbWVdLnNwbGljZShqLDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICRlLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW25hbWVdLnB1c2gob3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAkZS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihyZXNbbmFtZV09PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgJGUuc2libGluZ3MoXCJzcGFuOmNvbnRhaW5zKCfkuI3pmZAnKVwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAkZS5zaWJsaW5ncyhcInNwYW46Y29udGFpbnMoJ+S4jemZkCcpXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bnNlbGVjdDpmdW5jdGlvbihlLGV2ZW50KXtcclxuICAgICAgICAgICAgdmFyICRldmVudD0kKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgcz10aGlzLnNlbGVjdGRhdGE7XHJcbiAgICAgICAgICAgIGlmKHNbZV09PW51bGwpIHJldHVybjtcclxuICAgICAgICAgICAgZGVsZXRlIHNbZV07XHJcbiAgICAgICAgICAgICRldmVudC5hZGRDbGFzcyhcImFjdGl2ZVwiKS5zaWJsaW5ncyhcInNwYW5cIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbnNlYXJjaDpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLmJvPXRoaXMuc2VhcmNoKHRoaXMuc2VsZWN0ZGF0YSk7XHJcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgICAgICB0aGlzLnNldFBhZ2VEYXRhKHRoaXMuYm9zaXplLDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBrcy5jb21wbGV4RmlsdHJhdGlvbi52dWU/MTQwMTY4ODUiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    props: {\n        //标题\n        titles: Array,\n        onclick: Function\n    },\n    created: function created() {\n        var self = this;\n        $(document).on(\"click\", \".jurassic-tab-btn\", function (e) {\n            var target$ = $(e.currentTarget);\n            self.onClicks(target$[0].innerText);\n            target$.addClass(\"active\").siblings().removeClass(\"active\");\n            var anchor = target$.data() && target$.data().anchor;\n            if (!anchor) return;\n            var tab$ = target$.closest(\".jurassic-tab\");\n            tab$.children(\".jurassic-tab-body\").children(\".jurassic-tab-container\" + \"[data-anchor=\" + anchor + \"]\").addClass(\"active\").siblings().removeClass(\"active\");\n        });\n    },\n    mounted: function mounted() {\n        $(\".jurassic-tab\").find(\".jurassic-tab-btn\" + \":first-child\").not(\".active\").trigger(\"click\");\n    },\n\n    methods: {\n        onClicks: function onClicks(e) {\n            this.onclick && this.onclick(e);\n        }\n\n    }\n\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmN0YWJzLnZ1ZT82N2NhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7O0FBSUE7Z0JBQ0E7aUJBRUE7QUFKQTtnQ0FLQTttQkFDQTtrRUFDQTs4QkFDQTtxQ0FDQTs4REFDQTswREFDQTt5QkFDQTt1Q0FDQTsrSkFDQTtBQUNBO0FBQ0E7Z0NBQ0E7NkZBQ0E7QUFDQTs7O3VDQUVBO3lDQUNBO0FBSUE7O0FBTkE7O0FBckJBIiwiZmlsZSI6IjIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy10YWJcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXRhYi1oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy10YWItYnRuXCIgOmRhdGEtYW5jaG9yPVwiJ2pycycraW5kZXhcIiB2LWZvcj1cIih0aXRsZSxpbmRleCkgaW4gdGl0bGVzXCIgOmtleT1cInRpdGxlXCI+e3t0aXRsZX19PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtdGFiLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXRhYi1jb250YWluZXJcIiA6ZGF0YS1hbmNob3I9XCInanJzJytpbmRleFwiIHYtZm9yPVwiKHRpdGxlLGluZGV4KSBpbiB0aXRsZXNcIiA6a2V5PVwidGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c2xvdCA6bmFtZT1cInRpdGxlXCI+PC9zbG90PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICAvL+agh+mimFxyXG4gICAgICAgIHRpdGxlczogQXJyYXksXHJcbiAgICAgICAgb25jbGljazpGdW5jdGlvblxyXG4gICAgfSxcclxuICAgIGNyZWF0ZWQoKXtcclxuICAgICAgICB2YXIgc2VsZj10aGlzO1xyXG4gICAgICAgICAkKGRvY3VtZW50KS5vbihcImNsaWNrXCIsXCIuanVyYXNzaWMtdGFiLWJ0blwiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCQgPSAkKGUuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLm9uQ2xpY2tzKHRhcmdldCRbMF0uaW5uZXJUZXh0KTtcclxuICAgICAgICAgICAgICAgIHRhcmdldCQuYWRkQ2xhc3MoXCJhY3RpdmVcIikuc2libGluZ3MoKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSB0YXJnZXQkLmRhdGEoKSAmJiB0YXJnZXQkLmRhdGEoKS5hbmNob3I7XHJcbiAgICAgICAgICAgICAgICBpZighYW5jaG9yKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFiJCA9IHRhcmdldCQuY2xvc2VzdChcIi5qdXJhc3NpYy10YWJcIik7XHJcbiAgICAgICAgICAgICAgICB0YWIkLmNoaWxkcmVuKFwiLmp1cmFzc2ljLXRhYi1ib2R5XCIpLmNoaWxkcmVuKFwiLmp1cmFzc2ljLXRhYi1jb250YWluZXJcIiArIFwiW2RhdGEtYW5jaG9yPVwiICsgYW5jaG9yICsgXCJdXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKXtcclxuICAgICAgICAgICAgJChcIi5qdXJhc3NpYy10YWJcIikuZmluZChcIi5qdXJhc3NpYy10YWItYnRuXCIgKyBcIjpmaXJzdC1jaGlsZFwiKS5ub3QoXCIuYWN0aXZlXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcclxuICAgIH0sXHJcbiAgICBtZXRob2RzOntcclxuICAgICAgICBvbkNsaWNrczpmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgdGhpcy5vbmNsaWNrJiZ0aGlzLm9uY2xpY2soZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLmN0YWJzLnZ1ZT82YWQzOTEyYiJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    data: function data() {\n        return {\n            selecteditems: [],\n            tempitems: [],\n            showmoreclasstop: \"glyphicon glyphicon-triangle-top\",\n            showmoreclassbottom: \"glyphicon glyphicon-triangle-bottom\"\n        };\n    },\n    props: {\n        //是否展示搜索框\n        showsearchbtn: {\n            type: Boolean,\n            default: true\n        },\n\n        //要查询的目标的类型\n        targettype: {\n            type: String,\n            default: \"井\"\n        },\n\n        //当一排的数量超过多少是显示”更多“\n        shownum: {\n            type: Number,\n            default: 5\n        },\n\n        //结果的条数\n        resultnum: {\n            type: Number,\n            default: 0\n        },\n        //checkbox或radio的数据项\n        //      {\n        //         catelog: \"地区\",\n        //         type: \"checkbox\",\n        //         list: [\"库车凹陷1\", \"库车凹陷2\", \"库车凹陷3\", \"库车凹陷4\", \"库车凹陷5\", \"库车凹陷6\"]\n        //     },\n        //    {\n        //        catelog: \"评价类型\",\n        //        type: \"radio\",\n        //        list: [\"评价1\", \"评价2\", \"评价3\"]\n        //    }\n        items: Array,\n        //点击搜索按钮的事件\n        searchbtnclick: Function,\n        //点击查询按钮的事件\n        querybtnclick: Function\n\n    },\n    watch: {\n        selecteditems: function selecteditems(val) {\n            //每次当selecteditems的值改变的时候就会修改tempitems的值\n            var items = this.selecteditems;\n            this.tempitems = [];\n            var temp = this.tempitems;\n            $(items).each(function (index) {\n                temp.push(items[index].catelog + items[index].value);\n            });\n\n            //一致界面上CheckBox的状态\n            var boxs = $(\".jurassic-checkbox\");\n            boxs.each(function (index) {\n                var catelog = boxs[index].name;\n                var value = $(boxs[index]).val();\n                if (temp.indexOf(catelog + value) == -1) {\n                    $(boxs[index]).prop(\"checked\", false);\n                } else {\n                    $(boxs[index]).prop(\"checked\", true);\n                }\n            });\n        }\n    },\n\n    // updated: function () {\n    //     //回调返回已选结果\n    //     this.callback && this.callback(this.selecteditems);\n    // },\n\n    methods: {\n\n        onshowmoreclick: function onshowmoreclick(catelog) {\n            var showmoreioc = $(\"#\" + catelog).children(\"i\");\n            var morepart = $(\"#\" + catelog + \".jurassic-search-filter-more\");\n            if (showmoreioc.hasClass(this.showmoreclasstop)) {\n                showmoreioc.removeClass(this.showmoreclasstop).addClass(this.showmoreclassbottom);\n                morepart.css(\"display\", \"none\");\n            } else {\n                showmoreioc.removeClass(this.showmoreclassbottom).addClass(this.showmoreclasstop);\n                morepart.css(\"display\", \"inline\");\n            }\n        },\n\n        Searchbtnclick: function Searchbtnclick() {\n            var inputvalue = $(\".jurassic-search-input\").val();\n            this.searchbtnclick && this.searchbtnclick({ type: this.targettype, content: inputvalue });\n        },\n\n        onqueryclick: function onqueryclick() {\n            //回调返回已选结果\n            this.querybtnclick && this.querybtnclick(this.selecteditems);\n        },\n\n        checkboxclick: function checkboxclick(e) {\n            var item = e.target;\n            var catelog = item.name;\n            var value = item.value;\n            var this$ = this;\n            var items = this.selecteditems;\n            var tempitems = this.tempitems;\n            if (item.getAttribute('type').toUpperCase() == 'CHECKBOX') {\n                if (value == \"All\") {\n                    var boxs = $(\":checkbox[name=\" + catelog.substring(3) + \"]\");\n                    if (item.checked) {\n                        boxs.each(function (index) {\n                            var catelog2 = boxs[index].name;\n                            var value2 = $(boxs[index]).val();\n                            if (tempitems.indexOf(catelog2 + value2) == -1) {\n                                items.push({ \"catelog\": catelog2, \"value\": value2 });\n                            }\n                        });\n                    } else {\n                        boxs.each(function (index) {\n                            var catelog2 = boxs[index].name;\n                            var value2 = $(boxs[index]).val();\n                            this$.removeFormSelecteditems(catelog2, value2);\n                        });\n                    }\n                } else {\n                    $(\":checkbox[name=All\" + catelog + \"]\").prop(\"checked\", false);\n                    if (item.checked) {\n                        items.push({ \"catelog\": catelog, \"value\": value });\n                    } else {\n                        this.removeFormSelecteditems(item.name, item.value);\n                    }\n                }\n            } else if (item.getAttribute('type').toUpperCase() == 'RADIO') {\n                var deleteindex = -1;\n                $(items).each(function (index) {\n                    if (items[index].catelog == catelog) {\n                        deleteindex = index;\n                    }\n                });\n                items.push({ \"catelog\": catelog, \"value\": value });\n                if (deleteindex != -1) {\n                    items.splice(deleteindex, 1);\n                }\n            }\n        },\n\n        removeclick: function removeclick(e) {\n            var item = $(e.target);\n            var pre = item.prev();\n            var catelog = pre.prop(\"id\");\n            var value = pre.text();\n            this.removeFormSelecteditems(catelog, value);\n        },\n\n        clearall: function clearall() {\n            this.selecteditems = [];\n            $(\".jurassic-checkbox-all\").prop(\"checked\", false);\n            // this.resultnum=0;\n        },\n\n        removeFormSelecteditems: function removeFormSelecteditems(catelog, value) {\n            var tempitems = this.tempitems;\n            var index = tempitems.indexOf(catelog + value);\n            tempitems.splice(index, 1);\n            this.selecteditems.splice(index, 1);\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmZpbHRlcmxpc3QudnVlP2I1MTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0ZBOzswQkFHQTs7MkJBRUE7dUJBQ0E7OEJBQ0E7aUNBRUE7QUFMQTtBQU1BOztBQUVBOztrQkFFQTtxQkFHQTtBQUpBOztBQUtBOztrQkFFQTtxQkFHQTtBQUpBOztBQUtBOztrQkFFQTtxQkFHQTtBQUpBOztBQUtBOztrQkFFQTtxQkFFQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtlQUNBO0FBQ0E7d0JBQ0E7QUFDQTt1QkFHQTs7QUF6Q0E7O21EQTJDQTtBQUNBOzZCQUNBOzZCQUNBOzRCQUNBOzJDQUNBOzhEQUNBO0FBRUE7O0FBQ0E7eUJBQ0E7dUNBQ0E7MENBQ0E7MkNBQ0E7eURBQ0E7bURBQ0E7QUFDQSx1QkFDQTttREFDQTtBQUNBO0FBQ0E7QUFHQTtBQXhCQTs7QUF5QkE7QUFDQTtBQUNBO0FBRUE7Ozs7MkRBR0E7d0RBQ0E7NkNBQ0E7NkRBQ0E7NkVBQ0E7d0NBQ0E7QUFDQSxtQkFDQTtnRkFDQTt3Q0FDQTtBQUNBO0FBRUE7O2tEQUNBO3lEQUNBO3lGQUNBO0FBRUE7OzhDQUNBO0FBQ0E7MERBQ0E7QUFFQTs7aURBQ0E7eUJBQ0E7K0JBQ0E7NkJBQ0E7d0JBQ0E7NkJBQ0E7aUNBQ0E7dUVBQ0E7b0NBQ0E7NEVBQ0E7c0NBQ0E7bURBQ0E7dURBQ0E7d0RBQ0E7NEVBQ0E7MkVBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQ0E7bURBQ0E7dURBQ0E7d0RBQ0E7b0VBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQ0E7NEVBQ0E7c0NBQ0E7a0VBQ0E7QUFDQSwyQkFDQTtxRUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFDQTttQ0FDQTsrQ0FDQTt5REFDQTtzQ0FDQTtBQUNBO0FBQ0E7MERBQ0E7dUNBQ0E7OENBQ0E7QUFDQTtBQUNBO0FBRUE7OzZDQUNBOzJCQUNBOzJCQUNBO21DQUNBOzRCQUNBO2tEQUNBO0FBRUE7O3NDQUNBO2lDQUNBO3dEQUNBO0FBQ0E7QUFFQTs7a0ZBQ0E7aUNBQ0E7b0RBQ0E7b0NBQ0E7NkNBQ0E7QUFFQTtBQS9GQTtBQWxGQSIsImZpbGUiOiIyMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1jb21wb25lbnRcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1wYW5lbFwiIHYtaWY9XCJzaG93c2VhcmNoYnRuXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtc2VhcmNoXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1pbnRlcmFjdGlvblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtc2VhcmNoLWludGVyYWN0aW9uLXBhbmVsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1pbnB1dFwiIDpwbGFjZWhvbGRlcj1cIifor7fovpPlhaXopoHmn6Xor6IgJyt0YXJnZXR0eXBlKycg55qE5ZCN56ewJ1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtc2VhcmNoLWF1dG8tY29tcGxldGUtY29udGFpbmVyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBzdHlsZT1cImZsb2F0OnJpZ2h0XCIgY2xhc3M9XCJqdXJhc3NpYy1zZWFyY2gtYnRuXCIgQGNsaWNrPVwiU2VhcmNoYnRuY2xpY2tcIj7mkJzntKI8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1maWx0ZXJcIiB2LWZvcj1cIihpdGVtLGluZGV4KSBpbiBpdGVtc1wiIDprZXk9XCJpbmRleFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1maWx0ZXItYmFzZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImp1cmFzc2ljLWNhcHRpb25cIj57e2l0ZW0uY2F0ZWxvZ319IO+8mjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1jb2wtOVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwianVyYXNzaWMtbGFiZWxcIiB2LWlmPVwiaXRlbS50eXBlPT0nY2hlY2tib3gnXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwianVyYXNzaWMtY2hlY2tib3gtYWxsXCIgOm5hbWU9XCInQWxsJytpdGVtLmNhdGVsb2dcIiA6aWQ9XCInQWxsJytpdGVtLmNhdGVsb2dcIiA6dHlwZT1cIml0ZW0udHlwZT09Jyc/J2NoZWNrYm94JzppdGVtLnR5cGVcIiBAY2xpY2s9XCJjaGVja2JveGNsaWNrXCIgdmFsdWU9XCJBbGxcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCA6Zm9yPVwiJ0FsbCcraXRlbS5jYXRlbG9nXCI+5LiN6ZmQPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJqdXJhc3NpYy1sYWJlbFwiIHYtZm9yPVwiKG5hbWUsaW5kZXgpIGluIGl0ZW0ubGlzdFwiIDprZXk9XCJpbmRleFwiIHYtaWY9XCJpbmRleDxzaG93bnVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwianVyYXNzaWMtY2hlY2tib3hcIiA6bmFtZT1cIml0ZW0uY2F0ZWxvZ1wiIDppZD1cIm5hbWVcIiA6dHlwZT1cIml0ZW0udHlwZT09Jyc/J2NoZWNrYm94JzppdGVtLnR5cGVcIiBAY2xpY2s9XCJjaGVja2JveGNsaWNrXCIgOnZhbHVlPVwibmFtZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsICA6Zm9yPVwibmFtZVwiPnt7bmFtZX19PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTFcIiB2LWlmPVwiaXRlbS5saXN0Lmxlbmd0aD5zaG93bnVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImp1cmFzc2ljLWxhYmVsXCIgQGNsaWNrPVwib25zaG93bW9yZWNsaWNrKGl0ZW0uY2F0ZWxvZylcIiA6aWQ9XCJpdGVtLmNhdGVsb2dcIj7mm7TlpJpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSA6Y2xhc3M9XCJzaG93bW9yZWNsYXNzYm90dG9tXCI+PC9pPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1maWx0ZXItbW9yZVwiIDppZD1cIml0ZW0uY2F0ZWxvZ1wiIHYtaWY9XCJpdGVtLmxpc3QubGVuZ3RoPnNob3dudW1cIiBzdHlsZT1cImRpc3BsYXk6IG5vbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1jb2wtMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIiBjbGFzcz1cImp1cmFzc2ljLWxhYmVsIGp1cmFzc2ljLWNhcHRpb25cIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTEwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJqdXJhc3NpYy1sYWJlbFwiIHYtZm9yPVwiKG5hbWUsaW5kZXgpIGluIGl0ZW0ubGlzdFwiIDprZXk9XCJpbmRleFwiIHYtaWY9XCJpbmRleD5zaG93bnVtLTFcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJqdXJhc3NpYy1jaGVja2JveFwiIDpuYW1lPVwiaXRlbS5jYXRlbG9nXCIgOmlkPVwibmFtZVwiIDp0eXBlPVwiaXRlbS50eXBlPT0nJz8nY2hlY2tib3gnOml0ZW0udHlwZVwiIEBjbGljaz1cImNoZWNrYm94Y2xpY2tcIiA6dmFsdWU9XCJuYW1lXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgIDpmb3I9XCJuYW1lXCI+e3tuYW1lfX08L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1zZWFyY2gtZGlzcGxheVwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC05XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwianVyYXNzaWMtbGFiZWxcIj7lt7LpgInmnaHku7Y6PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtc2VhcmNoLWZpbHRlci1pbmZvXCIgdi1mb3I9XCIoaXRlbSxpbmRleCkgaW4gc2VsZWN0ZWRpdGVtc1wiIDprZXk9XCJpbmRleFwiIHYtaWY9XCJpdGVtLnZhbHVlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiA6aWQ9XCJpdGVtLmNhdGVsb2dcIj57e2l0ZW0udmFsdWV9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcIiBAY2xpY2s9XCJyZW1vdmVjbGlja1wiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwianVyYXNzaWMtc2VhcmNoLWRpc3BsYXktY2xlYXJcIiBAY2xpY2s9XCJjbGVhcmFsbFwiPuOAkOa4heepuuWFqOmDqOOAkTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTFcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImp1cmFzc2ljLXNlYXJjaC1idG5cIiBAY2xpY2s9XCJvbnF1ZXJ5Y2xpY2tcIj7mn6Xor6I8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0xXCIgdi1pZj1cInJlc3VsdG51bT4wXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwianVyYXNzaWMtc2VhcmNoLXJlc3VsdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3tyZXN1bHRudW19fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPuadoee7k+aenDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gICAgZGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkaXRlbXM6IFtdLFxyXG4gICAgICAgICAgICB0ZW1waXRlbXM6IFtdLFxyXG4gICAgICAgICAgICBzaG93bW9yZWNsYXNzdG9wOiBcImdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtdG9wXCIsXHJcbiAgICAgICAgICAgIHNob3dtb3JlY2xhc3Nib3R0b206IFwiZ2x5cGhpY29uIGdseXBoaWNvbi10cmlhbmdsZS1ib3R0b21cIixcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICAvL+aYr+WQpuWxleekuuaQnOe0ouahhlxyXG4gICAgICAgIHNob3dzZWFyY2hidG46IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8v6KaB5p+l6K+i55qE55uu5qCH55qE57G75Z6LXHJcbiAgICAgICAgdGFyZ2V0dHlwZToge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwi5LqVXCJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL+W9k+S4gOaOkueahOaVsOmHj+i2hei/h+WkmuWwkeaYr+aYvuekuuKAneabtOWkmuKAnFxyXG4gICAgICAgIHNob3dudW06IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiA1XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy/nu5PmnpznmoTmnaHmlbBcclxuICAgICAgICByZXN1bHRudW06IHtcclxuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2NoZWNrYm945oiWcmFkaW/nmoTmlbDmja7poblcclxuICAgICAgICAvLyAgICAgIHtcclxuICAgICAgICAvLyAgICAgICAgIGNhdGVsb2c6IFwi5Zyw5Yy6XCIsXHJcbiAgICAgICAgLy8gICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXHJcbiAgICAgICAgLy8gICAgICAgICBsaXN0OiBbXCLlupPovablh7npmbcxXCIsIFwi5bqT6L2m5Ye56Zm3MlwiLCBcIuW6k+i9puWHuemZtzNcIiwgXCLlupPovablh7npmbc0XCIsIFwi5bqT6L2m5Ye56Zm3NVwiLCBcIuW6k+i9puWHuemZtzZcIl1cclxuICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAvLyAgICB7XHJcbiAgICAgICAgLy8gICAgICAgIGNhdGVsb2c6IFwi6K+E5Lu357G75Z6LXCIsXHJcbiAgICAgICAgLy8gICAgICAgIHR5cGU6IFwicmFkaW9cIixcclxuICAgICAgICAvLyAgICAgICAgbGlzdDogW1wi6K+E5Lu3MVwiLCBcIuivhOS7tzJcIiwgXCLor4Tku7czXCJdXHJcbiAgICAgICAgLy8gICAgfVxyXG4gICAgICAgIGl0ZW1zOiBBcnJheSxcclxuICAgICAgICAvL+eCueWHu+aQnOe0ouaMiemSrueahOS6i+S7tlxyXG4gICAgICAgIHNlYXJjaGJ0bmNsaWNrOiBGdW5jdGlvbixcclxuICAgICAgICAvL+eCueWHu+afpeivouaMiemSrueahOS6i+S7tlxyXG4gICAgICAgIHF1ZXJ5YnRuY2xpY2s6IEZ1bmN0aW9uLFxyXG5cclxuICAgIH0sXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgIHNlbGVjdGVkaXRlbXM6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgLy/mr4/mrKHlvZNzZWxlY3RlZGl0ZW1z55qE5YC85pS55Y+Y55qE5pe25YCZ5bCx5Lya5L+u5pS5dGVtcGl0ZW1z55qE5YC8XHJcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuc2VsZWN0ZWRpdGVtcztcclxuICAgICAgICAgICAgdGhpcy50ZW1waXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLnRlbXBpdGVtcztcclxuICAgICAgICAgICAgJChpdGVtcykuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRlbXAucHVzaChpdGVtc1tpbmRleF0uY2F0ZWxvZyArIGl0ZW1zW2luZGV4XS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy/kuIDoh7TnlYzpnaLkuIpDaGVja0JveOeahOeKtuaAgVxyXG4gICAgICAgICAgICB2YXIgYm94cyA9ICQoXCIuanVyYXNzaWMtY2hlY2tib3hcIik7XHJcbiAgICAgICAgICAgIGJveHMuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYXRlbG9nID0gYm94c1tpbmRleF0ubmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICQoYm94c1tpbmRleF0pLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXAuaW5kZXhPZihjYXRlbG9nICsgdmFsdWUpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJChib3hzW2luZGV4XSkucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJChib3hzW2luZGV4XSkucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXBkYXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gICAgIC8v5Zue6LCD6L+U5Zue5bey6YCJ57uT5p6cXHJcbiAgICAvLyAgICAgdGhpcy5jYWxsYmFjayAmJiB0aGlzLmNhbGxiYWNrKHRoaXMuc2VsZWN0ZWRpdGVtcyk7XHJcbiAgICAvLyB9LFxyXG5cclxuICAgIG1ldGhvZHM6IHtcclxuXHJcbiAgICAgICAgb25zaG93bW9yZWNsaWNrOiBmdW5jdGlvbiAoY2F0ZWxvZykge1xyXG4gICAgICAgICAgICB2YXIgc2hvd21vcmVpb2MgPSAkKFwiI1wiICsgY2F0ZWxvZykuY2hpbGRyZW4oXCJpXCIpO1xyXG4gICAgICAgICAgICB2YXIgbW9yZXBhcnQgPSAkKFwiI1wiICsgY2F0ZWxvZyArIFwiLmp1cmFzc2ljLXNlYXJjaC1maWx0ZXItbW9yZVwiKTtcclxuICAgICAgICAgICAgaWYgKHNob3dtb3JlaW9jLmhhc0NsYXNzKHRoaXMuc2hvd21vcmVjbGFzc3RvcCkpIHtcclxuICAgICAgICAgICAgICAgIHNob3dtb3JlaW9jLnJlbW92ZUNsYXNzKHRoaXMuc2hvd21vcmVjbGFzc3RvcCkuYWRkQ2xhc3ModGhpcy5zaG93bW9yZWNsYXNzYm90dG9tKTtcclxuICAgICAgICAgICAgICAgIG1vcmVwYXJ0LmNzcyhcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hvd21vcmVpb2MucmVtb3ZlQ2xhc3ModGhpcy5zaG93bW9yZWNsYXNzYm90dG9tKS5hZGRDbGFzcyh0aGlzLnNob3dtb3JlY2xhc3N0b3ApO1xyXG4gICAgICAgICAgICAgICAgbW9yZXBhcnQuY3NzKFwiZGlzcGxheVwiLCBcImlubGluZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFNlYXJjaGJ0bmNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dHZhbHVlID0gJChcIi5qdXJhc3NpYy1zZWFyY2gtaW5wdXRcIikudmFsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoYnRuY2xpY2sgJiYgdGhpcy5zZWFyY2hidG5jbGljayh7dHlwZTp0aGlzLnRhcmdldHR5cGUsY29udGVudDppbnB1dHZhbHVlfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb25xdWVyeWNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8v5Zue6LCD6L+U5Zue5bey6YCJ57uT5p6cXHJcbiAgICAgICAgICAgIHRoaXMucXVlcnlidG5jbGljayAmJiB0aGlzLnF1ZXJ5YnRuY2xpY2sodGhpcy5zZWxlY3RlZGl0ZW1zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjaGVja2JveGNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgY2F0ZWxvZyA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlbS52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHRoaXMkID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5zZWxlY3RlZGl0ZW1zO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGl0ZW1zID0gdGhpcy50ZW1waXRlbXM7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmdldEF0dHJpYnV0ZSgndHlwZScpLnRvVXBwZXJDYXNlKCkgPT0gJ0NIRUNLQk9YJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiQWxsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm94cyA9ICQoXCI6Y2hlY2tib3hbbmFtZT1cIiArIGNhdGVsb2cuc3Vic3RyaW5nKDMpICsgXCJdXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94cy5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVsb2cyID0gYm94c1tpbmRleF0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTIgPSAkKGJveHNbaW5kZXhdKS52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1waXRlbXMuaW5kZXhPZihjYXRlbG9nMiArIHZhbHVlMikgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHsgXCJjYXRlbG9nXCI6IGNhdGVsb2cyLCBcInZhbHVlXCI6IHZhbHVlMiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hzLmVhY2goZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2F0ZWxvZzIgPSBib3hzW2luZGV4XS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlMiA9ICQoYm94c1tpbmRleF0pLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyQucmVtb3ZlRm9ybVNlbGVjdGVkaXRlbXMoY2F0ZWxvZzIsIHZhbHVlMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICQoXCI6Y2hlY2tib3hbbmFtZT1BbGxcIiArIGNhdGVsb2cgKyBcIl1cIikucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7IFwiY2F0ZWxvZ1wiOiBjYXRlbG9nLCBcInZhbHVlXCI6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb3JtU2VsZWN0ZWRpdGVtcyhpdGVtLm5hbWUsIGl0ZW0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmdldEF0dHJpYnV0ZSgndHlwZScpLnRvVXBwZXJDYXNlKCkgPT0gJ1JBRElPJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0ZWluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAkKGl0ZW1zKS5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpbmRleF0uY2F0ZWxvZyA9PSBjYXRlbG9nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHsgXCJjYXRlbG9nXCI6IGNhdGVsb2csIFwidmFsdWVcIjogdmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoZGVsZXRlaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVtb3ZlY2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gJChlLnRhcmdldCk7XHJcbiAgICAgICAgICAgIHZhciBwcmUgPSBpdGVtLnByZXYoKTtcclxuICAgICAgICAgICAgdmFyIGNhdGVsb2cgPSBwcmUucHJvcChcImlkXCIpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwcmUudGV4dCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvcm1TZWxlY3RlZGl0ZW1zKGNhdGVsb2csIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGVhcmFsbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkaXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgJChcIi5qdXJhc3NpYy1jaGVja2JveC1hbGxcIikucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLnJlc3VsdG51bT0wO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZUZvcm1TZWxlY3RlZGl0ZW1zOiBmdW5jdGlvbiAoY2F0ZWxvZywgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBpdGVtcyA9IHRoaXMudGVtcGl0ZW1zO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0ZW1waXRlbXMuaW5kZXhPZihjYXRlbG9nICsgdmFsdWUpO1xyXG4gICAgICAgICAgICB0ZW1waXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZGl0ZW1zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLmZpbHRlcmxpc3QudnVlPzI2NDYyNWI3Il0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n      props: {\n            data: Array,\n            map: Object,\n            onclick: Function\n      },\n      methods: {\n            onClick: function onClick(e) {\n                  this.onclick && this.onclick(e);\n            }\n      }\n\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmltZ2xpc3QudnVlP2EwZDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7O2tCQUdBO2lCQUNBO3FCQUVBO0FBSkE7O3lDQU1BOytDQUNBO0FBR0E7QUFMQTs7QUFOQSIsImZpbGUiOiIyMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgPHVsPlxyXG4gICAgICA8bGkgY2xhc3M9XCJqdXJhc3NpYy1saXN0Ym94XCIgdi1mb3I9XCIoaXRlbSxpbmRleCkgaW4gZGF0YVwiIDprZXk9XCIna2V5JytpbmRleFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWxpc3RpbWdcIiBAY2xpY2s9XCJvbkNsaWNrKGl0ZW1bbWFwWydwYXJhbSddXSlcIj5cclxuICAgICAgICAgICAgICA8aW1nIDpzcmM9XCJpdGVtW21hcFsndG9wJ11dXCIgOmFsdD1cIml0ZW1bbWFwWydib3R0b20nXV1cIj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWl0ZW1pbmZvXCI+XHJcbiAgICAgICAgICAgICAgPHA+e3tpdGVtW21hcFsnYm90dG9tJ11dfX08L3A+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9saT5cclxuICA8L3VsPiBcclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgICBkYXRhOkFycmF5LFxyXG4gICAgICAgICAgbWFwOk9iamVjdCxcclxuICAgICAgICAgIG9uY2xpY2s6RnVuY3Rpb25cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgIG9uQ2xpY2s6ZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIHRoaXMub25jbGljayYmdGhpcy5vbmNsaWNrKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG48L3NjcmlwdD5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwa3MuaW1nbGlzdC52dWU/OGYyZGRmN2UiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        return {\n            width: '100%',\n            height: '100%',\n            viewer: {}\n        };\n    },\n\n    props: {\n        data: Array,\n        map: Object,\n        onclick: Function\n    },\n    methods: {\n        onClick: function onClick(e) {\n            this.onclick && this.onclick(e);\n        },\n        initfun: function initfun() {\n            if (this.data == null || this.data.length == 0) {\n                var temp = {};\n                temp[this.map[\"url\"]] = \"\";\n                temp[this.map[\"thumbnail\"]] = \"\";\n                temp[this.map[\"bottom\"]] = \"暂无图片\";\n                temp[this.map[\"param\"]] = \"\";\n                this.data.push(temp);\n            }\n\n            var options = {\n                url: 'data-original'\n            };\n            this.viewer = $(this.$el).viewer(options);\n        },\n        destroy: function destroy() {\n            this.viewer.data().viewer.destroy();\n        }\n    },\n    mounted: function mounted() {\n        this.initfun();\n    },\n\n    watch: {\n        \"data\": function data() {\n            this.$nextTick(function () {\n                // ==》更新dom后，加载数据      \n                this.destroy();\n                this.initfun();\n            });\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmltZ3ZpZXdlci52dWU/MGVjNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7MEJBRUE7O21CQUVBO29CQUNBO29CQUVBO0FBSkE7QUFLQTs7O2NBRUE7YUFDQTtpQkFFQTtBQUpBOztxQ0FNQTt5Q0FDQTtBQUNBO29DQUNBOzREQUNBOzJCQUNBO3dDQUNBOzhDQUNBOzJDQUNBOzBDQUNBOytCQUNBO0FBRUE7OztxQkFHQTtBQUZBOzZDQUdBO0FBQ0E7aUJBQ0EsbUJBQ0E7c0NBQ0E7QUFFQTtBQXZCQTtnQ0F3QkE7YUFDQTtBQUNBOzs7Z0NBRUE7O0FBQ0E7cUJBQ0E7cUJBQ0E7QUFFQTtBQUVBO0FBUkE7QUF4Q0EiLCJmaWxlIjoiMjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPHVsIGNsYXNzPVwianVyYXNzaWMtaW1ndmlld2VyXCI+XHJcbiAgICAgICAgPGxpIGNsYXNzPVwianVyYXNzaWMtbGlzdGJveFwiIHYtZm9yPVwiKGl0ZW0saW5kZXgpIGluIGRhdGFcIiA6a2V5PVwiJ2tleScraW5kZXhcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWxpc3RpbWdcIj5cclxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJqdXJhc3NpYy1pbWdcIiBcclxuICAgICAgICAgICAgICAgIDpzcmM9XCJpdGVtW21hcFsndGh1bWJuYWlsJ11dP2l0ZW1bbWFwWyd0aHVtYm5haWwnXV06aXRlbVttYXBbJ3VybCddXVwiIFxyXG4gICAgICAgICAgICAgICAgOmRhdGEtb3JpZ2luYWw9XCJpdGVtW21hcFsndXJsJ11dXCIgXHJcbiAgICAgICAgICAgICAgICBhbHQ9XCLmmoLml6Dlm77niYdcIiBcclxuICAgICAgICAgICAgICAgIDpzdHlsZT1cInt3aWR0aDp3aWR0aCxoZWlnaHQ6aGVpZ2h0fVwiPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWl0ZW1pbmZvIGp1cmFzc2ljLW5ld3MtYnJpZWZcIiBAY2xpY2s9XCJvbkNsaWNrKGl0ZW1bbWFwWydwYXJhbSddXSlcIj5cclxuICAgICAgICAgICAgICAgIDxwIDp0aXRsZT1cIml0ZW1bbWFwWydib3R0b20nXV1cIj57e2l0ZW1bbWFwWydib3R0b20nXV19fTwvcD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9saT5cclxuICAgIDwvdWw+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKXtcclxuICAgICAgICByZXR1cm57XHJcbiAgICAgICAgICAgIHdpZHRoOicxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OicxMDAlJyxcclxuICAgICAgICAgICAgdmlld2VyOnt9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgZGF0YTogQXJyYXksXHJcbiAgICAgICAgbWFwOiBPYmplY3QsXHJcbiAgICAgICAgb25jbGljazogRnVuY3Rpb25cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbmNsaWNrICYmIHRoaXMub25jbGljayhlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRmdW46ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYodGhpcy5kYXRhPT1udWxsfHx0aGlzLmRhdGEubGVuZ3RoPT0wKXtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wPXt9O1xyXG4gICAgICAgICAgICAgICAgdGVtcFt0aGlzLm1hcFtcInVybFwiXV09XCJcIjtcclxuICAgICAgICAgICAgICAgIHRlbXBbdGhpcy5tYXBbXCJ0aHVtYm5haWxcIl1dPVwiXCI7XHJcbiAgICAgICAgICAgICAgICB0ZW1wW3RoaXMubWFwW1wiYm90dG9tXCJdXT1cIuaaguaXoOWbvueJh1wiO1xyXG4gICAgICAgICAgICAgICAgdGVtcFt0aGlzLm1hcFtcInBhcmFtXCJdXT1cIlwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2godGVtcCk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICB1cmw6ICdkYXRhLW9yaWdpbmFsJyxcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52aWV3ZXI9JCh0aGlzLiRlbCkudmlld2VyKG9wdGlvbnMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzdHJveTpmdW5jdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdlci5kYXRhKCkudmlld2VyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZCgpe1xyXG4gICAgICAgIHRoaXMuaW5pdGZ1bigpO1xyXG4gICAgfSxcclxuICAgIHdhdGNoOntcclxuICAgICAgICBcImRhdGFcIjpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkgeyAgLy8gPT3jgIvmm7TmlrBkb23lkI7vvIzliqDovb3mlbDmja4gICAgICBcclxuICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICB0aGlzLmluaXRmdW4oKTsgXHJcbiAgICAgICAgICAgIH0pOyBcclxuICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLmltZ3ZpZXdlci52dWU/NTBmOTAxZGMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue__ = __webpack_require__(81);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        //点击列表项事件\n        onclick: Function,\n        items: Array,\n        map: Object\n    },\n    methods: {\n        onClick: function onClick(e) {\n            this.onclick && this.onclick(e);\n        }\n    },\n    components: { listItem: __WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue___default.a }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmxpc3QudnVlP2NkYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7O0FBR0E7aUJBQ0E7ZUFDQTthQUVBO0FBTEE7O3FDQU9BO3lDQUNBO0FBRUE7QUFKQTtrQkFLQTtBQVpBIiwiZmlsZSI6IjIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcGFuZWwtYm9keVwiPlxyXG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJqdXJhc3NpYy1saXN0XCI+XHJcbiAgICAgICAgICAgICAgICA8bGlzdEl0ZW0gdi1mb3I9XCIoaXRlbSxpbmRleCkgaW4gaXRlbXNcIiA6Y29udGVudGxlZnQ9XCJpdGVtW21hcFsnbGVmdCddXVwiIDp1cmw9XCJpdGVtW21hcFsndXJsJ11dXCIgOmNvbnRlbnRyaWdodD1cIml0ZW1bbWFwWydyaWdodCddXVwiIDpvbmNsaWNrPVwib25DbGlja1wiIDprZXk9XCIna2V5JytpbmRleFwiPjwvbGlzdEl0ZW0+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgIFxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgbGlzdEl0ZW0gZnJvbSAnLi9wa3MubGlzdEl0ZW0udnVlJ1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v54K55Ye75YiX6KGo6aG55LqL5Lu2XHJcbiAgICAgICAgb25jbGljazogRnVuY3Rpb24sXHJcbiAgICAgICAgaXRlbXM6QXJyYXksXHJcbiAgICAgICAgbWFwOk9iamVjdCAgICAgIFxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uY2xpY2sgJiYgdGhpcy5vbmNsaWNrKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRzOiB7IGxpc3RJdGVtIH1cclxufVxyXG48L3NjcmlwdD5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwa3MubGlzdC52dWU/MWI3OTQ5MzIiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        //左边\n        contentleft: String,\n        //右边\n        contentright: {\n            type: String,\n            default: \"\"\n        },\n        //参数\n        url: {\n            type: String,\n            default: \"\"\n        },\n        //点击事件\n        onclick: Function\n    },\n    methods: {\n        onClick: function onClick() {\n            this.onclick && this.onclick(this.url);\n        }\n    }\n\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmxpc3RJdGVtLnZ1ZT83MDhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUdBO3FCQUNBO0FBQ0E7O2tCQUVBO3FCQUVBO0FBSEE7QUFJQTs7a0JBRUE7cUJBRUE7QUFIQTtBQUlBO2lCQUVBO0FBZkE7O29DQWlCQTs4Q0FDQTtBQUdBO0FBTEE7O0FBakJBIiwiZmlsZSI6IjIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxsaSBjbGFzcz1cImp1cmFzc2ljLWxpc3QtaXRlbVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1uZXdzXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1yb3dcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1jb2wtMTAganVyYXNzaWMtbmV3cy1icmllZlwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwianVyYXNzaWMtbmV3cy10ZXh0XCIgQGNsaWNrPVwib25DbGljaygpXCI+e3tjb250ZW50bGVmdH19PC9hPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTIganVyYXNzaWMtdGV4dC1yaWdodFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwianVyYXNzaWMtbmV3cy1kYXRlXCI+e3tjb250ZW50cmlnaHR9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvbGk+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v5bem6L65XHJcbiAgICAgICAgY29udGVudGxlZnQ6U3RyaW5nLFxyXG4gICAgICAgIC8v5Y+z6L65XHJcbiAgICAgICAgY29udGVudHJpZ2h0OntcclxuICAgICAgICAgICAgdHlwZTpTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XCJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/lj4LmlbBcclxuICAgICAgICB1cmw6e1xyXG4gICAgICAgICAgICB0eXBlOlN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDpcIlwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL+eCueWHu+S6i+S7tlxyXG4gICAgICAgIG9uY2xpY2s6RnVuY3Rpb25cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgb25DbGljazpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLm9uY2xpY2smJnRoaXMub25jbGljayh0aGlzLnVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG48L3NjcmlwdD5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwa3MubGlzdEl0ZW0udnVlPzUxZGI5MDc1Il0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue__ = __webpack_require__(81);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        //点击列表项事件\n        onclick: Function,\n        data: Array,\n        //映射关系\n        map: Object\n    },\n    methods: {\n        onClick: function onClick(e) {\n            this.onclick && this.onclick(e);\n        }\n    },\n    components: { listItem: __WEBPACK_IMPORTED_MODULE_0__pks_listItem_vue___default.a }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmxpc3RtLnZ1ZT80NDAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFVQTtBQUNBOztBQUdBO2lCQUNBO2NBQ0E7QUFDQTthQUVBO0FBTkE7O3FDQVFBO3lDQUNBO0FBRUE7QUFKQTtrQkFLQTtBQWJBIiwiZmlsZSI6IjIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcGFuZWwtYm9keVwiPlxyXG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJqdXJhc3NpYy1saXN0XCI+XHJcbiAgICAgICAgICAgICAgICA8bGlzdEl0ZW0gdi1mb3I9XCIoaXRlbSxpbmRleCkgaW4gZGF0YVwiIDpjb250ZW50bGVmdD1cIml0ZW1bbWFwWydsZWZ0J11dXCIgOnVybD1cIml0ZW1bbWFwWyd1cmwnXV1cIiA6Y29udGVudHJpZ2h0PVwiaXRlbVttYXBbJ3JpZ2h0J11dXCIgOm9uY2xpY2s9XCJvbkNsaWNrXCIgOmtleT1cIidrZXknK2luZGV4XCI+PC9saXN0SXRlbT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBsaXN0SXRlbSBmcm9tICcuL3Brcy5saXN0SXRlbS52dWUnXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgLy/ngrnlh7vliJfooajpobnkuovku7ZcclxuICAgICAgICBvbmNsaWNrOiBGdW5jdGlvbixcclxuICAgICAgICBkYXRhOkFycmF5LFxyXG4gICAgICAgIC8v5pig5bCE5YWz57O7XHJcbiAgICAgICAgbWFwOk9iamVjdCAgICAgICBcclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbmNsaWNrICYmIHRoaXMub25jbGljayhlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50czogeyBsaXN0SXRlbSB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLmxpc3RtLnZ1ZT83NjcwMTMzMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    props: {\n        //标题\n        items: Array,\n        itemclick: Function\n    },\n    methods: {\n        itemClick: function itemClick(item) {\n            this.itemclick && this.itemclick(item);\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmxpc3R0YWJsZS52dWU/MGViNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQWFBOzs7QUFJQTtlQUNBO21CQUVBO0FBSkE7OzRDQU1BOzZDQUNBO0FBRUE7QUFKQTtBQU5BIiwiZmlsZSI6IjIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1yb3dcIj5cclxuICAgICAgIDx0YWJsZSBjbGFzcz1cImp1cmFzc2ljLXRhYmxlTGlzdFwiPlxyXG4gICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgPHRyIHYtZm9yPVwiaXRlbSBpbiBpdGVtc1wiIHN0eWxlPVwiYmFja2dyb3VuZDojZmZmICFpbXBvcnRhbnQ7XCI+XHJcbiAgICAgICAgICAgICAgICAgICA8dGQgdi1mb3I9XCJzaXRlbSBpbiBpdGVtXCI+PGEgaHJlZj1cIiNcIiBAY2xpY2s9XCJpdGVtQ2xpY2soc2l0ZW0pXCI+e3tzaXRlbS5uYW1lfX0gPC9hPjwvdGQ+XHJcbiAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgIDwvdGFibGU+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v5qCH6aKYXHJcbiAgICAgICAgaXRlbXM6IEFycmF5LFxyXG4gICAgICAgIGl0ZW1jbGljazogRnVuY3Rpb25cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaXRlbUNsaWNrOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1jbGljayAmJiB0aGlzLml0ZW1jbGljayhpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLmxpc3R0YWJsZS52dWU/YjA5ZjZmNDQiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_list_vue__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_list_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__pks_list_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pks_panelList_vue__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pks_panelList_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__pks_panelList_vue__);\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    props: {\n        //标题\n        titles: Array,\n        //点击More事件\n        onshowmore: Function,\n        //图标\n        fontclass: String,\n        //是否显示\"+MORE\"\n        show: {\n            type: Boolean,\n            default: true\n        },\n        data: Array,\n        map: Array,\n        //点击列表项事件\n        onclick: Function\n    },\n    methods: {\n        onShowMore: function onShowMore(e) {\n            this.onshowmore && this.onshowmore(e);\n        },\n        onClick: function onClick(e) {\n            this.onclick && this.onclick(e);\n        }\n    },\n    components: { list: __WEBPACK_IMPORTED_MODULE_0__pks_list_vue___default.a, panellist: __WEBPACK_IMPORTED_MODULE_1__pks_panelList_vue___default.a }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLm11bHRpcGxlVGl0bGUudnVlPzI5ODQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7OztBQUlBO2dCQUNBO0FBQ0E7b0JBQ0E7QUFDQTttQkFDQTtBQUNBOztrQkFFQTtxQkFFQTtBQUhBO2NBSUE7YUFDQTtBQUNBO2lCQUVBO0FBaEJBOzsyQ0FrQkE7K0NBQ0E7QUFDQTtxQ0FDQTt5Q0FDQTtBQUVBO0FBUEE7K0VBUUE7QUExQkEiLCJmaWxlIjoiMjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPHBhbmVsbGlzdCA6dGl0bGVzPVwidGl0bGVzXCIgOm9uc2hvd21vcmU9XCJvblNob3dNb3JlXCIgOnNob3c9XCJzaG93XCIgOmZvbnRjbGFzcz1cImZvbnRjbGFzc1wiPlxyXG4gICAgICAgIDxsaXN0IHYtZm9yPVwiKGxpc3RkYXRhLGluZGV4KSBpbiBkYXRhXCIgOnNsb3Q9XCJ0aXRsZXNbaW5kZXhdXCIgOmtleT1cImluZGV4XCIgOml0ZW1zPVwibGlzdGRhdGFcIiA6bWFwPVwibWFwW2luZGV4XVwiIDpvbmNsaWNrPVwib25DbGlja1wiPjwvbGlzdD5cclxuICAgIDwvcGFuZWxsaXN0PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgbGlzdCBmcm9tICcuL3Brcy5saXN0LnZ1ZSc7XHJcbmltcG9ydCBwYW5lbGxpc3QgZnJvbSAnLi9wa3MucGFuZWxMaXN0LnZ1ZSc7XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v5qCH6aKYXHJcbiAgICAgICAgdGl0bGVzOiBBcnJheSxcclxuICAgICAgICAvL+eCueWHu01vcmXkuovku7ZcclxuICAgICAgICBvbnNob3dtb3JlOiBGdW5jdGlvbixcclxuICAgICAgICAvL+Wbvuagh1xyXG4gICAgICAgIGZvbnRjbGFzczogU3RyaW5nLFxyXG4gICAgICAgIC8v5piv5ZCm5pi+56S6XCIrTU9SRVwiXHJcbiAgICAgICAgc2hvdzoge1xyXG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkYXRhOiBBcnJheSxcclxuICAgICAgICBtYXA6IEFycmF5LFxyXG4gICAgICAgIC8v54K55Ye75YiX6KGo6aG55LqL5Lu2XHJcbiAgICAgICAgb25jbGljazogRnVuY3Rpb25cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgb25TaG93TW9yZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbnNob3dtb3JlICYmIHRoaXMub25zaG93bW9yZShlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25jbGljayAmJiB0aGlzLm9uY2xpY2soZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudHM6IHsgbGlzdCwgcGFuZWxsaXN0IH1cclxufVxyXG48L3NjcmlwdD5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwa3MubXVsdGlwbGVUaXRsZS52dWU/M2NjYWExMGEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        //标题\n        wellposition: Array,\n        welldata: Array,\n        gastotal: \"\",\n        oiltotal: \"\"\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLm5vc3RydWN0dGFibGUudnVlPzg5MjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFFQTs7QUFHQTtzQkFDQTtrQkFDQTtrQkFDQTtrQkFFQTtBQU5BO0FBREEiLCJmaWxlIjoiMjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPHRhYmxlIGJvcmRlcj1cIjFcIiBjZWxscGFkZGluZz1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBib3JkZXJjb2xvcj1cIiMwMDAwMDBcIiBzdHlsZT1cIndpZHRoOjcwMHB4XCI+XHJcbiAgICAgICAgPHRlbXBsYXRlIHYtZm9yPVwicGl0ZW0gaW4gd2VsbHBvc2l0aW9uXCI+XHJcbiAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgIDx0aCB3aWR0aD1cIjcyXCI+5LqV5YirPC90aD5cclxuICAgICAgICAgICAgICAgIDx0aCBjb2xzcGFuPVwiOVwiPnt7cGl0ZW0ud2VsbHR5cGV9fTwvdGg+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgIDx0aD7nu4/nuqzluqY8L3RkPlxyXG4gICAgICAgICAgICAgICAgPHRoIHdpZHRoPVwiNzJcIiByb3dzcGFuPVwiMlwiPuS6leWPozwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggY29sc3Bhbj1cIjJcIj7kuJznu488L3RoPlxyXG4gICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCI+e3twaXRlbS5lYXN0fX08L3RkPlxyXG4gICAgICAgICAgICAgICAgPHRoIGNvbHNwYW49XCIyXCI+5YyX57qsPC90aD5cclxuICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiMlwiPnt7cGl0ZW0uZWFzdHh9fTwvdGQ+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgIDx0aD7lnZDmoIc8L3RoPlxyXG4gICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCI+eDwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjJcIj57e3BpdGVtLm5vcnRofX08L3RkPlxyXG4gICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCI+eTwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjJcIj57e3BpdGVtLm5vcnRoeX19PC90ZD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgPHRoPuS9jee9rjwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjlcIj57e3BpdGVtLnBvc2l0aW9ufX08L3RkPlxyXG4gICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICA8dGg+6K6+6K6h5LqV5rexPC90aD5cclxuICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiNVwiPnt7cGl0ZW0ud2VsbGRlcHRofX08L3RkPlxyXG4gICAgICAgICAgICAgICAgPHRoIGNvbHNwYW49XCIyXCI+5rW35rC05rex5bqmPC90aD5cclxuICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiMlwiPnt7cGl0ZW0uc2VhZGVwdGh9fTwvdGQ+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgIDx0aD7lrozpkrvlsYLkvY08L3RoPlxyXG4gICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCI5XCI+e3twaXRlbS5sYXllcn19PC90ZD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICA8L3RlbXBsYXRlPiBcclxuICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgPHRoIHJvd3NwYW49XCIyXCI+5Zyw5bGC5bGC5L2NPC90aD5cclxuICAgICAgICAgICAgICAgIDx0aCByb3dzcGFuPVwiMlwiPuWxguS9jTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggd2lkdGg9XCI3MlwiIHJvd3NwYW49XCIyXCI+5Y+N5bCE5pe26Ze0KG1zKTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggY29sc3Bhbj1cIjJcIiByb3dzcGFuPVwiMlwiPua3seW6pihUVkRTUyxtKTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggY29sc3Bhbj1cIjJcIiByb3dzcGFuPVwiMlwiPuWciOmXremdouenryhrbcKyKTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggY29sc3Bhbj1cIjNcIj7kupXmjqfotYTmupDph488L3RoPlxyXG4gICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICA8dGggY29sc3Bhbj1cIjJcIj7lpKnnhLbmsJQxMDxzcGFuIHN0eWxlPVwidmVydGljYWwtYWxpZ246c3VwZXJcIj44PC9zcGFuPm3CszwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGggd2lkdGg9XCI3MlwiPuefs+ayuTEwPHNwYW4gc3R5bGU9XCJ2ZXJ0aWNhbC1hbGlnbjpzdXBlclwiPjQ8L3NwYW4+dChtwrMpPC90aD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtZm9yPVwiKGl0ZW0saW5kZXgpIGluIHdlbGxkYXRhXCI+XHJcbiAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7aXRlbS5zZ2xheWVyfX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57e2l0ZW0ubGF5ZXJ9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7aXRlbS5yZWZsZWN0dGltZX1944CAPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjJcIj57e2l0ZW0uZGVwdGh9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCI+e3tpdGVtLnRyYXBhcmVhfX08L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiMlwiPnt7aXRlbS5nYXN9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7aXRlbS5vaWx9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICA8L3RlbXBsYXRlPlxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICA8dGg+5ZCI6K6hPC90aD5cclxuICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiNlwiPuOAgDwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjJcIj57e2dhc3RvdGFsfX3jgIA8L3RkPlxyXG4gICAgICAgICAgICAgICAgPHRkPnt7b2lsdG90YWx9fTwvdGQ+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICA8L3RhYmxlPlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v5qCH6aKYXHJcbiAgICAgICAgd2VsbHBvc2l0aW9uOiBBcnJheSxcclxuICAgICAgICB3ZWxsZGF0YTogQXJyYXksXHJcbiAgICAgICAgZ2FzdG90YWw6XCJcIixcclxuICAgICAgICBvaWx0b3RhbDpcIlwiXHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLm5vc3RydWN0dGFibGUudnVlPzJkNmJhNjgzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        current: Number,\n        totaldata: Number,\n        pagesize: {\n            type: Number,\n            default: 10\n        },\n        onclick: Function\n    },\n    watch: {\n        totaldata: function totaldata() {\n            this.refreshPagination();\n        },\n        pagesize: function pagesize() {\n            this.refreshPagination();\n        }\n    },\n    methods: {\n        refreshPagination: function refreshPagination(e) {\n            var self = this;\n            $(self.$el).pagination({\n                pageCount: Math.ceil(self.totaldata / self.pagesize),\n                current: self.current,\n                jump: true,\n                coping: true,\n                isHide: false,\n                count: 2,\n                homePage: '首页',\n                endPage: '末页',\n                prevContent: '上页',\n                nextContent: '下页',\n                callback: function callback(api) {\n                    self.onclick && self.onclick(api.getCurrent());\n                }\n            });\n        }\n    },\n    mounted: function mounted() {\n        this.refreshPagination();\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnBhZ2VyLnZ1ZT9lZmQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBT0E7O2lCQUdBO21CQUNBOztrQkFFQTtxQkFFQTtBQUhBO2lCQUtBO0FBUkE7O3dDQVVBO2lCQUNBO0FBQ0E7c0NBQ0E7aUJBQ0E7QUFFQTtBQVBBOzt5REFTQTt1QkFDQTs7MkRBRUE7OEJBQ0E7c0JBQ0E7d0JBQ0E7d0JBQ0E7dUJBQ0E7MEJBQ0E7eUJBQ0E7NkJBQ0E7NkJBQ0E7aURBQ0E7cURBQ0E7QUFFQTtBQWRBO0FBZ0JBO0FBbkJBO2dDQW9CQTthQUNBO0FBQ0E7QUF4Q0EiLCJmaWxlIjoiMjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJwYWdlclwiPlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGN1cnJlbnQ6IE51bWJlcixcclxuICAgICAgICB0b3RhbGRhdGE6IE51bWJlcixcclxuICAgICAgICBwYWdlc2l6ZToge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbmNsaWNrOiBGdW5jdGlvblxyXG4gICAgfSxcclxuICAgIHdhdGNoOntcclxuICAgICAgICB0b3RhbGRhdGE6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoUGFnaW5hdGlvbigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFnZXNpemU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoUGFnaW5hdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgcmVmcmVzaFBhZ2luYXRpb246ZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgdmFyIHNlbGY9dGhpcztcclxuICAgICAgICAgICAgJChzZWxmLiRlbCkucGFnaW5hdGlvbih7XHJcbiAgICAgICAgICAgICAgICBwYWdlQ291bnQ6IE1hdGguY2VpbChzZWxmLnRvdGFsZGF0YSAvIHNlbGYucGFnZXNpemUpLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudDogc2VsZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAganVtcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvcGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGlzSGlkZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb3VudDoyLFxyXG4gICAgICAgICAgICAgICAgaG9tZVBhZ2U6ICfpppbpobUnLFxyXG4gICAgICAgICAgICAgICAgZW5kUGFnZTogJ+acq+mhtScsXHJcbiAgICAgICAgICAgICAgICBwcmV2Q29udGVudDogJ+S4iumhtScsXHJcbiAgICAgICAgICAgICAgICBuZXh0Q29udGVudDogJ+S4i+mhtScsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGFwaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25jbGljayAmJiBzZWxmLm9uY2xpY2soYXBpLmdldEN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoUGFnaW5hdGlvbigpO1xyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIHNjb3BlZD5cclxuXHJcbjwvc3R5bGU+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBrcy5wYWdlci52dWU/MTZiOTRjNWUiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        //标题\n        title: String,\n        //点击more\n        onshowmore: Function,\n        //是否显示more\n        show: {\n            type: Boolean,\n            default: true\n        },\n        //图标\n        fontclass: {\n            type: String,\n            default: \"glyphicon glyphicon-list jurassic-panel-logo\"\n        }\n    },\n    methods: {\n        onShowMore: function onShowMore() {\n            this.onshowmore && this.onshowmore(this.title);\n        }\n    }\n\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnBhbmVsLnZ1ZT82YTcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFHQTtlQUNBO0FBQ0E7b0JBQ0E7QUFDQTs7a0JBRUE7cUJBRUE7QUFIQTtBQUlBOztrQkFFQTtxQkFHQTtBQUpBO0FBWEE7OzBDQWlCQTtvREFDQTtBQUdBO0FBTEE7O0FBakJBIiwiZmlsZSI6IjIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1wYW5lbFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsLWhlYWRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1yb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC05XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSA6Y2xhc3M9XCJmb250Y2xhc3NcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsLXRpdGxlXCI+e3t0aXRsZX19PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0zIGp1cmFzc2ljLXRleHQtcmlnaHRcIiB2LWlmPVwic2hvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJqdXJhc3NpYy1wYW5lbC1tb3JlXCIgQGNsaWNrPVwib25TaG93TW9yZVwiPitNT1JFPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwicGFuZWxcIj48L3Nsb3Q+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v5qCH6aKYXHJcbiAgICAgICAgdGl0bGU6IFN0cmluZyxcclxuICAgICAgICAvL+eCueWHu21vcmVcclxuICAgICAgICBvbnNob3dtb3JlOkZ1bmN0aW9uLFxyXG4gICAgICAgIC8v5piv5ZCm5pi+56S6bW9yZVxyXG4gICAgICAgIHNob3c6e1xyXG4gICAgICAgICAgICB0eXBlOkJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6dHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/lm77moIdcclxuICAgICAgICBmb250Y2xhc3M6e1xyXG4gICAgICAgICAgICB0eXBlOlN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDpcImdseXBoaWNvbiBnbHlwaGljb24tbGlzdCBqdXJhc3NpYy1wYW5lbC1sb2dvXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczp7XHJcbiAgICAgICAgb25TaG93TW9yZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLm9uc2hvd21vcmUmJnRoaXMub25zaG93bW9yZSh0aGlzLnRpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbjwvc2NyaXB0PlxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBrcy5wYW5lbC52dWU/ZWViMTNkNTAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        //标题\n        title: String,\n        //点击more\n        date: String,\n        //图标\n        fontclass: {\n            type: String,\n            default: \"glyphicon glyphicon-list jurassic-panel-logo\"\n        },\n        onleft: Function,\n        onright: Function\n    },\n    methods: {\n        onShowMore: function onShowMore() {\n            this.onshowmore && this.onshowmore(this.title);\n        },\n        onLeft: function onLeft() {\n            this.onleft && this.onleft();\n        },\n        onRight: function onRight() {\n            this.onright && this.onright();\n        }\n    }\n\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnBhbmVsMi52dWU/NWJiNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTs7QUFHQTtlQUNBO0FBQ0E7Y0FDQTtBQUNBOztrQkFFQTtxQkFFQTtBQUhBO2dCQUlBO2lCQUVBO0FBWkE7OzBDQWNBO29EQUNBO0FBQ0E7a0NBQ0E7Z0NBQ0E7QUFDQTtvQ0FDQTtpQ0FDQTtBQUdBO0FBWEE7O0FBZEEiLCJmaWxlIjoiMjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsLWhlYWRlclwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTlcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aSA6Y2xhc3M9XCJmb250Y2xhc3NcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJqdXJhc3NpYy1wYW5lbC10aXRsZVwiPnt7dGl0bGV9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0zIGp1cmFzc2ljLXRleHQtcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1sZWZ0XCIgQGNsaWNrPVwib25MZWZ0XCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwibWFyZ2luOjAgMjBweDtcIj57e2RhdGV9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1yaWdodFwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OjIwcHg7XCIgQGNsaWNrPVwib25SaWdodFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcGFuZWwtYm9keVwiPlxyXG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwicGFuZWxcIj48L3Nsb3Q+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgLy/moIfpophcclxuICAgICAgICB0aXRsZTogU3RyaW5nLFxyXG4gICAgICAgIC8v54K55Ye7bW9yZVxyXG4gICAgICAgIGRhdGU6IFN0cmluZyxcclxuICAgICAgICAvL+Wbvuagh1xyXG4gICAgICAgIGZvbnRjbGFzczoge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiZ2x5cGhpY29uIGdseXBoaWNvbi1saXN0IGp1cmFzc2ljLXBhbmVsLWxvZ29cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25sZWZ0OkZ1bmN0aW9uLFxyXG4gICAgICAgIG9ucmlnaHQ6RnVuY3Rpb25cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgb25TaG93TW9yZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uc2hvd21vcmUgJiYgdGhpcy5vbnNob3dtb3JlKHRoaXMudGl0bGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWZ0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMub25sZWZ0JiZ0aGlzLm9ubGVmdCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25SaWdodDpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLm9ucmlnaHQmJnRoaXMub25yaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLnBhbmVsMi52dWU/NzUyMDM1YmMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        return {\n            _thisTitle: \"\"\n        };\n    },\n\n    props: {\n        //标题\n        titles: Array,\n        //是否显示more\n        show: {\n            type: Boolean,\n            default: true\n        },\n        //点击more事件\n        onshowmore: Function,\n        //图标\n        fontclass: {\n            type: String,\n            default: \"glyphicon glyphicon-list jurassic-panel-logo\"\n        }\n    },\n    methods: {\n        onShowMore: function onShowMore() {\n            this.onshowmore && this.onshowmore(this._thisTitle);\n        }\n    },\n    created: function created() {\n        var self = this;\n        $(document).on(\"mousemove\", \".jurassic-tab-panel-title\", function (e) {\n            var target$ = $(e.currentTarget);\n            self._thisTitle = target$[0].innerText;\n            target$.addClass(\"active\").parent().siblings().find(\".active\").removeClass(\"active\");\n            var anchor = target$.data() && target$.data().anchor;\n            if (!anchor) return;\n            var tab$ = target$.closest(\".jurassic-panel\");\n            tab$.find(\".jurassic-tab-panel-container\" + \"[data-anchor=\" + anchor + \"]\").addClass(\"active\").siblings().removeClass(\"active\");\n        });\n    },\n    mounted: function mounted() {\n        $(\".jurassic-panel\").find(\".jurassic-template:first-of-type\").find(\".jurassic-tab-panel-title\").not(\".active\").trigger(\"mousemove\");\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnBhbmVsTGlzdC52dWU/N2QxMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzBCQUVBOzt3QkFHQTtBQUZBO0FBR0E7OztBQUVBO2dCQUNBO0FBQ0E7O2tCQUVBO3FCQUVBO0FBSEE7QUFJQTtvQkFDQTtBQUNBOztrQkFFQTtxQkFHQTtBQUpBO0FBWEE7OzBDQWlCQTtvREFDQTtBQUVBO0FBSkE7Z0NBS0E7bUJBQ0E7OEVBQ0E7OEJBQ0E7eUNBQ0E7dUZBQ0E7MERBQ0E7eUJBQ0E7dUNBQ0E7a0lBQ0E7QUFDQTtBQUNBO2dDQUNBOytIQUNBO0FBQ0E7QUF6Q0EiLCJmaWxlIjoiMjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsLWhlYWRlclwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtY29sLTlcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aSA6Y2xhc3M9XCJmb250Y2xhc3NcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWlubGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtdGVtcGxhdGVcIiAgdi1mb3I9XCIodGl0bGUsaW5kZXgpIGluIHRpdGxlc1wiIDprZXk9XCJpbmRleCsna2V5J1wiIHN0eWxlPVwiZGlzcGxheTppbmxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwianVyYXNzaWMtdGFiLXBhbmVsLXRpdGxlXCIgOmRhdGEtYW5jaG9yPVwiJ2pyYycraW5kZXhcIj57e3RpdGxlfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImp1cmFzc2ljLXNwbGl0LWxpbmVcIiB2LWlmPVwiaW5kZXgrMTx0aXRsZXMubGVuZ3RoP3RydWU6ZmFsc2VcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2ID5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLWNvbC0zICBqdXJhc3NpYy10ZXh0LXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cImp1cmFzc2ljLXBhbmVsLW1vcmVcIiBAY2xpY2s9XCJvblNob3dNb3JlXCIgdi1pZj1cInNob3dcIj4rTU9SRTwvYT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtcGFuZWwtYm9keVwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtdGFiLXBhbmVsLWNvbnRhaW5lclwiIDpkYXRhLWFuY2hvcj1cIidqcmMnK2luZGV4XCIgdi1mb3I9XCIodGl0bGUsaW5kZXgpIGluIHRpdGxlc1wiIDprZXk9XCJpbmRleCsna2V5J1wiPlxyXG4gICAgICAgICAgICAgICAgPHNsb3QgOm5hbWU9XCJ0aXRsZVwiPjwvc2xvdD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKXtcclxuICAgICAgICByZXR1cm57XHJcbiAgICAgICAgICAgIF90aGlzVGl0bGU6XCJcIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v5qCH6aKYXHJcbiAgICAgICAgdGl0bGVzOiBBcnJheSxcclxuICAgICAgICAvL+aYr+WQpuaYvuekum1vcmVcclxuICAgICAgICBzaG93OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v54K55Ye7bW9yZeS6i+S7tlxyXG4gICAgICAgIG9uc2hvd21vcmU6IEZ1bmN0aW9uLFxyXG4gICAgICAgIC8v5Zu+5qCHXHJcbiAgICAgICAgZm9udGNsYXNzOntcclxuICAgICAgICAgICAgdHlwZTpTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XCJnbHlwaGljb24gZ2x5cGhpY29uLWxpc3QganVyYXNzaWMtcGFuZWwtbG9nb1wiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBvblNob3dNb3JlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25zaG93bW9yZSAmJiB0aGlzLm9uc2hvd21vcmUodGhpcy5fdGhpc1RpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlZCgpe1xyXG4gICAgICAgIHZhciBzZWxmPXRoaXM7XHJcbiAgICAgICAgJChkb2N1bWVudCkub24oXCJtb3VzZW1vdmVcIiwgXCIuanVyYXNzaWMtdGFiLXBhbmVsLXRpdGxlXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0JCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3RoaXNUaXRsZT10YXJnZXQkWzBdLmlubmVyVGV4dDtcclxuICAgICAgICAgICAgICAgIHRhcmdldCQuYWRkQ2xhc3MoXCJhY3RpdmVcIikucGFyZW50KCkuc2libGluZ3MoKS5maW5kKFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSB0YXJnZXQkLmRhdGEoKSAmJiB0YXJnZXQkLmRhdGEoKS5hbmNob3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFuY2hvcikgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhYiQgPSB0YXJnZXQkLmNsb3Nlc3QoXCIuanVyYXNzaWMtcGFuZWxcIik7XHJcbiAgICAgICAgICAgICAgICB0YWIkLmZpbmQoXCIuanVyYXNzaWMtdGFiLXBhbmVsLWNvbnRhaW5lclwiICsgXCJbZGF0YS1hbmNob3I9XCIgKyBhbmNob3IgKyBcIl1cIikuYWRkQ2xhc3MoXCJhY3RpdmVcIikuc2libGluZ3MoKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LCAgXHJcbiAgICBtb3VudGVkKCl7XHJcbiAgICAgICAgJChcIi5qdXJhc3NpYy1wYW5lbFwiKS5maW5kKFwiLmp1cmFzc2ljLXRlbXBsYXRlOmZpcnN0LW9mLXR5cGVcIikuZmluZChcIi5qdXJhc3NpYy10YWItcGFuZWwtdGl0bGVcIikubm90KFwiLmFjdGl2ZVwiKS50cmlnZ2VyKFwibW91c2Vtb3ZlXCIpO1xyXG4gICAgfSBcclxufVxyXG48L3NjcmlwdD5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwa3MucGFuZWxMaXN0LnZ1ZT9kOWMzNTAyZSJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_list_vue__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pks_list_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__pks_list_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pks_panel_vue__ = __webpack_require__(43);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pks_panel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__pks_panel_vue__);\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        id: String,\n        //标题\n        title: {\n            type: String,\n            default: \"\"\n        },\n        //点击more事件\n        onshowmore: Function,\n        //图标\n        fontclass: String,\n        //是否显示more\n        show: {\n            type: Boolean,\n            default: true\n        },\n        data: Array,\n        map: Object,\n        //点击列表项事件\n        onclick: Function\n    },\n    methods: {\n        onShowMore: function onShowMore(e) {\n            this.onshowmore && this.onshowmore(e);\n        },\n        onClick: function onClick(e) {\n            this.onclick && this.onclick(e);\n        }\n    },\n    components: { list: __WEBPACK_IMPORTED_MODULE_0__pks_list_vue___default.a, panel: __WEBPACK_IMPORTED_MODULE_1__pks_panel_vue___default.a }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnNpbmdsZVRpdGxlLnZ1ZT9kOTY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O1lBR0E7QUFDQTs7a0JBRUE7cUJBRUE7QUFIQTtBQUlBO29CQUNBO0FBQ0E7bUJBQ0E7QUFDQTs7a0JBRUE7cUJBRUE7QUFIQTtjQUlBO2FBQ0E7QUFDQTtpQkFFQTtBQXBCQTs7MkNBc0JBOytDQUNBO0FBQ0E7cUNBQ0E7eUNBQ0E7QUFFQTtBQVBBOytFQVFBO0FBOUJBIiwiZmlsZSI6IjI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuXHJcbiAgICAgICAgPHBhbmVsICA6dGl0bGU9XCJ0aXRsZVwiIDpvbnNob3dtb3JlPVwib25TaG93TW9yZVwiIDpzaG93PVwic2hvd1wiIDpmb250Y2xhc3M9XCJmb250Y2xhc3NcIj5cclxuICAgICAgICAgICA8bGlzdCA6aXRlbXM9XCJkYXRhXCIgOm1hcD1cIm1hcFwiIDpvbmNsaWNrPVwib25DbGlja1wiIHNsb3Q9XCJwYW5lbFwiPjwvbGlzdD5cclxuICAgICAgICA8L3BhbmVsPlxyXG5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IGxpc3QgZnJvbSAnLi9wa3MubGlzdC52dWUnO1xyXG5pbXBvcnQgcGFuZWwgZnJvbSAnLi9wa3MucGFuZWwudnVlJztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBpZDpTdHJpbmcsXHJcbiAgICAgICAgLy/moIfpophcclxuICAgICAgICB0aXRsZTp7XHJcbiAgICAgICAgICAgIHR5cGU6U3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OlwiXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v54K55Ye7bW9yZeS6i+S7tlxyXG4gICAgICAgIG9uc2hvd21vcmU6RnVuY3Rpb24sXHJcbiAgICAgICAgLy/lm77moIdcclxuICAgICAgICBmb250Y2xhc3M6U3RyaW5nLFxyXG4gICAgICAgIC8v5piv5ZCm5pi+56S6bW9yZVxyXG4gICAgICAgIHNob3c6e1xyXG4gICAgICAgICAgICB0eXBlOkJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6dHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGF0YTpBcnJheSxcclxuICAgICAgICBtYXA6T2JqZWN0LFxyXG4gICAgICAgIC8v54K55Ye75YiX6KGo6aG55LqL5Lu2XHJcbiAgICAgICAgb25jbGljazpGdW5jdGlvblxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBvblNob3dNb3JlOmZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICB0aGlzLm9uc2hvd21vcmUmJnRoaXMub25zaG93bW9yZShlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xpY2s6ZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uY2xpY2smJnRoaXMub25jbGljayhlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50czogeyBsaXN0LHBhbmVsfVxyXG59XHJcbjwvc2NyaXB0PlxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBrcy5zaW5nbGVUaXRsZS52dWU/MTExNjUyNTQiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        return {\n            viewer: {}\n        };\n    },\n\n    props: {\n        item: Object,\n        map: Object,\n        onclick: Function,\n        width: {\n            type: String,\n            default: \"100%\"\n        },\n        height: {\n            type: String,\n            default: \"100%\"\n        }\n    },\n    methods: {\n        onClick: function onClick(e) {\n            this.onclick && this.onclick(e);\n        },\n        initfun: function initfun() {\n            if (this.item && this.item[this.map['url']]) {\n                var options = {\n                    url: 'data-original'\n                };\n                this.viewer = $(this.$el).viewer(options);\n            }\n        },\n        destroy: function destroy() {\n            if (this.viewer.data && this.viewer.data().viewer) {\n                this.viewer.data().viewer.destroy();\n            }\n        }\n    },\n    mounted: function mounted() {\n        this.initfun();\n    },\n\n    watch: {\n        item: function item() {\n            this.$nextTick(function () {\n                // ==》更新dom后，加载数据      \n                this.destroy();\n                this.initfun();\n            });\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnNpbmdsZWltZy52dWU/MmZjZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzBCQUVBOztvQkFHQTtBQUZBO0FBR0E7OztjQUVBO2FBQ0E7aUJBQ0E7O2tCQUVBO3FCQUVBO0FBSEE7O2tCQUtBO3FCQUdBO0FBSkE7QUFSQTs7cUNBY0E7eUNBQ0E7QUFDQTtvQ0FDQTtnREFDQSxTQUNBOzt5QkFHQTtBQUZBO2lEQUdBO0FBRUE7QUFDQTtvQ0FDQTt1REFDQSxRQUNBOzBDQUNBO0FBQ0E7QUFFQTtBQXBCQTtnQ0FxQkE7YUFDQTtBQUNBOzs7OEJBRUE7O0FBQ0E7cUJBQ0E7cUJBQ0E7QUFFQTtBQUVBO0FBUkE7QUEzQ0EiLCJmaWxlIjoiMjQxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPCEtLSA8ZGl2IGNsYXNzPVwianVyYXNzaWMtc2luZ2xlaW1nXCI+IC0tPlxyXG4gICAgPGRpdiBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7XCI+XHJcbiAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwianVyYXNzaWMtc2luZ2xlaW1nLWhlYWRcIj4gLS0+XHJcbiAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3RleHQtYWxpZ246Y2VudGVyXCIgdi1pZj1cIiFpdGVtfHwhaXRlbVttYXBbJ3VybCddXVwiPlxyXG4gICAgICAgICAgICDmmoLml6Dlm77niYdcclxuICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7dGV4dC1hbGlnbjpjZW50ZXJcIiB2LWVsc2U+XHJcbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJqdXJhc3NpYy1zaW5nbGVpbWctaW1nXCIgXHJcbiAgICAgICAgICAgIDpzcmM9XCJpdGVtW21hcFsndGh1bWJuYWlsJ11dP2l0ZW1bbWFwWyd0aHVtYm5haWwnXV06aXRlbVttYXBbJ3VybCddXVwiIFxyXG4gICAgICAgICAgICA6ZGF0YS1vcmlnaW5hbD1cIml0ZW1bbWFwWyd1cmwnXV1cIiBcclxuICAgICAgICAgICAgYWx0PVwi5pqC5peg5Zu+54mHXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgdi1pZj1cIiFpdGVtfHwhaXRlbVttYXBbJ3VybCddXVwiPlxyXG5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtc2luZ2xlaW1nLWJvdHRvbSBqdXJhc3NpYy1uZXdzLWJyaWVmXCIgIDpzdHlsZT1cInt3aWR0aDp3aWR0aH1cIiBcclxuICAgICAgICAgICAgQGNsaWNrPVwib25DbGljayhpdGVtW21hcFsncGFyYW0nXV0pXCIgdi1lbHNlPlxyXG4gICAgICAgICAgICA8cCA6dGl0bGU9XCJpdGVtW21hcFsnYm90dG9tJ11dXCIgPnt7aXRlbVttYXBbJ2JvdHRvbSddXX19PC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmlld2VyOiB7fVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGl0ZW06IE9iamVjdCxcclxuICAgICAgICBtYXA6IE9iamVjdCxcclxuICAgICAgICBvbmNsaWNrOiBGdW5jdGlvbixcclxuICAgICAgICB3aWR0aDp7XHJcbiAgICAgICAgICAgIHR5cGU6U3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OlwiMTAwJVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoZWlnaHQ6e1xyXG4gICAgICAgICAgICB0eXBlOlN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDpcIjEwMCVcIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbmNsaWNrICYmIHRoaXMub25jbGljayhlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRmdW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pdGVtJiZ0aGlzLml0ZW1bdGhpcy5tYXBbJ3VybCddXSlcclxuICAgICAgICAgICAgeyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgdXJsOiAnZGF0YS1vcmlnaW5hbCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdlcj0kKHRoaXMuJGVsKS52aWV3ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMudmlld2VyLmRhdGEmJiB0aGlzLnZpZXdlci5kYXRhKCkudmlld2VyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdlci5kYXRhKCkudmlld2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkKCkge1xyXG4gICAgICAgIHRoaXMuaW5pdGZ1bigpO1xyXG4gICAgfSxcclxuICAgIHdhdGNoOiB7XHJcbiAgICAgICAgaXRlbTogZnVuY3Rpb24gKCkgeyAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7ICAvLyA9PeOAi+abtOaWsGRvbeWQju+8jOWKoOi9veaVsOaNriAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRmdW4oKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwa3Muc2luZ2xlaW1nLnZ1ZT9jYTViOWYzOCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    props: {\n        //标题\n        items: Array,\n        onclick: Function\n    },\n    methods: {\n        itemclick: function itemclick(item) {\n            $(\"#\" + item.value).addClass(\"jurassic-sort-a-curr\").siblings().removeClass(\"jurassic-sort-a-curr\");\n            $(\"#\" + item.value + \" i\").parent().siblings().children().removeClass();\n            if ($(\"#\" + item.value + \" i\").hasClass(\"glyphicon glyphicon-triangle-bottom\")) {\n                $(\"#\" + item.value + \" i\").removeClass(\"glyphicon glyphicon-triangle-bottom\").addClass(\"glyphicon glyphicon-triangle-top\");\n                this.onclick && this.onclick(\"asc\", item);\n            } else {\n                $(\"#\" + item.value + \" i\").removeClass(\"glyphicon glyphicon-triangle-top\").addClass(\"glyphicon glyphicon-triangle-bottom\");\n                this.onclick && this.onclick(\"desc\", item);\n            }\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnNvcnQudnVlPzc4MjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQWVBOzs7QUFJQTtlQUNBO2lCQUVBO0FBSkE7OzRDQU1BO3dGQUNBO3NFQUNBOzRGQUNBO3VHQUNBO29EQUNBO21CQUNBO29HQUNBO3FEQUNBO0FBRUE7QUFFQTtBQWJBO0FBTkEiLCJmaWxlIjoiMjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXJvd1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1zb3J0XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1zb3J0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy1zb3J0LWl0ZW1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8YSB2LWZvcj1cIihpdGVtLGluZGV4KSBpbiBpdGVtc1wiIDprZXk9XCJpbmRleFwiIGhyZWY9XCIjXCIgY2xhc3M9XCJcIiA6aWQ9XCJpdGVtLnZhbHVlXCIgQGNsaWNrPVwiaXRlbWNsaWNrKGl0ZW0pXCI+e3tpdGVtLnZhbHVlfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGk+PC9pPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgLy/moIfpophcclxuICAgICAgICBpdGVtczogQXJyYXksXHJcbiAgICAgICAgb25jbGljazogRnVuY3Rpb25cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgaXRlbWNsaWNrOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAkKFwiI1wiICsgaXRlbS52YWx1ZSkuYWRkQ2xhc3MoXCJqdXJhc3NpYy1zb3J0LWEtY3VyclwiKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKFwianVyYXNzaWMtc29ydC1hLWN1cnJcIik7XHJcbiAgICAgICAgICAgICQoXCIjXCIgKyBpdGVtLnZhbHVlICsgXCIgaVwiKS5wYXJlbnQoKS5zaWJsaW5ncygpLmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MoKTtcclxuICAgICAgICAgICAgaWYgKCQoXCIjXCIgKyBpdGVtLnZhbHVlICsgXCIgaVwiKS5oYXNDbGFzcyhcImdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtYm90dG9tXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAkKFwiI1wiICsgaXRlbS52YWx1ZSArIFwiIGlcIikucmVtb3ZlQ2xhc3MoXCJnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLWJvdHRvbVwiKS5hZGRDbGFzcyhcImdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtdG9wXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNsaWNrICYmIHRoaXMub25jbGljayhcImFzY1wiLCBpdGVtKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICQoXCIjXCIgKyBpdGVtLnZhbHVlICsgXCIgaVwiKS5yZW1vdmVDbGFzcyhcImdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtdG9wXCIpLmFkZENsYXNzKFwiZ2x5cGhpY29uIGdseXBoaWNvbi10cmlhbmdsZS1ib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2xpY2sgJiYgdGhpcy5vbmNsaWNrKFwiZGVzY1wiLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcGtzLnNvcnQudnVlP2Y4N2RlMDljIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    props: {\n        //标题\n        titles: Array,\n        showmore: Boolean,\n        onshowmore: Function\n    },\n    created: function created() {\n        $(document).on(\"mousemove\", \".jurassic-tab-btn\", function (e) {\n            var target$ = $(e.currentTarget);\n            target$.addClass(\"active\").siblings().removeClass(\"active\");\n            var anchor = target$.data() && target$.data().anchor;\n            if (!anchor) return;\n            var tab$ = target$.closest(\".jurassic-tab\");\n            tab$.children(\".jurassic-tab-body\").children(\".jurassic-tab-container\" + \"[data-anchor=\" + anchor + \"]\").addClass(\"active\").siblings().removeClass(\"active\");\n        });\n    },\n    mounted: function mounted() {\n        $(\".jurassic-tab\").find(\".jurassic-tab-btn\" + \":first-child\").not(\".active\").trigger(\"mousemove\");\n    },\n\n    methods: {\n        onShowMore: function onShowMore() {\n            var activeTitle = $('.jurassic-tab-btn.active', $(this.$el)).text();\n            this.onshowmore && this.onshowmore(activeTitle);\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLnRhYnMudnVlPzJhNWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7QUFJQTtnQkFDQTtrQkFDQTtvQkFFQTtBQUxBO2dDQU1BO3NFQUNBOzhCQUNBOzhEQUNBOzBEQUNBO3lCQUNBO3VDQUNBOytKQUNBO0FBQ0E7QUFDQTtnQ0FDQTs2RkFDQTtBQUNBOzs7MENBRUE7eUVBQ0E7K0NBQ0E7QUFFQTtBQUxBO0FBcEJBIiwiZmlsZSI6IjI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy10YWJcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImp1cmFzc2ljLXRhYi1oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy10YWItYnRuXCIgOmRhdGEtYW5jaG9yPVwiJ2pycycraW5kZXhcIiB2LWZvcj1cIih0aXRsZSxpbmRleCkgaW4gdGl0bGVzXCIgOmtleT1cInRpdGxlXCI+e3t0aXRsZX19PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjogcmlnaHQ7cG9zaXRpb246IHJlbGF0aXZlO2Zsb2F0OiByaWdodFwiIHYtaWY9XCJzaG93bW9yZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImp1cmFzc2ljLXBhbmVsLW1vcmVcIiBAY2xpY2s9XCJvblNob3dNb3JlXCI+K01PUkU8L2E+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJqdXJhc3NpYy10YWItYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwianVyYXNzaWMtdGFiLWNvbnRhaW5lclwiIDpkYXRhLWFuY2hvcj1cIidqcnMnK2luZGV4XCIgdi1mb3I9XCIodGl0bGUsaW5kZXgpIGluIHRpdGxlc1wiIDprZXk9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzbG90IDpuYW1lPVwidGl0bGVcIj48L3Nsb3Q+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBcclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIC8v5qCH6aKYXHJcbiAgICAgICAgdGl0bGVzOiBBcnJheSxcclxuICAgICAgICBzaG93bW9yZTpCb29sZWFuLFxyXG4gICAgICAgIG9uc2hvd21vcmU6RnVuY3Rpb24sXHJcbiAgICB9LFxyXG4gICAgY3JlYXRlZCgpe1xyXG4gICAgICAgICAkKGRvY3VtZW50KS5vbihcIm1vdXNlbW92ZVwiLFwiLmp1cmFzc2ljLXRhYi1idG5cIixmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQkID0gJChlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0JC5hZGRDbGFzcyhcImFjdGl2ZVwiKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRhcmdldCQuZGF0YSgpICYmIHRhcmdldCQuZGF0YSgpLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgIGlmKCFhbmNob3IpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciB0YWIkID0gdGFyZ2V0JC5jbG9zZXN0KFwiLmp1cmFzc2ljLXRhYlwiKTtcclxuICAgICAgICAgICAgICAgIHRhYiQuY2hpbGRyZW4oXCIuanVyYXNzaWMtdGFiLWJvZHlcIikuY2hpbGRyZW4oXCIuanVyYXNzaWMtdGFiLWNvbnRhaW5lclwiICsgXCJbZGF0YS1hbmNob3I9XCIgKyBhbmNob3IgKyBcIl1cIikuYWRkQ2xhc3MoXCJhY3RpdmVcIikuc2libGluZ3MoKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZCgpe1xyXG4gICAgICAgICAgICAkKFwiLmp1cmFzc2ljLXRhYlwiKS5maW5kKFwiLmp1cmFzc2ljLXRhYi1idG5cIiArIFwiOmZpcnN0LWNoaWxkXCIpLm5vdChcIi5hY3RpdmVcIikudHJpZ2dlcihcIm1vdXNlbW92ZVwiKTtcclxuICAgIH0sXHJcbiAgICAgbWV0aG9kczp7XHJcbiAgICAgICAgb25TaG93TW9yZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgYWN0aXZlVGl0bGU9JCgnLmp1cmFzc2ljLXRhYi1idG4uYWN0aXZlJywkKHRoaXMuJGVsKSkudGV4dCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uc2hvd21vcmUmJnRoaXMub25zaG93bW9yZShhY3RpdmVUaXRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBrcy50YWJzLnZ1ZT8wM2JjNTg4NiJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n\n\n//require('./lib/viewer.min.js');\n//require('./lib/viewer.min.css');\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        id: { type: String },\n        items: Array,\n        itemwidth: { type: Number, default: 165 },\n        itemheight: { type: Number, default: 140 },\n        width: { type: Number, default: 500 },\n        height: { type: Number, default: 200 }\n    },\n    // data() {\n    //     return {\n    //         items: []\n    //     }\n    // },\n    watch: {},\n    computed: {\n        // itemwidth: function () {\n        //     if (this.items.length > 0 && this.width)\n        //         return Math.round((this.width / this.items.length) * 100) / 100 + \"px\";\n        //     return '100%';\n        // }\n        ulheight: function ulheight() {\n            return this.items.length == 1 ? \"100%\" : this.itemheight + 'px';\n        }\n    },\n    mounted: function mounted() {\n        this.initPictureViewer();\n    },\n    created: function created() {},\n    methods: {\n        initPictureViewer: function initPictureViewer() {\n            if (this.items.length == 1) return;\n            var $images = $('.picImgContainer');\n            var options = {\n                // inline: true,\n                url: 'data-original',\n                build: function build(e) {\n                    console.log(e.type);\n                },\n                built: function built(e) {\n                    console.log(e.type);\n                },\n                show: function show(e) {\n                    console.log(e.type);\n                },\n                shown: function shown(e) {\n                    console.log(e.type);\n                },\n                hide: function hide(e) {\n                    console.log(e.type);\n                },\n                hidden: function hidden(e) {\n                    console.log(e.type);\n                },\n                view: function view(e) {\n                    console.log(e.type);\n                },\n                viewed: function viewed(e) {\n                    console.log(e.type);\n                }\n            };\n            $images.on({\n                'build.viewer': function buildViewer(e) {\n                    console.log(e.type);\n                },\n                'built.viewer': function builtViewer(e) {\n                    console.log(e.type);\n                },\n                'show.viewer': function showViewer(e) {\n                    console.log(e.type);\n                },\n                'shown.viewer': function shownViewer(e) {\n                    console.log(e.type);\n                },\n                'hide.viewer': function hideViewer(e) {\n                    console.log(e.type);\n                },\n                'hidden.viewer': function hiddenViewer(e) {\n                    console.log(e.type);\n                },\n                'view.viewer': function viewViewer(e) {\n                    console.log(e.type);\n                },\n                'viewed.viewer': function viewedViewer(e) {\n                    console.log(e.type);\n                }\n            }).viewer(options);\n\n            $images.elastislide();\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcGtzLmltYWdlLnZ1ZT84OGNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O29CQUdBO2VBQ0E7NENBQ0E7NkNBQ0E7d0NBQ0E7eUNBRUE7QUFQQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7V0FHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO3NDQUNBO3VFQUNBO0FBRUE7QUFUQTtnQ0FVQTthQUVBO0FBQ0E7Z0NBRUEsQ0FDQTs7d0RBRUE7cUNBQ0EsR0FDQTs0QkFDQTs7QUFFQTtxQkFDQTt5Q0FDQTtrQ0FDQTtBQUNBO3lDQUNBO2tDQUNBO0FBQ0E7dUNBQ0E7a0NBQ0E7QUFDQTt5Q0FDQTtrQ0FDQTtBQUNBO3VDQUNBO2tDQUNBO0FBQ0E7MkNBQ0E7a0NBQ0E7QUFDQTt1Q0FDQTtrQ0FDQTtBQUNBOzJDQUNBO2tDQUNBO0FBRUE7QUEzQkE7O3dEQTZCQTtrQ0FDQTtBQUNBO3dEQUNBO2tDQUNBO0FBQ0E7c0RBQ0E7a0NBQ0E7QUFDQTt3REFDQTtrQ0FDQTtBQUNBO3NEQUNBO2tDQUNBO0FBQ0E7MERBQ0E7a0NBQ0E7QUFDQTtzREFDQTtrQ0FDQTtBQUNBOzBEQUNBO2tDQUNBO0FBQ0E7QUF4QkEsc0JBMEJBOztvQkFFQTtBQUVBO0FBL0RBO0FBbENBIiwiZmlsZSI6IjI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDx1bCA6aWQ9XCJpZFwiIGNsYXNzPVwicGljSW1nQ29udGFpbmVyIGNhcm91c2VsIGNsZWFyZml4XCIgdi1iaW5kOnN0eWxlPVwie2hlaWdodDp1bGhlaWdodH1cIj5cclxuICAgICAgICA8bGkgdi1mb3I9XCJpdGVtIGluIGl0ZW1zXCI+XHJcbiAgICAgICAgICAgPGltZyB2LWJpbmQ6ZGF0YS1vcmlnaW5hbD1cIml0ZW0uc3JjXCIgdi1iaW5kOnNyYz1cIml0ZW0udGh1bWJuYWlsP2l0ZW0udGh1bWJuYWlsOml0ZW0uc3JjXCIgdi1iaW5kOmFsdD1cIml0ZW0udGl0bGVcIj5cclxuICAgICAgICA8L2xpPlxyXG4gICAgPC91bD5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbi8vcmVxdWlyZSgnLi9saWIvdmlld2VyLm1pbi5qcycpO1xyXG4vL3JlcXVpcmUoJy4vbGliL3ZpZXdlci5taW4uY3NzJyk7XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaWQ6e3R5cGU6U3RyaW5nfSxcclxuICAgICAgICBpdGVtczogQXJyYXksXHJcbiAgICAgICAgaXRlbXdpZHRoOnsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAxNjUgfSxcclxuICAgICAgICBpdGVtaGVpZ2h0OnsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAxNDAgfSxcclxuICAgICAgICB3aWR0aDogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDUwMCB9LFxyXG4gICAgICAgIGhlaWdodDogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDIwMCB9XHJcbiAgICB9LFxyXG4gICAgLy8gZGF0YSgpIHtcclxuICAgIC8vICAgICByZXR1cm4ge1xyXG4gICAgLy8gICAgICAgICBpdGVtczogW11cclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9LFxyXG4gICAgd2F0Y2g6IHtcclxuICAgICAgICBcclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIC8vIGl0ZW13aWR0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPiAwICYmIHRoaXMud2lkdGgpXHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgodGhpcy53aWR0aCAvIHRoaXMuaXRlbXMubGVuZ3RoKSAqIDEwMCkgLyAxMDAgKyBcInB4XCI7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiAnMTAwJSc7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHVsaGVpZ2h0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aD09MT9cIjEwMCVcIjoodGhpcy5pdGVtaGVpZ2h0KydweCcpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0UGljdHVyZVZpZXdlcigpO1xyXG5cclxuICAgIH0sXHJcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBpbml0UGljdHVyZVZpZXdlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLml0ZW1zLmxlbmd0aD09MSlcclxuICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgJGltYWdlcyA9ICQoJy5waWNJbWdDb250YWluZXInKTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmxpbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB1cmw6ICdkYXRhLW9yaWdpbmFsJyxcclxuICAgICAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYnVpbHQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzaG93OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hvd246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdmlldzogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHZpZXdlZDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAkaW1hZ2VzLm9uKHtcclxuICAgICAgICAgICAgICAgICdidWlsZC52aWV3ZXInOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJ2J1aWx0LnZpZXdlcic6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnc2hvdy52aWV3ZXInOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJ3Nob3duLnZpZXdlcic6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnaGlkZS52aWV3ZXInOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJ2hpZGRlbi52aWV3ZXInOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJ3ZpZXcudmlld2VyJzogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICd2aWV3ZWQudmlld2VyJzogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS52aWV3ZXIob3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAkaW1hZ2VzLmVsYXN0aXNsaWRlKCk7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG51bC5waWNJbWdDb250YWluZXIge1xyXG4gICAgbWFyZ2luOiAwO1xyXG4gICAgcGFkZGluZzogMDtcclxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XHJcbn1cclxuXHJcbnVsLnBpY0ltZ0NvbnRhaW5lciBsaSB7XHJcbiAgIC8qIGZsb2F0OiBsZWZ0OyovXHJcbiAgICBtYXJnaW46IDAgLTFweCAtMXB4IDA7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbn1cclxuXHJcblxyXG51bC5waWNJbWdDb250YWluZXIgbGkgaW1nIHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG59XHJcbjwvc3R5bGU+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHBrcy5pbWFnZS52dWU/MDQxMzYxZGUiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\n    props: {\n        dd: {\n            type: String,\n            default: \"12\"\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZGVtby52dWU/ZjEyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFRQTs7OztrQkFLQTtxQkFHQTtBQUpBO0FBREE7QUFEQSIsImZpbGUiOiIyNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIDxoMT57e2RkfX08L2gxPlxyXG4gICAgICAgIDxpbnB1dCB2LW1vZGVsPVwiZGRcIi8+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGRkOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDogXCIxMlwiXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBkZW1vLnZ1ZT9iZTVhZjAzMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(80)();\n// imports\n\n\n// module\nexports.push([module.i, \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"pks.pager.vue\",\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYWdlci52dWU/MGUyNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLDJJQUE0SSxtR0FBbUc7O0FBRS9PIiwiZmlsZSI6IjI0Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJwa3MucGFnZXIudnVlXCIsXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtM2MwMjkxZjJcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYWdlci52dWVcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(80)();\n// imports\n\n\n// module\nexports.push([module.i, \"\\nul.picImgContainer {\\r\\n    margin: 0;\\r\\n    padding: 0;\\r\\n    list-style: none;\\n}\\nul.picImgContainer li {\\r\\n   /* float: left;*/\\r\\n    margin: 0 -1px -1px 0;\\r\\n    border: 1px solid transparent;\\r\\n    overflow: hidden;\\n}\\nul.picImgContainer li img {\\r\\n    width: 100%;\\n}\\r\\n\", \"\", {\"version\":3,\"sources\":[\"/./src/Components/DataRender/pks.image.vue?041361de\"],\"names\":[],\"mappings\":\";AAgHA;IACA,UAAA;IACA,WAAA;IACA,iBAAA;CACA;AAEA;GACA,iBAAA;IACA,sBAAA;IACA,8BAAA;IACA,iBAAA;CACA;AAGA;IACA,YAAA;CACA\",\"file\":\"pks.image.vue\",\"sourcesContent\":[\"<template>\\r\\n    <ul :id=\\\"id\\\" class=\\\"picImgContainer carousel clearfix\\\" v-bind:style=\\\"{height:ulheight}\\\">\\r\\n        <li v-for=\\\"item in items\\\">\\r\\n           <img v-bind:data-original=\\\"item.src\\\" v-bind:src=\\\"item.thumbnail?item.thumbnail:item.src\\\" v-bind:alt=\\\"item.title\\\">\\r\\n        </li>\\r\\n    </ul>\\r\\n</template>\\r\\n<script>\\r\\n\\r\\n//require('./lib/viewer.min.js');\\r\\n//require('./lib/viewer.min.css');\\r\\nexport default {\\r\\n    props: {\\r\\n        id:{type:String},\\r\\n        items: Array,\\r\\n        itemwidth:{ type: Number, default: 165 },\\r\\n        itemheight:{ type: Number, default: 140 },\\r\\n        width: { type: Number, default: 500 },\\r\\n        height: { type: Number, default: 200 }\\r\\n    },\\r\\n    // data() {\\r\\n    //     return {\\r\\n    //         items: []\\r\\n    //     }\\r\\n    // },\\r\\n    watch: {\\r\\n        \\r\\n    },\\r\\n    computed: {\\r\\n        // itemwidth: function () {\\r\\n        //     if (this.items.length > 0 && this.width)\\r\\n        //         return Math.round((this.width / this.items.length) * 100) / 100 + \\\"px\\\";\\r\\n        //     return '100%';\\r\\n        // }\\r\\n        ulheight:function(){\\r\\n            return this.items.length==1?\\\"100%\\\":(this.itemheight+'px');\\r\\n        }\\r\\n    },\\r\\n    mounted: function () {\\r\\n        this.initPictureViewer();\\r\\n\\r\\n    },\\r\\n    created: function () {\\r\\n\\r\\n    },\\r\\n    methods: {\\r\\n        initPictureViewer: function () {\\r\\n            if(this.items.length==1)\\r\\n               return;\\r\\n            var $images = $('.picImgContainer');\\r\\n            var options = {\\r\\n                // inline: true,\\r\\n                url: 'data-original',\\r\\n                build: function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                built: function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                show: function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                shown: function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                hide: function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                hidden: function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                view: function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                viewed: function (e) {\\r\\n                    console.log(e.type);\\r\\n                }\\r\\n            };\\r\\n            $images.on({\\r\\n                'build.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                'built.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                'show.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                'shown.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                'hide.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                'hidden.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                'view.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                },\\r\\n                'viewed.viewer': function (e) {\\r\\n                    console.log(e.type);\\r\\n                }\\r\\n            }).viewer(options);\\r\\n\\r\\n            $images.elastislide();\\r\\n\\r\\n        }\\r\\n    }\\r\\n}\\r\\n</script>\\r\\n<style>\\r\\nul.picImgContainer {\\r\\n    margin: 0;\\r\\n    padding: 0;\\r\\n    list-style: none;\\r\\n}\\r\\n\\r\\nul.picImgContainer li {\\r\\n   /* float: left;*/\\r\\n    margin: 0 -1px -1px 0;\\r\\n    border: 1px solid transparent;\\r\\n    overflow: hidden;\\r\\n}\\r\\n\\r\\n\\r\\nul.picImgContainer li img {\\r\\n    width: 100%;\\r\\n}\\r\\n</style>\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50cy9EYXRhUmVuZGVyL3Brcy5pbWFnZS52dWU/ZTY3NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLCtDQUFnRCxrQkFBa0IsbUJBQW1CLHlCQUF5QixHQUFHLHlCQUF5QixzQkFBc0IsZ0NBQWdDLHNDQUFzQyx5QkFBeUIsR0FBRyw2QkFBNkIsb0JBQW9CLEdBQUcsWUFBWSxzR0FBc0csTUFBTSxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssVUFBVSw2SUFBNkksZ0JBQWdCLG1SQUFtUixzQ0FBc0Msb0JBQW9CLGdCQUFnQixnQkFBZ0IsWUFBWSxpREFBaUQsNkJBQTZCLHlCQUF5Qiw2QkFBNkIscUJBQXFCLDZCQUE2QixzQkFBc0IsNkJBQTZCLFNBQVMsb0JBQW9CLHVCQUF1Qiw0Q0FBNEMsWUFBWSxpQkFBaUIscUJBQXFCLG9CQUFvQix1Q0FBdUMsMkpBQTJKLGlDQUFpQyxnQkFBZ0IsZ0NBQWdDLDRFQUE0RSxhQUFhLFNBQVMsK0JBQStCLHFDQUFxQyxhQUFhLCtCQUErQixhQUFhLG1CQUFtQiw0Q0FBNEMsa0VBQWtFLG9EQUFvRCwrQkFBK0Isc0hBQXNILDRDQUE0QyxxQkFBcUIsMENBQTBDLDRDQUE0QyxxQkFBcUIseUNBQXlDLDRDQUE0QyxxQkFBcUIsMENBQTBDLDRDQUE0QyxxQkFBcUIseUNBQXlDLDRDQUE0QyxxQkFBcUIsMkNBQTJDLDRDQUE0QyxxQkFBcUIseUNBQXlDLDRDQUE0QyxxQkFBcUIsMkNBQTJDLDRDQUE0QyxxQkFBcUIsa0JBQWtCLDRCQUE0QixrREFBa0QsNENBQTRDLHFCQUFxQixtREFBbUQsNENBQTRDLHFCQUFxQixrREFBa0QsNENBQTRDLHFCQUFxQixtREFBbUQsNENBQTRDLHFCQUFxQixrREFBa0QsNENBQTRDLHFCQUFxQixvREFBb0QsNENBQTRDLHFCQUFxQixrREFBa0QsNENBQTRDLHFCQUFxQixvREFBb0QsNENBQTRDLHFCQUFxQixpQkFBaUIsa0JBQWtCLDBDQUEwQyxpQkFBaUIsU0FBUyxLQUFLLGdEQUFnRCxrQkFBa0IsbUJBQW1CLHlCQUF5QixLQUFLLCtCQUErQixzQkFBc0IsZ0NBQWdDLHNDQUFzQyx5QkFBeUIsS0FBSyx1Q0FBdUMsb0JBQW9CLEtBQUsseUNBQXlDOztBQUVsOUkiLCJmaWxlIjoiMjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxudWwucGljSW1nQ29udGFpbmVyIHtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG51bC5waWNJbWdDb250YWluZXIgbGkge1xcclxcbiAgIC8qIGZsb2F0OiBsZWZ0OyovXFxyXFxuICAgIG1hcmdpbjogMCAtMXB4IC0xcHggMDtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbnVsLnBpY0ltZ0NvbnRhaW5lciBsaSBpbWcge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9Db21wb25lbnRzL0RhdGFSZW5kZXIvcGtzLmltYWdlLnZ1ZT8wNDEzNjFkZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBZ0hBO0lBQ0EsVUFBQTtJQUNBLFdBQUE7SUFDQSxpQkFBQTtDQUNBO0FBRUE7R0FDQSxpQkFBQTtJQUNBLHNCQUFBO0lBQ0EsOEJBQUE7SUFDQSxpQkFBQTtDQUNBO0FBR0E7SUFDQSxZQUFBO0NBQ0FcIixcImZpbGVcIjpcInBrcy5pbWFnZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgICA8dWwgOmlkPVxcXCJpZFxcXCIgY2xhc3M9XFxcInBpY0ltZ0NvbnRhaW5lciBjYXJvdXNlbCBjbGVhcmZpeFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7aGVpZ2h0OnVsaGVpZ2h0fVxcXCI+XFxyXFxuICAgICAgICA8bGkgdi1mb3I9XFxcIml0ZW0gaW4gaXRlbXNcXFwiPlxcclxcbiAgICAgICAgICAgPGltZyB2LWJpbmQ6ZGF0YS1vcmlnaW5hbD1cXFwiaXRlbS5zcmNcXFwiIHYtYmluZDpzcmM9XFxcIml0ZW0udGh1bWJuYWlsP2l0ZW0udGh1bWJuYWlsOml0ZW0uc3JjXFxcIiB2LWJpbmQ6YWx0PVxcXCJpdGVtLnRpdGxlXFxcIj5cXHJcXG4gICAgICAgIDwvbGk+XFxyXFxuICAgIDwvdWw+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0Plxcclxcblxcclxcbi8vcmVxdWlyZSgnLi9saWIvdmlld2VyLm1pbi5qcycpO1xcclxcbi8vcmVxdWlyZSgnLi9saWIvdmlld2VyLm1pbi5jc3MnKTtcXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHByb3BzOiB7XFxyXFxuICAgICAgICBpZDp7dHlwZTpTdHJpbmd9LFxcclxcbiAgICAgICAgaXRlbXM6IEFycmF5LFxcclxcbiAgICAgICAgaXRlbXdpZHRoOnsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAxNjUgfSxcXHJcXG4gICAgICAgIGl0ZW1oZWlnaHQ6eyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDE0MCB9LFxcclxcbiAgICAgICAgd2lkdGg6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiA1MDAgfSxcXHJcXG4gICAgICAgIGhlaWdodDogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDIwMCB9XFxyXFxuICAgIH0sXFxyXFxuICAgIC8vIGRhdGEoKSB7XFxyXFxuICAgIC8vICAgICByZXR1cm4ge1xcclxcbiAgICAvLyAgICAgICAgIGl0ZW1zOiBbXVxcclxcbiAgICAvLyAgICAgfVxcclxcbiAgICAvLyB9LFxcclxcbiAgICB3YXRjaDoge1xcclxcbiAgICAgICAgXFxyXFxuICAgIH0sXFxyXFxuICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICAvLyBpdGVtd2lkdGg6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIC8vICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPiAwICYmIHRoaXMud2lkdGgpXFxyXFxuICAgICAgICAvLyAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh0aGlzLndpZHRoIC8gdGhpcy5pdGVtcy5sZW5ndGgpICogMTAwKSAvIDEwMCArIFxcXCJweFxcXCI7XFxyXFxuICAgICAgICAvLyAgICAgcmV0dXJuICcxMDAlJztcXHJcXG4gICAgICAgIC8vIH1cXHJcXG4gICAgICAgIHVsaGVpZ2h0OmZ1bmN0aW9uKCl7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoPT0xP1xcXCIxMDAlXFxcIjoodGhpcy5pdGVtaGVpZ2h0KydweCcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICB0aGlzLmluaXRQaWN0dXJlVmlld2VyKCk7XFxyXFxuXFxyXFxuICAgIH0sXFxyXFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHtcXHJcXG5cXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcbiAgICAgICAgaW5pdFBpY3R1cmVWaWV3ZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICBpZih0aGlzLml0ZW1zLmxlbmd0aD09MSlcXHJcXG4gICAgICAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICAgICAgdmFyICRpbWFnZXMgPSAkKCcucGljSW1nQ29udGFpbmVyJyk7XFxyXFxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIGlubGluZTogdHJ1ZSxcXHJcXG4gICAgICAgICAgICAgICAgdXJsOiAnZGF0YS1vcmlnaW5hbCcsXFxyXFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgYnVpbHQ6IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xcclxcbiAgICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgICAgICBzaG93OiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgc2hvd246IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xcclxcbiAgICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgaGlkZGVuOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgdmlldzogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgIHZpZXdlZDogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9O1xcclxcbiAgICAgICAgICAgICRpbWFnZXMub24oe1xcclxcbiAgICAgICAgICAgICAgICAnYnVpbGQudmlld2VyJzogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgICdidWlsdC52aWV3ZXInOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgJ3Nob3cudmlld2VyJzogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgICdzaG93bi52aWV3ZXInOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50eXBlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgJ2hpZGUudmlld2VyJzogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgICdoaWRkZW4udmlld2VyJzogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgICd2aWV3LnZpZXdlcic6IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xcclxcbiAgICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgICAgICAndmlld2VkLnZpZXdlcic6IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnR5cGUpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSkudmlld2VyKG9wdGlvbnMpO1xcclxcblxcclxcbiAgICAgICAgICAgICRpbWFnZXMuZWxhc3Rpc2xpZGUoKTtcXHJcXG5cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxudWwucGljSW1nQ29udGFpbmVyIHtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBsaXN0LXN0eWxlOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG51bC5waWNJbWdDb250YWluZXIgbGkge1xcclxcbiAgIC8qIGZsb2F0OiBsZWZ0OyovXFxyXFxuICAgIG1hcmdpbjogMCAtMXB4IC0xcHggMDtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxufVxcclxcblxcclxcblxcclxcbnVsLnBpY0ltZ0NvbnRhaW5lciBsaSBpbWcge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG59XFxyXFxuPC9zdHlsZT5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZTA3Zjc2ZjJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL0NvbXBvbmVudHMvRGF0YVJlbmRlci9wa3MuaW1hZ2UudnVlXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-filter-card\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row jurassic-filter5th jurassic-filter-bottom\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-1 jurassic-filter-title\"\n  }, [_vm._v(\"\\n            年度\\n        \")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-11  jurassic-pointer\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row \"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-1  jurassic-click\"\n  }, [_c('span', {\n    staticClass: \"glyphicon glyphicon-menu-left\",\n    on: {\n      \"click\": _vm.onleft\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-8 fiveYear fiveYears\"\n  }, _vm._l((_vm.fiveYear.years), function(year) {\n    return _c('span', {\n      key: year,\n      on: {\n        \"click\": function($event) {\n          _vm.onClick(year, $event)\n        }\n      }\n    }, [_vm._v(_vm._s(year))])\n  })), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-1  jurassic-click\"\n  }, [_c('span', {\n    staticClass: \"glyphicon glyphicon-menu-right\",\n    on: {\n      \"click\": _vm.onright\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-2\"\n  }, [_c('span', {\n    staticClass: \"jurassic-filter-title jurassic-filter-fivecolor\"\n  }, [_vm._v(_vm._s(_vm.fiveYear.name))])])])])]), _vm._v(\" \"), _vm._l((_vm.filters), function(filter, index) {\n    return _c('div', {\n      key: 'filter' + index,\n      staticClass: \"jurassic-row filter  jurassic-filter5th  jurassic-filter-bottom\"\n    }, [_c('div', {\n      staticClass: \"jurassic-col-1  jurassic-filter-title\"\n    }, [_c('span', [_vm._v(_vm._s(filter.name))])]), _vm._v(\" \"), _c('div', {\n      staticClass: \"jurassic-col-11  fiveYear  jurassic-pointer\"\n    }, [_c('span', {\n      on: {\n        \"click\": function($event) {\n          _vm.unselect(filter.name, $event)\n        }\n      }\n    }, [_vm._v(\"不限\")]), _vm._v(\" \"), _vm._l((filter.options), function(option) {\n      return _c('span', {\n        key: option,\n        on: {\n          \"click\": function($event) {\n            _vm.onfilterclick(option, filter.name, $event)\n          }\n        }\n      }, [_vm._v(_vm._s(option))])\n    })], 2)])\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-row  jurassic-filter5th\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-1  jurassic-filter-title\"\n  }, [_c('span', [_vm._v(_vm._s(_vm.bo.name))])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-11 jurassic-pointer\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-1  jurassic-click\"\n  }, [_c('span', {\n    staticClass: \"glyphicon glyphicon-menu-left\",\n    on: {\n      \"click\": _vm.onboleft\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-8 fiveYear selectbo\"\n  }, [_vm._l((_vm.showbo), function(bo) {\n    return _c('span', {\n      key: bo,\n      on: {\n        \"click\": function($event) {\n          _vm.onboClick(bo)\n        }\n      }\n    }, [_vm._v(_vm._s(bo))])\n  }), _vm._v(\"\\n                     \\n                \")], 2), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-1  jurassic-click\"\n  }, [_c('span', {\n    staticClass: \"glyphicon glyphicon-menu-right\",\n    on: {\n      \"click\": _vm.onboright\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-1\"\n  }, [_c('span', [_vm._v(_vm._s(_vm.index) + \"/\" + _vm._s(_vm.total))])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-1  jurassic-click\"\n  }, [_c('span', {\n    staticClass: \"glyphicon glyphicon-search \",\n    on: {\n      \"click\": _vm.onsearch\n    }\n  })])])])])], 2)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-00866a0d\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5jb21wbGV4RmlsdHJhdGlvbi52dWU/ZDM0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNDguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1maWx0ZXItY2FyZFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXJvdyBqdXJhc3NpYy1maWx0ZXI1dGgganVyYXNzaWMtZmlsdGVyLWJvdHRvbVwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xIGp1cmFzc2ljLWZpbHRlci10aXRsZVwiXG4gIH0sIFtfdm0uX3YoXCJcXG4gICAgICAgICAgICDlubTluqZcXG4gICAgICAgIFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xMSAganVyYXNzaWMtcG9pbnRlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXJvdyBcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMSAganVyYXNzaWMtY2xpY2tcIlxuICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZ2x5cGhpY29uIGdseXBoaWNvbi1tZW51LWxlZnRcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0ub25sZWZ0XG4gICAgfVxuICB9KV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC04IGZpdmVZZWFyIGZpdmVZZWFyc1wiXG4gIH0sIF92bS5fbCgoX3ZtLmZpdmVZZWFyLnllYXJzKSwgZnVuY3Rpb24oeWVhcikge1xuICAgIHJldHVybiBfYygnc3BhbicsIHtcbiAgICAgIGtleTogeWVhcixcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLm9uQ2xpY2soeWVhciwgJGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MoeWVhcikpXSlcbiAgfSkpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1jbGlja1wiXG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJnbHlwaGljb24gZ2x5cGhpY29uLW1lbnUtcmlnaHRcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0ub25yaWdodFxuICAgIH1cbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMlwiXG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1maWx0ZXItdGl0bGUganVyYXNzaWMtZmlsdGVyLWZpdmVjb2xvclwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5maXZlWWVhci5uYW1lKSldKV0pXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX2woKF92bS5maWx0ZXJzKSwgZnVuY3Rpb24oZmlsdGVyLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAga2V5OiAnZmlsdGVyJyArIGluZGV4LFxuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtcm93IGZpbHRlciAganVyYXNzaWMtZmlsdGVyNXRoICBqdXJhc3NpYy1maWx0ZXItYm90dG9tXCJcbiAgICB9LCBbX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1maWx0ZXItdGl0bGVcIlxuICAgIH0sIFtfYygnc3BhbicsIFtfdm0uX3YoX3ZtLl9zKGZpbHRlci5uYW1lKSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY29sLTExICBmaXZlWWVhciAganVyYXNzaWMtcG9pbnRlclwiXG4gICAgfSwgW19jKCdzcGFuJywge1xuICAgICAgb246IHtcbiAgICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICBfdm0udW5zZWxlY3QoZmlsdGVyLm5hbWUsICRldmVudClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCLkuI3pmZBcIildKSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9sKChmaWx0ZXIub3B0aW9ucyksIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgcmV0dXJuIF9jKCdzcGFuJywge1xuICAgICAgICBrZXk6IG9wdGlvbixcbiAgICAgICAgb246IHtcbiAgICAgICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgX3ZtLm9uZmlsdGVyY2xpY2sob3B0aW9uLCBmaWx0ZXIubmFtZSwgJGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgW192bS5fdihfdm0uX3Mob3B0aW9uKSldKVxuICAgIH0pXSwgMildKVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1yb3cgIGp1cmFzc2ljLWZpbHRlcjV0aFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1maWx0ZXItdGl0bGVcIlxuICB9LCBbX2MoJ3NwYW4nLCBbX3ZtLl92KF92bS5fcyhfdm0uYm8ubmFtZSkpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMTEganVyYXNzaWMtcG9pbnRlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXJvd1wiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1jbGlja1wiXG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJnbHlwaGljb24gZ2x5cGhpY29uLW1lbnUtbGVmdFwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5vbmJvbGVmdFxuICAgIH1cbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtOCBmaXZlWWVhciBzZWxlY3Rib1wiXG4gIH0sIFtfdm0uX2woKF92bS5zaG93Ym8pLCBmdW5jdGlvbihibykge1xuICAgIHJldHVybiBfYygnc3BhbicsIHtcbiAgICAgIGtleTogYm8sXG4gICAgICBvbjoge1xuICAgICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIF92bS5vbmJvQ2xpY2soYm8pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyhibykpXSlcbiAgfSksIF92bS5fdihcIlxcbiAgICAgICAgICAgICAgICAgICAgwqBcXG4gICAgICAgICAgICAgICAgXCIpXSwgMiksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY29sLTEgIGp1cmFzc2ljLWNsaWNrXCJcbiAgfSwgW19jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1yaWdodFwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5vbmJvcmlnaHRcbiAgICB9XG4gIH0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY29sLTFcIlxuICB9LCBbX2MoJ3NwYW4nLCBbX3ZtLl92KF92bS5fcyhfdm0uaW5kZXgpICsgXCIvXCIgKyBfdm0uX3MoX3ZtLnRvdGFsKSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xICBqdXJhc3NpYy1jbGlja1wiXG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJnbHlwaGljb24gZ2x5cGhpY29uLXNlYXJjaCBcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0ub25zZWFyY2hcbiAgICB9XG4gIH0pXSldKV0pXSldLCAyKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0wMDg2NmEwZFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTAwODY2YTBkXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5jb21wbGV4RmlsdHJhdGlvbi52dWVcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-panel\"\n  }, [_c('div', {\n    staticClass: \"jurassic-panel-header\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-9\"\n  }, [_c('i', {\n    class: _vm.fontclass\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"jurassic-panel-title\"\n  }, [_vm._v(_vm._s(_vm.title))])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-3 jurassic-text-right\"\n  }, [_c('span', {\n    staticClass: \"glyphicon glyphicon-menu-left\",\n    on: {\n      \"click\": _vm.onLeft\n    }\n  }), _vm._v(\" \"), _c('span', {\n    staticStyle: {\n      \"margin\": \"0 20px\"\n    }\n  }, [_vm._v(_vm._s(_vm.date))]), _vm._v(\" \"), _c('span', {\n    staticClass: \"glyphicon glyphicon-menu-right\",\n    staticStyle: {\n      \"margin-right\": \"20px\"\n    },\n    on: {\n      \"click\": _vm.onRight\n    }\n  })])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-panel-body\"\n  }, [_vm._t(\"panel\")], 2)])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-11527c0f\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbDIudnVlP2Q5MTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1wYW5lbFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsLWhlYWRlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXJvd1wiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC05XCJcbiAgfSwgW19jKCdpJywge1xuICAgIGNsYXNzOiBfdm0uZm9udGNsYXNzXG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1wYW5lbC10aXRsZVwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS50aXRsZSkpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMyBqdXJhc3NpYy10ZXh0LXJpZ2h0XCJcbiAgfSwgW19jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1sZWZ0XCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLm9uTGVmdFxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICBcIm1hcmdpblwiOiBcIjAgMjBweFwiXG4gICAgfVxuICB9LCBbX3ZtLl92KF92bS5fcyhfdm0uZGF0ZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1yaWdodFwiLFxuICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIjIwcHhcIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLm9uUmlnaHRcbiAgICB9XG4gIH0pXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsLWJvZHlcIlxuICB9LCBbX3ZtLl90KFwicGFuZWxcIildLCAyKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTExNTI3YzBmXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMTE1MjdjMGZcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnBhbmVsMi52dWVcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-search-component\"\n  }, [(_vm.showsearchbtn) ? _c('div', {\n    staticClass: \"jurassic-search-panel\"\n  }, [_c('div', {\n    staticClass: \"jurassic-search\"\n  }, [_c('div', {\n    staticClass: \"jurassic-search-interaction\"\n  }, [_c('div', {\n    staticClass: \"jurassic-search-interaction-panel\"\n  }, [_c('input', {\n    staticClass: \"jurassic-search-input\",\n    attrs: {\n      \"type\": \"text\",\n      \"placeholder\": '请输入要查询 ' + _vm.targettype + ' 的名称'\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-search-auto-complete-container\"\n  })]), _vm._v(\" \"), _c('button', {\n    staticClass: \"jurassic-search-btn\",\n    staticStyle: {\n      \"float\": \"right\"\n    },\n    on: {\n      \"click\": _vm.Searchbtnclick\n    }\n  }, [_vm._v(\"搜索\")])])]) : _vm._e(), _vm._v(\" \"), _vm._l((_vm.items), function(item, index) {\n    return _c('div', {\n      key: index,\n      staticClass: \"jurassic-search-filter\"\n    }, [_c('div', {\n      staticClass: \"jurassic-search-filter-base\"\n    }, [_c('div', {\n      staticClass: \"jurassic-row\"\n    }, [_c('div', {\n      staticClass: \"jurassic-col-2\"\n    }, [_c('span', {\n      staticClass: \"jurassic-caption\"\n    }, [_vm._v(_vm._s(item.catelog) + \" ：\")])]), _vm._v(\" \"), _c('div', {\n      staticClass: \"jurassic-col-9\"\n    }, [(item.type == 'checkbox') ? _c('label', {\n      staticClass: \"jurassic-label\"\n    }, [_c('input', {\n      staticClass: \"jurassic-checkbox-all\",\n      attrs: {\n        \"name\": 'All' + item.catelog,\n        \"id\": 'All' + item.catelog,\n        \"type\": item.type == '' ? 'checkbox' : item.type,\n        \"value\": \"All\"\n      },\n      on: {\n        \"click\": _vm.checkboxclick\n      }\n    }), _vm._v(\" \"), _c('label', {\n      attrs: {\n        \"for\": 'All' + item.catelog\n      }\n    }, [_vm._v(\"不限\")])]) : _vm._e(), _vm._v(\" \"), _vm._l((item.list), function(name, index) {\n      return (index < _vm.shownum) ? _c('label', {\n        key: index,\n        staticClass: \"jurassic-label\"\n      }, [_c('input', {\n        staticClass: \"jurassic-checkbox\",\n        attrs: {\n          \"name\": item.catelog,\n          \"id\": name,\n          \"type\": item.type == '' ? 'checkbox' : item.type\n        },\n        domProps: {\n          \"value\": name\n        },\n        on: {\n          \"click\": _vm.checkboxclick\n        }\n      }), _vm._v(\" \"), _c('label', {\n        attrs: {\n          \"for\": name\n        }\n      }, [_vm._v(_vm._s(name))])]) : _vm._e()\n    })], 2), _vm._v(\" \"), (item.list.length > _vm.shownum) ? _c('div', {\n      staticClass: \"jurassic-col-1\"\n    }, [_c('span', {\n      staticClass: \"jurassic-label\",\n      attrs: {\n        \"id\": item.catelog\n      },\n      on: {\n        \"click\": function($event) {\n          _vm.onshowmoreclick(item.catelog)\n        }\n      }\n    }, [_vm._v(\"更多\\n                            \"), _c('i', {\n      class: _vm.showmoreclassbottom\n    })])]) : _vm._e()])]), _vm._v(\" \"), (item.list.length > _vm.shownum) ? _c('div', {\n      staticClass: \"jurassic-search-filter-more\",\n      staticStyle: {\n        \"display\": \"none\"\n      },\n      attrs: {\n        \"id\": item.catelog\n      }\n    }, [_c('div', {\n      staticClass: \"jurassic-row\"\n    }, [_vm._m(0, true), _vm._v(\" \"), _c('div', {\n      staticClass: \"jurassic-col-10\"\n    }, _vm._l((item.list), function(name, index) {\n      return (index > _vm.shownum - 1) ? _c('label', {\n        key: index,\n        staticClass: \"jurassic-label\"\n      }, [_c('input', {\n        staticClass: \"jurassic-checkbox\",\n        attrs: {\n          \"name\": item.catelog,\n          \"id\": name,\n          \"type\": item.type == '' ? 'checkbox' : item.type\n        },\n        domProps: {\n          \"value\": name\n        },\n        on: {\n          \"click\": _vm.checkboxclick\n        }\n      }), _vm._v(\" \"), _c('label', {\n        attrs: {\n          \"for\": name\n        }\n      }, [_vm._v(_vm._s(name))])]) : _vm._e()\n    }))])]) : _vm._e()])\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-search-display\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-9\"\n  }, [_c('span', {\n    staticClass: \"jurassic-label\"\n  }, [_vm._v(\"已选条件:\")]), _vm._v(\" \"), _vm._l((_vm.selecteditems), function(item, index) {\n    return (item.value) ? _c('div', {\n      key: index,\n      staticClass: \"jurassic-search-filter-info\"\n    }, [_c('span', {\n      attrs: {\n        \"id\": item.catelog\n      }\n    }, [_vm._v(_vm._s(item.value))]), _vm._v(\" \"), _c('span', {\n      staticClass: \"glyphicon glyphicon-remove\",\n      on: {\n        \"click\": _vm.removeclick\n      }\n    })]) : _vm._e()\n  })], 2), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-1\"\n  }, [_c('span', {\n    staticClass: \"jurassic-search-display-clear\",\n    on: {\n      \"click\": _vm.clearall\n    }\n  }, [_vm._v(\"【清空全部】\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-1\"\n  }, [_c('button', {\n    staticClass: \"jurassic-search-btn\",\n    on: {\n      \"click\": _vm.onqueryclick\n    }\n  }, [_vm._v(\"查询\")])]), _vm._v(\" \"), (_vm.resultnum > 0) ? _c('div', {\n    staticClass: \"jurassic-col-1\"\n  }, [_c('span', {\n    staticClass: \"jurassic-search-result\"\n  }, [_c('span', [_vm._v(_vm._s(_vm.resultnum))]), _vm._v(\" \"), _c('span', [_vm._v(\"条结果\")])])]) : _vm._e()])])], 2)])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-col-2\"\n  }, [_c('span', {\n    staticClass: \"jurassic-label jurassic-caption\",\n    staticStyle: {\n      \"visibility\": \"hidden\"\n    }\n  })])\n}]}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-116b44f7\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5maWx0ZXJsaXN0LnZ1ZT9mYWRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDLCtCQUErQixhQUFhLDBCQUEwQjtBQUN2RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1yb3dcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1zZWFyY2gtY29tcG9uZW50XCJcbiAgfSwgWyhfdm0uc2hvd3NlYXJjaGJ0bikgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNlYXJjaC1wYW5lbFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNlYXJjaFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNlYXJjaC1pbnRlcmFjdGlvblwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNlYXJjaC1pbnRlcmFjdGlvbi1wYW5lbFwiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc2VhcmNoLWlucHV0XCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogJ+ivt+i+k+WFpeimgeafpeivoiAnICsgX3ZtLnRhcmdldHR5cGUgKyAnIOeahOWQjeensCdcbiAgICB9XG4gIH0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc2VhcmNoLWF1dG8tY29tcGxldGUtY29udGFpbmVyXCJcbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1zZWFyY2gtYnRuXCIsXG4gICAgc3RhdGljU3R5bGU6IHtcbiAgICAgIFwiZmxvYXRcIjogXCJyaWdodFwiXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uU2VhcmNoYnRuY2xpY2tcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLmkJzntKJcIildKV0pXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9sKChfdm0uaXRlbXMpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAga2V5OiBpbmRleCxcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNlYXJjaC1maWx0ZXJcIlxuICAgIH0sIFtfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc2VhcmNoLWZpbHRlci1iYXNlXCJcbiAgICB9LCBbX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXJvd1wiXG4gICAgfSwgW19jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMlwiXG4gICAgfSwgW19jKCdzcGFuJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY2FwdGlvblwiXG4gICAgfSwgW192bS5fdihfdm0uX3MoaXRlbS5jYXRlbG9nKSArIFwiIO+8mlwiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtOVwiXG4gICAgfSwgWyhpdGVtLnR5cGUgPT0gJ2NoZWNrYm94JykgPyBfYygnbGFiZWwnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1sYWJlbFwiXG4gICAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNoZWNrYm94LWFsbFwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJuYW1lXCI6ICdBbGwnICsgaXRlbS5jYXRlbG9nLFxuICAgICAgICBcImlkXCI6ICdBbGwnICsgaXRlbS5jYXRlbG9nLFxuICAgICAgICBcInR5cGVcIjogaXRlbS50eXBlID09ICcnID8gJ2NoZWNrYm94JyA6IGl0ZW0udHlwZSxcbiAgICAgICAgXCJ2YWx1ZVwiOiBcIkFsbFwiXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgXCJjbGlja1wiOiBfdm0uY2hlY2tib3hjbGlja1xuICAgICAgfVxuICAgIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnbGFiZWwnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcImZvclwiOiAnQWxsJyArIGl0ZW0uY2F0ZWxvZ1xuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCLkuI3pmZBcIildKV0pIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIF92bS5fbCgoaXRlbS5saXN0KSwgZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiAoaW5kZXggPCBfdm0uc2hvd251bSkgPyBfYygnbGFiZWwnLCB7XG4gICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWxhYmVsXCJcbiAgICAgIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNoZWNrYm94XCIsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgXCJuYW1lXCI6IGl0ZW0uY2F0ZWxvZyxcbiAgICAgICAgICBcImlkXCI6IG5hbWUsXG4gICAgICAgICAgXCJ0eXBlXCI6IGl0ZW0udHlwZSA9PSAnJyA/ICdjaGVja2JveCcgOiBpdGVtLnR5cGVcbiAgICAgICAgfSxcbiAgICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgICBcInZhbHVlXCI6IG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBcImNsaWNrXCI6IF92bS5jaGVja2JveGNsaWNrXG4gICAgICAgIH1cbiAgICAgIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnbGFiZWwnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgXCJmb3JcIjogbmFtZVxuICAgICAgICB9XG4gICAgICB9LCBbX3ZtLl92KF92bS5fcyhuYW1lKSldKV0pIDogX3ZtLl9lKClcbiAgICB9KV0sIDIpLCBfdm0uX3YoXCIgXCIpLCAoaXRlbS5saXN0Lmxlbmd0aCA+IF92bS5zaG93bnVtKSA/IF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMVwiXG4gICAgfSwgW19jKCdzcGFuJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtbGFiZWxcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiaWRcIjogaXRlbS5jYXRlbG9nXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICBfdm0ub25zaG93bW9yZWNsaWNrKGl0ZW0uY2F0ZWxvZylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCLmm7TlpJpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIpLCBfYygnaScsIHtcbiAgICAgIGNsYXNzOiBfdm0uc2hvd21vcmVjbGFzc2JvdHRvbVxuICAgIH0pXSldKSA6IF92bS5fZSgpXSldKSwgX3ZtLl92KFwiIFwiKSwgKGl0ZW0ubGlzdC5sZW5ndGggPiBfdm0uc2hvd251bSkgPyBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc2VhcmNoLWZpbHRlci1tb3JlXCIsXG4gICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCJcbiAgICAgIH0sXG4gICAgICBhdHRyczoge1xuICAgICAgICBcImlkXCI6IGl0ZW0uY2F0ZWxvZ1xuICAgICAgfVxuICAgIH0sIFtfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtcm93XCJcbiAgICB9LCBbX3ZtLl9tKDAsIHRydWUpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY29sLTEwXCJcbiAgICB9LCBfdm0uX2woKGl0ZW0ubGlzdCksIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gKGluZGV4ID4gX3ZtLnNob3dudW0gLSAxKSA/IF9jKCdsYWJlbCcsIHtcbiAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtbGFiZWxcIlxuICAgICAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY2hlY2tib3hcIixcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBcIm5hbWVcIjogaXRlbS5jYXRlbG9nLFxuICAgICAgICAgIFwiaWRcIjogbmFtZSxcbiAgICAgICAgICBcInR5cGVcIjogaXRlbS50eXBlID09ICcnID8gJ2NoZWNrYm94JyA6IGl0ZW0udHlwZVxuICAgICAgICB9LFxuICAgICAgICBkb21Qcm9wczoge1xuICAgICAgICAgIFwidmFsdWVcIjogbmFtZVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIFwiY2xpY2tcIjogX3ZtLmNoZWNrYm94Y2xpY2tcbiAgICAgICAgfVxuICAgICAgfSksIF92bS5fdihcIiBcIiksIF9jKCdsYWJlbCcsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBcImZvclwiOiBuYW1lXG4gICAgICAgIH1cbiAgICAgIH0sIFtfdm0uX3YoX3ZtLl9zKG5hbWUpKV0pXSkgOiBfdm0uX2UoKVxuICAgIH0pKV0pXSkgOiBfdm0uX2UoKV0pXG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNlYXJjaC1kaXNwbGF5XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtcm93XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY29sLTlcIlxuICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtbGFiZWxcIlxuICB9LCBbX3ZtLl92KFwi5bey6YCJ5p2h5Lu2OlwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX2woKF92bS5zZWxlY3RlZGl0ZW1zKSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gKGl0ZW0udmFsdWUpID8gX2MoJ2RpdicsIHtcbiAgICAgIGtleTogaW5kZXgsXG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1zZWFyY2gtZmlsdGVyLWluZm9cIlxuICAgIH0sIFtfYygnc3BhbicsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiaWRcIjogaXRlbS5jYXRlbG9nXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MoaXRlbS52YWx1ZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcIixcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogX3ZtLnJlbW92ZWNsaWNrXG4gICAgICB9XG4gICAgfSldKSA6IF92bS5fZSgpXG4gIH0pXSwgMiksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY29sLTFcIlxuICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc2VhcmNoLWRpc3BsYXktY2xlYXJcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uY2xlYXJhbGxcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLjgJDmuIXnqbrlhajpg6jjgJFcIildKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0xXCJcbiAgfSwgW19jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc2VhcmNoLWJ0blwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5vbnF1ZXJ5Y2xpY2tcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLmn6Xor6JcIildKV0pLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLnJlc3VsdG51bSA+IDApID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMVwiXG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1zZWFyY2gtcmVzdWx0XCJcbiAgfSwgW19jKCdzcGFuJywgW192bS5fdihfdm0uX3MoX3ZtLnJlc3VsdG51bSkpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywgW192bS5fdihcIuadoee7k+aenFwiKV0pXSldKSA6IF92bS5fZSgpXSldKV0sIDIpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0yXCJcbiAgfSwgW19jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWxhYmVsIGp1cmFzc2ljLWNhcHRpb25cIixcbiAgICBzdGF0aWNTdHlsZToge1xuICAgICAgXCJ2aXNpYmlsaXR5XCI6IFwiaGlkZGVuXCJcbiAgICB9XG4gIH0pXSlcbn1dfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0xMTZiNDRmN1wiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTExNmI0NGY3XCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5maWx0ZXJsaXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('panel', {\n    attrs: {\n      \"title\": _vm.title,\n      \"onshowmore\": _vm.onShowMore,\n      \"show\": _vm.show,\n      \"fontclass\": _vm.fontclass\n    }\n  }, [_c('list', {\n    attrs: {\n      \"items\": _vm.data,\n      \"map\": _vm.map,\n      \"onclick\": _vm.onClick\n    },\n    slot: \"panel\"\n  })], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-1363f15f\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zaW5nbGVUaXRsZS52dWU/NDU4YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3BhbmVsJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInRpdGxlXCI6IF92bS50aXRsZSxcbiAgICAgIFwib25zaG93bW9yZVwiOiBfdm0ub25TaG93TW9yZSxcbiAgICAgIFwic2hvd1wiOiBfdm0uc2hvdyxcbiAgICAgIFwiZm9udGNsYXNzXCI6IF92bS5mb250Y2xhc3NcbiAgICB9XG4gIH0sIFtfYygnbGlzdCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJpdGVtc1wiOiBfdm0uZGF0YSxcbiAgICAgIFwibWFwXCI6IF92bS5tYXAsXG4gICAgICBcIm9uY2xpY2tcIjogX3ZtLm9uQ2xpY2tcbiAgICB9LFxuICAgIHNsb3Q6IFwicGFuZWxcIlxuICB9KV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTEzNjNmMTVmXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMTM2M2YxNWZcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnNpbmdsZVRpdGxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-tab\"\n  }, [_c('div', {\n    staticClass: \"jurassic-tab-header\"\n  }, [_vm._l((_vm.titles), function(title, index) {\n    return _c('div', {\n      key: title,\n      staticClass: \"jurassic-tab-btn\",\n      attrs: {\n        \"data-anchor\": 'jrs' + index\n      }\n    }, [_vm._v(_vm._s(title))])\n  }), _vm._v(\" \"), (_vm.showmore) ? _c('div', {\n    staticStyle: {\n      \"text-align\": \"right\",\n      \"position\": \"relative\",\n      \"float\": \"right\"\n    }\n  }, [_c('a', {\n    staticClass: \"jurassic-panel-more\",\n    on: {\n      \"click\": _vm.onShowMore\n    }\n  }, [_vm._v(\"+MORE\")])]) : _vm._e()], 2), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-tab-body\"\n  }, _vm._l((_vm.titles), function(title, index) {\n    return _c('div', {\n      key: title,\n      staticClass: \"jurassic-tab-container\",\n      attrs: {\n        \"data-anchor\": 'jrs' + index\n      }\n    }, [_vm._t(title)], 2)\n  }))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-15726f1f\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy50YWJzLnZ1ZT9mNmYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtdGFiXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtdGFiLWhlYWRlclwiXG4gIH0sIFtfdm0uX2woKF92bS50aXRsZXMpLCBmdW5jdGlvbih0aXRsZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICAgIGtleTogdGl0bGUsXG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy10YWItYnRuXCIsXG4gICAgICBhdHRyczoge1xuICAgICAgICBcImRhdGEtYW5jaG9yXCI6ICdqcnMnICsgaW5kZXhcbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyh0aXRsZSkpXSlcbiAgfSksIF92bS5fdihcIiBcIiksIChfdm0uc2hvd21vcmUpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNTdHlsZToge1xuICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwicmlnaHRcIixcbiAgICAgIFwicG9zaXRpb25cIjogXCJyZWxhdGl2ZVwiLFxuICAgICAgXCJmbG9hdFwiOiBcInJpZ2h0XCJcbiAgICB9XG4gIH0sIFtfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1wYW5lbC1tb3JlXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLm9uU2hvd01vcmVcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCIrTU9SRVwiKV0pXSkgOiBfdm0uX2UoKV0sIDIpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXRhYi1ib2R5XCJcbiAgfSwgX3ZtLl9sKChfdm0udGl0bGVzKSwgZnVuY3Rpb24odGl0bGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgICBrZXk6IHRpdGxlLFxuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtdGFiLWNvbnRhaW5lclwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJkYXRhLWFuY2hvclwiOiAnanJzJyArIGluZGV4XG4gICAgICB9XG4gICAgfSwgW192bS5fdCh0aXRsZSldLCAyKVxuICB9KSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0xNTcyNmYxZlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTE1NzI2ZjFmXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy50YWJzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('ul', _vm._l((_vm.data), function(item, index) {\n    return _c('li', {\n      key: 'key' + index,\n      staticClass: \"jurassic-listbox\"\n    }, [_c('div', {\n      staticClass: \"jurassic-listimg\",\n      on: {\n        \"click\": function($event) {\n          _vm.onClick(item[_vm.map['param']])\n        }\n      }\n    }, [_c('img', {\n      attrs: {\n        \"src\": item[_vm.map['top']],\n        \"alt\": item[_vm.map['bottom']]\n      }\n    })]), _vm._v(\" \"), _c('div', {\n      staticClass: \"jurassic-iteminfo\"\n    }, [_c('p', [_vm._v(_vm._s(item[_vm.map['bottom']]))])])])\n  }))\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-1768a850\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5pbWdsaXN0LnZ1ZT83Mjc2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCd1bCcsIF92bS5fbCgoX3ZtLmRhdGEpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnbGknLCB7XG4gICAgICBrZXk6ICdrZXknICsgaW5kZXgsXG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1saXN0Ym94XCJcbiAgICB9LCBbX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWxpc3RpbWdcIixcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLm9uQ2xpY2soaXRlbVtfdm0ubWFwWydwYXJhbSddXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygnaW1nJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJzcmNcIjogaXRlbVtfdm0ubWFwWyd0b3AnXV0sXG4gICAgICAgIFwiYWx0XCI6IGl0ZW1bX3ZtLm1hcFsnYm90dG9tJ11dXG4gICAgICB9XG4gICAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWl0ZW1pbmZvXCJcbiAgICB9LCBbX2MoJ3AnLCBbX3ZtLl92KF92bS5fcyhpdGVtW192bS5tYXBbJ2JvdHRvbSddXSkpXSldKV0pXG4gIH0pKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0xNzY4YTg1MFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTE3NjhhODUwXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5pbWdsaXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-tab\"\n  }, [_c('div', {\n    staticClass: \"jurassic-tab-header\"\n  }, _vm._l((_vm.titles), function(title, index) {\n    return _c('div', {\n      key: title,\n      staticClass: \"jurassic-tab-btn\",\n      attrs: {\n        \"data-anchor\": 'jrs' + index\n      }\n    }, [_vm._v(_vm._s(title))])\n  })), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-tab-body\"\n  }, _vm._l((_vm.titles), function(title, index) {\n    return _c('div', {\n      key: title,\n      staticClass: \"jurassic-tab-container\",\n      attrs: {\n        \"data-anchor\": 'jrs' + index\n      }\n    }, [_vm._t(title)], 2)\n  }))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-27c96d90\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5jdGFicy52dWU/MWQyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy10YWJcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy10YWItaGVhZGVyXCJcbiAgfSwgX3ZtLl9sKChfdm0udGl0bGVzKSwgZnVuY3Rpb24odGl0bGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgICBrZXk6IHRpdGxlLFxuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtdGFiLWJ0blwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJkYXRhLWFuY2hvclwiOiAnanJzJyArIGluZGV4XG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3ModGl0bGUpKV0pXG4gIH0pKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy10YWItYm9keVwiXG4gIH0sIF92bS5fbCgoX3ZtLnRpdGxlcyksIGZ1bmN0aW9uKHRpdGxlLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAga2V5OiB0aXRsZSxcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXRhYi1jb250YWluZXJcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiZGF0YS1hbmNob3JcIjogJ2pycycgKyBpbmRleFxuICAgICAgfVxuICAgIH0sIFtfdm0uX3QodGl0bGUpXSwgMilcbiAgfSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMjdjOTZkOTBcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yN2M5NmQ5MFwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MuY3RhYnMudnVlXG4vLyBtb2R1bGUgaWQgPSAyNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('table', {\n    staticClass: \"jurassic-tableList\"\n  }, [_c('tbody', _vm._l((_vm.items), function(item) {\n    return _c('tr', {\n      staticStyle: {\n        \"background\": \"#fff !important\"\n      }\n    }, _vm._l((item), function(sitem) {\n      return _c('td', [_c('a', {\n        attrs: {\n          \"href\": \"#\"\n        },\n        on: {\n          \"click\": function($event) {\n            _vm.itemClick(sitem)\n          }\n        }\n      }, [_vm._v(_vm._s(sitem.name) + \" \")])])\n    }))\n  }))])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-2962c3c2\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0dGFibGUudnVlPzIzOTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXJvd1wiXG4gIH0sIFtfYygndGFibGUnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtdGFibGVMaXN0XCJcbiAgfSwgW19jKCd0Ym9keScsIF92bS5fbCgoX3ZtLml0ZW1zKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygndHInLCB7XG4gICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICBcImJhY2tncm91bmRcIjogXCIjZmZmICFpbXBvcnRhbnRcIlxuICAgICAgfVxuICAgIH0sIF92bS5fbCgoaXRlbSksIGZ1bmN0aW9uKHNpdGVtKSB7XG4gICAgICByZXR1cm4gX2MoJ3RkJywgW19jKCdhJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIFwiaHJlZlwiOiBcIiNcIlxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBfdm0uaXRlbUNsaWNrKHNpdGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgW192bS5fdihfdm0uX3Moc2l0ZW0ubmFtZSkgKyBcIiBcIildKV0pXG4gICAgfSkpXG4gIH0pKV0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMjk2MmMzYzJcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yOTYyYzNjMlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MubGlzdHRhYmxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('div', {\n    staticClass: \"header-top\"\n  }, [_c('ul', {\n    staticClass: \"nav navbar-nav navbar-left\"\n  }, [_c('li', {\n    staticClass: \"active\"\n  }, [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": _vm.redirectGisSys\n    }\n  }, [_vm._m(0)])]), _vm._v(\" \"), _c('li', [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": _vm.redirectSysMgr\n    }\n  }, [_vm._m(1)])])]), _vm._v(\" \"), _c('ul', {\n    staticClass: \"nav navbar-nav navbar-right\"\n  }, [_c('li', [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    }\n  }, [_c('img', {\n    staticClass: \"img-circle\",\n    attrs: {\n      \"src\": _vm.imgsource\n    }\n  }), _vm._v(\" \"), _c('span', [_vm._v(_vm._s(_vm.currentuser))])])]), _vm._v(\" \"), _c('li', {\n    staticClass: \"active\"\n  }, [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": _vm.logOut\n    }\n  }, [_c('span', [_vm._v(\"退出\")])])])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"header-name header-search\"\n  }, [_c('div', {\n    staticClass: \"logo\"\n  }, [_c('img', {\n    attrs: {\n      \"src\": _vm.logosource\n    }\n  }), _vm._v(\" \"), _vm._m(2)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"search\",\n    staticStyle: {\n      \"width\": \"500px\"\n    }\n  }, [_c('div', {\n    staticClass: \"input-group\"\n  }, [_vm._m(3), _vm._v(\" \"), _c('input', {\n    ref: \"txtSearch\",\n    staticClass: \"form-control \",\n    attrs: {\n      \"type\": \"text\",\n      \"aria-label\": \"... \",\n      \"placeholder\": \"成果、数据、知识、百科、标准\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"input-group-btn \"\n  }, [_c('button', {\n    staticClass: \"btn btn-primary \",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": _vm.searchKnowledge\n    }\n  }, [_vm._v(\"搜索\")])])])])])])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', [_c('i', {\n    staticClass: \"glyphicon glyphicon-map-marker\"\n  }), _vm._v(\"Gis系统\")])\n},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', [_c('i', {\n    staticClass: \"glyphicon glyphicon-th-large\"\n  }), _vm._v(\"系统管理\")])\n},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"companyname\"\n  }, [_c('p', {\n    staticClass: \"p1\"\n  }, [_vm._v(\"中国海油深圳分公司\")]), _vm._v(\" \"), _c('p', {\n    staticClass: \"p2\"\n  }, [_vm._v(\"智能勘探协同工作平台\")])])\n},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"input-group-btn dropdown\",\n    staticStyle: {\n      \"display\": \"none\"\n    }\n  }, [_c('button', {\n    staticClass: \"btn btn-white dropdown-toggle\",\n    attrs: {\n      \"type\": \"button\",\n      \"id\": \"select-area\",\n      \"data-toggle\": \"dropdown\",\n      \"aria-haspopup\": \"true\",\n      \"aria-expanded\": \"true\"\n    }\n  }, [_vm._v(\"站内 \"), _c('span', {\n    staticClass: \"caret\"\n  })]), _vm._v(\" \"), _c('ul', {\n    staticClass: \"dropdown-menu\",\n    attrs: {\n      \"aria-labelledby\": \"select-area\"\n    }\n  }, [_c('li', [_c('a', {\n    attrs: {\n      \"href\": \"# \"\n    }\n  }, [_vm._v(\"站内\")])]), _vm._v(\" \"), _c('li', [_c('a', {\n    attrs: {\n      \"href\": \"# \"\n    }\n  }, [_vm._v(\"搜油\")])])])])\n}]}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-327d6fb2\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9MYXlvdXQvcGtzLmhlYWRlci52dWU/YTIwOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsK0JBQStCLGFBQWEsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxhQUFhLGFBQWEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxhQUFhLGFBQWEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxhQUFhLGFBQWEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImhlYWRlci10b3BcIlxuICB9LCBbX2MoJ3VsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdiBuYXZiYXItbmF2IG5hdmJhci1sZWZ0XCJcbiAgfSwgW19jKCdsaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJhY3RpdmVcIlxuICB9LCBbX2MoJ2EnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaHJlZlwiOiBcIiNcIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLnJlZGlyZWN0R2lzU3lzXG4gICAgfVxuICB9LCBbX3ZtLl9tKDApXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2xpJywgW19jKCdhJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImhyZWZcIjogXCIjXCJcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5yZWRpcmVjdFN5c01nclxuICAgIH1cbiAgfSwgW192bS5fbSgxKV0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3VsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdiBuYXZiYXItbmF2IG5hdmJhci1yaWdodFwiXG4gIH0sIFtfYygnbGknLCBbX2MoJ2EnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaHJlZlwiOiBcIiNcIlxuICAgIH1cbiAgfSwgW19jKCdpbWcnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaW1nLWNpcmNsZVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInNyY1wiOiBfdm0uaW1nc291cmNlXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3NwYW4nLCBbX3ZtLl92KF92bS5fcyhfdm0uY3VycmVudHVzZXIpKV0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2xpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImFjdGl2ZVwiXG4gIH0sIFtfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiI1wiXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0ubG9nT3V0XG4gICAgfVxuICB9LCBbX2MoJ3NwYW4nLCBbX3ZtLl92KFwi6YCA5Ye6XCIpXSldKV0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJoZWFkZXItbmFtZSBoZWFkZXItc2VhcmNoXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibG9nb1wiXG4gIH0sIFtfYygnaW1nJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInNyY1wiOiBfdm0ubG9nb3NvdXJjZVxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF92bS5fbSgyKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInNlYXJjaFwiLFxuICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICBcIndpZHRoXCI6IFwiNTAwcHhcIlxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaW5wdXQtZ3JvdXBcIlxuICB9LCBbX3ZtLl9tKDMpLCBfdm0uX3YoXCIgXCIpLCBfYygnaW5wdXQnLCB7XG4gICAgcmVmOiBcInR4dFNlYXJjaFwiLFxuICAgIHN0YXRpY0NsYXNzOiBcImZvcm0tY29udHJvbCBcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IFwiLi4uIFwiLFxuICAgICAgXCJwbGFjZWhvbGRlclwiOiBcIuaIkOaenOOAgeaVsOaNruOAgeefpeivhuOAgeeZvuenkeOAgeagh+WHhlwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJpbnB1dC1ncm91cC1idG4gXCJcbiAgfSwgW19jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYnRuIGJ0bi1wcmltYXJ5IFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJidXR0b25cIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLnNlYXJjaEtub3dsZWRnZVxuICAgIH1cbiAgfSwgW192bS5fdihcIuaQnOe0olwiKV0pXSldKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzcGFuJywgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImdseXBoaWNvbiBnbHlwaGljb24tbWFwLW1hcmtlclwiXG4gIH0pLCBfdm0uX3YoXCJHaXPns7vnu59cIildKVxufSxmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzcGFuJywgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImdseXBoaWNvbiBnbHlwaGljb24tdGgtbGFyZ2VcIlxuICB9KSwgX3ZtLl92KFwi57O757uf566h55CGXCIpXSlcbn0sZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbXBhbnluYW1lXCJcbiAgfSwgW19jKCdwJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInAxXCJcbiAgfSwgW192bS5fdihcIuS4reWbvea1t+ayuea3seWcs+WIhuWFrOWPuFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygncCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwMlwiXG4gIH0sIFtfdm0uX3YoXCLmmbrog73li5jmjqLljY/lkIzlt6XkvZzlubPlj7BcIildKV0pXG59LGZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJpbnB1dC1ncm91cC1idG4gZHJvcGRvd25cIixcbiAgICBzdGF0aWNTdHlsZToge1xuICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiXG4gICAgfVxuICB9LCBbX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidG4gYnRuLXdoaXRlIGRyb3Bkb3duLXRvZ2dsZVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJidXR0b25cIixcbiAgICAgIFwiaWRcIjogXCJzZWxlY3QtYXJlYVwiLFxuICAgICAgXCJkYXRhLXRvZ2dsZVwiOiBcImRyb3Bkb3duXCIsXG4gICAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJ0cnVlXCIsXG4gICAgICBcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLnq5nlhoUgXCIpLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjYXJldFwiXG4gIH0pXSksIF92bS5fdihcIiBcIiksIF9jKCd1bCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJkcm9wZG93bi1tZW51XCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwic2VsZWN0LWFyZWFcIlxuICAgIH1cbiAgfSwgW19jKCdsaScsIFtfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyBcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIuermeWGhVwiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdsaScsIFtfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyBcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIuaQnOayuVwiKV0pXSldKV0pXG59XX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMzI3ZDZmYjJcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zMjdkNmZiMlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vU3JjL0NvbXBvbmVudHMvTGF5b3V0L3Brcy5oZWFkZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"pager\"\n  })\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-3c0291f2\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYWdlci52dWU/ZTFhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI1Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInBhZ2VyXCJcbiAgfSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtM2MwMjkxZjJcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zYzAyOTFmMlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MucGFnZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('table', {\n    staticStyle: {\n      \"width\": \"700px\"\n    },\n    attrs: {\n      \"border\": \"1\",\n      \"cellpadding\": \"0\",\n      \"cellspacing\": \"0\",\n      \"bordercolor\": \"#000000\"\n    }\n  }, [_vm._l((_vm.wellposition), function(pitem) {\n    return [_c('tr', [_c('th', {\n      attrs: {\n        \"width\": \"72\"\n      }\n    }, [_vm._v(\"井别\")]), _vm._v(\" \"), _c('th', {\n      attrs: {\n        \"colspan\": \"9\"\n      }\n    }, [_vm._v(_vm._s(pitem.welltype))])]), _vm._v(\" \"), _c('tr', [_c('th', [_vm._v(\"经纬度\")]), _c('th', {\n      attrs: {\n        \"width\": \"72\",\n        \"rowspan\": \"2\"\n      }\n    }, [_vm._v(\"井口\")]), _vm._v(\" \"), _c('th', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(\"东经\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(pitem.east))]), _vm._v(\" \"), _c('th', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(\"北纬\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(pitem.eastx))])]), _vm._v(\" \"), _c('tr', [_c('th', [_vm._v(\"坐标\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(\"x\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(pitem.north))]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(\"y\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(pitem.northy))])]), _vm._v(\" \"), _c('tr', [_c('th', [_vm._v(\"位置\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"9\"\n      }\n    }, [_vm._v(_vm._s(pitem.position))])]), _vm._v(\" \"), _c('tr', [_c('th', [_vm._v(\"设计井深\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"5\"\n      }\n    }, [_vm._v(_vm._s(pitem.welldepth))]), _vm._v(\" \"), _c('th', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(\"海水深度\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(pitem.seadepth))])]), _vm._v(\" \"), _c('tr', [_c('th', [_vm._v(\"完钻层位\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"9\"\n      }\n    }, [_vm._v(_vm._s(pitem.layer))])])]\n  }), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _vm._m(1), _vm._v(\" \"), _vm._l((_vm.welldata), function(item, index) {\n    return [_c('tr', [_c('td', [_vm._v(_vm._s(item.sglayer))]), _vm._v(\" \"), _c('td', [_vm._v(_vm._s(item.layer))]), _vm._v(\" \"), _c('td', [_vm._v(_vm._s(item.reflecttime) + \"　\")]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(item.depth))]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(item.traparea))]), _vm._v(\" \"), _c('td', {\n      attrs: {\n        \"colspan\": \"2\"\n      }\n    }, [_vm._v(_vm._s(item.gas))]), _vm._v(\" \"), _c('td', [_vm._v(_vm._s(item.oil))])])]\n  }), _vm._v(\" \"), _c('tr', [_c('th', [_vm._v(\"合计\")]), _vm._v(\" \"), _c('td', {\n    attrs: {\n      \"colspan\": \"6\"\n    }\n  }), _vm._v(\" \"), _c('td', {\n    attrs: {\n      \"colspan\": \"2\"\n    }\n  }, [_vm._v(_vm._s(_vm.gastotal) + \"　\")]), _vm._v(\" \"), _c('td', [_vm._v(_vm._s(_vm.oiltotal))])])], 2)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('tr', [_c('th', {\n    attrs: {\n      \"rowspan\": \"2\"\n    }\n  }, [_vm._v(\"地层层位\")]), _vm._v(\" \"), _c('th', {\n    attrs: {\n      \"rowspan\": \"2\"\n    }\n  }, [_vm._v(\"层位\")]), _vm._v(\" \"), _c('th', {\n    attrs: {\n      \"width\": \"72\",\n      \"rowspan\": \"2\"\n    }\n  }, [_vm._v(\"反射时间(ms)\")]), _vm._v(\" \"), _c('th', {\n    attrs: {\n      \"colspan\": \"2\",\n      \"rowspan\": \"2\"\n    }\n  }, [_vm._v(\"深度(TVDSS,m)\")]), _vm._v(\" \"), _c('th', {\n    attrs: {\n      \"colspan\": \"2\",\n      \"rowspan\": \"2\"\n    }\n  }, [_vm._v(\"圈闭面积(km²)\")]), _vm._v(\" \"), _c('th', {\n    attrs: {\n      \"colspan\": \"3\"\n    }\n  }, [_vm._v(\"井控资源量\")])])\n},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('tr', [_c('th', {\n    attrs: {\n      \"colspan\": \"2\"\n    }\n  }, [_vm._v(\"天然气10\"), _c('span', {\n    staticStyle: {\n      \"vertical-align\": \"super\"\n    }\n  }, [_vm._v(\"8\")]), _vm._v(\"m³\")]), _vm._v(\" \"), _c('th', {\n    attrs: {\n      \"width\": \"72\"\n    }\n  }, [_vm._v(\"石油10\"), _c('span', {\n    staticStyle: {\n      \"vertical-align\": \"super\"\n    }\n  }, [_vm._v(\"4\")]), _vm._v(\"t(m³)\")])])\n}]}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-57eb6567\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5ub3N0cnVjdHRhYmxlLnZ1ZT81M2VhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsK0JBQStCLGFBQWEsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxhQUFhLGFBQWEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3RhYmxlJywge1xuICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICBcIndpZHRoXCI6IFwiNzAwcHhcIlxuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiYm9yZGVyXCI6IFwiMVwiLFxuICAgICAgXCJjZWxscGFkZGluZ1wiOiBcIjBcIixcbiAgICAgIFwiY2VsbHNwYWNpbmdcIjogXCIwXCIsXG4gICAgICBcImJvcmRlcmNvbG9yXCI6IFwiIzAwMDAwMFwiXG4gICAgfVxuICB9LCBbX3ZtLl9sKChfdm0ud2VsbHBvc2l0aW9uKSwgZnVuY3Rpb24ocGl0ZW0pIHtcbiAgICByZXR1cm4gW19jKCd0cicsIFtfYygndGgnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcIndpZHRoXCI6IFwiNzJcIlxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCLkupXliKtcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiOVwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MocGl0ZW0ud2VsbHR5cGUpKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwi57uP57qs5bqmXCIpXSksIF9jKCd0aCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwid2lkdGhcIjogXCI3MlwiLFxuICAgICAgICBcInJvd3NwYW5cIjogXCIyXCJcbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KFwi5LqV5Y+jXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiY29sc3BhblwiOiBcIjJcIlxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCLkuJznu49cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiMlwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MocGl0ZW0uZWFzdCkpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiY29sc3BhblwiOiBcIjJcIlxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCLljJfnuqxcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiMlwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MocGl0ZW0uZWFzdHgpKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwi5Z2Q5qCHXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiY29sc3BhblwiOiBcIjJcIlxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCJ4XCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiY29sc3BhblwiOiBcIjJcIlxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKHBpdGVtLm5vcnRoKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiMlwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihcInlcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiMlwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MocGl0ZW0ubm9ydGh5KSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndHInLCBbX2MoJ3RoJywgW192bS5fdihcIuS9jee9rlwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcImNvbHNwYW5cIjogXCI5XCJcbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyhwaXRlbS5wb3NpdGlvbikpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RyJywgW19jKCd0aCcsIFtfdm0uX3YoXCLorr7orqHkupXmt7FcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiNVwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MocGl0ZW0ud2VsbGRlcHRoKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiMlwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihcIua1t+awtOa3seW6plwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcImNvbHNwYW5cIjogXCIyXCJcbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyhwaXRlbS5zZWFkZXB0aCkpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RyJywgW19jKCd0aCcsIFtfdm0uX3YoXCLlrozpkrvlsYLkvY1cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiOVwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MocGl0ZW0ubGF5ZXIpKV0pXSldXG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX20oMCksIF92bS5fdihcIiBcIiksIF92bS5fbSgxKSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9sKChfdm0ud2VsbGRhdGEpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBbX2MoJ3RyJywgW19jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKGl0ZW0uc2dsYXllcikpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKGl0ZW0ubGF5ZXIpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhpdGVtLnJlZmxlY3R0aW1lKSArIFwi44CAXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiY29sc3BhblwiOiBcIjJcIlxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKGl0ZW0uZGVwdGgpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcImNvbHNwYW5cIjogXCIyXCJcbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyhpdGVtLnRyYXBhcmVhKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb2xzcGFuXCI6IFwiMlwiXG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MoaXRlbS5nYXMpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhpdGVtLm9pbCkpXSldKV1cbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwi5ZCI6K6hXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJjb2xzcGFuXCI6IFwiNlwiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImNvbHNwYW5cIjogXCIyXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5nYXN0b3RhbCkgKyBcIuOAgFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhfdm0ub2lsdG90YWwpKV0pXSldLCAyKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCd0cicsIFtfYygndGgnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm93c3BhblwiOiBcIjJcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIuWcsOWxguWxguS9jVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwicm93c3BhblwiOiBcIjJcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIuWxguS9jVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwid2lkdGhcIjogXCI3MlwiLFxuICAgICAgXCJyb3dzcGFuXCI6IFwiMlwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwi5Y+N5bCE5pe26Ze0KG1zKVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiY29sc3BhblwiOiBcIjJcIixcbiAgICAgIFwicm93c3BhblwiOiBcIjJcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIua3seW6pihUVkRTUyxtKVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiY29sc3BhblwiOiBcIjJcIixcbiAgICAgIFwicm93c3BhblwiOiBcIjJcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIuWciOmXremdouenryhrbcKyKVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiY29sc3BhblwiOiBcIjNcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIuS6leaOp+i1hOa6kOmHj1wiKV0pXSlcbn0sZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygndHInLCBbX2MoJ3RoJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImNvbHNwYW5cIjogXCIyXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLlpKnnhLbmsJQxMFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljU3R5bGU6IHtcbiAgICAgIFwidmVydGljYWwtYWxpZ25cIjogXCJzdXBlclwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiOFwiKV0pLCBfdm0uX3YoXCJtwrNcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIndpZHRoXCI6IFwiNzJcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIuefs+ayuTEwXCIpLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNTdHlsZToge1xuICAgICAgXCJ2ZXJ0aWNhbC1hbGlnblwiOiBcInN1cGVyXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCI0XCIpXSksIF92bS5fdihcInQobcKzKVwiKV0pXSlcbn1dfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi01N2ViNjU2N1wiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTU3ZWI2NTY3XCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5ub3N0cnVjdHRhYmxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('li', {\n    staticClass: \"jurassic-list-item\"\n  }, [_c('div', {\n    staticClass: \"jurassic-news\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-10 jurassic-news-brief\"\n  }, [_c('a', {\n    staticClass: \"jurassic-news-text\",\n    on: {\n      \"click\": function($event) {\n        _vm.onClick()\n      }\n    }\n  }, [_vm._v(_vm._s(_vm.contentleft))])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-2 jurassic-text-right\"\n  }, [_c('span', {\n    staticClass: \"jurassic-news-date\"\n  }, [_vm._v(_vm._s(_vm.contentright))])])])])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-5d7b631c\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0SXRlbS52dWU/NzZiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2xpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWxpc3QtaXRlbVwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLW5ld3NcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1yb3dcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMTAganVyYXNzaWMtbmV3cy1icmllZlwiXG4gIH0sIFtfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1uZXdzLXRleHRcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLm9uQ2xpY2soKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLmNvbnRlbnRsZWZ0KSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC0yIGp1cmFzc2ljLXRleHQtcmlnaHRcIlxuICB9LCBbX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtbmV3cy1kYXRlXCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLmNvbnRlbnRyaWdodCkpXSldKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi01ZDdiNjMxY1wiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTVkN2I2MzFjXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0SXRlbS52dWVcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-panel-body\"\n  }, [_c('ul', {\n    staticClass: \"jurassic-list\"\n  }, _vm._l((_vm.data), function(item, index) {\n    return _c('listItem', {\n      key: 'key' + index,\n      attrs: {\n        \"contentleft\": item[_vm.map['left']],\n        \"url\": item[_vm.map['url']],\n        \"contentright\": item[_vm.map['right']],\n        \"onclick\": _vm.onClick\n      }\n    })\n  }))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-83d18084\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0bS52dWU/NDJkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsLWJvZHlcIlxuICB9LCBbX2MoJ3VsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWxpc3RcIlxuICB9LCBfdm0uX2woKF92bS5kYXRhKSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gX2MoJ2xpc3RJdGVtJywge1xuICAgICAga2V5OiAna2V5JyArIGluZGV4LFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb250ZW50bGVmdFwiOiBpdGVtW192bS5tYXBbJ2xlZnQnXV0sXG4gICAgICAgIFwidXJsXCI6IGl0ZW1bX3ZtLm1hcFsndXJsJ11dLFxuICAgICAgICBcImNvbnRlbnRyaWdodFwiOiBpdGVtW192bS5tYXBbJ3JpZ2h0J11dLFxuICAgICAgICBcIm9uY2xpY2tcIjogX3ZtLm9uQ2xpY2tcbiAgICAgIH1cbiAgICB9KVxuICB9KSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi04M2QxODA4NFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTgzZDE4MDg0XCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0bS52dWVcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('ul', {\n    staticClass: \"jurassic-imgviewer\"\n  }, _vm._l((_vm.data), function(item, index) {\n    return _c('li', {\n      key: 'key' + index,\n      staticClass: \"jurassic-listbox\"\n    }, [_c('div', {\n      staticClass: \"jurassic-listimg\"\n    }, [_c('img', {\n      staticClass: \"jurassic-img\",\n      style: ({\n        width: _vm.width,\n        height: _vm.height\n      }),\n      attrs: {\n        \"src\": item[_vm.map['thumbnail']] ? item[_vm.map['thumbnail']] : item[_vm.map['url']],\n        \"data-original\": item[_vm.map['url']],\n        \"alt\": \"暂无图片\"\n      }\n    })]), _vm._v(\" \"), _c('div', {\n      staticClass: \"jurassic-iteminfo jurassic-news-brief\",\n      on: {\n        \"click\": function($event) {\n          _vm.onClick(item[_vm.map['param']])\n        }\n      }\n    }, [_c('p', {\n      attrs: {\n        \"title\": item[_vm.map['bottom']]\n      }\n    }, [_vm._v(_vm._s(item[_vm.map['bottom']]))])])])\n  }))\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-8eba9d78\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5pbWd2aWV3ZXIudnVlP2MyMjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3VsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWltZ3ZpZXdlclwiXG4gIH0sIF92bS5fbCgoX3ZtLmRhdGEpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnbGknLCB7XG4gICAgICBrZXk6ICdrZXknICsgaW5kZXgsXG4gICAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1saXN0Ym94XCJcbiAgICB9LCBbX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWxpc3RpbWdcIlxuICAgIH0sIFtfYygnaW1nJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtaW1nXCIsXG4gICAgICBzdHlsZTogKHtcbiAgICAgICAgd2lkdGg6IF92bS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBfdm0uaGVpZ2h0XG4gICAgICB9KSxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwic3JjXCI6IGl0ZW1bX3ZtLm1hcFsndGh1bWJuYWlsJ11dID8gaXRlbVtfdm0ubWFwWyd0aHVtYm5haWwnXV0gOiBpdGVtW192bS5tYXBbJ3VybCddXSxcbiAgICAgICAgXCJkYXRhLW9yaWdpbmFsXCI6IGl0ZW1bX3ZtLm1hcFsndXJsJ11dLFxuICAgICAgICBcImFsdFwiOiBcIuaaguaXoOWbvueJh1wiXG4gICAgICB9XG4gICAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWl0ZW1pbmZvIGp1cmFzc2ljLW5ld3MtYnJpZWZcIixcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLm9uQ2xpY2soaXRlbVtfdm0ubWFwWydwYXJhbSddXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfYygncCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwidGl0bGVcIjogaXRlbVtfdm0ubWFwWydib3R0b20nXV1cbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyhpdGVtW192bS5tYXBbJ2JvdHRvbSddXSkpXSldKV0pXG4gIH0pKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi04ZWJhOWQ3OFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LThlYmE5ZDc4XCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5pbWd2aWV3ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-panel\"\n  }, [_c('div', {\n    staticClass: \"jurassic-panel-header\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-9\"\n  }, [_c('i', {\n    class: _vm.fontclass\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"jurassic-panel-title\"\n  }, [_vm._v(_vm._s(_vm.title))])]), _vm._v(\" \"), (_vm.show) ? _c('div', {\n    staticClass: \"jurassic-col-3 jurassic-text-right\"\n  }, [_c('a', {\n    staticClass: \"jurassic-panel-more\",\n    on: {\n      \"click\": _vm.onShowMore\n    }\n  }, [_vm._v(\"+MORE\")])]) : _vm._e()])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-panel-body\"\n  }, [_vm._t(\"panel\")], 2)])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-a40cb89a\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbC52dWU/YjU1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI2Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtcGFuZWwtaGVhZGVyXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtcm93XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtY29sLTlcIlxuICB9LCBbX2MoJ2knLCB7XG4gICAgY2xhc3M6IF92bS5mb250Y2xhc3NcbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsLXRpdGxlXCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLnRpdGxlKSldKV0pLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLnNob3cpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMyBqdXJhc3NpYy10ZXh0LXJpZ2h0XCJcbiAgfSwgW19jKCdhJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsLW1vcmVcIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0ub25TaG93TW9yZVxuICAgIH1cbiAgfSwgW192bS5fdihcIitNT1JFXCIpXSldKSA6IF92bS5fZSgpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1wYW5lbC1ib2R5XCJcbiAgfSwgW192bS5fdChcInBhbmVsXCIpXSwgMildKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi1hNDBjYjg5YVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWE0MGNiODlhXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbC52dWVcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-sort\"\n  }, [_c('div', {\n    staticClass: \"jurassic-sort-line\"\n  }, [_c('div', {\n    staticClass: \"jurassic-sort-item\"\n  }, _vm._l((_vm.items), function(item, index) {\n    return _c('a', {\n      key: index,\n      attrs: {\n        \"href\": \"#\",\n        \"id\": item.value\n      },\n      on: {\n        \"click\": function($event) {\n          _vm.itemclick(item)\n        }\n      }\n    }, [_vm._v(_vm._s(item.value) + \"\\n                    \"), _c('i')])\n  }))])])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-a4f7bd82\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zb3J0LnZ1ZT9mMjRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1yb3dcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1zb3J0XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc29ydC1saW5lXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtc29ydC1pdGVtXCJcbiAgfSwgX3ZtLl9sKChfdm0uaXRlbXMpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnYScsIHtcbiAgICAgIGtleTogaW5kZXgsXG4gICAgICBhdHRyczoge1xuICAgICAgICBcImhyZWZcIjogXCIjXCIsXG4gICAgICAgIFwiaWRcIjogaXRlbS52YWx1ZVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLml0ZW1jbGljayhpdGVtKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW192bS5fdihfdm0uX3MoaXRlbS52YWx1ZSkgKyBcIlxcbiAgICAgICAgICAgICAgICAgICAgXCIpLCBfYygnaScpXSlcbiAgfSkpXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWE0ZjdiZDgyXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYTRmN2JkODJcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnNvcnQudnVlXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('panellist', {\n    attrs: {\n      \"titles\": _vm.titles,\n      \"onshowmore\": _vm.onShowMore,\n      \"show\": _vm.show,\n      \"fontclass\": _vm.fontclass\n    }\n  }, _vm._l((_vm.data), function(listdata, index) {\n    return _c('list', {\n      key: index,\n      attrs: {\n        \"items\": listdata,\n        \"map\": _vm.map[index],\n        \"onclick\": _vm.onClick\n      },\n      slot: _vm.titles[index]\n    })\n  }))\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-a5fc9252\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5tdWx0aXBsZVRpdGxlLnZ1ZT9lNTNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdwYW5lbGxpc3QnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidGl0bGVzXCI6IF92bS50aXRsZXMsXG4gICAgICBcIm9uc2hvd21vcmVcIjogX3ZtLm9uU2hvd01vcmUsXG4gICAgICBcInNob3dcIjogX3ZtLnNob3csXG4gICAgICBcImZvbnRjbGFzc1wiOiBfdm0uZm9udGNsYXNzXG4gICAgfVxuICB9LCBfdm0uX2woKF92bS5kYXRhKSwgZnVuY3Rpb24obGlzdGRhdGEsIGluZGV4KSB7XG4gICAgcmV0dXJuIF9jKCdsaXN0Jywge1xuICAgICAga2V5OiBpbmRleCxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiaXRlbXNcIjogbGlzdGRhdGEsXG4gICAgICAgIFwibWFwXCI6IF92bS5tYXBbaW5kZXhdLFxuICAgICAgICBcIm9uY2xpY2tcIjogX3ZtLm9uQ2xpY2tcbiAgICAgIH0sXG4gICAgICBzbG90OiBfdm0udGl0bGVzW2luZGV4XVxuICAgIH0pXG4gIH0pKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi1hNWZjOTI1MlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWE1ZmM5MjUyXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5tdWx0aXBsZVRpdGxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('h1', [_vm._v(_vm._s(_vm.dd))]), _vm._v(\" \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.dd),\n      expression: \"dd\"\n    }],\n    domProps: {\n      \"value\": (_vm.dd)\n    },\n    on: {\n      \"input\": function($event) {\n        if ($event.target.composing) { return; }\n        _vm.dd = $event.target.value\n      }\n    }\n  })])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-c04a604c\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50cy9TYW1wbGVzL2RlbW8udnVlP2ViYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIFtfYygnaDEnLCBbX3ZtLl92KF92bS5fcyhfdm0uZGQpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnaW5wdXQnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0uZGQpLFxuICAgICAgZXhwcmVzc2lvbjogXCJkZFwiXG4gICAgfV0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogKF92bS5kZClcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImlucHV0XCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIF92bS5kZCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtYzA0YTYwNGNcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1jMDRhNjA0Y1wifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL0NvbXBvbmVudHMvU2FtcGxlcy9kZW1vLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-panel-body\"\n  }, [_c('ul', {\n    staticClass: \"jurassic-list\"\n  }, _vm._l((_vm.items), function(item, index) {\n    return _c('listItem', {\n      key: 'key' + index,\n      attrs: {\n        \"contentleft\": item[_vm.map['left']],\n        \"url\": item[_vm.map['url']],\n        \"contentright\": item[_vm.map['right']],\n        \"onclick\": _vm.onClick\n      }\n    })\n  }))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-caa94782\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0LnZ1ZT9mZGUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtcGFuZWwtYm9keVwiXG4gIH0sIFtfYygndWwnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtbGlzdFwiXG4gIH0sIF92bS5fbCgoX3ZtLml0ZW1zKSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gX2MoJ2xpc3RJdGVtJywge1xuICAgICAga2V5OiAna2V5JyArIGluZGV4LFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJjb250ZW50bGVmdFwiOiBpdGVtW192bS5tYXBbJ2xlZnQnXV0sXG4gICAgICAgIFwidXJsXCI6IGl0ZW1bX3ZtLm1hcFsndXJsJ11dLFxuICAgICAgICBcImNvbnRlbnRyaWdodFwiOiBpdGVtW192bS5tYXBbJ3JpZ2h0J11dLFxuICAgICAgICBcIm9uY2xpY2tcIjogX3ZtLm9uQ2xpY2tcbiAgICAgIH1cbiAgICB9KVxuICB9KSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi1jYWE5NDc4MlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWNhYTk0NzgyXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5saXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    style: ({\n      height: _vm.height,\n      width: _vm.width\n    }),\n    attrs: {\n      \"name\": \"echarts\"\n    }\n  })\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-d33d2420\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9EYXRhUmVuZGVyL3Brcy5oaXN0b2dyYW0udnVlPzljMTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0eWxlOiAoe1xuICAgICAgaGVpZ2h0OiBfdm0uaGVpZ2h0LFxuICAgICAgd2lkdGg6IF92bS53aWR0aFxuICAgIH0pLFxuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJlY2hhcnRzXCJcbiAgICB9XG4gIH0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWQzM2QyNDIwXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZDMzZDI0MjBcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1NyYy9Db21wb25lbnRzL0RhdGFSZW5kZXIvcGtzLmhpc3RvZ3JhbS52dWVcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticStyle: {\n      \"width\": \"100%\",\n      \"height\": \"100%\"\n    }\n  }, [(!_vm.item || !_vm.item[_vm.map['url']]) ? _c('div', {\n    staticStyle: {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"text-align\": \"center\"\n    }\n  }, [_vm._v(\"\\n        暂无图片\\n     \")]) : _c('div', {\n    staticStyle: {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"text-align\": \"center\"\n    }\n  }, [_c('img', {\n    staticClass: \"jurassic-singleimg-img\",\n    attrs: {\n      \"src\": _vm.item[_vm.map['thumbnail']] ? _vm.item[_vm.map['thumbnail']] : _vm.item[_vm.map['url']],\n      \"data-original\": _vm.item[_vm.map['url']],\n      \"alt\": \"暂无图片\"\n    }\n  })]), _vm._v(\" \"), (!_vm.item || !_vm.item[_vm.map['url']]) ? _c('div') : _c('div', {\n    staticClass: \"jurassic-singleimg-bottom jurassic-news-brief\",\n    style: ({\n      width: _vm.width\n    }),\n    on: {\n      \"click\": function($event) {\n        _vm.onClick(_vm.item[_vm.map['param']])\n      }\n    }\n  }, [_c('p', {\n    attrs: {\n      \"title\": _vm.item[_vm.map['bottom']]\n    }\n  }, [_vm._v(_vm._s(_vm.item[_vm.map['bottom']]))])])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-dba11dac\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5zaW5nbGVpbWcudnVlPzc2YWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNTdHlsZToge1xuICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiXG4gICAgfVxuICB9LCBbKCFfdm0uaXRlbSB8fCAhX3ZtLml0ZW1bX3ZtLm1hcFsndXJsJ11dKSA/IF9jKCdkaXYnLCB7XG4gICAgc3RhdGljU3R5bGU6IHtcbiAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXG4gICAgICBcImhlaWdodFwiOiBcIjEwMCVcIixcbiAgICAgIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICDmmoLml6Dlm77niYdcXG4gICAgIFwiKV0pIDogX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNTdHlsZToge1xuICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLFxuICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCJcbiAgICB9XG4gIH0sIFtfYygnaW1nJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNpbmdsZWltZy1pbWdcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJzcmNcIjogX3ZtLml0ZW1bX3ZtLm1hcFsndGh1bWJuYWlsJ11dID8gX3ZtLml0ZW1bX3ZtLm1hcFsndGh1bWJuYWlsJ11dIDogX3ZtLml0ZW1bX3ZtLm1hcFsndXJsJ11dLFxuICAgICAgXCJkYXRhLW9yaWdpbmFsXCI6IF92bS5pdGVtW192bS5tYXBbJ3VybCddXSxcbiAgICAgIFwiYWx0XCI6IFwi5pqC5peg5Zu+54mHXCJcbiAgICB9XG4gIH0pXSksIF92bS5fdihcIiBcIiksICghX3ZtLml0ZW0gfHwgIV92bS5pdGVtW192bS5tYXBbJ3VybCddXSkgPyBfYygnZGl2JykgOiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNpbmdsZWltZy1ib3R0b20ganVyYXNzaWMtbmV3cy1icmllZlwiLFxuICAgIHN0eWxlOiAoe1xuICAgICAgd2lkdGg6IF92bS53aWR0aFxuICAgIH0pLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0ub25DbGljayhfdm0uaXRlbVtfdm0ubWFwWydwYXJhbSddXSlcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfYygncCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0aXRsZVwiOiBfdm0uaXRlbVtfdm0ubWFwWydib3R0b20nXV1cbiAgICB9XG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5pdGVtW192bS5tYXBbJ2JvdHRvbSddXSkpXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWRiYTExZGFjXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZGJhMTFkYWNcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1NyYy9Db21wb25lbnRzL1NaWFQvcGtzLnNpbmdsZWltZy52dWVcbi8vIG1vZHVsZSBpZCA9IDI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('ul', {\n    staticClass: \"picImgContainer carousel clearfix\",\n    style: ({\n      height: _vm.ulheight\n    }),\n    attrs: {\n      \"id\": _vm.id\n    }\n  }, _vm._l((_vm.items), function(item) {\n    return _c('li', [_c('img', {\n      attrs: {\n        \"data-original\": item.src,\n        \"src\": item.thumbnail ? item.thumbnail : item.src,\n        \"alt\": item.title\n      }\n    })])\n  }))\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-e07f76f2\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50cy9EYXRhUmVuZGVyL3Brcy5pbWFnZS52dWU/ZTY5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3VsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInBpY0ltZ0NvbnRhaW5lciBjYXJvdXNlbCBjbGVhcmZpeFwiLFxuICAgIHN0eWxlOiAoe1xuICAgICAgaGVpZ2h0OiBfdm0udWxoZWlnaHRcbiAgICB9KSxcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBfdm0uaWRcbiAgICB9XG4gIH0sIF92bS5fbCgoX3ZtLml0ZW1zKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygnbGknLCBbX2MoJ2ltZycsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiZGF0YS1vcmlnaW5hbFwiOiBpdGVtLnNyYyxcbiAgICAgICAgXCJzcmNcIjogaXRlbS50aHVtYm5haWwgPyBpdGVtLnRodW1ibmFpbCA6IGl0ZW0uc3JjLFxuICAgICAgICBcImFsdFwiOiBpdGVtLnRpdGxlXG4gICAgICB9XG4gICAgfSldKVxuICB9KSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtZTA3Zjc2ZjJcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1lMDdmNzZmMlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL0NvbXBvbmVudHMvRGF0YVJlbmRlci9wa3MuaW1hZ2UudnVlXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"header-nav\"\n  }, [_c('div', {\n    staticClass: \"navbar-navone\"\n  }, [_c('ul', _vm._l((_vm.items), function(item) {\n    return _c('li', {\n      staticClass: \"drop-menu-effect\"\n    }, [_c('a', {\n      attrs: {\n        \"href\": _vm.menuClick(item.url, item.key),\n        \"data-key\": item.key,\n        \"target\": \"_self\"\n      }\n    }, [_vm._v(_vm._s(item.name))]), _vm._v(\" \"), (item.children.length > 0 && item.hasThird == true) ? _c('div', {\n      staticClass: \"dropdown-menus\",\n      style: ({\n        width: item.children.length * 150 + 'px'\n      })\n    }, [_vm._l((item.children), function(sitem) {\n      return _c('div', {\n        staticClass: \"dropdown-menus-li\"\n      }, [_c('div', {\n        staticClass: \"nav-sub\"\n      }, [_c('a', {\n        attrs: {\n          \"href\": _vm.menuClick(sitem.url, sitem.key),\n          \"data-key\": sitem.key,\n          \"target\": \"_self\"\n        }\n      }, [_vm._v(_vm._s(sitem.name))])]), _vm._v(\" \"), _vm._l((sitem.children), function(titem) {\n        return (sitem.children.length > 0) ? _c('div', {\n          staticClass: \"nav-sub-sub\"\n        }, [_c('a', {\n          attrs: {\n            \"href\": _vm.menuClick(titem.url, titem.key),\n            \"data-key\": titem.key,\n            \"target\": \"_self\"\n          }\n        }, [_vm._v(_vm._s(titem.name))])]) : _vm._e()\n      })], 2)\n    }), _vm._v(\" \"), _c('div', {\n      staticStyle: {\n        \"clear\": \"both\",\n        \"height\": \"0px\",\n        \"overflow\": \"hidden\"\n      }\n    })], 2) : _c('div', {\n      staticClass: \"dropdown-menus\"\n    }, [_vm._l((item.children), function(sitem) {\n      return _c('div', {\n        staticClass: \"dropdown-menus-li\"\n      }, [_c('div', {\n        staticClass: \"nav-sub\"\n      }, [_c('a', {\n        attrs: {\n          \"href\": _vm.menuClick(sitem.url, sitem.key),\n          \"data-key\": sitem.key,\n          \"target\": \"_self\"\n        }\n      }, [_vm._v(_vm._s(sitem.name))])])])\n    }), _vm._v(\" \"), _c('div', {\n      staticStyle: {\n        \"clear\": \"both\",\n        \"height\": \"0px\",\n        \"overflow\": \"hidden\"\n      }\n    })], 2)])\n  }))])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-eae78b0e\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9MYXlvdXQvcGtzLm1lbnUudnVlP2M3YjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI3MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImhlYWRlci1uYXZcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItbmF2b25lXCJcbiAgfSwgW19jKCd1bCcsIF92bS5fbCgoX3ZtLml0ZW1zKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygnbGknLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJkcm9wLW1lbnUtZWZmZWN0XCJcbiAgICB9LCBbX2MoJ2EnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcImhyZWZcIjogX3ZtLm1lbnVDbGljayhpdGVtLnVybCwgaXRlbS5rZXkpLFxuICAgICAgICBcImRhdGEta2V5XCI6IGl0ZW0ua2V5LFxuICAgICAgICBcInRhcmdldFwiOiBcIl9zZWxmXCJcbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyhpdGVtLm5hbWUpKV0pLCBfdm0uX3YoXCIgXCIpLCAoaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIGl0ZW0uaGFzVGhpcmQgPT0gdHJ1ZSkgPyBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZHJvcGRvd24tbWVudXNcIixcbiAgICAgIHN0eWxlOiAoe1xuICAgICAgICB3aWR0aDogaXRlbS5jaGlsZHJlbi5sZW5ndGggKiAxNTAgKyAncHgnXG4gICAgICB9KVxuICAgIH0sIFtfdm0uX2woKGl0ZW0uY2hpbGRyZW4pLCBmdW5jdGlvbihzaXRlbSkge1xuICAgICAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcImRyb3Bkb3duLW1lbnVzLWxpXCJcbiAgICAgIH0sIFtfYygnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYtc3ViXCJcbiAgICAgIH0sIFtfYygnYScsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBcImhyZWZcIjogX3ZtLm1lbnVDbGljayhzaXRlbS51cmwsIHNpdGVtLmtleSksXG4gICAgICAgICAgXCJkYXRhLWtleVwiOiBzaXRlbS5rZXksXG4gICAgICAgICAgXCJ0YXJnZXRcIjogXCJfc2VsZlwiXG4gICAgICAgIH1cbiAgICAgIH0sIFtfdm0uX3YoX3ZtLl9zKHNpdGVtLm5hbWUpKV0pXSksIF92bS5fdihcIiBcIiksIF92bS5fbCgoc2l0ZW0uY2hpbGRyZW4pLCBmdW5jdGlvbih0aXRlbSkge1xuICAgICAgICByZXR1cm4gKHNpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApID8gX2MoJ2RpdicsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYtc3ViLXN1YlwiXG4gICAgICAgIH0sIFtfYygnYScsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgXCJocmVmXCI6IF92bS5tZW51Q2xpY2sodGl0ZW0udXJsLCB0aXRlbS5rZXkpLFxuICAgICAgICAgICAgXCJkYXRhLWtleVwiOiB0aXRlbS5rZXksXG4gICAgICAgICAgICBcInRhcmdldFwiOiBcIl9zZWxmXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtfdm0uX3YoX3ZtLl9zKHRpdGVtLm5hbWUpKV0pXSkgOiBfdm0uX2UoKVxuICAgICAgfSldLCAyKVxuICAgIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgICAgc3RhdGljU3R5bGU6IHtcbiAgICAgICAgXCJjbGVhclwiOiBcImJvdGhcIixcbiAgICAgICAgXCJoZWlnaHRcIjogXCIwcHhcIixcbiAgICAgICAgXCJvdmVyZmxvd1wiOiBcImhpZGRlblwiXG4gICAgICB9XG4gICAgfSldLCAyKSA6IF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogXCJkcm9wZG93bi1tZW51c1wiXG4gICAgfSwgW192bS5fbCgoaXRlbS5jaGlsZHJlbiksIGZ1bmN0aW9uKHNpdGVtKSB7XG4gICAgICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwiZHJvcGRvd24tbWVudXMtbGlcIlxuICAgICAgfSwgW19jKCdkaXYnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcIm5hdi1zdWJcIlxuICAgICAgfSwgW19jKCdhJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIFwiaHJlZlwiOiBfdm0ubWVudUNsaWNrKHNpdGVtLnVybCwgc2l0ZW0ua2V5KSxcbiAgICAgICAgICBcImRhdGEta2V5XCI6IHNpdGVtLmtleSxcbiAgICAgICAgICBcInRhcmdldFwiOiBcIl9zZWxmXCJcbiAgICAgICAgfVxuICAgICAgfSwgW192bS5fdihfdm0uX3Moc2l0ZW0ubmFtZSkpXSldKV0pXG4gICAgfSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICBcImNsZWFyXCI6IFwiYm90aFwiLFxuICAgICAgICBcImhlaWdodFwiOiBcIjBweFwiLFxuICAgICAgICBcIm92ZXJmbG93XCI6IFwiaGlkZGVuXCJcbiAgICAgIH1cbiAgICB9KV0sIDIpXSlcbiAgfSkpXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi1lYWU3OGIwZVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWVhZTc4YjBlXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9MYXlvdXQvcGtzLm1lbnUudnVlXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"jurassic-panel\"\n  }, [_c('div', {\n    staticClass: \"jurassic-panel-header\"\n  }, [_c('div', {\n    staticClass: \"jurassic-row\"\n  }, [_c('div', {\n    staticClass: \"jurassic-col-9\"\n  }, [_c('i', {\n    class: _vm.fontclass\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-inline\"\n  }, _vm._l((_vm.titles), function(title, index) {\n    return _c('div', {\n      key: index + 'key',\n      staticClass: \"jurassic-template\",\n      staticStyle: {\n        \"display\": \"inline\"\n      }\n    }, [_c('span', {\n      staticClass: \"jurassic-tab-panel-title\",\n      attrs: {\n        \"data-anchor\": 'jrc' + index\n      }\n    }, [_vm._v(_vm._s(title))]), _vm._v(\" \"), (index + 1 < _vm.titles.length ? true : false) ? _c('span', {\n      staticClass: \"jurassic-split-line\"\n    }) : _vm._e()])\n  }))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-col-3  jurassic-text-right\"\n  }, [(_vm.show) ? _c('a', {\n    staticClass: \"jurassic-panel-more\",\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": _vm.onShowMore\n    }\n  }, [_vm._v(\"+MORE\")]) : _vm._e()])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"jurassic-panel-body\"\n  }, _vm._l((_vm.titles), function(title, index) {\n    return _c('div', {\n      key: index + 'key',\n      staticClass: \"jurassic-tab-panel-container\",\n      attrs: {\n        \"data-anchor\": 'jrc' + index\n      }\n    }, [_vm._t(title)], 2)\n  }))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-f305981e\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYW5lbExpc3QudnVlPzJkZGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1wYW5lbFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsLWhlYWRlclwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXJvd1wiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWNvbC05XCJcbiAgfSwgW19jKCdpJywge1xuICAgIGNsYXNzOiBfdm0uZm9udGNsYXNzXG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLWlubGluZVwiXG4gIH0sIF92bS5fbCgoX3ZtLnRpdGxlcyksIGZ1bmN0aW9uKHRpdGxlLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAga2V5OiBpbmRleCArICdrZXknLFxuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtdGVtcGxhdGVcIixcbiAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgIFwiZGlzcGxheVwiOiBcImlubGluZVwiXG4gICAgICB9XG4gICAgfSwgW19jKCdzcGFuJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtdGFiLXBhbmVsLXRpdGxlXCIsXG4gICAgICBhdHRyczoge1xuICAgICAgICBcImRhdGEtYW5jaG9yXCI6ICdqcmMnICsgaW5kZXhcbiAgICAgIH1cbiAgICB9LCBbX3ZtLl92KF92bS5fcyh0aXRsZSkpXSksIF92bS5fdihcIiBcIiksIChpbmRleCArIDEgPCBfdm0udGl0bGVzLmxlbmd0aCA/IHRydWUgOiBmYWxzZSkgPyBfYygnc3BhbicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXNwbGl0LWxpbmVcIlxuICAgIH0pIDogX3ZtLl9lKCldKVxuICB9KSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJqdXJhc3NpYy1jb2wtMyAganVyYXNzaWMtdGV4dC1yaWdodFwiXG4gIH0sIFsoX3ZtLnNob3cpID8gX2MoJ2EnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwianVyYXNzaWMtcGFuZWwtbW9yZVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImhyZWZcIjogXCIjXCJcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5vblNob3dNb3JlXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiK01PUkVcIildKSA6IF92bS5fZSgpXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXBhbmVsLWJvZHlcIlxuICB9LCBfdm0uX2woKF92bS50aXRsZXMpLCBmdW5jdGlvbih0aXRsZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICAgIGtleTogaW5kZXggKyAna2V5JyxcbiAgICAgIHN0YXRpY0NsYXNzOiBcImp1cmFzc2ljLXRhYi1wYW5lbC1jb250YWluZXJcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiZGF0YS1hbmNob3JcIjogJ2pyYycgKyBpbmRleFxuICAgICAgfVxuICAgIH0sIFtfdm0uX3QodGl0bGUpXSwgMilcbiAgfSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtZjMwNTk4MWVcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1mMzA1OTgxZVwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vU3JjL0NvbXBvbmVudHMvU1pYVC9wa3MucGFuZWxMaXN0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(246);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(82)(\"4fe02164\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3c0291f2\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./pks.pager.vue\", function() {\n     var newContent = require(\"!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3c0291f2\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./pks.pager.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYWdlci52dWU/MjRhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLHFDQUE2TjtBQUM3TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLGtGQUFrRjtBQUM1TixtSkFBbUosa0ZBQWtGO0FBQ3JPO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMjcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNjMDI5MWYyXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3Brcy5wYWdlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjRmZTAyMTY0XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNjMDI5MWYyXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3Brcy5wYWdlci52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2MwMjkxZjJcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vcGtzLnBhZ2VyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtM2MwMjkxZjJcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9TcmMvQ29tcG9uZW50cy9TWlhUL3Brcy5wYWdlci52dWVcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(247);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(82)(\"439b22ec\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-e07f76f2\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./pks.image.vue\", function() {\n     var newContent = require(\"!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-e07f76f2\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./pks.image.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50cy9EYXRhUmVuZGVyL3Brcy5pbWFnZS52dWU/YjBjMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLHFDQUE4TjtBQUM5TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLG1GQUFtRjtBQUM3TixtSkFBbUosbUZBQW1GO0FBQ3RPO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMjczLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWUwN2Y3NmYyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9wa3MuaW1hZ2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI0MzliMjJlY1wiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lMDdmNzZmMlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vcGtzLmltYWdlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lMDdmNzZmMlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vcGtzLmltYWdlLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZTA3Zjc2ZjJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL0NvbXBvbmVudHMvRGF0YVJlbmRlci9wa3MuaW1hZ2UudnVlXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 274 */
/***/ (function(module, exports) {

eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanM/YTA4MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 275 */,
/* 276 */
/***/ (function(module, exports) {

eval("/* (ignored) */\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ290IChpZ25vcmVkKT9lODE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjI3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGdvdCAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ })
],[221]);